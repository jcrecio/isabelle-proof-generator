{"file_name": "/home/qj213/afp-2021-10-22/thys/QHLProver/Complex_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QHLProver", "problem_names": ["lemma trace_zero [simp]:\n  \"trace (0\\<^sub>m n n) = 0\"", "lemma trace_id [simp]:\n  \"trace (1\\<^sub>m n) = n\"", "lemma trace_comm:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A * B) = trace (B * A)\"", "lemma trace_add_linear:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A + B) = trace A + trace B\" (is \"?lhs = ?rhs\")", "lemma trace_minus_linear:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A - B) = trace A - trace B\" (is \"?lhs = ?rhs\")", "lemma trace_smult: \n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"trace (c \\<cdot>\\<^sub>m A) = c * trace A\"", "lemma conjugate_scalar_prod:\n  fixes v w :: \"'a::conjugatable_ring vec\"\n  assumes \"dim_vec v = dim_vec w\"\n  shows \"conjugate (v \\<bullet> w) = conjugate v \\<bullet> conjugate w\"", "lemma conjugate_scalar_prod_Im [simp]:\n  \"Im (v \\<bullet>c v) = 0\"", "lemma conjugate_scalar_prod_Re [simp]:\n  \"Re (v \\<bullet>c v) \\<ge> 0\"", "lemma self_cscalar_prod_geq_0:\n  fixes v ::  \"'a::conjugatable_ordered_field vec\"\n  shows \"v \\<bullet>c v \\<ge> 0\"", "lemma inner_prod_distrib_left:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod (v + w) u = inner_prod v u + inner_prod w u\" (is \"?lhs = ?rhs\")", "lemma inner_prod_distrib_right:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod u (v + w) = inner_prod u v + inner_prod u w\" (is \"?lhs = ?rhs\")", "lemma inner_prod_minus_distrib_right:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod u (v - w) = inner_prod u v - inner_prod u w\" (is \"?lhs = ?rhs\")", "lemma inner_prod_smult_right:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" \n  shows \"inner_prod (a \\<cdot>\\<^sub>v u) v = conjugate a * inner_prod u v\" (is \"?lhs = ?rhs\")", "lemma inner_prod_smult_left:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv: \"v \\<in> carrier_vec n\" \n  shows \"inner_prod u (a \\<cdot>\\<^sub>v v) = a * inner_prod u v\" (is \"?lhs = ?rhs\")", "lemma inner_prod_smult_left_right:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv: \"v \\<in> carrier_vec n\" \n  shows \"inner_prod (a \\<cdot>\\<^sub>v u) (b \\<cdot>\\<^sub>v v) = conjugate a * b  * inner_prod u v\" (is \"?lhs = ?rhs\")", "lemma inner_prod_swap:\n  fixes x y :: \"complex vec\"\n  assumes \"y \\<in> carrier_vec n\" and \"x \\<in> carrier_vec n\" \n  shows \"inner_prod y x = conjugate (inner_prod x y)\"", "lemma aux_Cauchy:\n  fixes x y :: \"complex vec\"\n  assumes \"x \\<in> carrier_vec n\" and \"y \\<in> carrier_vec n\"\n  shows \"0 \\<le> inner_prod x x + a * (inner_prod x y) + (cnj a) * ((cnj (inner_prod x y)) + a * (inner_prod y y))\"", "lemma Cauchy_Schwarz_complex_vec:\n  fixes x y :: \"complex vec\"\n  assumes \"x \\<in> carrier_vec n\" and \"y \\<in> carrier_vec n\"\n  shows \"inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y\"", "lemma adjoint_dim_row [simp]:\n  \"dim_row (adjoint A) = dim_col A\"", "lemma adjoint_dim_col [simp]:\n  \"dim_col (adjoint A) = dim_row A\"", "lemma adjoint_dim:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> adjoint A \\<in> carrier_mat n n\"", "lemma adjoint_def:\n  \"adjoint A = mat (dim_col A) (dim_row A) (\\<lambda>(i,j). conjugate (A $$ (j,i)))\"", "lemma adjoint_eval:\n  assumes \"i < dim_col A\" \"j < dim_row A\"\n  shows \"(adjoint A) $$ (i,j) = conjugate (A $$ (j,i))\"", "lemma adjoint_row:\n  assumes \"i < dim_col A\"\n  shows \"row (adjoint A) i = conjugate (col A i)\"", "lemma adjoint_col:\n  assumes \"i < dim_row A\"\n  shows \"col (adjoint A) i = conjugate (row A i)\"", "lemma adjoint_def_alter:\n  fixes v w :: \"'a::conjugatable_field vec\"\n    and A :: \"'a::conjugatable_field mat\"\n  assumes dims: \"v \\<in> carrier_vec n\" \"w \\<in> carrier_vec m\" \"A \\<in> carrier_mat n m\"\n  shows \"inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w\" (is \"?lhs = ?rhs\")", "lemma adjoint_one:\n  shows \"adjoint (1\\<^sub>m n) = (1\\<^sub>m n::complex mat)\"", "lemma adjoint_scale:\n  fixes A :: \"'a::conjugatable_field mat\"\n  shows \"adjoint (a \\<cdot>\\<^sub>m A) = (conjugate a) \\<cdot>\\<^sub>m adjoint A\"", "lemma adjoint_add:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat n m\"\n  shows \"adjoint (A + B) = adjoint A + adjoint B\"", "lemma adjoint_minus:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat n m\"\n  shows \"adjoint (A - B) = adjoint A - adjoint B\"", "lemma adjoint_mult:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat m l\"\n  shows \"adjoint (A * B) = adjoint B * adjoint A\"", "lemma adjoint_adjoint:\n  fixes A :: \"'a::conjugatable_field mat\"\n  shows \"adjoint (adjoint A) = A\"", "lemma trace_adjoint_positive:\n  fixes A :: \"complex mat\"\n  shows \"trace (A * adjoint A) \\<ge> 0\"", "lemma right_add_zero_mat[simp]:\n  \"(A :: 'a :: monoid_add mat) \\<in> carrier_mat nr nc \\<Longrightarrow> A + 0\\<^sub>m nr nc = A\"", "lemma add_carrier_mat':\n  \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc \\<Longrightarrow> A + B \\<in> carrier_mat nr nc\"", "lemma minus_carrier_mat':\n  \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc \\<Longrightarrow> A - B \\<in> carrier_mat nr nc\"", "lemma swap_plus_mat:\n  fixes A B C :: \"'a::semiring_1 mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\"\n  shows \"A + B + C = A + C + B\"", "lemma uminus_mat:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"-A = (-1) \\<cdot>\\<^sub>m A\"", "lemma mat_assoc_test:\n  fixes A B C D :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n  shows\n    \"(A * B) * (C * D) = A * B * C * D\"\n    \"adjoint (A * adjoint B) * C = B * (adjoint A * C)\"\n    \"A * 1\\<^sub>m n * 1\\<^sub>m n * B * 1\\<^sub>m n = A * B\"\n    \"(A - B) + (B - C) = A + (-B) + B + (-C)\"\n    \"A + (B - C) = A + B - C\"\n    \"A - (B + C + D) = A - B - C - D\"\n    \"(A + B) * (B + C) = A * B + B * B + A * C + B * C\"\n    \"A - B = A + (-1) \\<cdot>\\<^sub>m B\"\n    \"A * (B - C) * D = A * B * D - A * C * D\"\n    \"trace (A * B * C) = trace (B * C * A)\"\n    \"trace (A * B * C * D) = trace (C * D * A * B)\"\n    \"trace (A + B * C) = trace A + trace (C * B)\"\n    \"A + B = B + A\"\n    \"A + B + C = C + B + A\"\n    \"A + B + (C + D) = A + C + (B + D)\"", "lemma hermitian_one:\n  shows \"hermitian ((1\\<^sub>m n)::('a::conjugatable_field mat))\"", "lemma inverts_mat_symm:\n  fixes A B :: \"'a::field mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n    and AB: \"inverts_mat A B\"\n  shows \"inverts_mat B A\"", "lemma inverts_mat_unique:\n  fixes A B C :: \"'a::field mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \n    and AB: \"inverts_mat A B\" and AC: \"inverts_mat A C\"\n  shows \"B = C\"", "lemma unitaryD2:\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"unitary A \\<Longrightarrow> inverts_mat (adjoint A) A\"", "lemma unitary_simps [simp]:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> unitary A \\<Longrightarrow> adjoint A * A = 1\\<^sub>m n\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> unitary A \\<Longrightarrow> A * adjoint A = 1\\<^sub>m n\"", "lemma unitary_adjoint [simp]:\n  assumes \"A \\<in> carrier_mat n n\" \"unitary A\"\n  shows \"unitary (adjoint A)\"", "lemma unitary_one:\n  shows \"unitary ((1\\<^sub>m n)::('a::conjugatable_field mat))\"", "lemma unitary_zero:\n  fixes A :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat 0 0\"\n  shows \"unitary A\"", "lemma unitary_elim:\n  assumes dims: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"P \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and eq: \"P * A * adjoint P = P * B * adjoint P\"\n  shows \"A = B\"", "lemma unitary_is_corthogonal:\n  fixes U :: \"'a::conjugatable_field mat\"\n  assumes dim: \"U \\<in> carrier_mat n n\" \n    and U: \"unitary U\"\n  shows \"corthogonal_mat U\"", "lemma unitary_times_unitary:\n  fixes P Q :: \"'a:: conjugatable_field mat\"\n  assumes dim: \"P \\<in> carrier_mat n n\" \"Q \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and uQ: \"unitary Q\"\n  shows \"unitary (P * Q)\"", "lemma unitary_operator_keep_trace:\n  fixes U A :: \"complex mat\"\n  assumes dU: \"U \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" and u: \"unitary U\"\n  shows \"trace A = trace (adjoint U * A * U)\"", "lemma vec_norm_geq_0:\n  fixes v :: \"complex vec\"\n  shows \"vec_norm v \\<ge> 0\"", "lemma vec_norm_zero:\n  fixes v ::  \"complex vec\"\n  assumes dim: \"v \\<in> carrier_vec n\"\n  shows \"vec_norm v = 0 \\<longleftrightarrow> v = 0\\<^sub>v n\"", "lemma vec_norm_ge_0:\n  fixes v ::  \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" and neq0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_norm v > 0\"", "lemma normalized_vec_dim[simp]:\n  assumes \"(v::complex vec) \\<in> carrier_vec n\"\n  shows \"vec_normalize v \\<in> carrier_vec n\"", "lemma vec_eq_norm_smult_normalized:\n  shows \"v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\"", "lemma normalized_cscalar_prod:\n  fixes v w :: \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" and dim_w: \"w \\<in> carrier_vec n\"\n  shows \"v \\<bullet>c w = (vec_norm v * vec_norm w) * (vec_normalize v \\<bullet>c vec_normalize w)\"", "lemma normalized_vec_norm :\n  fixes v :: \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" \n    and neq0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_normalize v \\<bullet>c vec_normalize v = 1\"", "lemma normalize_zero:\n  assumes \"v \\<in> carrier_vec n\"\n  shows \"vec_normalize v = 0\\<^sub>v n \\<longleftrightarrow> v = 0\\<^sub>v n\"", "lemma normalize_normalize[simp]:\n  \"vec_normalize (vec_normalize v) = vec_normalize v\"", "lemma normalize_keep_corthogonal:\n  fixes vs :: \"complex vec list\"\n  assumes cor: \"corthogonal vs\" and dims: \"set vs \\<subseteq> carrier_vec n\"\n  shows \"corthogonal (map vec_normalize vs)\"", "lemma normalized_corthogonal_mat_is_unitary:\n  assumes W: \"set ws \\<subseteq> carrier_vec n\"\n    and orth: \"corthogonal ws\"\n    and len: \"length ws = n\"\n  shows \"unitary (mat_of_cols n (map vec_normalize ws))\" (is \"unitary ?W\")", "lemma normalize_keep_eigenvector:\n  assumes ev: \"eigenvector A v e\" \n    and dim: \"A \\<in> carrier_mat n n\" \"v \\<in> carrier_vec n\"\n  shows \"eigenvector A (vec_normalize v) e\"", "lemma four_block_mat_adjoint:\n  fixes A B C D :: \"'a::conjugatable_field mat\"\n  assumes dim: \"A \\<in> carrier_mat nr1 nc1\" \"B \\<in> carrier_mat nr1 nc2\"\n  \"C \\<in> carrier_mat nr2 nc1\" \"D \\<in> carrier_mat nr2 nc2\"\n  shows \"adjoint (four_block_mat A B C D) \n    = four_block_mat (adjoint A) (adjoint C) (adjoint B) (adjoint D)\"", "theorem unitary_schur_decomposition:\n  assumes A: \"(A::complex mat) \\<in> carrier_mat n n\"\n      and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n      and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es \\<and> unitary P \\<and> (Q = adjoint P)\"", "lemma complex_mat_char_poly_factorizable:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>as. char_poly A =  (\\<Prod> a \\<leftarrow> as. [:- a, 1:]) \\<and> length as = n\"", "lemma complex_mat_has_unitary_schur_decomposition:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>B P es. similar_mat_wit A B P (adjoint P) \\<and> unitary P \n    \\<and> char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:]) \\<and> diag_mat B = es\"", "lemma normal_upper_triangular_matrix_is_diagonal:\n  fixes A :: \"'a::conjugatable_ordered_field mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and norm: \"A * adjoint A = adjoint A * A\"\n  shows \"diagonal_mat A\"", "lemma normal_complex_mat_has_spectral_decomposition:\n  assumes A: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and normal: \"A * adjoint A  = adjoint A * A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\"", "lemma complex_mat_has_jordan_nf:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>n_as. jordan_nf A n_as\"", "lemma hermitian_is_normal:\n  assumes \"hermitian A\"\n  shows \"A * adjoint A = adjoint A * A\"", "lemma hermitian_eigenvalue_real:\n  assumes dim: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and hA: \"hermitian A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\"", "lemma hermitian_inner_prod_real:\n  assumes dimA: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and dimv: \"v \\<in> carrier_vec n\"\n    and hA: \"hermitian A\"\n  shows \"inner_prod v (A *\\<^sub>v v) \\<in> Reals\"", "lemma unit_vec_bracket:\n  fixes A :: \"complex mat\"\n  assumes dimA: \"A \\<in> carrier_mat n n\" and i: \"i < n\"\n  shows \"inner_prod (unit_vec n i) (A *\\<^sub>v (unit_vec n i)) = A$$(i, i)\"", "lemma spectral_decomposition_extract_diag:\n  fixes P B :: \"complex mat\"\n  assumes dimP: \"P \\<in> carrier_mat n n\" and dimB: \"B \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and dB: \"diagonal_mat B\" and i: \"i < n\"\n  shows \"inner_prod (col P i) (P * B * (adjoint P) *\\<^sub>v (col P i)) = B$$(i, i)\"", "lemma hermitian_inner_prod_zero:\n  fixes A :: \"complex mat\"\n  assumes dimA: \"A \\<in> carrier_mat n n\" and hA: \"hermitian A\"\n    and zero: \"\\<forall>v\\<in>carrier_vec n. inner_prod v (A *\\<^sub>v v) = 0\"\n  shows \"A = 0\\<^sub>m n n\"", "lemma complex_mat_decomposition_to_hermitian:\n  fixes A :: \"complex mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>B C. hermitian B \\<and> hermitian C \\<and> A = B + \\<i> \\<cdot>\\<^sub>m C \\<and> B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n\"", "lemma outer_prod_dim[simp]:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec m\"\n  shows \"outer_prod v w \\<in> carrier_mat n m\"", "lemma mat_of_vec_mult_eq_scalar_prod:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes \"v \\<in> carrier_vec n\" and \"w \\<in> carrier_vec n\"\n  shows \"mat 1 (dim_vec v) (\\<lambda>(i, j). (conjugate v) $ j) * mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i) \n    = mat 1 1 (\\<lambda>k. inner_prod v w)\"", "lemma one_dim_mat_mult_is_scale:\n  fixes A B :: \"('a::conjugatable_field mat)\"\n  assumes \"B \\<in> carrier_mat 1 n\"\n  shows \"(mat 1 1 (\\<lambda>k. a)) * B = a \\<cdot>\\<^sub>m B\"", "lemma outer_prod_mult_outer_prod:\n  fixes a b c d :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d1\" and b: \"b \\<in> carrier_vec d2\"\n    and c: \"c \\<in> carrier_vec d2\" and d: \"d \\<in> carrier_vec d3\"\n  shows \"outer_prod a b * outer_prod c d = inner_prod b c \\<cdot>\\<^sub>m outer_prod a d\"", "lemma index_outer_prod:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec m\"\n    and ij: \"i < n\" \"j < m\"\n  shows \"(outer_prod v w)$$(i, j) = v $ i * conjugate (w $ j)\"", "lemma mat_of_vec_mult_vec:\n  fixes a b c :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d\" and b: \"b \\<in> carrier_vec d\"\n  shows \"mat 1 d (\\<lambda>(i, j). (conjugate a) $ j) *\\<^sub>v b = vec 1 (\\<lambda>k. inner_prod a b)\"", "lemma mat_of_vec_mult_one_dim_vec:\n  fixes a b :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d\" \n  shows \"mat d 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v vec 1 (\\<lambda>k. c) = c \\<cdot>\\<^sub>v a\"", "lemma outer_prod_mult_vec:\n  fixes a b c :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d1\" and b: \"b \\<in> carrier_vec d2\"\n    and c: \"c \\<in> carrier_vec d2\"\n  shows \"outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a\"", "lemma trace_outer_prod_right:\n  fixes A :: \"'a::conjugatable_field mat\" and v w :: \"'a vec\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\"\n  shows \"trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)\" (is \"?lhs = ?rhs\")", "lemma trace_outer_prod:\n  fixes v w :: \"('a::conjugatable_field vec)\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\"\n  shows \"trace (outer_prod v w) = inner_prod w v\" (is \"?lhs = ?rhs\")", "lemma inner_prod_outer_prod:\n  fixes a b c d :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec n\" and b: \"b \\<in> carrier_vec n\"\n    and c: \"c \\<in> carrier_vec m\" and d: \"d \\<in> carrier_vec m\"\n  shows \"inner_prod a (outer_prod b c *\\<^sub>v d) = inner_prod a b * inner_prod c d\" (is \"?lhs = ?rhs\")", "lemma positive_iff_normalized_vec:\n  \"positive A \\<longleftrightarrow>\n    A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v. (dim_vec v = dim_col A \\<and> vec_norm v = 1) \\<longrightarrow> inner_prod v (A *\\<^sub>v v) \\<ge> 0)\"", "lemma positive_is_hermitian:\n  fixes A :: \"complex mat\"\n  assumes pA: \"positive A\"\n  shows \"hermitian A\"", "lemma positive_eigenvalue_positive:\n  assumes dimA: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and pA: \"positive A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<ge> 0\"", "lemma diag_mat_mult_diag_mat:\n  fixes B D :: \"'a::semiring_0 mat\"\n  assumes dimB: \"B \\<in> carrier_mat n n\" and dimD: \"D \\<in> carrier_mat n n\"\n    and dB: \"diagonal_mat B\" and dD: \"diagonal_mat D\"\n  shows \"B * D = mat n n (\\<lambda>(i,j). (if i = j then (B$$(i, i)) * (D$$(i, i)) else 0))\"", "lemma positive_only_if_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\" and pA: \"positive A\"\n  shows \"\\<exists>M \\<in> carrier_mat n n. M * adjoint M = A\"", "lemma positive_if_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\" and \"\\<exists>M. M * adjoint M = A\"\n  shows \"positive A\"", "lemma positive_iff_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\"\n  shows \"positive A \\<longleftrightarrow> (\\<exists>M\\<in>carrier_mat n n. M * adjoint M = A)\"", "lemma positive_dim_eq:\n  assumes \"positive A\"\n  shows \"dim_row A = dim_col A\"", "lemma positive_zero:\n  \"positive (0\\<^sub>m n n)\"", "lemma positive_one:\n  \"positive (1\\<^sub>m n)\"", "lemma positive_antisym:\n  assumes pA: \"positive A\" and pnA: \"positive (-A)\"\n  shows \"A = 0\\<^sub>m (dim_col A) (dim_col A)\"", "lemma positive_add:\n  assumes pA: \"positive A\" and pB: \"positive B\"\n    and dimA: \"A \\<in> carrier_mat n n\" and dimB: \"B \\<in> carrier_mat n n\"\n  shows \"positive (A + B)\"", "lemma positive_trace:\n  assumes \"A \\<in> carrier_mat n n\" and \"positive A\"\n  shows \"trace A \\<ge> 0\"", "lemma positive_close_under_left_right_mult_adjoint:\n  fixes M A :: \"complex mat\"\n  assumes dM: \"M \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" \n    and pA: \"positive A\"\n  shows \"positive (M * A * adjoint M)\"", "lemma positive_same_outer_prod:\n  fixes v w :: \"complex vec\"\n  assumes v: \"v \\<in> carrier_vec n\" \n  shows \"positive (outer_prod v v)\"", "lemma smult_smult_mat: \n  fixes k :: complex and l :: complex\n  assumes \"A \\<in> carrier_mat nr n\"\n  shows \"k \\<cdot>\\<^sub>m (l \\<cdot>\\<^sub>m A) = (k * l) \\<cdot>\\<^sub>m A\"", "lemma positive_smult: \n  assumes \"A \\<in> carrier_mat n n\"\n    and \"positive A\"\n    and \"c \\<ge> 0\"\n  shows \"positive (c \\<cdot>\\<^sub>m A)\"", "lemma positive_scale: \n  fixes c :: real\n  assumes  \"A \\<in> carrier_mat n n\"\n    and \"positive A\"\n    and \"c \\<ge> 0\"\n  shows \"positive (c \\<cdot>\\<^sub>m A)\"", "lemma lowner_le_refl:\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"A \\<le>\\<^sub>L A\"", "lemma lowner_le_antisym:\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n    and L1: \"A \\<le>\\<^sub>L B\" and L2: \"B \\<le>\\<^sub>L A\"\n  shows \"A = B\"", "lemma lowner_le_inner_prod_le:\n  fixes A B :: \"complex mat\" and v :: \"complex vec\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n    and v: \"v \\<in> carrier_vec n\"\n    and \"A \\<le>\\<^sub>L B\"\n  shows \"inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\"", "lemma lowner_le_trans:\n  fixes A B C :: \"complex mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\" and C: \"C \\<in> carrier_mat n n\"\n    and L1: \"A \\<le>\\<^sub>L B\" and L2: \"B \\<le>\\<^sub>L C\"\n  shows \"A \\<le>\\<^sub>L C\"", "lemma lowner_le_imp_trace_le:\n  assumes \"A \\<in> carrier_mat n n\" and \"B \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\"\n  shows \"trace A \\<le> trace B\"", "lemma lowner_le_add:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\" \"C \\<le>\\<^sub>L D\"\n  shows \"A + C \\<le>\\<^sub>L B + D\"", "lemma lowner_le_swap:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \n    and \"A \\<le>\\<^sub>L B\" \n  shows \"-B \\<le>\\<^sub>L -A\"", "lemma lowner_le_minus:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\" \"C \\<le>\\<^sub>L D\"\n  shows \"A - D \\<le>\\<^sub>L B - C\"", "lemma outer_prod_le_one:\n  assumes \"v \\<in> carrier_vec n\"\n    and \"inner_prod v v \\<le> 1\"\n  shows \"outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n\"", "lemma zero_lowner_le_positiveD:\n  fixes A :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and le: \"0\\<^sub>m n n \\<le>\\<^sub>L A\"\n  shows \"positive A\"", "lemma zero_lowner_le_positiveI:\n  fixes A :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and le: \"positive A\"\n  shows \"0\\<^sub>m n n \\<le>\\<^sub>L A\"", "lemma lowner_le_trans_positiveI:\n  fixes A B :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and pA: \"positive A\" and le: \"A \\<le>\\<^sub>L B\"\n  shows \"positive B\"", "lemma lowner_le_keep_under_measurement:\n  fixes M A B :: \"complex mat\"\n  assumes dM: \"M \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" and dB: \"B \\<in> carrier_mat n n\"\n    and le: \"A \\<le>\\<^sub>L B\"\n  shows \"adjoint M * A * M \\<le>\\<^sub>L adjoint M * B * M\"", "lemma smult_distrib_left_minus_mat:\n  fixes A B :: \"'a::comm_ring_1 mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A\"", "lemma lowner_le_smultc:\n  fixes c :: complex\n  assumes \"c \\<ge> 0\" \"A \\<le>\\<^sub>L B\" \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B\"", "lemma lowner_le_smult:\n  fixes c :: real\n  assumes \"c \\<ge> 0\" \"A \\<le>\\<^sub>L B\" \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B\"", "lemma minus_smult_vec_distrib:\n  fixes w :: \"'a::comm_ring_1 vec\"\n  shows \"(a - b) \\<cdot>\\<^sub>v w = a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w\"", "lemma smult_mat_mult_mat_vec_assoc:\n  fixes A :: \"'a::comm_ring_1 mat\"\n  assumes A: \"A \\<in> carrier_mat n m\" and w: \"w \\<in> carrier_vec m\"\n  shows \"a \\<cdot>\\<^sub>m A *\\<^sub>v w = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)\"", "lemma mult_mat_vec_smult_vec_assoc:\n  fixes A :: \"'a::comm_ring_1 mat\"\n  assumes A: \"A \\<in> carrier_mat n m\" and w: \"w \\<in> carrier_vec m\"\n  shows \"A *\\<^sub>v (a \\<cdot>\\<^sub>v w) = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)\"", "lemma outer_prod_left_right_mat:\n  fixes A B :: \"complex mat\"\n  assumes du: \"u \\<in> carrier_vec d2\" and dv: \"v \\<in> carrier_vec d3\"\n    and dA: \"A \\<in> carrier_mat d1 d2\" and dB: \"B \\<in> carrier_mat d3 d4\"\n  shows \"A * (outer_prod u v) * B = (outer_prod (A *\\<^sub>v u) (adjoint B *\\<^sub>v v))\"", "lemma pure_state_self_outer_prod_is_partial_density_operator:\n  fixes v :: \"complex vec\"\n  assumes dimv: \"v \\<in> carrier_vec n\" and nv: \"vec_norm v = 1\"\n  shows \"partial_density_operator (outer_prod v v)\"", "lemma lowner_le_trace:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and B: \"B \\<in> carrier_mat n n\"\n  shows \"A \\<le>\\<^sub>L B \\<longleftrightarrow> (\\<forall>\\<rho>\\<in>carrier_mat n n. partial_density_operator \\<rho> \\<longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>))\"", "lemma lowner_le_traceI:\n  assumes \"A \\<in> carrier_mat n n\"\n    and \"B \\<in> carrier_mat n n\"\n    and \"\\<And>\\<rho>. \\<rho> \\<in> carrier_mat n n \\<Longrightarrow> partial_density_operator \\<rho> \\<Longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\"\n  shows \"A \\<le>\\<^sub>L B\"", "lemma trace_pdo_eq_imp_eq:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and B: \"B \\<in> carrier_mat n n\"\n    and teq: \"\\<And>\\<rho>. \\<rho> \\<in> carrier_mat n n \\<Longrightarrow> partial_density_operator \\<rho> \\<Longrightarrow> trace (A * \\<rho>) = trace (B * \\<rho>)\"\n  shows \"A = B\"", "lemma lowner_le_traceD:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"\\<rho> \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\"\n    and \"partial_density_operator \\<rho>\"\n  shows \"trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\"", "lemma sum_only_one_neq_0:\n  assumes \"finite A\" and \"j \\<in> A\" and \"\\<And>i. i \\<in> A \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> g i = 0\"\n  shows \"sum g A = g j\""], "translations": [["", "lemma trace_zero [simp]:\n  \"trace (0\\<^sub>m n n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (0\\<^sub>m n n) = (0::'a)", "by (simp add: trace_def)"], ["", "lemma trace_id [simp]:\n  \"trace (1\\<^sub>m n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (1\\<^sub>m n) = int n", "by (simp add: trace_def)"], ["", "lemma trace_comm:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A * B) = trace (B * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A * B) = trace (B * A)", "proof (simp add: trace_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "have \"(\\<Sum>i = 0..<n. (A * B) $$ (i, i)) = (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i,j) * B $$ (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       (A * B) $$ (x, x) = (\\<Sum>j = 0..<n. A $$ (x, j) * B $$ (j, x))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       (A * B) $$ (x, x) = (\\<Sum>j = 0..<n. A $$ (x, j) * B $$ (j, x))", "by (auto simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "have \"\\<dots> = (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i,j) * B $$ (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n    (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i))", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n  (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n  (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "have \"\\<dots> = (\\<Sum>j = 0..<n. col A j \\<bullet> row B j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n    (\\<Sum>j = 0..<n. col A j \\<bullet> row B j)", "by (metis (no_types, lifting) A B atLeastLessThan_iff carrier_matD index_col index_row scalar_prod_def sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n  (\\<Sum>j = 0..<n. col A j \\<bullet> row B j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n. \\<Sum>i = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n  (\\<Sum>j = 0..<n. col A j \\<bullet> row B j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "have \"\\<dots> = (\\<Sum>j = 0..<n. row B j \\<bullet> col A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n. col A j \\<bullet> row B j) =\n    (\\<Sum>j = 0..<n. row B j \\<bullet> col A j)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       col A x \\<bullet> row B x = row B x \\<bullet> col A x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < n \\<Longrightarrow>\n       col A x \\<bullet> row B x = row B x \\<bullet> col A x", "apply (subst comm_scalar_prod[where n=n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x < n \\<Longrightarrow> col A x \\<in> carrier_vec n\n 2. \\<And>x. x < n \\<Longrightarrow> row B x \\<in> carrier_vec n\n 3. \\<And>x.\n       x < n \\<Longrightarrow>\n       row B x \\<bullet> col A x = row B x \\<bullet> col A x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x < n \\<Longrightarrow> col A x \\<in> carrier_vec n\n 2. \\<And>x. x < n \\<Longrightarrow> row B x \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. \\<And>x. x < n \\<Longrightarrow> col A x \\<in> carrier_vec n\n 2. \\<And>x. x < n \\<Longrightarrow> row B x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n. col A j \\<bullet> row B j) =\n  (\\<Sum>j = 0..<n. row B j \\<bullet> col A j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n. col A j \\<bullet> row B j) =\n  (\\<Sum>j = 0..<n. row B j \\<bullet> col A j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "have \"\\<dots> = (\\<Sum>j = 0..<n. (B * A) $$ (j, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<n. row B j \\<bullet> col A j) =\n    (\\<Sum>j = 0..<n. (B * A) $$ (j, j))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       row B x \\<bullet> col A x = (B * A) $$ (x, x)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       row B x \\<bullet> col A x = (B * A) $$ (x, x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<n. row B j \\<bullet> col A j) =\n  (\\<Sum>j = 0..<n. (B * A) $$ (j, j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n  (\\<Sum>j = 0..<n. (B * A) $$ (j, j))", "show \"(\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) = (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n  (\\<Sum>j = 0..<n. (B * A) $$ (j, j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "using A B"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. (A * B) $$ (i, i)) =\n  (\\<Sum>j = 0..<n. (B * A) $$ (j, j))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_row A. (A * B) $$ (i, i)) =\n  (\\<Sum>i = 0..<dim_row B. (B * A) $$ (i, i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_add_linear:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A + B) = trace A + trace B\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "have \"?lhs = (\\<Sum>i=0..<n. A$$(i, i) + B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A + B) = (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A + B). (A + B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i))", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A + B). (A + B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  trace (A + B) = (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "also"], ["proof (state)\nthis:\n  trace (A + B) = (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "have \"\\<dots> = (\\<Sum>i=0..<n. A$$(i, i)) + (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "by (auto simp add: sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. A $$ (i, i) + B $$ (i, i)) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "finally"], ["proof (chain)\npicking this:\n  trace (A + B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "have l: \"?lhs = (\\<Sum>i=0..<n. A$$(i, i)) + (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\nusing this:\n  trace (A + B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "."], ["proof (state)\nthis:\n  trace (A + B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "have r: \"?rhs = (\\<Sum>i=0..<n. A$$(i, i)) + (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace A + trace B =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) +\n    (\\<Sum>i = 0..<dim_row B. B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) +\n    (\\<Sum>i = 0..<dim_row B. B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  trace A + trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "from l r"], ["proof (chain)\npicking this:\n  trace (A + B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n  trace A + trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (A + B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n  trace A + trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) + (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A + B) = trace A + trace B", "by auto"], ["proof (state)\nthis:\n  trace (A + B) = trace A + trace B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_minus_linear:\n  fixes A B :: \"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n  shows \"trace (A - B) = trace A - trace B\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "have \"?lhs = (\\<Sum>i=0..<n. A$$(i, i) - B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A - B) = (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A - B). (A - B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i))", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A - B). (A - B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  trace (A - B) = (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "also"], ["proof (state)\nthis:\n  trace (A - B) = (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "have \"\\<dots> = (\\<Sum>i=0..<n. A$$(i, i)) - (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "by (auto simp add: sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. A $$ (i, i) - B $$ (i, i)) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "finally"], ["proof (chain)\npicking this:\n  trace (A - B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "have l: \"?lhs = (\\<Sum>i=0..<n. A$$(i, i)) - (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\nusing this:\n  trace (A - B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "."], ["proof (state)\nthis:\n  trace (A - B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "have r: \"?rhs = (\\<Sum>i=0..<n. A$$(i, i)) - (\\<Sum>i=0..<n. B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace A - trace B =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) -\n    (\\<Sum>i = 0..<dim_row B. B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) -\n    (\\<Sum>i = 0..<dim_row B. B $$ (i, i)) =\n    (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  trace A - trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "from l r"], ["proof (chain)\npicking this:\n  trace (A - B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n  trace A - trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (A - B) =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n  trace A - trace B =\n  (\\<Sum>i = 0..<n. A $$ (i, i)) - (\\<Sum>i = 0..<n. B $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (A - B) = trace A - trace B", "by auto"], ["proof (state)\nthis:\n  trace (A - B) = trace A - trace B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_smult: \n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"trace (c \\<cdot>\\<^sub>m A) = c * trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "have \"trace (c \\<cdot>\\<^sub>m A) = (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (c \\<cdot>\\<^sub>m A).\n        (c \\<cdot>\\<^sub>m A) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (c \\<cdot>\\<^sub>m A).\n        (c \\<cdot>\\<^sub>m A) $$ (i, i)) =\n    (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  trace (c \\<cdot>\\<^sub>m A) = (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "also"], ["proof (state)\nthis:\n  trace (c \\<cdot>\\<^sub>m A) = (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "have \"\\<dots> = c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i)) =\n    c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i)) =\n  c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_row A. c * A $$ (i, i)) =\n  c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "have \"\\<dots> = c * trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) = c * trace A", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) =\n    c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) = c * trace A\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "ultimately"], ["proof (chain)\npicking this:\n  trace (c \\<cdot>\\<^sub>m A) = c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))\n  c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) = c * trace A", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (c \\<cdot>\\<^sub>m A) = c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i))\n  c * (\\<Sum>i = 0..<dim_row A. A $$ (i, i)) = c * trace A\n\ngoal (1 subgoal):\n 1. trace (c \\<cdot>\\<^sub>m A) = c * trace A", "by auto"], ["proof (state)\nthis:\n  trace (c \\<cdot>\\<^sub>m A) = c * trace A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Conjugate of a vector\\<close>"], ["", "lemma conjugate_scalar_prod:\n  fixes v w :: \"'a::conjugatable_ring vec\"\n  assumes \"dim_vec v = dim_vec w\"\n  shows \"conjugate (v \\<bullet> w) = conjugate v \\<bullet> conjugate w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (v \\<bullet> w) = conjugate v \\<bullet>c w", "using assms"], ["proof (prove)\nusing this:\n  dim_vec v = dim_vec w\n\ngoal (1 subgoal):\n 1. conjugate (v \\<bullet> w) = conjugate v \\<bullet>c w", "by (simp add: scalar_prod_def sum_conjugate conjugate_dist_mul)"], ["", "subsection \\<open>Inner product\\<close>"], ["", "abbreviation inner_prod :: \"'a vec \\<Rightarrow> 'a vec \\<Rightarrow> 'a :: conjugatable_ring\"\n  where \"inner_prod v w \\<equiv> w \\<bullet>c v\""], ["", "lemma conjugate_scalar_prod_Im [simp]:\n  \"Im (v \\<bullet>c v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (inner_prod v v) = 0", "by (simp add: scalar_prod_def conjugate_vec_def sum.neutral)"], ["", "lemma conjugate_scalar_prod_Re [simp]:\n  \"Re (v \\<bullet>c v) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re (inner_prod v v)", "by (simp add: scalar_prod_def conjugate_vec_def sum_nonneg)"], ["", "lemma self_cscalar_prod_geq_0:\n  fixes v ::  \"'a::conjugatable_ordered_field vec\"\n  shows \"v \\<bullet>c v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> inner_prod v v", "by (auto simp add: scalar_prod_def, rule sum_nonneg, rule conjugate_square_positive)"], ["", "lemma inner_prod_distrib_left:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod (v + w) u = inner_prod v u + inner_prod w u\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "have dimcv: \"conjugate v \\<in> carrier_vec n\" and dimcw: \"conjugate w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate v \\<in> carrier_vec n &&& conjugate w \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate v \\<in> carrier_vec n &&& conjugate w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  conjugate v \\<in> carrier_vec n\n  conjugate w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "have dimvw: \"conjugate (v + w) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (v + w) \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (v + w) \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  conjugate (v + w) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "have \"u \\<bullet> (conjugate (v + w)) = u \\<bullet> conjugate v + u \\<bullet> conjugate w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "using dimv dimw dimu dimcv dimcw"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n  u \\<in> carrier_vec n\n  conjugate v \\<in> carrier_vec n\n  conjugate w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "by (metis conjugate_add_vec scalar_prod_add_distrib)"], ["proof (state)\nthis:\n  inner_prod (v + w) u = inner_prod v u + inner_prod w u\n\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "then"], ["proof (chain)\npicking this:\n  inner_prod (v + w) u = inner_prod v u + inner_prod w u", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod (v + w) u = inner_prod v u + inner_prod w u\n\ngoal (1 subgoal):\n 1. inner_prod (v + w) u = inner_prod v u + inner_prod w u", "by auto"], ["proof (state)\nthis:\n  inner_prod (v + w) u = inner_prod v u + inner_prod w u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_prod_distrib_right:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod u (v + w) = inner_prod u v + inner_prod u w\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "have dimvw: \"v + w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v + w \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v + w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v + w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "have dimcu: \"conjugate u \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  conjugate u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "have \"(v + w) \\<bullet> (conjugate u) = v \\<bullet> conjugate u + w \\<bullet> conjugate u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "apply (simp add: comm_scalar_prod[OF dimvw dimcu])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<bullet> (v + w) = inner_prod u v + inner_prod u w", "apply (simp add: scalar_prod_add_distrib[OF dimcu dimv dimw])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<bullet> v + conjugate u \\<bullet> w =\n    inner_prod u v + inner_prod u w", "apply (insert dimv dimw dimcu, simp add: comm_scalar_prod[of _ n])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod u (v + w) = inner_prod u v + inner_prod u w\n\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "then"], ["proof (chain)\npicking this:\n  inner_prod u (v + w) = inner_prod u v + inner_prod u w", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod u (v + w) = inner_prod u v + inner_prod u w\n\ngoal (1 subgoal):\n 1. inner_prod u (v + w) = inner_prod u v + inner_prod u w", "by auto"], ["proof (state)\nthis:\n  inner_prod u (v + w) = inner_prod u v + inner_prod u w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_prod_minus_distrib_right:\n  fixes u v w :: \"('a::conjugatable_field) vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" and dimw: \"w \\<in> carrier_vec n\" \n  shows \"inner_prod u (v - w) = inner_prod u v - inner_prod u w\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "have dimvw: \"v - w \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - w \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v - w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v - w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "have dimcu: \"conjugate u \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  conjugate u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "have \"(v - w) \\<bullet> (conjugate u) = v \\<bullet> conjugate u - w \\<bullet> conjugate u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "apply (simp add: comm_scalar_prod[OF dimvw dimcu])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<bullet> (v - w) = inner_prod u v - inner_prod u w", "apply (simp add: scalar_prod_minus_distrib[OF dimcu dimv dimw])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate u \\<bullet> v - conjugate u \\<bullet> w =\n    inner_prod u v - inner_prod u w", "apply (insert dimv dimw dimcu, simp add: comm_scalar_prod[of _ n])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod u (v - w) = inner_prod u v - inner_prod u w\n\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "then"], ["proof (chain)\npicking this:\n  inner_prod u (v - w) = inner_prod u v - inner_prod u w", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod u (v - w) = inner_prod u v - inner_prod u w\n\ngoal (1 subgoal):\n 1. inner_prod u (v - w) = inner_prod u v - inner_prod u w", "by auto"], ["proof (state)\nthis:\n  inner_prod u (v - w) = inner_prod u v - inner_prod u w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_prod_smult_right:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv:\"v \\<in> carrier_vec n\" \n  shows \"inner_prod (a \\<cdot>\\<^sub>v u) v = conjugate a * inner_prod u v\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (a \\<cdot>\\<^sub>v u) v = conjugate a * inner_prod u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (a \\<cdot>\\<^sub>v u) v = conjugate a * inner_prod u v", "apply (simp add: scalar_prod_def conjugate_dist_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. v $ i * (cnj a * cnj (u $ i))) =\n                      cnj a * (\\<Sum>i = 0..<n. v $ i * cnj (u $ i))", "apply (subst sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. v $ i * (cnj a * cnj (u $ i))) =\n                      (\\<Sum>n = 0..<n. cnj a * (v $ n * cnj (u $ n)))", "by (rule sum.cong, auto)"], ["", "lemma inner_prod_smult_left:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv: \"v \\<in> carrier_vec n\" \n  shows \"inner_prod u (a \\<cdot>\\<^sub>v v) = a * inner_prod u v\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (a \\<cdot>\\<^sub>v v) = a * inner_prod u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod u (a \\<cdot>\\<^sub>v v) = a * inner_prod u v", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. a * v $ i * cnj (u $ i)) =\n                      a * (\\<Sum>i = 0..<n. v $ i * cnj (u $ i))", "apply (subst sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. a * v $ i * cnj (u $ i)) =\n                      (\\<Sum>n = 0..<n. a * (v $ n * cnj (u $ n)))", "by (rule sum.cong, auto)"], ["", "lemma inner_prod_smult_left_right:\n  fixes u v :: \"complex vec\"\n  assumes dimu: \"u \\<in> carrier_vec n\" and dimv: \"v \\<in> carrier_vec n\" \n  shows \"inner_prod (a \\<cdot>\\<^sub>v u) (b \\<cdot>\\<^sub>v v) = conjugate a * b  * inner_prod u v\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (a \\<cdot>\\<^sub>v u) (b \\<cdot>\\<^sub>v v) =\n    conjugate a * b * inner_prod u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (a \\<cdot>\\<^sub>v u) (b \\<cdot>\\<^sub>v v) =\n    conjugate a * b * inner_prod u v", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. b * v $ i * (cnj a * cnj (u $ i))) =\n                      cnj a * b * (\\<Sum>i = 0..<n. v $ i * cnj (u $ i))", "apply (subst sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n. b * v $ i * (cnj a * cnj (u $ i))) =\n                      (\\<Sum>n = 0..<n. cnj a * b * (v $ n * cnj (u $ n)))", "by (rule sum.cong, auto)"], ["", "lemma inner_prod_swap:\n  fixes x y :: \"complex vec\"\n  assumes \"y \\<in> carrier_vec n\" and \"x \\<in> carrier_vec n\" \n  shows \"inner_prod y x = conjugate (inner_prod x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod y x = conjugate (inner_prod x y)", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec y. x $ i * cnj (y $ i)) =\n    (\\<Sum>xa = 0..<dim_vec x. cnj (y $ xa) * x $ xa)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<dim_vec y} = {0..<dim_vec x}\n 2. \\<And>xa.\n       xa \\<in> {0..<dim_vec x} \\<Longrightarrow>\n       x $ xa * cnj (y $ xa) = cnj (y $ xa) * x $ xa", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> carrier_vec n\n  x \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. {0..<dim_vec y} = {0..<dim_vec x}\n 2. \\<And>xa.\n       xa \\<in> {0..<dim_vec x} \\<Longrightarrow>\n       x $ xa * cnj (y $ xa) = cnj (y $ xa) * x $ xa", "by auto"], ["", "text \\<open>Cauchy-Schwarz theorem for complex vectors. This is analogous to aux\\_Cauchy\n  and Cauchy\\_Schwarz\\_ineq in Generalizations2.thy in QR\\_Decomposition. Consider\n  merging and moving to Isabelle library.\\<close>"], ["", "lemma aux_Cauchy:\n  fixes x y :: \"complex vec\"\n  assumes \"x \\<in> carrier_vec n\" and \"y \\<in> carrier_vec n\"\n  shows \"0 \\<le> inner_prod x x + a * (inner_prod x y) + (cnj a) * ((cnj (inner_prod x y)) + a * (inner_prod y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "have \"(inner_prod (x+ a \\<cdot>\\<^sub>v y) (x+a \\<cdot>\\<^sub>v y)) = (inner_prod (x+a \\<cdot>\\<^sub>v y) x) + (inner_prod (x+a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (x + a \\<cdot>\\<^sub>v y) (x + a \\<cdot>\\<^sub>v y) =\n    inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)", "apply (subst inner_prod_distrib_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x + a \\<cdot>\\<^sub>v y \\<in> carrier_vec ?n\n 2. x \\<in> carrier_vec ?n\n 3. a \\<cdot>\\<^sub>v y \\<in> carrier_vec ?n\n 4. inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y) =\n    inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n  y \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. x + a \\<cdot>\\<^sub>v y \\<in> carrier_vec ?n\n 2. x \\<in> carrier_vec ?n\n 3. a \\<cdot>\\<^sub>v y \\<in> carrier_vec ?n\n 4. inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y) =\n    inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)", "by auto"], ["proof (state)\nthis:\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (x + a \\<cdot>\\<^sub>v y) =\n  inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "also"], ["proof (state)\nthis:\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (x + a \\<cdot>\\<^sub>v y) =\n  inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "have \"\\<dots> = inner_prod x x + (a) * (inner_prod x y) + cnj a * ((cnj (inner_prod x y)) + (a) * (inner_prod y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n    inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y) =\n    inner_prod x x + a * inner_prod x y +\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (subst (1 2) inner_prod_distrib_left[of _ n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. a \\<cdot>\\<^sub>v y \\<in> carrier_vec n\n 2. x \\<in> carrier_vec n\n 3. inner_prod x x + inner_prod (a \\<cdot>\\<^sub>v y) x +\n    (inner_prod x (a \\<cdot>\\<^sub>v y) +\n     inner_prod (a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y)) =\n    inner_prod x x + a * inner_prod x y +\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (auto simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (a \\<cdot>\\<^sub>v y) x +\n    (inner_prod x (a \\<cdot>\\<^sub>v y) +\n     a * inner_prod (a \\<cdot>\\<^sub>v y) y) =\n    a * inner_prod x y + cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (subst (1 2) inner_prod_smult_right[of _ n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> carrier_vec n\n 2. x \\<in> carrier_vec n\n 3. conjugate a * inner_prod y x +\n    (inner_prod x (a \\<cdot>\\<^sub>v y) +\n     a * (conjugate a * inner_prod y y)) =\n    a * inner_prod x y + cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (auto simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a * inner_prod y x +\n    (inner_prod x (a \\<cdot>\\<^sub>v y) + a * (cnj a * inner_prod y y)) =\n    a * inner_prod x y + cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (subst inner_prod_smult_left[of _ n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> carrier_vec n\n 2. y \\<in> carrier_vec n\n 3. cnj a * inner_prod y x +\n    (a * inner_prod x y + a * (cnj a * inner_prod y y)) =\n    a * inner_prod x y + cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (auto simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a * inner_prod y x + a * (cnj a * inner_prod y y) =\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (subst inner_prod_swap[of y n x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> carrier_vec n\n 2. x \\<in> carrier_vec n\n 3. cnj a * conjugate (inner_prod x y) + a * (cnj a * inner_prod y y) =\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "apply (auto simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a * cnj (inner_prod x y) + a * (cnj a * inner_prod y y) =\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "unfolding distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a * cnj (inner_prod x y) + a * (cnj a * inner_prod y y) =\n    cnj a * cnj (inner_prod x y) + cnj a * (a * inner_prod y y)", "by auto"], ["proof (state)\nthis:\n  inner_prod (x + a \\<cdot>\\<^sub>v y) x +\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (a \\<cdot>\\<^sub>v y) =\n  inner_prod x x + a * inner_prod x y +\n  cnj a * (cnj (inner_prod x y) + a * inner_prod y y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "finally"], ["proof (chain)\npicking this:\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (x + a \\<cdot>\\<^sub>v y) =\n  inner_prod x x + a * inner_prod x y +\n  cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod (x + a \\<cdot>\\<^sub>v y) (x + a \\<cdot>\\<^sub>v y) =\n  inner_prod x x + a * inner_prod x y +\n  cnj a * (cnj (inner_prod x y) + a * inner_prod y y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "by (metis self_cscalar_prod_geq_0)"], ["proof (state)\nthis:\n  0 \\<le> inner_prod x x + a * inner_prod x y +\n          cnj a * (cnj (inner_prod x y) + a * inner_prod y y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cauchy_Schwarz_complex_vec:\n  fixes x y :: \"complex vec\"\n  assumes \"x \\<in> carrier_vec n\" and \"y \\<in> carrier_vec n\"\n  shows \"inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "define cnj_a where \"cnj_a = - (inner_prod x y)/ cnj (inner_prod y y)\""], ["proof (state)\nthis:\n  cnj_a = - inner_prod x y / cnj (inner_prod y y)\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "define a where \"a = cnj (cnj_a)\""], ["proof (state)\nthis:\n  a = cnj cnj_a\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have cnj_rw: \"(cnj a) = cnj_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a = cnj_a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (cnj cnj_a) = cnj_a", "by (simp)"], ["proof (state)\nthis:\n  cnj a = cnj_a\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have rw_0: \"cnj (inner_prod x y) + a * (inner_prod y y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (inner_prod x y) + a * inner_prod y y = 0", "unfolding a_def cnj_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (inner_prod x y) +\n    cnj (- inner_prod x y / cnj (inner_prod y y)) * inner_prod y y =\n    0", "using assms(1) assms(2) conjugate_square_eq_0_vec"], ["proof (prove)\nusing this:\n  x \\<in> carrier_vec n\n  y \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow>\n  (inner_prod ?v ?v = (0::?'a)) = (?v = 0\\<^sub>v ?n)\n\ngoal (1 subgoal):\n 1. cnj (inner_prod x y) +\n    cnj (- inner_prod x y / cnj (inner_prod y y)) * inner_prod y y =\n    0", "by fastforce"], ["proof (state)\nthis:\n  cnj (inner_prod x y) + a * inner_prod y y = 0\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have \"0 \\<le>  (inner_prod x x + a * (inner_prod x y) + (cnj a) * ((cnj (inner_prod x y)) + a * (inner_prod y y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "using aux_Cauchy assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; ?y \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> inner_prod ?x ?x + ?a * inner_prod ?x ?y +\n                            cnj ?a *\n                            (cnj (inner_prod ?x ?y) + ?a * inner_prod ?y ?y)\n  x \\<in> carrier_vec n\n  y \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x + a * inner_prod x y +\n            cnj a * (cnj (inner_prod x y) + a * inner_prod y y)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod x x + a * inner_prod x y +\n          cnj a * (cnj (inner_prod x y) + a * inner_prod y y)\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "also"], ["proof (state)\nthis:\n  0 \\<le> inner_prod x x + a * inner_prod x y +\n          cnj a * (cnj (inner_prod x y) + a * inner_prod y y)\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have \"\\<dots> =  (inner_prod x x + a * (inner_prod x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod x x + a * inner_prod x y +\n    cnj a * (cnj (inner_prod x y) + a * inner_prod y y) =\n    inner_prod x x + a * inner_prod x y", "unfolding rw_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod x x + a * inner_prod x y + cnj a * 0 =\n    inner_prod x x + a * inner_prod x y", "by auto"], ["proof (state)\nthis:\n  inner_prod x x + a * inner_prod x y +\n  cnj a * (cnj (inner_prod x y) + a * inner_prod y y) =\n  inner_prod x x + a * inner_prod x y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "also"], ["proof (state)\nthis:\n  inner_prod x x + a * inner_prod x y +\n  cnj a * (cnj (inner_prod x y) + a * inner_prod y y) =\n  inner_prod x x + a * inner_prod x y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have \"\\<dots> =  (inner_prod x x - (inner_prod x y) * cnj (inner_prod x y) / (inner_prod y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod x x + a * inner_prod x y =\n    inner_prod x x - inner_prod x y * cnj (inner_prod x y) / inner_prod y y", "unfolding a_def cnj_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod x x +\n    cnj (- inner_prod x y / cnj (inner_prod y y)) * inner_prod x y =\n    inner_prod x x - inner_prod x y * cnj (inner_prod x y) / inner_prod y y", "by simp"], ["proof (state)\nthis:\n  inner_prod x x + a * inner_prod x y =\n  inner_prod x x - inner_prod x y * cnj (inner_prod x y) / inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod x x -\n          inner_prod x y * cnj (inner_prod x y) / inner_prod y y", "have \" 0 \\<le>  (inner_prod x x - (inner_prod x y) * cnj (inner_prod x y) / (inner_prod y y)) \""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod x x -\n          inner_prod x y * cnj (inner_prod x y) / inner_prod y y\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod x x -\n            inner_prod x y * cnj (inner_prod x y) / inner_prod y y", "."], ["proof (state)\nthis:\n  0 \\<le> inner_prod x x -\n          inner_prod x y * cnj (inner_prod x y) / inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "hence \"0 \\<le> (inner_prod x x - (inner_prod x y) * cnj (inner_prod x y) / (inner_prod y y)) * (inner_prod y y)\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod x x -\n          inner_prod x y * cnj (inner_prod x y) / inner_prod y y\n\ngoal (1 subgoal):\n 1. 0 \\<le> (inner_prod x x -\n             inner_prod x y * cnj (inner_prod x y) / inner_prod y y) *\n            inner_prod y y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (inner_prod x x -\n           inner_prod x y * cnj (inner_prod x y) / inner_prod y y) *\n          inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "also"], ["proof (state)\nthis:\n  0 \\<le> (inner_prod x x -\n           inner_prod x y * cnj (inner_prod x y) / inner_prod y y) *\n          inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "have \"\\<dots> = ((inner_prod x x)*(inner_prod y y) - (inner_prod x y) * cnj (inner_prod x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inner_prod x x -\n     inner_prod x y * cnj (inner_prod x y) / inner_prod y y) *\n    inner_prod y y =\n    inner_prod x x * inner_prod y y - inner_prod x y * cnj (inner_prod x y)", "by (smt add.inverse_neutral add_diff_cancel diff_0 diff_divide_eq_iff divide_cancel_right mult_eq_0_iff nonzero_mult_div_cancel_right rw_0)"], ["proof (state)\nthis:\n  (inner_prod x x -\n   inner_prod x y * cnj (inner_prod x y) / inner_prod y y) *\n  inner_prod y y =\n  inner_prod x x * inner_prod y y - inner_prod x y * cnj (inner_prod x y)\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod x x * inner_prod y y -\n          inner_prod x y * cnj (inner_prod x y)", "have \"(inner_prod x y) * cnj (inner_prod x y) \\<le> (inner_prod x x)*(inner_prod y y)\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod x x * inner_prod y y -\n          inner_prod x y * cnj (inner_prod x y)\n\ngoal (1 subgoal):\n 1. inner_prod x y * cnj (inner_prod x y)\n    \\<le> inner_prod x x * inner_prod y y", "by auto"], ["proof (state)\nthis:\n  inner_prod x y * cnj (inner_prod x y)\n  \\<le> inner_prod x x * inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "then"], ["proof (chain)\npicking this:\n  inner_prod x y * cnj (inner_prod x y)\n  \\<le> inner_prod x x * inner_prod y y", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod x y * cnj (inner_prod x y)\n  \\<le> inner_prod x x * inner_prod y y\n\ngoal (1 subgoal):\n 1. inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y", "apply (subst inner_prod_swap[of y n x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inner_prod x y * cnj (inner_prod x y)\n    \\<le> inner_prod x x * inner_prod y y \\<Longrightarrow>\n    y \\<in> carrier_vec n\n 2. inner_prod x y * cnj (inner_prod x y)\n    \\<le> inner_prod x x * inner_prod y y \\<Longrightarrow>\n    x \\<in> carrier_vec n\n 3. inner_prod x y * cnj (inner_prod x y)\n    \\<le> inner_prod x x * inner_prod y y \\<Longrightarrow>\n    inner_prod x y * conjugate (inner_prod x y)\n    \\<le> inner_prod x x * inner_prod y y", "by (auto simp add: assms)"], ["proof (state)\nthis:\n  inner_prod x y * inner_prod y x \\<le> inner_prod x x * inner_prod y y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Hermitian adjoint of a matrix\\<close>"], ["", "abbreviation adjoint where \"adjoint \\<equiv> mat_adjoint\""], ["", "lemma adjoint_dim_row [simp]:\n  \"dim_row (adjoint A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (adjoint A) = dim_col A", "by (simp add: mat_adjoint_def)"], ["", "lemma adjoint_dim_col [simp]:\n  \"dim_col (adjoint A) = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (adjoint A) = dim_row A", "by (simp add: mat_adjoint_def)"], ["", "lemma adjoint_dim:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> adjoint A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    adjoint A \\<in> carrier_mat n n", "using adjoint_dim_col adjoint_dim_row"], ["proof (prove)\nusing this:\n  dim_col (adjoint ?A) = dim_row ?A\n  dim_row (adjoint ?A) = dim_col ?A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    adjoint A \\<in> carrier_mat n n", "by blast"], ["", "lemma adjoint_def:\n  \"adjoint A = mat (dim_col A) (dim_row A) (\\<lambda>(i,j). conjugate (A $$ (j,i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint A =\n    mat (dim_col A) (dim_row A) (\\<lambda>(i, j). conjugate (A $$ (j, i)))", "unfolding mat_adjoint_def mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length (map conjugate (cols A))) (dim_row A)\n     (\\<lambda>(i, y). map conjugate (cols A) ! i $ y) =\n    mat (dim_col A) (dim_row A) (\\<lambda>(i, j). conjugate (A $$ (j, i)))", "by auto"], ["", "lemma adjoint_eval:\n  assumes \"i < dim_col A\" \"j < dim_row A\"\n  shows \"(adjoint A) $$ (i,j) = conjugate (A $$ (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint A $$ (i, j) = conjugate (A $$ (j, i))", "using assms"], ["proof (prove)\nusing this:\n  i < dim_col A\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. adjoint A $$ (i, j) = conjugate (A $$ (j, i))", "by (simp add: adjoint_def)"], ["", "lemma adjoint_row:\n  assumes \"i < dim_col A\"\n  shows \"row (adjoint A) i = conjugate (col A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (adjoint A) i = conjugate (col A i)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec (conjugate (col A i)) \\<Longrightarrow>\n       row (adjoint A) i $ ia = conjugate (col A i) $ ia\n 2. dim_vec (row (adjoint A) i) = dim_vec (conjugate (col A i))", "using assms"], ["proof (prove)\nusing this:\n  i < dim_col A\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec (conjugate (col A i)) \\<Longrightarrow>\n       row (adjoint A) i $ ia = conjugate (col A i) $ ia\n 2. dim_vec (row (adjoint A) i) = dim_vec (conjugate (col A i))", "by (auto simp add: adjoint_eval)"], ["", "lemma adjoint_col:\n  assumes \"i < dim_row A\"\n  shows \"col (adjoint A) i = conjugate (row A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (adjoint A) i = conjugate (row A i)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec (conjugate (row A i)) \\<Longrightarrow>\n       col (adjoint A) i $ ia = conjugate (row A i) $ ia\n 2. dim_vec (col (adjoint A) i) = dim_vec (conjugate (row A i))", "using assms"], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia < dim_vec (conjugate (row A i)) \\<Longrightarrow>\n       col (adjoint A) i $ ia = conjugate (row A i) $ ia\n 2. dim_vec (col (adjoint A) i) = dim_vec (conjugate (row A i))", "by (auto simp add: adjoint_eval)"], ["", "text \\<open>The identity <v, A w> = <A* v, w>\\<close>"], ["", "lemma adjoint_def_alter:\n  fixes v w :: \"'a::conjugatable_field vec\"\n    and A :: \"'a::conjugatable_field mat\"\n  assumes dims: \"v \\<in> carrier_vec n\" \"w \\<in> carrier_vec m\" \"A \\<in> carrier_mat n m\"\n  shows \"inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "from dims"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  A \\<in> carrier_mat n m", "have \"?lhs = (\\<Sum>i=0..<dim_vec v. (\\<Sum>j=0..<dim_vec w.\n                conjugate (v$i) * A$$(i, j) * w$j))\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) =\n    (\\<Sum>i = 0..<dim_vec v.\n        \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)", "apply (simp add: scalar_prod_def sum_distrib_right )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec m;\n     A \\<in> carrier_mat n m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                          \\<Sum>n = 0..<m.\n                             A $$ (i, n) * w $ n * conjugate (v $ i)) =\n                      (\\<Sum>i = 0..<n.\n                          \\<Sum>j = 0..<m.\n                             conjugate (v $ i) * A $$ (i, j) * w $ j)", "apply (rule sum.cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec m;\n        A \\<in> carrier_mat n m; x \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n = 0..<m.\n                             A $$ (x, n) * w $ n * conjugate (v $ x)) =\n                         (\\<Sum>j = 0..<m.\n                             conjugate (v $ x) * A $$ (x, j) * w $ j)", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v w) =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "moreover"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v w) =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  A \\<in> carrier_mat n m", "have \"?rhs = (\\<Sum>i=0..<dim_vec v. (\\<Sum>j=0..<dim_vec w.\n                conjugate (v$i) * A$$(i, j) * w$j))\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. inner_prod (adjoint A *\\<^sub>v v) w =\n    (\\<Sum>i = 0..<dim_vec v.\n        \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)", "apply (simp add: scalar_prod_def  adjoint_eval \n                     sum_conjugate conjugate_dist_mul sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec m;\n     A \\<in> carrier_mat n m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<m.\n                          \\<Sum>n = 0..<n.\n                             w $ i * (A $$ (n, i) * conjugate (v $ n))) =\n                      (\\<Sum>i = 0..<n.\n                          \\<Sum>j = 0..<m.\n                             conjugate (v $ i) * A $$ (i, j) * w $ j)", "apply (subst sum.swap[where ?A = \"{0..<n}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec m;\n     A \\<in> carrier_mat n m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<m.\n                          \\<Sum>n = 0..<n.\n                             w $ i * (A $$ (n, i) * conjugate (v $ n))) =\n                      (\\<Sum>j = 0..<m.\n                          \\<Sum>i = 0..<n.\n                             conjugate (v $ i) * A $$ (i, j) * w $ j)", "apply (rule sum.cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v \\<in> carrier_vec n; w \\<in> carrier_vec m;\n        A \\<in> carrier_mat n m; x \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n = 0..<n.\n                             w $ x * (A $$ (n, x) * conjugate (v $ n))) =\n                         (\\<Sum>i = 0..<n.\n                             conjugate (v $ i) * A $$ (i, x) * w $ x)", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod (adjoint A *\\<^sub>v v) w =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v w) =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n  inner_prod (adjoint A *\\<^sub>v v) w =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v w) =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n  inner_prod (adjoint A *\\<^sub>v v) w =\n  (\\<Sum>i = 0..<dim_vec v.\n      \\<Sum>j = 0..<dim_vec w. conjugate (v $ i) * A $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w", "by simp"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v w) = inner_prod (adjoint A *\\<^sub>v v) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjoint_one:\n  shows \"adjoint (1\\<^sub>m n) = (1\\<^sub>m n::complex mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m n);\n        j < dim_col (1\\<^sub>m n)\\<rbrakk>\n       \\<Longrightarrow> adjoint (1\\<^sub>m n) $$ (i, j) =\n                         1\\<^sub>m n $$ (i, j)\n 2. dim_row (adjoint (1\\<^sub>m n)) = dim_row (1\\<^sub>m n)\n 3. dim_col (adjoint (1\\<^sub>m n)) = dim_col (1\\<^sub>m n)", "by (auto simp add: adjoint_eval)"], ["", "lemma adjoint_scale:\n  fixes A :: \"'a::conjugatable_field mat\"\n  shows \"adjoint (a \\<cdot>\\<^sub>m A) = (conjugate a) \\<cdot>\\<^sub>m adjoint A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (a \\<cdot>\\<^sub>m A) = conjugate a \\<cdot>\\<^sub>m adjoint A", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (conjugate a \\<cdot>\\<^sub>m adjoint A);\n        j < dim_col (conjugate a \\<cdot>\\<^sub>m adjoint A)\\<rbrakk>\n       \\<Longrightarrow> adjoint (a \\<cdot>\\<^sub>m A) $$ (i, j) =\n                         (conjugate a \\<cdot>\\<^sub>m adjoint A) $$ (i, j)\n 2. dim_row (adjoint (a \\<cdot>\\<^sub>m A)) =\n    dim_row (conjugate a \\<cdot>\\<^sub>m adjoint A)\n 3. dim_col (adjoint (a \\<cdot>\\<^sub>m A)) =\n    dim_col (conjugate a \\<cdot>\\<^sub>m adjoint A)", "using conjugatable_ring_class.conjugate_dist_mul"], ["proof (prove)\nusing this:\n  conjugate (?a * ?b) = conjugate ?a * conjugate ?b\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (conjugate a \\<cdot>\\<^sub>m adjoint A);\n        j < dim_col (conjugate a \\<cdot>\\<^sub>m adjoint A)\\<rbrakk>\n       \\<Longrightarrow> adjoint (a \\<cdot>\\<^sub>m A) $$ (i, j) =\n                         (conjugate a \\<cdot>\\<^sub>m adjoint A) $$ (i, j)\n 2. dim_row (adjoint (a \\<cdot>\\<^sub>m A)) =\n    dim_row (conjugate a \\<cdot>\\<^sub>m adjoint A)\n 3. dim_col (adjoint (a \\<cdot>\\<^sub>m A)) =\n    dim_col (conjugate a \\<cdot>\\<^sub>m adjoint A)", "by (auto simp add: adjoint_eval)"], ["", "lemma adjoint_add:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat n m\"\n  shows \"adjoint (A + B) = adjoint A + adjoint B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (A + B) = adjoint A + adjoint B", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (adjoint A + adjoint B);\n        j < dim_col (adjoint A + adjoint B)\\<rbrakk>\n       \\<Longrightarrow> adjoint (A + B) $$ (i, j) =\n                         (adjoint A + adjoint B) $$ (i, j)\n 2. dim_row (adjoint (A + B)) = dim_row (adjoint A + adjoint B)\n 3. dim_col (adjoint (A + B)) = dim_col (adjoint A + adjoint B)", "using assms conjugatable_ring_class.conjugate_dist_add"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  B \\<in> carrier_mat n m\n  conjugate (?a + ?b) = conjugate ?a + conjugate ?b\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (adjoint A + adjoint B);\n        j < dim_col (adjoint A + adjoint B)\\<rbrakk>\n       \\<Longrightarrow> adjoint (A + B) $$ (i, j) =\n                         (adjoint A + adjoint B) $$ (i, j)\n 2. dim_row (adjoint (A + B)) = dim_row (adjoint A + adjoint B)\n 3. dim_col (adjoint (A + B)) = dim_col (adjoint A + adjoint B)", "by( auto simp add: adjoint_eval)"], ["", "lemma adjoint_minus:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat n m\"\n  shows \"adjoint (A - B) = adjoint A - adjoint B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (A - B) = adjoint A - adjoint B", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (adjoint A - adjoint B);\n        j < dim_col (adjoint A - adjoint B)\\<rbrakk>\n       \\<Longrightarrow> adjoint (A - B) $$ (i, j) =\n                         (adjoint A - adjoint B) $$ (i, j)\n 2. dim_row (adjoint (A - B)) = dim_row (adjoint A - adjoint B)\n 3. dim_col (adjoint (A - B)) = dim_col (adjoint A - adjoint B)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  B \\<in> carrier_mat n m\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (adjoint A - adjoint B);\n        j < dim_col (adjoint A - adjoint B)\\<rbrakk>\n       \\<Longrightarrow> adjoint (A - B) $$ (i, j) =\n                         (adjoint A - adjoint B) $$ (i, j)\n 2. dim_row (adjoint (A - B)) = dim_row (adjoint A - adjoint B)\n 3. dim_col (adjoint (A - B)) = dim_col (adjoint A - adjoint B)", "apply(auto simp add: adjoint_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < m; j < n; A \\<in> carrier_mat n m;\n        B \\<in> carrier_mat n m\\<rbrakk>\n       \\<Longrightarrow> conjugate (A $$ (j, i) - B $$ (j, i)) =\n                         conjugate (A $$ (j, i)) - conjugate (B $$ (j, i))", "by (metis add_uminus_conv_diff conjugate_dist_add conjugate_neg)"], ["", "lemma adjoint_mult:\n  fixes A B :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat n m\" \"B \\<in> carrier_mat m l\"\n  shows \"adjoint (A * B) = adjoint B * adjoint A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (A * B) = adjoint B * adjoint A", "proof (rule eq_matI, auto simp add: adjoint_eval adjoint_row adjoint_col)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col B; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> conjugate (row A j \\<bullet> col B i) =\n                         inner_prod (row A j) (conjugate (col B i))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col B; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> conjugate (row A j \\<bullet> col B i) =\n                         inner_prod (row A j) (conjugate (col B i))", "assume \"i < dim_col B\" \"j < dim_row A\""], ["proof (state)\nthis:\n  i < dim_col B\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_col B; j < dim_row A\\<rbrakk>\n       \\<Longrightarrow> conjugate (row A j \\<bullet> col B i) =\n                         inner_prod (row A j) (conjugate (col B i))", "show \"conjugate (row A j \\<bullet> col B i) = conjugate (col B i) \\<bullet> conjugate (row A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (row A j \\<bullet> col B i) =\n    inner_prod (row A j) (conjugate (col B i))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  B \\<in> carrier_mat m l\n\ngoal (1 subgoal):\n 1. conjugate (row A j \\<bullet> col B i) =\n    inner_prod (row A j) (conjugate (col B i))", "apply (simp add: conjugate_scalar_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n m; B \\<in> carrier_mat m l\\<rbrakk>\n    \\<Longrightarrow> inner_prod (col B i) (conjugate (row A j)) =\n                      inner_prod (row A j) (conjugate (col B i))", "apply (subst comm_scalar_prod[where n=\"dim_row B\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>A \\<in> carrier_mat n m; B \\<in> carrier_mat m l\\<rbrakk>\n    \\<Longrightarrow> conjugate (row A j) \\<in> carrier_vec (dim_row B)\n 2. \\<lbrakk>A \\<in> carrier_mat n m; B \\<in> carrier_mat m l\\<rbrakk>\n    \\<Longrightarrow> conjugate (col B i) \\<in> carrier_vec (dim_row B)\n 3. \\<lbrakk>A \\<in> carrier_mat n m; B \\<in> carrier_mat m l\\<rbrakk>\n    \\<Longrightarrow> inner_prod (row A j) (conjugate (col B i)) =\n                      inner_prod (row A j) (conjugate (col B i))", "by (auto simp add: carrier_vecI)"], ["proof (state)\nthis:\n  conjugate (row A j \\<bullet> col B i) =\n  inner_prod (row A j) (conjugate (col B i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjoint_adjoint:\n  fixes A :: \"'a::conjugatable_field mat\"\n  shows \"adjoint (adjoint A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (adjoint A) = A", "by (rule eq_matI, auto simp add: adjoint_eval)"], ["", "lemma trace_adjoint_positive:\n  fixes A :: \"complex mat\"\n  shows \"trace (A * adjoint A) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> trace (A * adjoint A)", "apply (auto simp add: trace_def adjoint_col)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>x = 0..<dim_row A. Re (inner_prod (row A x) (row A x)))", "apply (rule sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<dim_row A} \\<Longrightarrow>\n       0 \\<le> Re (inner_prod (row A x) (row A x))", "by auto"], ["", "subsection \\<open>Algebraic manipulations on matrices\\<close>"], ["", "lemma right_add_zero_mat[simp]:\n  \"(A :: 'a :: monoid_add mat) \\<in> carrier_mat nr nc \\<Longrightarrow> A + 0\\<^sub>m nr nc = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat nr nc \\<Longrightarrow> A + 0\\<^sub>m nr nc = A", "by (intro eq_matI, auto)"], ["", "lemma add_carrier_mat':\n  \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc \\<Longrightarrow> A + B \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> A + B \\<in> carrier_mat nr nc", "by simp"], ["", "lemma minus_carrier_mat':\n  \"A \\<in> carrier_mat nr nc \\<Longrightarrow> B \\<in> carrier_mat nr nc \\<Longrightarrow> A - B \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc\\<rbrakk>\n    \\<Longrightarrow> A - B \\<in> carrier_mat nr nc", "by auto"], ["", "lemma swap_plus_mat:\n  fixes A B C :: \"'a::semiring_1 mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\"\n  shows \"A + B + C = A + C + B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B + C = A + C + B", "by (metis assms assoc_add_mat comm_add_mat)"], ["", "lemma uminus_mat:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"-A = (-1) \\<cdot>\\<^sub>m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A = - 1 \\<cdot>\\<^sub>m A", "by auto"], ["", "ML_file \"mat_alg.ML\""], ["", "method_setup mat_assoc = \\<open>mat_assoc_method\\<close>\n  \"Normalization of expressions on matrices\""], ["", "lemma mat_assoc_test:\n  fixes A B C D :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n  shows\n    \"(A * B) * (C * D) = A * B * C * D\"\n    \"adjoint (A * adjoint B) * C = B * (adjoint A * C)\"\n    \"A * 1\\<^sub>m n * 1\\<^sub>m n * B * 1\\<^sub>m n = A * B\"\n    \"(A - B) + (B - C) = A + (-B) + B + (-C)\"\n    \"A + (B - C) = A + B - C\"\n    \"A - (B + C + D) = A - B - C - D\"\n    \"(A + B) * (B + C) = A * B + B * B + A * C + B * C\"\n    \"A - B = A + (-1) \\<cdot>\\<^sub>m B\"\n    \"A * (B - C) * D = A * B * D - A * C * D\"\n    \"trace (A * B * C) = trace (B * C * A)\"\n    \"trace (A * B * C * D) = trace (C * D * A * B)\"\n    \"trace (A + B * C) = trace A + trace (C * B)\"\n    \"A + B = B + A\"\n    \"A + B + C = C + B + A\"\n    \"A + B + (C + D) = A + C + (B + D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A * B * (C * D) = A * B * C * D &&&\n      adjoint (A * adjoint B) * C = B * (adjoint A * C) &&&\n      A * 1\\<^sub>m n * 1\\<^sub>m n * B * 1\\<^sub>m n = A * B) &&&\n     (A - B + (B - C) = A + - B + B + - C &&& A + (B - C) = A + B - C) &&&\n     A - (B + C + D) = A - B - C - D &&&\n     (A + B) * (B + C) = A * B + B * B + A * C + B * C) &&&\n    ((A - B = A + - 1 \\<cdot>\\<^sub>m B &&&\n      A * (B - C) * D = A * B * D - A * C * D) &&&\n     trace (A * B * C) = trace (B * C * A) &&&\n     trace (A * B * C * D) = trace (C * D * A * B)) &&&\n    (trace (A + B * C) = trace A + trace (C * B) &&& A + B = B + A) &&&\n    A + B + C = C + B + A &&& A + B + (C + D) = A + C + (B + D)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. ((A * B * (C * D) = A * B * C * D &&&\n      adjoint (A * adjoint B) * C = B * (adjoint A * C) &&&\n      A * 1\\<^sub>m n * 1\\<^sub>m n * B * 1\\<^sub>m n = A * B) &&&\n     (A - B + (B - C) = A + - B + B + - C &&& A + (B - C) = A + B - C) &&&\n     A - (B + C + D) = A - B - C - D &&&\n     (A + B) * (B + C) = A * B + B * B + A * C + B * C) &&&\n    ((A - B = A + - 1 \\<cdot>\\<^sub>m B &&&\n      A * (B - C) * D = A * B * D - A * C * D) &&&\n     trace (A * B * C) = trace (B * C * A) &&&\n     trace (A * B * C * D) = trace (C * D * A * B)) &&&\n    (trace (A + B * C) = trace A + trace (C * B) &&& A + B = B + A) &&&\n    A + B + C = C + B + A &&& A + B + (C + D) = A + C + (B + D)", "by (mat_assoc n)+"], ["", "subsection \\<open>Hermitian matrices\\<close>"], ["", "text \\<open>A Hermitian matrix is a matrix that is equal to its Hermitian adjoint.\\<close>"], ["", "definition hermitian :: \"'a::conjugatable_field mat \\<Rightarrow> bool\" where\n  \"hermitian A \\<longleftrightarrow> (adjoint A = A)\""], ["", "lemma hermitian_one:\n  shows \"hermitian ((1\\<^sub>m n)::('a::conjugatable_field mat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m n)", "unfolding hermitian_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "have \"conjugate (1::'a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (1::'a) = (1::'a)", "apply (subst mult_1_right[symmetric, of \"conjugate 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (1::'a) * (1::'a) = (1::'a)", "apply (subst conjugate_id[symmetric, of \"conjugate 1 * 1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (conjugate (conjugate (1::'a) * (1::'a))) = (1::'a)", "apply (subst conjugate_dist_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (conjugate (conjugate (1::'a)) * conjugate (1::'a)) = (1::'a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  conjugate (1::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  conjugate (1::'a) = (1::'a)", "show \"adjoint ((1\\<^sub>m n)::('a::conjugatable_field mat)) = (1\\<^sub>m n)\""], ["proof (prove)\nusing this:\n  conjugate (1::'a) = (1::'a)\n\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "by (auto simp add: adjoint_eval)"], ["proof (state)\nthis:\n  adjoint (1\\<^sub>m n) = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Inverse matrices\\<close>"], ["", "lemma inverts_mat_symm:\n  fixes A B :: \"'a::field mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n    and AB: \"inverts_mat A B\"\n  shows \"inverts_mat B A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat B A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverts_mat B A", "have \"A * B = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "using dim AB"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  inverts_mat A B\n\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A * B = 1\\<^sub>m (dim_row A)\n\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A * B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inverts_mat B A", "with dim"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A * B = 1\\<^sub>m n", "have \"B * A = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A * B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B * A = 1\\<^sub>m n", "by (rule mat_mult_left_right_inverse)"], ["proof (state)\nthis:\n  B * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inverts_mat B A", "then"], ["proof (chain)\npicking this:\n  B * A = 1\\<^sub>m n", "show \"inverts_mat B A\""], ["proof (prove)\nusing this:\n  B * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inverts_mat B A", "using dim inverts_mat_def"], ["proof (prove)\nusing this:\n  B * A = 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n\ngoal (1 subgoal):\n 1. inverts_mat B A", "by auto"], ["proof (state)\nthis:\n  inverts_mat B A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverts_mat_unique:\n  fixes A B C :: \"'a::field mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \n    and AB: \"inverts_mat A B\" and AC: \"inverts_mat A C\"\n  shows \"B = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B = C", "have AB1: \"A * B = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "using AB dim"], ["proof (prove)\nusing this:\n  inverts_mat A B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  A * B = 1\\<^sub>m (dim_row A)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A * B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C", "have \"A * C = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * C = 1\\<^sub>m n", "using AC dim"], ["proof (prove)\nusing this:\n  inverts_mat A C\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A * C = 1\\<^sub>m n", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  A * C = 1\\<^sub>m (dim_row A)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A * C = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A * C = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C", "then"], ["proof (chain)\npicking this:\n  A * C = 1\\<^sub>m n", "have CA1: \"C * A = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A * C = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. C * A = 1\\<^sub>m n", "using mat_mult_left_right_inverse[of A n C] dim"], ["proof (prove)\nusing this:\n  A * C = 1\\<^sub>m n\n  \\<lbrakk>A \\<in> carrier_mat n n; C \\<in> carrier_mat n n;\n   A * C = 1\\<^sub>m n\\<rbrakk>\n  \\<Longrightarrow> C * A = 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. C * A = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C", "then"], ["proof (chain)\npicking this:\n  C * A = 1\\<^sub>m n", "have \"C = C * 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. C = C * 1\\<^sub>m n", "using dim"], ["proof (prove)\nusing this:\n  C * A = 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. C = C * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  C = C * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C", "also"], ["proof (state)\nthis:\n  C = C * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C", "have \"\\<dots> = C * (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * 1\\<^sub>m n = C * (A * B)", "using AB1"], ["proof (prove)\nusing this:\n  A * B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. C * 1\\<^sub>m n = C * (A * B)", "by auto"], ["proof (state)\nthis:\n  C * 1\\<^sub>m n = C * (A * B)\n\ngoal (1 subgoal):\n 1. B = C", "also"], ["proof (state)\nthis:\n  C * 1\\<^sub>m n = C * (A * B)\n\ngoal (1 subgoal):\n 1. B = C", "have \"\\<dots> = (C * A) * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * (A * B) = C * A * B", "using dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. C * (A * B) = C * A * B", "by auto"], ["proof (state)\nthis:\n  C * (A * B) = C * A * B\n\ngoal (1 subgoal):\n 1. B = C", "also"], ["proof (state)\nthis:\n  C * (A * B) = C * A * B\n\ngoal (1 subgoal):\n 1. B = C", "have \"\\<dots> = 1\\<^sub>m n * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C * A * B = 1\\<^sub>m n * B", "using CA1"], ["proof (prove)\nusing this:\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. C * A * B = 1\\<^sub>m n * B", "by auto"], ["proof (state)\nthis:\n  C * A * B = 1\\<^sub>m n * B\n\ngoal (1 subgoal):\n 1. B = C", "also"], ["proof (state)\nthis:\n  C * A * B = 1\\<^sub>m n * B\n\ngoal (1 subgoal):\n 1. B = C", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B = B", "using dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B = B", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * B = B\n\ngoal (1 subgoal):\n 1. B = C", "finally"], ["proof (chain)\npicking this:\n  C = B", "show \"B = C\""], ["proof (prove)\nusing this:\n  C = B\n\ngoal (1 subgoal):\n 1. B = C", ".."], ["proof (state)\nthis:\n  B = C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unitary matrices\\<close>"], ["", "text \\<open>A unitary matrix is a matrix whose Hermitian adjoint is also its inverse.\\<close>"], ["", "definition unitary :: \"'a::conjugatable_field mat \\<Rightarrow> bool\" where\n  \"unitary A \\<longleftrightarrow> A \\<in> carrier_mat (dim_row A) (dim_row A) \\<and> inverts_mat A (adjoint A)\""], ["", "lemma unitaryD2:\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"unitary A \\<Longrightarrow> inverts_mat (adjoint A) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary A \\<Longrightarrow> inverts_mat (adjoint A) A", "using assms adjoint_dim inverts_mat_symm unitary_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  adjoint ?A \\<in> carrier_mat ?n ?n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   inverts_mat ?A ?B\\<rbrakk>\n  \\<Longrightarrow> inverts_mat ?B ?A\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n\ngoal (1 subgoal):\n 1. unitary A \\<Longrightarrow> inverts_mat (adjoint A) A", "by blast"], ["", "lemma unitary_simps [simp]:\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> unitary A \\<Longrightarrow> adjoint A * A = 1\\<^sub>m n\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> unitary A \\<Longrightarrow> A * adjoint A = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<in> carrier_mat n n; unitary A\\<rbrakk>\n     \\<Longrightarrow> adjoint A * A = 1\\<^sub>m n) &&&\n    (\\<lbrakk>A \\<in> carrier_mat n n; unitary A\\<rbrakk>\n     \\<Longrightarrow> A * adjoint A = 1\\<^sub>m n)", "apply (metis adjoint_dim_row carrier_matD(2) inverts_mat_def unitaryD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; unitary A\\<rbrakk>\n    \\<Longrightarrow> A * adjoint A = 1\\<^sub>m n", "by (simp add: inverts_mat_def unitary_def)"], ["", "lemma unitary_adjoint [simp]:\n  assumes \"A \\<in> carrier_mat n n\" \"unitary A\"\n  shows \"unitary (adjoint A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (adjoint A)", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint A\n    \\<in> carrier_mat (dim_row (adjoint A)) (dim_row (adjoint A)) \\<and>\n    inverts_mat (adjoint A) (adjoint (adjoint A))", "using  adjoint_dim[OF assms(1)] assms"], ["proof (prove)\nusing this:\n  adjoint A \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  unitary A\n\ngoal (1 subgoal):\n 1. adjoint A\n    \\<in> carrier_mat (dim_row (adjoint A)) (dim_row (adjoint A)) \\<and>\n    inverts_mat (adjoint A) (adjoint (adjoint A))", "by (auto simp add: unitaryD2[OF assms] adjoint_adjoint)"], ["", "lemma unitary_one:\n  shows \"unitary ((1\\<^sub>m n)::('a::conjugatable_field mat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (1\\<^sub>m n)", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "define I where I_def[simp]: \"I \\<equiv> ((1\\<^sub>m n)::('a::conjugatable_field mat))\""], ["proof (state)\nthis:\n  I \\<equiv> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "have dim: \"I \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "have \"hermitian I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I", "using hermitian_one"], ["proof (prove)\nusing this:\n  hermitian (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. hermitian I", "by auto"], ["proof (state)\nthis:\n  hermitian I\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "hence \"adjoint I = I\""], ["proof (prove)\nusing this:\n  hermitian I\n\ngoal (1 subgoal):\n 1. adjoint I = I", "using hermitian_def"], ["proof (prove)\nusing this:\n  hermitian I\n  hermitian ?A = (adjoint ?A = ?A)\n\ngoal (1 subgoal):\n 1. adjoint I = I", "by auto"], ["proof (state)\nthis:\n  adjoint I = I\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n\n    \\<in> carrier_mat (dim_row (1\\<^sub>m n)) (dim_row (1\\<^sub>m n)) \\<and>\n    inverts_mat (1\\<^sub>m n) (adjoint (1\\<^sub>m n))", "with dim"], ["proof (chain)\npicking this:\n  I \\<in> carrier_mat n n\n  adjoint I = I", "show \"I \\<in> carrier_mat (dim_row I) (dim_row I) \\<and> inverts_mat I (adjoint I)\""], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  adjoint I = I\n\ngoal (1 subgoal):\n 1. I \\<in> carrier_mat (dim_row I) (dim_row I) \\<and>\n    inverts_mat I (adjoint I)", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  adjoint I = I\n\ngoal (1 subgoal):\n 1. I \\<in> carrier_mat (dim_row I) (dim_row I) \\<and>\n    I * adjoint I = 1\\<^sub>m (dim_row I)", "using dim"], ["proof (prove)\nusing this:\n  I \\<in> carrier_mat n n\n  adjoint I = I\n  I \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. I \\<in> carrier_mat (dim_row I) (dim_row I) \\<and>\n    I * adjoint I = 1\\<^sub>m (dim_row I)", "by auto"], ["proof (state)\nthis:\n  I \\<in> carrier_mat (dim_row I) (dim_row I) \\<and>\n  inverts_mat I (adjoint I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_zero:\n  fixes A :: \"'a::conjugatable_field mat\"\n  assumes \"A \\<in> carrier_mat 0 0\"\n  shows \"unitary A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary A", "unfolding unitary_def inverts_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n    A * adjoint A = 1\\<^sub>m (dim_row A)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 0 0\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n    A * adjoint A = 1\\<^sub>m (dim_row A)", "by auto"], ["", "lemma unitary_elim:\n  assumes dims: \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"P \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and eq: \"P * A * adjoint P = P * B * adjoint P\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "have dimaP: \"adjoint P \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P \\<in> carrier_mat n n", "using dims"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = B", "have iv: \"inverts_mat P (adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat P (adjoint P)", "using uP unitary_def"], ["proof (prove)\nusing this:\n  unitary P\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n\ngoal (1 subgoal):\n 1. inverts_mat P (adjoint P)", "by auto"], ["proof (state)\nthis:\n  inverts_mat P (adjoint P)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  inverts_mat P (adjoint P)", "have \"P * (adjoint P) = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  inverts_mat P (adjoint P)\n\ngoal (1 subgoal):\n 1. P * adjoint P = 1\\<^sub>m n", "using inverts_mat_def dims"], ["proof (prove)\nusing this:\n  inverts_mat P (adjoint P)\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * adjoint P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  P * adjoint P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  P * adjoint P = 1\\<^sub>m n", "have aPP: \"adjoint P * P = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  P * adjoint P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "using mat_mult_left_right_inverse[OF dims(3) dimaP]"], ["proof (prove)\nusing this:\n  P * adjoint P = 1\\<^sub>m n\n  P * adjoint P = 1\\<^sub>m n \\<Longrightarrow> adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "have \"adjoint P * (P * A * adjoint P) * P = (adjoint P * P) * A * (adjoint P * P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * (P * A * adjoint P) * P =\n    adjoint P * P * A * (adjoint P * P)", "using dims dimaP"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P * (P * A * adjoint P) * P =\n    adjoint P * P * A * (adjoint P * P)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  adjoint P * (P * A * adjoint P) * P = adjoint P * P * A * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. A = B", "also"], ["proof (state)\nthis:\n  adjoint P * (P * A * adjoint P) * P = adjoint P * P * A * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. A = B", "have \"\\<dots> = 1\\<^sub>m n * A * 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * P * A * (adjoint P * P) = 1\\<^sub>m n * A * 1\\<^sub>m n", "using aPP"], ["proof (prove)\nusing this:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P * A * (adjoint P * P) = 1\\<^sub>m n * A * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P * A * (adjoint P * P) = 1\\<^sub>m n * A * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "also"], ["proof (state)\nthis:\n  adjoint P * P * A * (adjoint P * P) = 1\\<^sub>m n * A * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "have \"\\<dots> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * A * 1\\<^sub>m n = A", "using dims"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * A * 1\\<^sub>m n = A", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * A * 1\\<^sub>m n = A\n\ngoal (1 subgoal):\n 1. A = B", "finally"], ["proof (chain)\npicking this:\n  adjoint P * (P * A * adjoint P) * P = A", "have eqA: \"A = adjoint P * (P * A * adjoint P) * P\""], ["proof (prove)\nusing this:\n  adjoint P * (P * A * adjoint P) * P = A\n\ngoal (1 subgoal):\n 1. A = adjoint P * (P * A * adjoint P) * P", ".."], ["proof (state)\nthis:\n  A = adjoint P * (P * A * adjoint P) * P\n\ngoal (1 subgoal):\n 1. A = B", "have \"adjoint P * (P * B * adjoint P) * P = (adjoint P * P) * B * (adjoint P * P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * (P * B * adjoint P) * P =\n    adjoint P * P * B * (adjoint P * P)", "using dims dimaP"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P * (P * B * adjoint P) * P =\n    adjoint P * P * B * (adjoint P * P)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  adjoint P * (P * B * adjoint P) * P = adjoint P * P * B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. A = B", "also"], ["proof (state)\nthis:\n  adjoint P * (P * B * adjoint P) * P = adjoint P * P * B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. A = B", "have \"\\<dots> = 1\\<^sub>m n * B * 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * P * B * (adjoint P * P) = 1\\<^sub>m n * B * 1\\<^sub>m n", "using aPP"], ["proof (prove)\nusing this:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P * B * (adjoint P * P) = 1\\<^sub>m n * B * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P * B * (adjoint P * P) = 1\\<^sub>m n * B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "also"], ["proof (state)\nthis:\n  adjoint P * P * B * (adjoint P * P) = 1\\<^sub>m n * B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = B", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B * 1\\<^sub>m n = B", "using dims"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B * 1\\<^sub>m n = B", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * B * 1\\<^sub>m n = B\n\ngoal (1 subgoal):\n 1. A = B", "finally"], ["proof (chain)\npicking this:\n  adjoint P * (P * B * adjoint P) * P = B", "have eqB: \"B = adjoint P * (P * B * adjoint P) * P\""], ["proof (prove)\nusing this:\n  adjoint P * (P * B * adjoint P) * P = B\n\ngoal (1 subgoal):\n 1. B = adjoint P * (P * B * adjoint P) * P", ".."], ["proof (state)\nthis:\n  B = adjoint P * (P * B * adjoint P) * P\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  B = adjoint P * (P * B * adjoint P) * P", "show ?thesis"], ["proof (prove)\nusing this:\n  B = adjoint P * (P * B * adjoint P) * P\n\ngoal (1 subgoal):\n 1. A = B", "using eqA eqB eq"], ["proof (prove)\nusing this:\n  B = adjoint P * (P * B * adjoint P) * P\n  A = adjoint P * (P * A * adjoint P) * P\n  B = adjoint P * (P * B * adjoint P) * P\n  P * A * adjoint P = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_is_corthogonal:\n  fixes U :: \"'a::conjugatable_field mat\"\n  assumes dim: \"U \\<in> carrier_mat n n\" \n    and U: \"unitary U\"\n  shows \"corthogonal_mat U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal_mat U", "unfolding corthogonal_mat_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_mat (adjoint U * U) \\<and>\n    (\\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a))", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. diagonal_mat (adjoint U * U)\n 2. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "have dima: \"adjoint U \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U \\<in> carrier_mat n n", "using dim"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint U \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint U \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. diagonal_mat (adjoint U * U)\n 2. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "have aUU: \"mat_adjoint U * U = (1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint U * U = 1\\<^sub>m n", "apply (insert U[unfolded unitary_def] dim dima, drule conjunct2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>U \\<in> carrier_mat n n; adjoint U \\<in> carrier_mat n n;\n     inverts_mat U (adjoint U)\\<rbrakk>\n    \\<Longrightarrow> adjoint U * U = 1\\<^sub>m n", "apply (drule inverts_mat_symm[of \"U\", OF dim dima], unfold inverts_mat_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  adjoint U * U = 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. diagonal_mat (adjoint U * U)\n 2. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "then"], ["proof (chain)\npicking this:\n  adjoint U * U = 1\\<^sub>m n", "show \"diagonal_mat (mat_adjoint U * U)\""], ["proof (prove)\nusing this:\n  adjoint U * U = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. diagonal_mat (adjoint U * U)", "by (simp add: diagonal_mat_def)"], ["proof (state)\nthis:\n  diagonal_mat (adjoint U * U)\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "show \"\\<forall>i<dim_col U. (mat_adjoint U * U) $$ (i, i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "using dim"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)", "by (simp add: aUU)"], ["proof (state)\nthis:\n  \\<forall>i<dim_col U. (adjoint U * U) $$ (i, i) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_times_unitary:\n  fixes P Q :: \"'a:: conjugatable_field mat\"\n  assumes dim: \"P \\<in> carrier_mat n n\" \"Q \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and uQ: \"unitary Q\"\n  shows \"unitary (P * Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (P * Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (P * Q)", "have dim_pq: \"P * Q \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q \\<in> carrier_mat n n", "using dim"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P * Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "have \"(P * Q) * adjoint (P * Q) = P * (Q * adjoint Q) * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q * adjoint (P * Q) = P * (Q * adjoint Q) * adjoint P", "using dim"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * Q * adjoint (P * Q) = P * (Q * adjoint Q) * adjoint P", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * Q * adjoint (P * Q) = P * (Q * adjoint Q) * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "also"], ["proof (state)\nthis:\n  P * Q * adjoint (P * Q) = P * (Q * adjoint Q) * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "have \"\\<dots> = P * (1\\<^sub>m n) * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (Q * adjoint Q) * adjoint P = P * 1\\<^sub>m n * adjoint P", "using uQ dim"], ["proof (prove)\nusing this:\n  unitary Q\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * (Q * adjoint Q) * adjoint P = P * 1\\<^sub>m n * adjoint P", "by auto"], ["proof (state)\nthis:\n  P * (Q * adjoint Q) * adjoint P = P * 1\\<^sub>m n * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "also"], ["proof (state)\nthis:\n  P * (Q * adjoint Q) * adjoint P = P * 1\\<^sub>m n * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "have \"\\<dots> = P * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * 1\\<^sub>m n * adjoint P = P * adjoint P", "using dim"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * 1\\<^sub>m n * adjoint P = P * adjoint P", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * 1\\<^sub>m n * adjoint P = P * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "also"], ["proof (state)\nthis:\n  P * 1\\<^sub>m n * adjoint P = P * adjoint P\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "have \"\\<dots> = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * adjoint P = 1\\<^sub>m n", "using uP dim"], ["proof (prove)\nusing this:\n  unitary P\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * adjoint P = 1\\<^sub>m n", "by simp"], ["proof (state)\nthis:\n  P * adjoint P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "finally"], ["proof (chain)\npicking this:\n  P * Q * adjoint (P * Q) = 1\\<^sub>m n", "have \"(P * Q) * adjoint (P * Q) = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  P * Q * adjoint (P * Q) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. P * Q * adjoint (P * Q) = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  P * Q * adjoint (P * Q) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "hence \"inverts_mat (P * Q) (adjoint (P * Q))\""], ["proof (prove)\nusing this:\n  P * Q * adjoint (P * Q) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inverts_mat (P * Q) (adjoint (P * Q))", "using inverts_mat_def dim_pq"], ["proof (prove)\nusing this:\n  P * Q * adjoint (P * Q) = 1\\<^sub>m n\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n  P * Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat (P * Q) (adjoint (P * Q))", "by auto"], ["proof (state)\nthis:\n  inverts_mat (P * Q) (adjoint (P * Q))\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "thus \"unitary (P*Q)\""], ["proof (prove)\nusing this:\n  inverts_mat (P * Q) (adjoint (P * Q))\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "using unitary_def dim_pq"], ["proof (prove)\nusing this:\n  inverts_mat (P * Q) (adjoint (P * Q))\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n  P * Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (P * Q)", "by auto"], ["proof (state)\nthis:\n  unitary (P * Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_operator_keep_trace:\n  fixes U A :: \"complex mat\"\n  assumes dU: \"U \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" and u: \"unitary U\"\n  shows \"trace A = trace (adjoint U * A * U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "have u': \"U * adjoint U = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U * adjoint U = 1\\<^sub>m n", "using u"], ["proof (prove)\nusing this:\n  unitary U\n\ngoal (1 subgoal):\n 1. U * adjoint U = 1\\<^sub>m n", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat (dim_row U) (dim_row U) \\<and>\n  U * adjoint U = 1\\<^sub>m (dim_row U)\n\ngoal (1 subgoal):\n 1. U * adjoint U = 1\\<^sub>m n", "using dU"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat (dim_row U) (dim_row U) \\<and>\n  U * adjoint U = 1\\<^sub>m (dim_row U)\n  U \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. U * adjoint U = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  U * adjoint U = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "have \"trace (adjoint U * A * U) = trace (U * adjoint U * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (adjoint U * A * U) = trace (U * adjoint U * A)", "using dU dA"], ["proof (prove)\nusing this:\n  U \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (adjoint U * A * U) = trace (U * adjoint U * A)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  trace (adjoint U * A * U) = trace (U * adjoint U * A)\n\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "also"], ["proof (state)\nthis:\n  trace (adjoint U * A * U) = trace (U * adjoint U * A)\n\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "have \"\\<dots> = trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (U * adjoint U * A) = trace A", "using u' dA"], ["proof (prove)\nusing this:\n  U * adjoint U = 1\\<^sub>m n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (U * adjoint U * A) = trace A", "by auto"], ["proof (state)\nthis:\n  trace (U * adjoint U * A) = trace A\n\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "finally"], ["proof (chain)\npicking this:\n  trace (adjoint U * A * U) = trace A", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (adjoint U * A * U) = trace A\n\ngoal (1 subgoal):\n 1. trace A = trace (adjoint U * A * U)", "by auto"], ["proof (state)\nthis:\n  trace A = trace (adjoint U * A * U)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Normalization of vectors\\<close>"], ["", "definition vec_norm :: \"complex vec \\<Rightarrow> complex\" where\n  \"vec_norm v \\<equiv> csqrt (v \\<bullet>c v)\""], ["", "lemma vec_norm_geq_0:\n  fixes v :: \"complex vec\"\n  shows \"vec_norm v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> vec_norm v", "unfolding vec_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> csqrt (inner_prod v v)", "by (insert self_cscalar_prod_geq_0[of v], simp)"], ["", "lemma vec_norm_zero:\n  fixes v ::  \"complex vec\"\n  assumes dim: \"v \\<in> carrier_vec n\"\n  shows \"vec_norm v = 0 \\<longleftrightarrow> v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_norm v = 0) = (v = 0\\<^sub>v n)", "unfolding vec_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (csqrt (inner_prod v v) = 0) = (v = 0\\<^sub>v n)", "by (subst conjugate_square_eq_0_vec[OF dim, symmetric], rule csqrt_eq_0)"], ["", "lemma vec_norm_ge_0:\n  fixes v ::  \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" and neq0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_norm v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "have geq: \"vec_norm v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> vec_norm v", "using vec_norm_geq_0"], ["proof (prove)\nusing this:\n  0 \\<le> vec_norm ?v\n\ngoal (1 subgoal):\n 1. 0 \\<le> vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 \\<le> vec_norm v\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "have neq: \"vec_norm v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm v \\<noteq> 0", "apply (insert dim_v neq0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n    \\<Longrightarrow> vec_norm v \\<noteq> 0", "apply (drule vec_norm_zero, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vec_norm v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using neq geq"], ["proof (prove)\nusing this:\n  vec_norm v \\<noteq> 0\n  0 \\<le> vec_norm v\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by (rule dual_order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal:\nNo subgoals!", "qed"], ["", "definition vec_normalize :: \"complex vec \\<Rightarrow> complex vec\" where\n  \"vec_normalize v = (if (v = 0\\<^sub>v (dim_vec v)) then v else 1 / (vec_norm v) \\<cdot>\\<^sub>v v)\""], ["", "lemma normalized_vec_dim[simp]:\n  assumes \"(v::complex vec) \\<in> carrier_vec n\"\n  shows \"vec_normalize v \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec n", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v)\n    \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v)\n    \\<in> carrier_vec n", "by auto"], ["", "lemma vec_eq_norm_smult_normalized:\n  shows \"v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "proof (cases \"v = 0\\<^sub>v (dim_vec v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "define n where \"n = dim_vec v\""], ["proof (state)\nthis:\n  n = dim_vec v\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  n = dim_vec v", "have dimv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  n = dim_vec v\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n", "have dimnv: \"vec_normalize v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  vec_normalize v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "{"], ["proof (state)\nthis:\n  vec_normalize v \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "case True"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v = 0\\<^sub>v (dim_vec v)", "have v0: \"v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n", "using n_def"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (dim_vec v)\n  n = dim_vec v\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v = 0\\<^sub>v n", "have n0: \"vec_norm v = 0\""], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_norm v = 0", "using vec_norm_def"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n  vec_norm ?v \\<equiv> csqrt (inner_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. vec_norm v = 0", "by auto"], ["proof (state)\nthis:\n  vec_norm v = 0\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "have \"vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n", "unfolding smult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_vec (vec_normalize v))\n     (\\<lambda>i. vec_norm v * vec_normalize v $ i) =\n    0\\<^sub>v n", "by (auto simp add: n0 carrier_vecD[OF dimnv])"], ["proof (state)\nthis:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "using v0"], ["proof (prove)\nusing this:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = 0\\<^sub>v n\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "by auto"], ["proof (state)\nthis:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "case False"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)", "have v: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "using n_def"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)\n  n = dim_vec v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n", "have ge0: \"vec_norm v > 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using vec_norm_ge_0 dimv"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "have \"vec_normalize v = (1 / vec_norm v) \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v", "using False vec_normalize_def"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)\n  vec_normalize ?v =\n  (if ?v = 0\\<^sub>v (dim_vec ?v) then ?v\n   else 1 / vec_norm ?v \\<cdot>\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v", "have \"vec_norm v \\<cdot>\\<^sub>v vec_normalize v = (vec_norm v * (1 / vec_norm v)) \\<cdot>\\<^sub>v v\""], ["proof (prove)\nusing this:\n  vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. vec_norm v \\<cdot>\\<^sub>v vec_normalize v =\n    vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v", "using smult_smult_assoc"], ["proof (prove)\nusing this:\n  vec_normalize v = 1 / vec_norm v \\<cdot>\\<^sub>v v\n  ?a \\<cdot>\\<^sub>v (?b \\<cdot>\\<^sub>v ?v) = ?a * ?b \\<cdot>\\<^sub>v ?v\n\ngoal (1 subgoal):\n 1. vec_norm v \\<cdot>\\<^sub>v vec_normalize v =\n    vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v =\n  vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "also"], ["proof (state)\nthis:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v =\n  vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "have \"\\<dots> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v = v", "using ge0"], ["proof (prove)\nusing this:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v = v", "by auto"], ["proof (state)\nthis:\n  vec_norm v * (1 / vec_norm v) \\<cdot>\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "finally"], ["proof (chain)\npicking this:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = v", "have \"v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\""], ["proof (prove)\nusing this:\n  vec_norm v \\<cdot>\\<^sub>v vec_normalize v = v\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", ".."], ["proof (state)\nthis:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "show \"v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\""], ["proof (prove)\nusing this:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "using v"], ["proof (prove)\nusing this:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v", "by auto"], ["proof (state)\nthis:\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  v = vec_norm v \\<cdot>\\<^sub>v vec_normalize v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_cscalar_prod:\n  fixes v w :: \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" and dim_w: \"w \\<in> carrier_vec n\"\n  shows \"v \\<bullet>c w = (vec_norm v * vec_norm w) * (vec_normalize v \\<bullet>c vec_normalize w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w v =\n    vec_norm v * vec_norm w * inner_prod (vec_normalize w) (vec_normalize v)", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w v =\n    vec_norm v * vec_norm w *\n    inner_prod\n     (if w = 0\\<^sub>v (dim_vec w) then w\n      else 1 / vec_norm w \\<cdot>\\<^sub>v w)\n     (if v = 0\\<^sub>v (dim_vec v) then v\n      else 1 / vec_norm v \\<cdot>\\<^sub>v v)", "apply (split if_split, split if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = 0\\<^sub>v (dim_vec w) \\<longrightarrow>\n     (v = 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n      inner_prod w v = vec_norm v * vec_norm w * inner_prod w v) \\<and>\n     (v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n      inner_prod w v =\n      vec_norm v * vec_norm w *\n      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v))) \\<and>\n    (w \\<noteq> 0\\<^sub>v (dim_vec w) \\<longrightarrow>\n     (v = 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n      inner_prod w v =\n      vec_norm v * vec_norm w *\n      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v) \\<and>\n     (v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n      inner_prod w v =\n      vec_norm v * vec_norm w *\n      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n       (1 / vec_norm v \\<cdot>\\<^sub>v v)))", "proof (intro conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "note dim0 = dim_v dim_w"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have dim: \"dim_vec v = n\" \"dim_vec w = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = n &&& dim_vec w = n", "using dim0"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec v = n &&& dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  dim_vec v = n\n  dim_vec w = n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "{"], ["proof (state)\nthis:\n  dim_vec v = n\n  dim_vec w = n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "assume \"w = 0\\<^sub>v n\" \"v = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  w = 0\\<^sub>v n\n  v = 0\\<^sub>v n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  w = 0\\<^sub>v n\n  v = 0\\<^sub>v n", "have lhs: \"v \\<bullet>c w = 0\""], ["proof (prove)\nusing this:\n  w = 0\\<^sub>v n\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. inner_prod w v = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod w v = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  inner_prod w v = 0", "moreover"], ["proof (chain)\npicking this:\n  inner_prod w v = 0", "have rhs: \"vec_norm v * vec_norm w * (v \\<bullet>c w) = 0\""], ["proof (prove)\nusing this:\n  inner_prod w v = 0\n\ngoal (1 subgoal):\n 1. vec_norm v * vec_norm w * inner_prod w v = 0", "by auto"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w * inner_prod w v = 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod w v = 0\n  vec_norm v * vec_norm w * inner_prod w v = 0", "have \"v \\<bullet>c w = vec_norm v * vec_norm w * (v \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  inner_prod w v = 0\n  vec_norm v * vec_norm w * inner_prod w v = 0\n\ngoal (1 subgoal):\n 1. inner_prod w v = vec_norm v * vec_norm w * inner_prod w v", "by auto"], ["proof (state)\nthis:\n  inner_prod w v = vec_norm v * vec_norm w * inner_prod w v\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w * inner_prod w v\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v\n 2. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 4. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim"], ["proof (chain)\npicking this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w = 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w * inner_prod w v", "show \"w = 0\\<^sub>v (dim_vec w) \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> v \\<bullet>c w = vec_norm v * vec_norm w * (v \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w = 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w * inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w * inner_prod w v", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w * inner_prod w v\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v (dim_vec w); v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w * inner_prod w v\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "assume asm: \"w = 0\\<^sub>v n\" \"v \\<noteq> 0\\<^sub>v n\""], ["proof (state)\nthis:\n  w = 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  w = 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n", "have w0: \"conjugate w = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  w = 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. conjugate w = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  conjugate w = 0\\<^sub>v n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim0"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n  conjugate w = 0\\<^sub>v n", "have \"(1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c w = 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n  conjugate w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0", "moreover"], ["proof (chain)\npicking this:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0", "have rhs: \"vec_norm v * vec_norm w * ((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c w) = 0\""], ["proof (prove)\nusing this:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. vec_norm v * vec_norm w *\n    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    0", "by auto"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w *\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "moreover"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w *\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"v \\<bullet>c w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w v = 0", "using w0 dim0"], ["proof (prove)\nusing this:\n  conjugate w = 0\\<^sub>v n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w v = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod w v = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0\n  vec_norm v * vec_norm w *\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  0\n  inner_prod w v = 0", "have \"v \\<bullet>c w = vec_norm v * vec_norm w * ((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) = 0\n  vec_norm v * vec_norm w *\n  inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  0\n  inner_prod w v = 0\n\ngoal (1 subgoal):\n 1. inner_prod w v =\n    vec_norm v * vec_norm w *\n    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod w v =\n  vec_norm v * vec_norm w * inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 3. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim"], ["proof (chain)\npicking this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w = 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)", "show \"w = 0\\<^sub>v (dim_vec w) \\<Longrightarrow> v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow> v \\<bullet>c w = vec_norm v * vec_norm w * ((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w = 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n   v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>w = 0\\<^sub>v (dim_vec w);\n   v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod w (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "assume asm: \"w \\<noteq> 0\\<^sub>v n\" \"v = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  w \\<noteq> 0\\<^sub>v n\n  v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim0"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  v = 0\\<^sub>v n", "have \"v \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w) = 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0", "moreover"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0", "have rhs: \"vec_norm v * vec_norm w * (v \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w)) = 0\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0\n\ngoal (1 subgoal):\n 1. vec_norm v * vec_norm w *\n    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n    0", "by auto"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w *\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "moreover"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w *\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"v \\<bullet>c w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w v = 0", "using asm dim0"], ["proof (prove)\nusing this:\n  w \\<noteq> 0\\<^sub>v n\n  v = 0\\<^sub>v n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w v = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod w v = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0\n  vec_norm v * vec_norm w *\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  0\n  inner_prod w v = 0", "have \"v \\<bullet>c w = vec_norm v * vec_norm w * (v \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w))\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v = 0\n  vec_norm v * vec_norm w *\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  0\n  inner_prod w v = 0\n\ngoal (1 subgoal):\n 1. inner_prod w v =\n    vec_norm v * vec_norm w *\n    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v", "by auto"], ["proof (state)\nthis:\n  inner_prod w v =\n  vec_norm v * vec_norm w * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n 2. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim"], ["proof (chain)\npicking this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v", "show \"w \\<noteq> 0\\<^sub>v (dim_vec w) \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> v \\<bullet>c w = vec_norm v * vec_norm w * (v \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w))\""], ["proof (prove)\nusing this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v = 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n   v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n   v = 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "assume asmw: \"w \\<noteq> 0\\<^sub>v n\" and asmv: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (state)\nthis:\n  w \\<noteq> 0\\<^sub>v n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"vec_norm w > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec_norm w", "by (insert asmw dim0, rule vec_norm_ge_0, auto)"], ["proof (state)\nthis:\n  0 < vec_norm w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  0 < vec_norm w", "have cw: \"conjugate (1 / vec_norm w) = 1 / vec_norm w\""], ["proof (prove)\nusing this:\n  0 < vec_norm w\n\ngoal (1 subgoal):\n 1. conjugate (1 / vec_norm w) = 1 / vec_norm w", "by (simp add: complex_eq_iff complex_is_Real_iff)"], ["proof (state)\nthis:\n  conjugate (1 / vec_norm w) = 1 / vec_norm w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "from dim0"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n", "have \n      \"((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w)) = 1 / vec_norm v * (v \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w))\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v", "by auto"], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"\\<dots> = 1 / vec_norm v * (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n    1 / vec_norm v *\n    (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w))", "by (subst conjugate_smult_vec, auto)"], ["proof (state)\nthis:\n  1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  1 / vec_norm v *\n  (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  1 / vec_norm v * inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w) v =\n  1 / vec_norm v *\n  (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"\\<dots> = 1 / vec_norm v * conjugate (1 / vec_norm w) * (v \\<bullet> conjugate w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / vec_norm v *\n    (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w)) =\n    1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v", "using dim"], ["proof (prove)\nusing this:\n  dim_vec v = n\n  dim_vec w = n\n\ngoal (1 subgoal):\n 1. 1 / vec_norm v *\n    (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w)) =\n    1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v", "by auto"], ["proof (state)\nthis:\n  1 / vec_norm v *\n  (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w)) =\n  1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  1 / vec_norm v *\n  (v \\<bullet> (conjugate (1 / vec_norm w) \\<cdot>\\<^sub>v conjugate w)) =\n  1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "have \"\\<dots> = 1 / vec_norm v * (1 / vec_norm w) * (v \\<bullet>c w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v =\n    1 / vec_norm v * (1 / vec_norm w) * inner_prod w v", "using vec_norm_ge_0 cw"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  conjugate (1 / vec_norm w) = 1 / vec_norm w\n\ngoal (1 subgoal):\n 1. 1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v =\n    1 / vec_norm v * (1 / vec_norm w) * inner_prod w v", "by auto"], ["proof (state)\nthis:\n  1 / vec_norm v * conjugate (1 / vec_norm w) * inner_prod w v =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v", "have eq1: \"(1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w) = 1 / vec_norm v * (1 / vec_norm w) * (v \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    1 / vec_norm v * (1 / vec_norm w) * inner_prod w v", "."], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v", "have \"vec_norm v * vec_norm w * ((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w)) = (v \\<bullet>c w)\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  1 / vec_norm v * (1 / vec_norm w) * inner_prod w v\n\ngoal (1 subgoal):\n 1. vec_norm v * vec_norm w *\n    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    inner_prod w v", "by (subst eq1, insert vec_norm_ge_0[of v n, OF dim_v asmv] vec_norm_ge_0[of w n, OF dim_w asmw], auto)"], ["proof (state)\nthis:\n  vec_norm v * vec_norm w *\n  inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n   (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n  inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n                    inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "with dim"], ["proof (chain)\npicking this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n                    inner_prod w v", "show \" w \\<noteq> 0\\<^sub>v (dim_vec w) \\<Longrightarrow> v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow> v \\<bullet>c w = vec_norm v * vec_norm w * ((1 / vec_norm v \\<cdot>\\<^sub>v v) \\<bullet>c (1 / vec_norm w \\<cdot>\\<^sub>v w))\""], ["proof (prove)\nusing this:\n  dim_vec v = n\n  dim_vec w = n\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v n; v \\<noteq> 0\\<^sub>v n\\<rbrakk>\n  \\<Longrightarrow> vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                     (1 / vec_norm v \\<cdot>\\<^sub>v v) =\n                    inner_prod w v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v =\n                      vec_norm v * vec_norm w *\n                      inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                       (1 / vec_norm v \\<cdot>\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> 0\\<^sub>v (dim_vec w);\n   v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n  \\<Longrightarrow> inner_prod w v =\n                    vec_norm v * vec_norm w *\n                    inner_prod (1 / vec_norm w \\<cdot>\\<^sub>v w)\n                     (1 / vec_norm v \\<cdot>\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_vec_norm :\n  fixes v :: \"complex vec\"\n  assumes dim_v: \"v \\<in> carrier_vec n\" \n    and neq0: \"v \\<noteq> 0\\<^sub>v n\"\n  shows \"vec_normalize v \\<bullet>c vec_normalize v = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (vec_normalize v) (vec_normalize v) = 1", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod\n     (if v = 0\\<^sub>v (dim_vec v) then v\n      else 1 / vec_norm v \\<cdot>\\<^sub>v v)\n     (if v = 0\\<^sub>v (dim_vec v) then v\n      else 1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    1", "proof (simp, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<longrightarrow> inner_prod v v = 1\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "show \"v = 0\\<^sub>v (dim_vec v) \\<longrightarrow> v \\<bullet>c v = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v) \\<longrightarrow> inner_prod v v = 1", "using neq0 dim_v"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v) \\<longrightarrow> inner_prod v v = 1", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v) \\<longrightarrow> inner_prod v v = 1\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "have dim_a: \"(vec_normalize v) \\<in> carrier_vec n\" \"conjugate (vec_normalize v) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec n &&&\n    conjugate (vec_normalize v) \\<in> carrier_vec n", "using dim_v vec_normalize_def"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  vec_normalize ?v =\n  (if ?v = 0\\<^sub>v (dim_vec ?v) then ?v\n   else 1 / vec_norm ?v \\<cdot>\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec n &&&\n    conjugate (vec_normalize v) \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  vec_normalize v \\<in> carrier_vec n\n  conjugate (vec_normalize v) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "note dim = dim_v dim_a"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  vec_normalize v \\<in> carrier_vec n\n  conjugate (vec_normalize v) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "have nvge0: \"vec_norm v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using vec_norm_ge_0 neq0 dim_v"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  v \\<noteq> 0\\<^sub>v n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "then"], ["proof (chain)\npicking this:\n  0 < vec_norm v", "have vvvv: \"v \\<bullet>c v = (vec_norm v) * (vec_norm v)\""], ["proof (prove)\nusing this:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. inner_prod v v = vec_norm v * vec_norm v", "unfolding vec_norm_def"], ["proof (prove)\nusing this:\n  0 < csqrt (inner_prod v v)\n\ngoal (1 subgoal):\n 1. inner_prod v v = csqrt (inner_prod v v) * csqrt (inner_prod v v)", "by (metis power2_csqrt power2_eq_square)"], ["proof (state)\nthis:\n  inner_prod v v = vec_norm v * vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "from nvge0"], ["proof (chain)\npicking this:\n  0 < vec_norm v", "have \"conjugate (vec_norm v) = vec_norm v\""], ["proof (prove)\nusing this:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. conjugate (vec_norm v) = vec_norm v", "by (simp add: complex_eq_iff complex_is_Real_iff)"], ["proof (state)\nthis:\n  conjugate (vec_norm v) = vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "then"], ["proof (chain)\npicking this:\n  conjugate (vec_norm v) = vec_norm v", "have \"v \\<bullet>c (1 / vec_norm v \\<cdot>\\<^sub>v v) = 1 / vec_norm v * (v \\<bullet>c v)\""], ["proof (prove)\nusing this:\n  conjugate (vec_norm v) = vec_norm v\n\ngoal (1 subgoal):\n 1. inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v =\n    1 / vec_norm v * inner_prod v v", "by (subst conjugate_smult_vec, auto)"], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v =\n  1 / vec_norm v * inner_prod v v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "also"], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v =\n  1 / vec_norm v * inner_prod v v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "have \"\\<dots> = 1 / vec_norm v * vec_norm v * vec_norm v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / vec_norm v * inner_prod v v =\n    1 / vec_norm v * vec_norm v * vec_norm v", "using vvvv"], ["proof (prove)\nusing this:\n  inner_prod v v = vec_norm v * vec_norm v\n\ngoal (1 subgoal):\n 1. 1 / vec_norm v * inner_prod v v =\n    1 / vec_norm v * vec_norm v * vec_norm v", "by auto"], ["proof (state)\nthis:\n  1 / vec_norm v * inner_prod v v = 1 / vec_norm v * vec_norm v * vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "also"], ["proof (state)\nthis:\n  1 / vec_norm v * inner_prod v v = 1 / vec_norm v * vec_norm v * vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "have \"\\<dots> = vec_norm v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / vec_norm v * vec_norm v * vec_norm v = vec_norm v", "by auto"], ["proof (state)\nthis:\n  1 / vec_norm v * vec_norm v * vec_norm v = vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "finally"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "have \"v \\<bullet>c (1 / vec_norm v \\<cdot>\\<^sub>v v) = vec_norm v\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v\n\ngoal (1 subgoal):\n 1. inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "."], ["proof (state)\nthis:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "then"], ["proof (chain)\npicking this:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "show \"v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow> vec_norm v \\<noteq> 0 \\<and> v \\<bullet>c (1 / vec_norm v \\<cdot>\\<^sub>v v) = vec_norm v\""], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "using neq0 nvge0"], ["proof (prove)\nusing this:\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v\n  v \\<noteq> 0\\<^sub>v n\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n    vec_norm v \\<noteq> 0 \\<and>\n    inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v (dim_vec v) \\<longrightarrow>\n  vec_norm v \\<noteq> 0 \\<and>\n  inner_prod (1 / vec_norm v \\<cdot>\\<^sub>v v) v = vec_norm v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_zero:\n  assumes \"v \\<in> carrier_vec n\"\n  shows \"vec_normalize v = 0\\<^sub>v n \\<longleftrightarrow> v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_normalize v = 0\\<^sub>v n) = (v = 0\\<^sub>v n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n\n 2. v = 0\\<^sub>v n \\<Longrightarrow> vec_normalize v = 0\\<^sub>v n", "show \"v = 0\\<^sub>v n \\<Longrightarrow> vec_normalize v = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n \\<Longrightarrow> vec_normalize v = 0\\<^sub>v n", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v n \\<Longrightarrow>\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n \\<Longrightarrow> vec_normalize v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n", "have \"v \\<noteq> 0\\<^sub>v n \\<Longrightarrow> vec_normalize v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    vec_normalize v \\<noteq> 0\\<^sub>v n", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v) \\<noteq>\n    0\\<^sub>v n", "proof (simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "assume asm: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n", "have \"vec_norm v > 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using vec_norm_ge_0 assms"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  0 < vec_norm v", "have nvge0: \"1 / vec_norm v > 0\""], ["proof (prove)\nusing this:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. 0 < 1 / vec_norm v", "by (simp add: complex_is_Real_iff)"], ["proof (state)\nthis:\n  0 < 1 / vec_norm v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "have \"\\<exists>k < n. v $ k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<n. v $ k \\<noteq> 0", "using asm assms"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<exists>k<n. v $ k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>k<n. v $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<n. v $ k \\<noteq> 0", "obtain k where kn: \"k < n\" and  vkneq0: \"v $ k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>k<n. v $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < n; v $ k \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < n\n  v $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  k < n\n  v $ k \\<noteq> 0", "have \"(1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = (1 / vec_norm v) * (v $ k)\""], ["proof (prove)\nusing this:\n  k < n\n  v $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = 1 / vec_norm v * v $ k", "using assms carrier_vecD index_smult_vec(1)"], ["proof (prove)\nusing this:\n  k < n\n  v $ k \\<noteq> 0\n  v \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  ?i < dim_vec ?v \\<Longrightarrow>\n  (?a \\<cdot>\\<^sub>v ?v) $ ?i = ?a * ?v $ ?i\n\ngoal (1 subgoal):\n 1. (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = 1 / vec_norm v * v $ k", "by blast"], ["proof (state)\nthis:\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = 1 / vec_norm v * v $ k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "with nvge0 vkneq0"], ["proof (chain)\npicking this:\n  0 < 1 / vec_norm v\n  v $ k \\<noteq> 0\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = 1 / vec_norm v * v $ k", "have \"(1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < 1 / vec_norm v\n  v $ k \\<noteq> 0\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k = 1 / vec_norm v * v $ k\n\ngoal (1 subgoal):\n 1. (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n;\n     v \\<noteq> 0\\<^sub>v (dim_vec v)\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0", "show \"1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "using assms kn"], ["proof (prove)\nusing this:\n  (1 / vec_norm v \\<cdot>\\<^sub>v v) $ k \\<noteq> 0\n  v \\<in> carrier_vec n\n  k < n\n\ngoal (1 subgoal):\n 1. 1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n", "by fastforce"], ["proof (state)\nthis:\n  1 / vec_norm v \\<cdot>\\<^sub>v v \\<noteq> 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n  vec_normalize v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n  vec_normalize v \\<noteq> 0\\<^sub>v n", "show \"vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n  vec_normalize v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  vec_normalize v = 0\\<^sub>v n \\<Longrightarrow> v = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_normalize[simp]:\n  \"vec_normalize (vec_normalize v) = vec_normalize v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize (vec_normalize v) = vec_normalize v", "proof (rule disjE[of \"v = 0\\<^sub>v (dim_vec v)\" \"v \\<noteq> 0\\<^sub>v (dim_vec v)\"], auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "let ?n = \"dim_vec v\""], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "assume \"v = 0\\<^sub>v ?n\""], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v = 0\\<^sub>v (dim_vec v)", "have \"vec_normalize v = v\""], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. vec_normalize v = v", "unfolding vec_normalize_def"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    v", "by auto"], ["proof (state)\nthis:\n  vec_normalize v = v\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v\n 2. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "then"], ["proof (chain)\npicking this:\n  vec_normalize v = v", "show \"vec_normalize (vec_normalize v) = vec_normalize v\""], ["proof (prove)\nusing this:\n  vec_normalize v = v\n\ngoal (1 subgoal):\n 1. vec_normalize (vec_normalize v) = vec_normalize v", "by auto"], ["proof (state)\nthis:\n  vec_normalize (vec_normalize v) = vec_normalize v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "}"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n  vec_normalize (vec_normalize v) = vec_normalize v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "assume neq0: \"v \\<noteq> 0\\<^sub>v ?n\""], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "have dim: \"v \\<in> carrier_vec ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (dim_vec v)", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (dim_vec v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "have \"vec_norm (vec_normalize v) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm (vec_normalize v) = 1", "unfolding vec_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt (inner_prod (vec_normalize v) (vec_normalize v)) = 1", "using normalized_vec_norm[OF dim neq0]"], ["proof (prove)\nusing this:\n  inner_prod (vec_normalize v) (vec_normalize v) = 1\n\ngoal (1 subgoal):\n 1. csqrt (inner_prod (vec_normalize v) (vec_normalize v)) = 1", "by auto"], ["proof (state)\nthis:\n  vec_norm (vec_normalize v) = 1\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v (dim_vec v) \\<Longrightarrow>\n    vec_normalize (vec_normalize v) = vec_normalize v", "then"], ["proof (chain)\npicking this:\n  vec_norm (vec_normalize v) = 1", "show \"vec_normalize (vec_normalize v) = vec_normalize v\""], ["proof (prove)\nusing this:\n  vec_norm (vec_normalize v) = 1\n\ngoal (1 subgoal):\n 1. vec_normalize (vec_normalize v) = vec_normalize v", "by (subst (1) vec_normalize_def, simp)"], ["proof (state)\nthis:\n  vec_normalize (vec_normalize v) = vec_normalize v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Spectral decomposition of normal complex matrices\\<close>"], ["", "lemma normalize_keep_corthogonal:\n  fixes vs :: \"complex vec list\"\n  assumes cor: \"corthogonal vs\" and dims: \"set vs \\<subseteq> carrier_vec n\"\n  shows \"corthogonal (map vec_normalize vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal (map vec_normalize vs)", "unfolding corthogonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (map vec_normalize vs).\n       \\<forall>j<length (map vec_normalize vs).\n          (inner_prod (map vec_normalize vs ! j)\n            (map vec_normalize vs ! i) =\n           0) =\n          (i \\<noteq> j)", "proof (rule allI, rule impI, rule allI, rule impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "case c: (1 i j)"], ["proof (state)\nthis:\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "let ?m = \"length vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "have len: \"length (map vec_normalize vs) = ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map vec_normalize vs) = length vs", "by auto"], ["proof (state)\nthis:\n  length (map vec_normalize vs) = length vs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "have dim: \"\\<And>k. k < ?m \\<Longrightarrow> (vs ! k) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<in> carrier_vec n", "using dims"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "have map: \"\\<And>k. k < ?m \\<Longrightarrow>  map vec_normalize vs ! k = vec_normalize (vs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length vs \\<Longrightarrow>\n       map vec_normalize vs ! k = vec_normalize (vs ! k)", "by auto"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow>\n  map vec_normalize vs ! ?k = vec_normalize (vs ! ?k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "have eq1: \"\\<And>j k. j < ?m \\<Longrightarrow> k < ?m \\<Longrightarrow> ((vs ! j) \\<bullet>c (vs ! k) = 0) = (j \\<noteq> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j k.\n       \\<lbrakk>j < length vs; k < length vs\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (vs ! k) (vs ! j) = 0) = (j \\<noteq> k)", "using assms"], ["proof (prove)\nusing this:\n  corthogonal vs\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>j k.\n       \\<lbrakk>j < length vs; k < length vs\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (vs ! k) (vs ! j) = 0) = (j \\<noteq> k)", "unfolding corthogonal_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length vs.\n     \\<forall>j<length vs.\n        (inner_prod (vs ! j) (vs ! i) = 0) = (i \\<noteq> j)\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>j k.\n       \\<lbrakk>j < length vs; k < length vs\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (vs ! k) (vs ! j) = 0) = (j \\<noteq> k)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length vs; ?k < length vs\\<rbrakk>\n  \\<Longrightarrow> (inner_prod (vs ! ?k) (vs ! ?j) = 0) = (?j \\<noteq> ?k)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j < length vs; ?k < length vs\\<rbrakk>\n  \\<Longrightarrow> (inner_prod (vs ! ?k) (vs ! ?j) = 0) = (?j \\<noteq> ?k)", "have \"\\<And>k. k < ?m \\<Longrightarrow> (vs ! k) \\<bullet>c (vs ! k) \\<noteq> 0 \""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length vs; ?k < length vs\\<rbrakk>\n  \\<Longrightarrow> (inner_prod (vs ! ?k) (vs ! ?j) = 0) = (?j \\<noteq> ?k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length vs \\<Longrightarrow>\n       inner_prod (vs ! k) (vs ! k) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow> inner_prod (vs ! ?k) (vs ! ?k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "then"], ["proof (chain)\npicking this:\n  ?k < length vs \\<Longrightarrow> inner_prod (vs ! ?k) (vs ! ?k) \\<noteq> 0", "have \"\\<And>k. k < ?m \\<Longrightarrow> (vs ! k) \\<noteq> (0\\<^sub>v n)\""], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> inner_prod (vs ! ?k) (vs ! ?k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<noteq> 0\\<^sub>v n", "using dim"], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> inner_prod (vs ! ?k) (vs ! ?k) \\<noteq> 0\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<noteq> 0\\<^sub>v n", "by (auto simp add: conjugate_square_eq_0_vec[of _ n, OF dim])"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "then"], ["proof (chain)\npicking this:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<noteq> 0\\<^sub>v n", "have vnneq0: \"\\<And>k. k < ?m \\<Longrightarrow> vec_norm (vs ! k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vec_norm (vs ! k) \\<noteq> 0", "using vec_norm_zero[OF dim]"], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<noteq> 0\\<^sub>v n\n  ?k1 < length vs \\<Longrightarrow>\n  (vec_norm (vs ! ?k1) = 0) = (vs ! ?k1 = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vec_norm (vs ! k) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow> vec_norm (vs ! ?k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "then"], ["proof (chain)\npicking this:\n  ?k < length vs \\<Longrightarrow> vec_norm (vs ! ?k) \\<noteq> 0", "have i0: \"vec_norm (vs ! i) \\<noteq> 0\" and j0: \"vec_norm (vs ! j) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> vec_norm (vs ! ?k) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_norm (vs ! i) \\<noteq> 0 &&& vec_norm (vs ! j) \\<noteq> 0", "using c"], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow> vec_norm (vs ! ?k) \\<noteq> 0\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n\ngoal (1 subgoal):\n 1. vec_norm (vs ! i) \\<noteq> 0 &&& vec_norm (vs ! j) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  vec_norm (vs ! i) \\<noteq> 0\n  vec_norm (vs ! j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "have \"(vs ! i) \\<bullet>c (vs ! j) = vec_norm (vs ! i) * vec_norm (vs ! j) * (vec_normalize (vs ! i) \\<bullet>c vec_normalize (vs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (vs ! j) (vs ! i) =\n    vec_norm (vs ! i) * vec_norm (vs ! j) *\n    inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i))", "by (subst normalized_cscalar_prod[of \"vs ! i\" n \"vs ! j\"], auto, insert dim c, auto)"], ["proof (state)\nthis:\n  inner_prod (vs ! j) (vs ! i) =\n  vec_norm (vs ! i) * vec_norm (vs ! j) *\n  inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "with i0 j0"], ["proof (chain)\npicking this:\n  vec_norm (vs ! i) \\<noteq> 0\n  vec_norm (vs ! j) \\<noteq> 0\n  inner_prod (vs ! j) (vs ! i) =\n  vec_norm (vs ! i) * vec_norm (vs ! j) *\n  inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i))", "have \"(vec_normalize (vs ! i) \\<bullet>c vec_normalize (vs ! j) = 0) = ((vs ! i) \\<bullet>c (vs ! j) = 0)\""], ["proof (prove)\nusing this:\n  vec_norm (vs ! i) \\<noteq> 0\n  vec_norm (vs ! j) \\<noteq> 0\n  inner_prod (vs ! j) (vs ! i) =\n  vec_norm (vs ! i) * vec_norm (vs ! j) *\n  inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i))\n\ngoal (1 subgoal):\n 1. (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n    (inner_prod (vs ! j) (vs ! i) = 0)", "by auto"], ["proof (state)\nthis:\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (inner_prod (vs ! j) (vs ! i) = 0)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "with eq1 c"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j < length vs; ?k < length vs\\<rbrakk>\n  \\<Longrightarrow> (inner_prod (vs ! ?k) (vs ! ?j) = 0) = (?j \\<noteq> ?k)\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (inner_prod (vs ! j) (vs ! i) = 0)", "have \"(vec_normalize (vs ! i) \\<bullet>c vec_normalize (vs ! j) = 0) = (i \\<noteq> j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < length vs; ?k < length vs\\<rbrakk>\n  \\<Longrightarrow> (inner_prod (vs ! ?k) (vs ! ?j) = 0) = (?j \\<noteq> ?k)\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (inner_prod (vs ! j) (vs ! i) = 0)\n\ngoal (1 subgoal):\n 1. (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n    (i \\<noteq> j)", "by auto"], ["proof (state)\nthis:\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (i \\<noteq> j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (map vec_normalize vs);\n        j < length (map vec_normalize vs)\\<rbrakk>\n       \\<Longrightarrow> (inner_prod (map vec_normalize vs ! j)\n                           (map vec_normalize vs ! i) =\n                          0) =\n                         (i \\<noteq> j)", "with map c"], ["proof (chain)\npicking this:\n  ?k < length vs \\<Longrightarrow>\n  map vec_normalize vs ! ?k = vec_normalize (vs ! ?k)\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (i \\<noteq> j)", "show \"(map vec_normalize vs ! i \\<bullet>c map vec_normalize vs ! j = 0) = (i \\<noteq> j)\""], ["proof (prove)\nusing this:\n  ?k < length vs \\<Longrightarrow>\n  map vec_normalize vs ! ?k = vec_normalize (vs ! ?k)\n  i < length (map vec_normalize vs)\n  j < length (map vec_normalize vs)\n  (inner_prod (vec_normalize (vs ! j)) (vec_normalize (vs ! i)) = 0) =\n  (i \\<noteq> j)\n\ngoal (1 subgoal):\n 1. (inner_prod (map vec_normalize vs ! j) (map vec_normalize vs ! i) = 0) =\n    (i \\<noteq> j)", "by auto"], ["proof (state)\nthis:\n  (inner_prod (map vec_normalize vs ! j) (map vec_normalize vs ! i) = 0) =\n  (i \\<noteq> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_corthogonal_mat_is_unitary:\n  assumes W: \"set ws \\<subseteq> carrier_vec n\"\n    and orth: \"corthogonal ws\"\n    and len: \"length ws = n\"\n  shows \"unitary (mat_of_cols n (map vec_normalize ws))\" (is \"unitary ?W\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "define vs where \"vs = map vec_normalize ws\""], ["proof (state)\nthis:\n  vs = map vec_normalize ws\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "define W where \"W = mat_of_cols n vs\""], ["proof (state)\nthis:\n  W = mat_of_cols n vs\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have W': \"set vs \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set vs \\<subseteq> carrier_vec n", "using assms vs_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  vs = map vec_normalize ws\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  set vs \\<subseteq> carrier_vec n", "have W'': \"\\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  set vs \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>k. k < length vs \\<Longrightarrow> vs ! k \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?k < length vs \\<Longrightarrow> vs ! ?k \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have orth': \"corthogonal vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal vs", "using assms normalize_keep_corthogonal vs_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  \\<lbrakk>corthogonal ?vs; set ?vs \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal (map vec_normalize ?vs)\n  vs = map vec_normalize ws\n\ngoal (1 subgoal):\n 1. corthogonal vs", "by auto"], ["proof (state)\nthis:\n  corthogonal vs\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have len'[simp]: \"length vs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs = n", "using assms vs_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  vs = map vec_normalize ws\n\ngoal (1 subgoal):\n 1. length vs = n", "by auto"], ["proof (state)\nthis:\n  length vs = n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have dimW: \"W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "using W_def len"], ["proof (prove)\nusing this:\n  W = mat_of_cols n vs\n  length ws = n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"adjoint W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "using dimW"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  adjoint W \\<in> carrier_mat n n", "have dimaW: \"mat_adjoint W \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "{"], ["proof (state)\nthis:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "assume i: \"i < n\" and j: \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have dimws: \"(ws ! i) \\<in> carrier_vec n\" \"(ws ! j) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n &&& ws ! j \\<in> carrier_vec n", "using W len i j"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  length ws = n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. ws ! i \\<in> carrier_vec n &&& ws ! j \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ws ! i \\<in> carrier_vec n\n  ws ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"(ws ! i) \\<bullet>c (ws ! i) \\<noteq> 0\" \"(ws ! j) \\<bullet>c (ws ! j) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (ws ! i) (ws ! i) \\<noteq> 0 &&&\n    inner_prod (ws ! j) (ws ! j) \\<noteq> 0", "using orth corthogonal_def[of ws] len i j"], ["proof (prove)\nusing this:\n  corthogonal ws\n  corthogonal ws \\<equiv>\n  \\<forall>i<length ws.\n     \\<forall>j<length ws.\n        (inner_prod (ws ! j) (ws ! i) = 0) = (i \\<noteq> j)\n  length ws = n\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. inner_prod (ws ! i) (ws ! i) \\<noteq> 0 &&&\n    inner_prod (ws ! j) (ws ! j) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  inner_prod (ws ! i) (ws ! i) \\<noteq> 0\n  inner_prod (ws ! j) (ws ! j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  inner_prod (ws ! i) (ws ! i) \\<noteq> 0\n  inner_prod (ws ! j) (ws ! j) \\<noteq> 0", "have neq0: \"(ws ! i) \\<noteq> 0\\<^sub>v n\" \"(ws ! j) \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  inner_prod (ws ! i) (ws ! i) \\<noteq> 0\n  inner_prod (ws ! j) (ws ! j) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ws ! i \\<noteq> 0\\<^sub>v n &&& ws ! j \\<noteq> 0\\<^sub>v n", "by (auto simp add: conjugate_square_eq_0_vec[of \"ws ! i\" n])"], ["proof (state)\nthis:\n  ws ! i \\<noteq> 0\\<^sub>v n\n  ws ! j \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  ws ! i \\<noteq> 0\\<^sub>v n\n  ws ! j \\<noteq> 0\\<^sub>v n", "have \"vec_norm (ws ! i) > 0\" \"vec_norm (ws ! j) > 0\""], ["proof (prove)\nusing this:\n  ws ! i \\<noteq> 0\\<^sub>v n\n  ws ! j \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm (ws ! i) &&& 0 < vec_norm (ws ! j)", "using vec_norm_ge_0 dimws"], ["proof (prove)\nusing this:\n  ws ! i \\<noteq> 0\\<^sub>v n\n  ws ! j \\<noteq> 0\\<^sub>v n\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  ws ! i \\<in> carrier_vec n\n  ws ! j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm (ws ! i) &&& 0 < vec_norm (ws ! j)", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm (ws ! i)\n  0 < vec_norm (ws ! j)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  0 < vec_norm (ws ! i)\n  0 < vec_norm (ws ! j)", "have ge0: \"vec_norm (ws ! i) * vec_norm (ws ! j) > 0\""], ["proof (prove)\nusing this:\n  0 < vec_norm (ws ! i)\n  0 < vec_norm (ws ! j)\n\ngoal (1 subgoal):\n 1. 0 < vec_norm (ws ! i) * vec_norm (ws ! j)", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm (ws ! i) * vec_norm (ws ! j)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have ws': \"vs ! i = vec_normalize (ws ! i)\" \n        \"vs ! j = vec_normalize (ws ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs ! i = vec_normalize (ws ! i) &&& vs ! j = vec_normalize (ws ! j)", "using len i j vs_def"], ["proof (prove)\nusing this:\n  length ws = n\n  i < n\n  j < n\n  vs = map vec_normalize ws\n\ngoal (1 subgoal):\n 1. vs ! i = vec_normalize (ws ! i) &&& vs ! j = vec_normalize (ws ! j)", "by auto"], ["proof (state)\nthis:\n  vs ! i = vec_normalize (ws ! i)\n  vs ! j = vec_normalize (ws ! j)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have ii1: \"(vs ! i) \\<bullet>c (vs ! i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (vs ! i) (vs ! i) = 1", "apply (simp add: ws')"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (vec_normalize (ws ! i)) (vec_normalize (ws ! i)) = 1", "apply (rule normalized_vec_norm[of \"ws ! i\"], rule dimws, rule neq0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod (vs ! i) (vs ! i) = 1\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have ij0: \"i \\<noteq> j \\<Longrightarrow> (ws ! i)  \\<bullet>c (ws ! j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0", "by (insert orth, auto simp add: corthogonal_def[of ws] len)"], ["proof (state)\nthis:\n  i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"i \\<noteq> j \\<Longrightarrow> (ws ! i)  \\<bullet>c (ws ! j) =  (vec_norm (ws ! i) * vec_norm (ws ! j)) * ((vs ! i) \\<bullet>c (vs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    inner_prod (ws ! j) (ws ! i) =\n    vec_norm (ws ! i) * vec_norm (ws ! j) * inner_prod (vs ! j) (vs ! i)", "apply (auto simp add: ws')"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    inner_prod (ws ! j) (ws ! i) =\n    vec_norm (ws ! i) * vec_norm (ws ! j) *\n    inner_prod (vec_normalize (ws ! j)) (vec_normalize (ws ! i))", "apply (rule normalized_cscalar_prod)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<noteq> j \\<Longrightarrow> ws ! i \\<in> carrier_vec ?n1\n 2. i \\<noteq> j \\<Longrightarrow> ws ! j \\<in> carrier_vec ?n1", "apply (rule dimws, rule dimws)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  i \\<noteq> j \\<Longrightarrow>\n  inner_prod (ws ! j) (ws ! i) =\n  vec_norm (ws ! i) * vec_norm (ws ! j) * inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "with ij0"], ["proof (chain)\npicking this:\n  i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0\n  i \\<noteq> j \\<Longrightarrow>\n  inner_prod (ws ! j) (ws ! i) =\n  vec_norm (ws ! i) * vec_norm (ws ! j) * inner_prod (vs ! j) (vs ! i)", "have ij0': \"i \\<noteq> j \\<Longrightarrow> (vs ! i) \\<bullet>c (vs ! j) = 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0\n  i \\<noteq> j \\<Longrightarrow>\n  inner_prod (ws ! j) (ws ! i) =\n  vec_norm (ws ! i) * vec_norm (ws ! j) * inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> inner_prod (vs ! j) (vs ! i) = 0", "using ge0"], ["proof (prove)\nusing this:\n  i \\<noteq> j \\<Longrightarrow> inner_prod (ws ! j) (ws ! i) = 0\n  i \\<noteq> j \\<Longrightarrow>\n  inner_prod (ws ! j) (ws ! i) =\n  vec_norm (ws ! i) * vec_norm (ws ! j) * inner_prod (vs ! j) (vs ! i)\n  0 < vec_norm (ws ! i) * vec_norm (ws ! j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> inner_prod (vs ! j) (vs ! i) = 0", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j \\<Longrightarrow> inner_prod (vs ! j) (vs ! i) = 0\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have cWk: \"\\<And>k. k < n \\<Longrightarrow> col W k = vs ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < n \\<Longrightarrow> col W k = vs ! k", "unfolding W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < n \\<Longrightarrow> col (mat_of_cols n vs) k = vs ! k", "apply (subst col_mat_of_cols)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k. k < n \\<Longrightarrow> k < length vs\n 2. \\<And>k. k < n \\<Longrightarrow> vs ! k \\<in> carrier_vec n\n 3. \\<And>k. k < n \\<Longrightarrow> vs ! k = vs ! k", "apply (auto simp add: W'')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> col W ?k = vs ! ?k\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"(mat_adjoint W * W) $$ (j, i) = row (mat_adjoint W) j \\<bullet> col W i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adjoint W * W) $$ (j, i) = row (adjoint W) j \\<bullet> col W i", "by (insert dimW i j dimaW, auto)"], ["proof (state)\nthis:\n  (adjoint W * W) $$ (j, i) = row (adjoint W) j \\<bullet> col W i\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "also"], ["proof (state)\nthis:\n  (adjoint W * W) $$ (j, i) = row (adjoint W) j \\<bullet> col W i\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"\\<dots> = conjugate (col W j) \\<bullet> col W i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (adjoint W) j \\<bullet> col W i =\n    conjugate (col W j) \\<bullet> col W i", "by (insert dimW i j dimaW, auto simp add: mat_adjoint_def)"], ["proof (state)\nthis:\n  row (adjoint W) j \\<bullet> col W i =\n  conjugate (col W j) \\<bullet> col W i\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "also"], ["proof (state)\nthis:\n  row (adjoint W) j \\<bullet> col W i =\n  conjugate (col W j) \\<bullet> col W i\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"\\<dots> = col W i \\<bullet> conjugate (col W j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (col W j) \\<bullet> col W i = inner_prod (col W j) (col W i)", "using comm_scalar_prod[of \"col W i\" n] dimW"], ["proof (prove)\nusing this:\n  \\<lbrakk>col W i \\<in> carrier_vec n;\n   ?v\\<^sub>2 \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> col W i \\<bullet> ?v\\<^sub>2 =\n                    ?v\\<^sub>2 \\<bullet> col W i\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. conjugate (col W j) \\<bullet> col W i = inner_prod (col W j) (col W i)", "by auto"], ["proof (state)\nthis:\n  conjugate (col W j) \\<bullet> col W i = inner_prod (col W j) (col W i)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "also"], ["proof (state)\nthis:\n  conjugate (col W j) \\<bullet> col W i = inner_prod (col W j) (col W i)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have \"\\<dots> = (vs ! i) \\<bullet>c (vs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (col W j) (col W i) = inner_prod (vs ! j) (vs ! i)", "using W_def col_mat_of_cols i j len cWk"], ["proof (prove)\nusing this:\n  W = mat_of_cols n vs\n  \\<lbrakk>?j < length ?vs; ?vs ! ?j \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> col (mat_of_cols ?n ?vs) ?j = ?vs ! ?j\n  i < n\n  j < n\n  length ws = n\n  ?k < n \\<Longrightarrow> col W ?k = vs ! ?k\n\ngoal (1 subgoal):\n 1. inner_prod (col W j) (col W i) = inner_prod (vs ! j) (vs ! i)", "by auto"], ["proof (state)\nthis:\n  inner_prod (col W j) (col W i) = inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "finally"], ["proof (chain)\npicking this:\n  (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)", "have \"(mat_adjoint W * W) $$ (j, i) = (vs ! i) \\<bullet>c (vs ! j)\""], ["proof (prove)\nusing this:\n  (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)", "."], ["proof (state)\nthis:\n  (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)", "have \"(mat_adjoint W * W) $$ (j, i) = (if (j = i) then 1 else 0)\""], ["proof (prove)\nusing this:\n  (adjoint W * W) $$ (j, i) = inner_prod (vs ! j) (vs ! i)\n\ngoal (1 subgoal):\n 1. (adjoint W * W) $$ (j, i) = (if j = i then 1 else 0)", "by (auto simp add: ii1 ij0')"], ["proof (state)\nthis:\n  (adjoint W * W) $$ (j, i) = (if j = i then 1 else 0)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "note maWW = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)", "have \"mat_adjoint W * W = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. adjoint W * W = 1\\<^sub>m n", "unfolding one_mat_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. adjoint W * W = mat n n (\\<lambda>(i, j). if i = j then 1 else 0)", "using dimW dimaW"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (adjoint W * W) $$ (?j2, ?i2) =\n                    (if ?j2 = ?i2 then 1 else 0)\n  W \\<in> carrier_mat n n\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W * W = mat n n (\\<lambda>(i, j). if i = j then 1 else 0)", "by (auto simp add: maWW adjoint_def)"], ["proof (state)\nthis:\n  adjoint W * W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  adjoint W * W = 1\\<^sub>m n", "have iv0: \"adjoint W * W = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  adjoint W * W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint W * W = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint W * W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "have dimaW: \"adjoint W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "using dimaW"], ["proof (prove)\nusing this:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  adjoint W \\<in> carrier_mat n n", "have iv1: \"W * adjoint W  = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W * adjoint W = 1\\<^sub>m n", "using mat_mult_left_right_inverse dimW iv0"], ["proof (prove)\nusing this:\n  adjoint W \\<in> carrier_mat n n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?A * ?B = 1\\<^sub>m ?n\\<rbrakk>\n  \\<Longrightarrow> ?B * ?A = 1\\<^sub>m ?n\n  W \\<in> carrier_mat n n\n  adjoint W * W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. W * adjoint W = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  W * adjoint W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary (mat_of_cols n (map vec_normalize ws))", "then"], ["proof (chain)\npicking this:\n  W * adjoint W = 1\\<^sub>m n", "show \"unitary W\""], ["proof (prove)\nusing this:\n  W * adjoint W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. unitary W", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\nusing this:\n  W * adjoint W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat (dim_row W) (dim_row W) \\<and>\n    W * adjoint W = 1\\<^sub>m (dim_row W)", "using dimW dimaW iv0 iv1"], ["proof (prove)\nusing this:\n  W * adjoint W = 1\\<^sub>m n\n  W \\<in> carrier_mat n n\n  adjoint W \\<in> carrier_mat n n\n  adjoint W * W = 1\\<^sub>m n\n  W * adjoint W = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat (dim_row W) (dim_row W) \\<and>\n    W * adjoint W = 1\\<^sub>m (dim_row W)", "by auto"], ["proof (state)\nthis:\n  unitary W\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_keep_eigenvector:\n  assumes ev: \"eigenvector A v e\" \n    and dim: \"A \\<in> carrier_mat n n\" \"v \\<in> carrier_vec n\"\n  shows \"eigenvector A (vec_normalize v) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector A (vec_normalize v) e", "unfolding eigenvector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec (dim_row A) \\<and>\n    vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. vec_normalize v \\<in> carrier_vec (dim_row A)\n 2. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "show \"vec_normalize v \\<in> carrier_vec (dim_row A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec (dim_row A)", "using dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<in> carrier_vec (dim_row A)", "by auto"], ["proof (state)\nthis:\n  vec_normalize v \\<in> carrier_vec (dim_row A)\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "have eg: \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "using ev dim eigenvector_def"], ["proof (prove)\nusing this:\n  eigenvector A v e\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  eigenvector ?A ?v ?k =\n  (?v \\<in> carrier_vec (dim_row ?A) \\<and>\n   ?v \\<noteq> 0\\<^sub>v (dim_row ?A) \\<and>\n   ?A *\\<^sub>v ?v = ?k \\<cdot>\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "have vneq0: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "using ev dim"], ["proof (prove)\nusing this:\n  eigenvector A v e\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n", "have s0: \"vec_normalize v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v n", "by (insert dim, subst normalize_zero[of v], auto)"], ["proof (state)\nthis:\n  vec_normalize v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "from vneq0"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n", "have vvge0: \"vec_norm v > 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using vec_norm_ge_0 dim"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "have s1: \"A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "unfolding vec_normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    e \\<cdot>\\<^sub>v\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v)", "using vneq0 dim"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v) =\n    e \\<cdot>\\<^sub>v\n    (if v = 0\\<^sub>v (dim_vec v) then v\n     else 1 / vec_norm v \\<cdot>\\<^sub>v v)", "apply (auto, simp add: mult_mat_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> 0\\<^sub>v n; A \\<in> carrier_mat n n;\n     v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> 1 / vec_norm v \\<cdot>\\<^sub>v (A *\\<^sub>v v) =\n                      e \\<cdot>\\<^sub>v (1 / vec_norm v \\<cdot>\\<^sub>v v)", "apply (subst eg, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "with s0 dim"], ["proof (chain)\npicking this:\n  vec_normalize v \\<noteq> 0\\<^sub>v n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "show \"vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and> A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v\""], ["proof (prove)\nusing this:\n  vec_normalize v \\<noteq> 0\\<^sub>v n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v\n\ngoal (1 subgoal):\n 1. vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v", "by auto"], ["proof (state)\nthis:\n  vec_normalize v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v vec_normalize v = e \\<cdot>\\<^sub>v vec_normalize v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma four_block_mat_adjoint:\n  fixes A B C D :: \"'a::conjugatable_field mat\"\n  assumes dim: \"A \\<in> carrier_mat nr1 nc1\" \"B \\<in> carrier_mat nr1 nc2\"\n  \"C \\<in> carrier_mat nr2 nc1\" \"D \\<in> carrier_mat nr2 nc2\"\n  shows \"adjoint (four_block_mat A B C D) \n    = four_block_mat (adjoint A) (adjoint C) (adjoint B) (adjoint D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (four_block_mat A B C D) =\n    four_block_mat (adjoint A) (adjoint C) (adjoint B) (adjoint D)", "by (rule eq_matI, insert dim, auto simp add: adjoint_eval)"], ["", "fun unitary_schur_decomposition :: \"complex mat \\<Rightarrow> complex list \\<Rightarrow> complex mat \\<times> complex mat \\<times> complex mat\" where \n  \"unitary_schur_decomposition A [] = (A, 1\\<^sub>m (dim_row A), 1\\<^sub>m (dim_row A))\"\n| \"unitary_schur_decomposition A (e # es) = (let\n       n = dim_row A;\n       n1 = n - 1;\n       v' = find_eigenvector A e;\n       v = vec_normalize v';\n       ws0 = gram_schmidt n (basis_completion v);\n       ws = map vec_normalize ws0;\n       W = mat_of_cols n ws;\n       W' = corthogonal_inv W;\n       A' = W' * A * W;\n       (A1,A2,A0,A3) = split_block A' 1 1;\n       (B,P,Q) = unitary_schur_decomposition A3 es;\n       z_row = (0\\<^sub>m 1 n1);\n       z_col = (0\\<^sub>m n1 1);\n       one_1 = 1\\<^sub>m 1\n     in (four_block_mat A1 (A2 * P) A0 B, \n     W * four_block_mat one_1 z_row z_col P, \n     four_block_mat one_1 z_row z_col Q * W'))\""], ["", "theorem unitary_schur_decomposition:\n  assumes A: \"(A::complex mat) \\<in> carrier_mat n n\"\n      and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n      and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> diag_mat B = es \\<and> unitary P \\<and> (Q = adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and>\n    upper_triangular B \\<and>\n    diag_mat B = es \\<and> unitary P \\<and> Q = adjoint P", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and>\n    upper_triangular B \\<and>\n    diag_mat B = es \\<and> unitary P \\<and> Q = adjoint P", "proof (induct es arbitrary: n A B P Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n A B P Q.\n       \\<lbrakk>A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1:]);\n        unitary_schur_decomposition A [] = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = [] \\<and>\n                         unitary P \\<and> Q = adjoint P\n 2. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "case Nil"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1:])\n  unitary_schur_decomposition A [] = (B, P, Q)\n\ngoal (2 subgoals):\n 1. \\<And>n A B P Q.\n       \\<lbrakk>A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1:]);\n        unitary_schur_decomposition A [] = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = [] \\<and>\n                         unitary P \\<and> Q = adjoint P\n 2. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with degree_monic_char_poly[of A n]"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n \\<Longrightarrow>\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1:])\n  unitary_schur_decomposition A [] = (B, P, Q)", "show ?case"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n \\<Longrightarrow>\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>[]. [:- e, 1:])\n  unitary_schur_decomposition A [] = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and>\n    upper_triangular B \\<and>\n    diag_mat B = [] \\<and> unitary P \\<and> Q = adjoint P", "by (auto intro: similar_mat_wit_refl simp: diag_mat_def unitary_zero)"], ["proof (state)\nthis:\n  similar_mat_wit A B P Q \\<and>\n  upper_triangular B \\<and>\n  diag_mat B = [] \\<and> unitary P \\<and> Q = adjoint P\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "case (Cons e es n A C P Q)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n   unitary_schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and>\n                    diag_mat ?B = es \\<and>\n                    unitary ?P \\<and> ?Q = adjoint ?P\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1:])\n  unitary_schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "let ?n1 = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n   unitary_schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and>\n                    diag_mat ?B = es \\<and>\n                    unitary ?P \\<and> ?Q = adjoint ?P\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1:])\n  unitary_schur_decomposition A (e # es) = (C, P, Q)", "have A: \"A \\<in> carrier_mat n n\" and dim: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n   unitary_schur_decomposition ?A es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P ?Q \\<and>\n                    upper_triangular ?B \\<and>\n                    diag_mat ?B = es \\<and>\n                    unitary ?P \\<and> ?Q = adjoint ?P\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1:])\n  unitary_schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& dim_row A = n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "let ?cp = \"char_poly A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from Cons(3)"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1:])", "have cp: \"?cp = [: -e, 1 :] * (\\<Prod>e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>e\\<leftarrow>e # es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. char_poly A = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])", "by auto"], ["proof (state)\nthis:\n  char_poly A = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have mon: \"monic (\\<Prod>e\\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (\\<Prod>e\\<leftarrow>es. [:- e, 1:])", "by (rule monic_prod_list, auto)"], ["proof (state)\nthis:\n  monic (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have deg: \"degree ?cp = Suc (degree (\\<Prod>e\\<leftarrow> es. [:- e, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly A) = Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1:]))", "unfolding cp"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])) =\n    Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1:]))", "by (subst degree_mult_eq, insert mon, auto)"], ["proof (state)\nthis:\n  degree (char_poly A) = Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1:]))\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with degree_monic_char_poly[OF A]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n  degree (char_poly A) = Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1:]))", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n  degree (char_poly A) = Suc (degree (\\<Prod>e\\<leftarrow>es. [:- e, 1:]))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define v' where \"v' = find_eigenvector A e\""], ["proof (state)\nthis:\n  v' = find_eigenvector A e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define v where \"v = vec_normalize v'\""], ["proof (state)\nthis:\n  v = vec_normalize v'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define b where \"b = basis_completion v\""], ["proof (state)\nthis:\n  b = basis_completion v\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define ws0 where \"ws0 = gram_schmidt n b\""], ["proof (state)\nthis:\n  ws0 = gram_schmidt n b\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define ws where \"ws = map vec_normalize ws0\""], ["proof (state)\nthis:\n  ws = map vec_normalize ws0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define W where \"W = mat_of_cols n ws\""], ["proof (state)\nthis:\n  W = mat_of_cols n ws\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define W' where \"W' = corthogonal_inv W\""], ["proof (state)\nthis:\n  W' = corthogonal_inv W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "define A' where \"A' = W' * A * W\""], ["proof (state)\nthis:\n  A' = W' * A * W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "obtain A1 A2 A0 A3 where splitA': \"split_block A' 1 1 = (A1,A2,A0,A3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A1 A2 A0 A3.\n        split_block A' 1 1 = (A1, A2, A0, A3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_block A' 1 1\", auto)"], ["proof (state)\nthis:\n  split_block A' 1 1 = (A1, A2, A0, A3)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "obtain B P' Q' where schur: \"unitary_schur_decomposition A3 es = (B,P',Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P' Q'.\n        unitary_schur_decomposition A3 es = (B, P', Q') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A3 es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A3 es = (B, P', Q')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "let ?P' = \"four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 ?n1) (0\\<^sub>m ?n1 1) P'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "let ?Q' = \"four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 ?n1) (0\\<^sub>m ?n1 1) Q'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have C: \"C = four_block_mat A1 (A2 * P') A0 B\" and P: \"P = W * ?P'\" and Q: \"Q = ?Q' * W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "using Cons(4)"], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A (e # es) = (C, P, Q)\n\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "unfolding unitary_schur_decomposition.simps\n    Let_def list.sel dim\n    v'_def[symmetric] v_def[symmetric] b_def[symmetric] ws0_def[symmetric] ws_def[symmetric] W'_def[symmetric] W_def[symmetric]\n    A'_def[symmetric] split splitA' schur"], ["proof (prove)\nusing this:\n  (four_block_mat A1 (A2 * P') A0 B,\n   W *\n   four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n    P',\n   four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n    Q' *\n   W') =\n  (C, P, Q)\n\ngoal (1 subgoal):\n 1. C = four_block_mat A1 (A2 * P') A0 B &&&\n    P =\n    W *\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P' &&&\n    Q =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "by auto"], ["proof (state)\nthis:\n  C = four_block_mat A1 (A2 * P') A0 B\n  P =\n  W *\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   P'\n  Q =\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have e: \"eigenvalue A e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A e", "unfolding eigenvalue_root_char_poly[OF A] cp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])) e = 0", "by simp"], ["proof (state)\nthis:\n  eigenvalue A e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from find_eigenvector[OF A e]"], ["proof (chain)\npicking this:\n  eigenvector A (find_eigenvector A e) e", "have ev': \"eigenvector A v' e\""], ["proof (prove)\nusing this:\n  eigenvector A (find_eigenvector A e) e\n\ngoal (1 subgoal):\n 1. eigenvector A v' e", "unfolding v'_def"], ["proof (prove)\nusing this:\n  eigenvector A (find_eigenvector A e) e\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "."], ["proof (state)\nthis:\n  eigenvector A v' e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  eigenvector A v' e", "have \"v' \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  eigenvector A v' e\n\ngoal (1 subgoal):\n 1. v' \\<in> carrier_vec n", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  v' \\<in> carrier_vec (dim_row A) \\<and>\n  v' \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v' = e \\<cdot>\\<^sub>v v'\n\ngoal (1 subgoal):\n 1. v' \\<in> carrier_vec n", "using A"], ["proof (prove)\nusing this:\n  v' \\<in> carrier_vec (dim_row A) \\<and>\n  v' \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v' = e \\<cdot>\\<^sub>v v'\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v' \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v' \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with ev'"], ["proof (chain)\npicking this:\n  eigenvector A v' e\n  v' \\<in> carrier_vec n", "have ev: \"eigenvector A v e\""], ["proof (prove)\nusing this:\n  eigenvector A v' e\n  v' \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. eigenvector A v e", "unfolding v_def"], ["proof (prove)\nusing this:\n  eigenvector A v' e\n  v' \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. eigenvector A (vec_normalize v') e", "using A dim normalize_keep_eigenvector"], ["proof (prove)\nusing this:\n  eigenvector A v' e\n  v' \\<in> carrier_vec n\n  A \\<in> carrier_mat n n\n  dim_row A = n\n  \\<lbrakk>eigenvector ?A ?v ?e; ?A \\<in> carrier_mat ?n ?n;\n   ?v \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> eigenvector ?A (vec_normalize ?v) ?e\n\ngoal (1 subgoal):\n 1. eigenvector A (vec_normalize v') e", "by auto"], ["proof (state)\nthis:\n  eigenvector A v e\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from this[unfolded eigenvector_def]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "have v[simp]: \"v \\<in> carrier_vec n\" and v0: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& v \\<noteq> 0\\<^sub>v n", "using A"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "interpret cof_vec_space n \"TYPE(complex)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from basis_completion[OF v v0, folded b_def]"], ["proof (chain)\npicking this:\n  basis (set b)\n  set b \\<subseteq> carrier_vec n\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  length b = n\n  hd b = v", "have span_b: \"span (set b) = carrier_vec n\" and dist_b: \"distinct b\" \n    and indep: \"\\<not> lin_dep (set b)\" and b: \"set b \\<subseteq> carrier_vec n\" and hdb: \"hd b = v\" \n    and len_b: \"length b = n\""], ["proof (prove)\nusing this:\n  basis (set b)\n  set b \\<subseteq> carrier_vec n\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  length b = n\n  hd b = v\n\ngoal (1 subgoal):\n 1. (local.span (set b) = carrier_vec n &&&\n     distinct b &&& lin_indpt (set b)) &&&\n    set b \\<subseteq> carrier_vec n &&& hd b = v &&& length b = n", "by auto"], ["proof (state)\nthis:\n  local.span (set b) = carrier_vec n\n  distinct b\n  lin_indpt (set b)\n  set b \\<subseteq> carrier_vec n\n  hd b = v\n  length b = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from hdb len_b n"], ["proof (chain)\npicking this:\n  hd b = v\n  length b = n\n  n \\<noteq> 0", "obtain vs where bv: \"b = v # vs\""], ["proof (prove)\nusing this:\n  hd b = v\n  length b = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>vs. b = v # vs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases b, auto)"], ["proof (state)\nthis:\n  b = v # vs\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from gram_schmidt_result[OF b dist_b indep refl, folded ws0_def]"], ["proof (chain)\npicking this:\n  local.span (set b) = local.span (set ws0)\n  corthogonal ws0\n  set ws0 \\<subseteq> carrier_vec n\n  length ws0 = length b\n  distinct ws0", "have ws0: \"set ws0 \\<subseteq> carrier_vec n\" \"corthogonal ws0\" \"length ws0 = n\""], ["proof (prove)\nusing this:\n  local.span (set b) = local.span (set ws0)\n  corthogonal ws0\n  set ws0 \\<subseteq> carrier_vec n\n  length ws0 = length b\n  distinct ws0\n\ngoal (1 subgoal):\n 1. set ws0 \\<subseteq> carrier_vec n &&& corthogonal ws0 &&& length ws0 = n", "by (auto simp: len_b)"], ["proof (state)\nthis:\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n", "have ws: \"set ws \\<subseteq> carrier_vec n\" \"corthogonal ws\" \"length ws = n\""], ["proof (prove)\nusing this:\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n\n\ngoal (1 subgoal):\n 1. set ws \\<subseteq> carrier_vec n &&& corthogonal ws &&& length ws = n", "unfolding ws_def"], ["proof (prove)\nusing this:\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n\n\ngoal (1 subgoal):\n 1. set (map vec_normalize ws0) \\<subseteq> carrier_vec n &&&\n    corthogonal (map vec_normalize ws0) &&&\n    length (map vec_normalize ws0) = n", "using normalize_keep_corthogonal"], ["proof (prove)\nusing this:\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n\n  \\<lbrakk>corthogonal ?vs; set ?vs \\<subseteq> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal (map vec_normalize ?vs)\n\ngoal (1 subgoal):\n 1. set (map vec_normalize ws0) \\<subseteq> carrier_vec n &&&\n    corthogonal (map vec_normalize ws0) &&&\n    length (map vec_normalize ws0) = n", "by auto"], ["proof (state)\nthis:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have ws0ne: \"ws0 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws0 \\<noteq> []", "using \\<open>length ws0 = n\\<close> n"], ["proof (prove)\nusing this:\n  length ws0 = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ws0 \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ws0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from gram_schmidt_hd[OF v, of vs, folded bv]"], ["proof (chain)\npicking this:\n  hd (gram_schmidt n b) = v", "have hdws0: \"hd ws0 = (vec_normalize v')\""], ["proof (prove)\nusing this:\n  hd (gram_schmidt n b) = v\n\ngoal (1 subgoal):\n 1. hd ws0 = vec_normalize v'", "unfolding ws0_def v_def"], ["proof (prove)\nusing this:\n  hd (gram_schmidt n b) = vec_normalize v'\n\ngoal (1 subgoal):\n 1. hd (gram_schmidt n b) = vec_normalize v'", "."], ["proof (state)\nthis:\n  hd ws0 = vec_normalize v'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"hd ws = vec_normalize (hd ws0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ws = vec_normalize (hd ws0)", "unfolding ws_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map vec_normalize ws0) = vec_normalize (hd ws0)", "using hd_map[OF ws0ne]"], ["proof (prove)\nusing this:\n  hd (map ?f ws0) = ?f (hd ws0)\n\ngoal (1 subgoal):\n 1. hd (map vec_normalize ws0) = vec_normalize (hd ws0)", "by auto"], ["proof (state)\nthis:\n  hd ws = vec_normalize (hd ws0)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  hd ws = vec_normalize (hd ws0)", "have hdws: \"hd ws = v\""], ["proof (prove)\nusing this:\n  hd ws = vec_normalize (hd ws0)\n\ngoal (1 subgoal):\n 1. hd ws = v", "unfolding v_def"], ["proof (prove)\nusing this:\n  hd ws = vec_normalize (hd ws0)\n\ngoal (1 subgoal):\n 1. hd ws = vec_normalize v'", "using normalize_normalize[of v'] hdws0"], ["proof (prove)\nusing this:\n  hd ws = vec_normalize (hd ws0)\n  vec_normalize (vec_normalize v') = vec_normalize v'\n  hd ws0 = vec_normalize v'\n\ngoal (1 subgoal):\n 1. hd ws = vec_normalize v'", "by auto"], ["proof (state)\nthis:\n  hd ws = v\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have orth_W: \"corthogonal_mat W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal_mat W", "using orthogonal_mat_of_cols ws"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?ws \\<subseteq> carrier_vec ?n; corthogonal ?ws;\n   length ?ws = ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal_mat (mat_of_cols ?n ?ws)\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. corthogonal_mat W", "unfolding W_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?ws \\<subseteq> carrier_vec ?n; corthogonal ?ws;\n   length ?ws = ?n\\<rbrakk>\n  \\<Longrightarrow> corthogonal_mat (mat_of_cols ?n ?ws)\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. corthogonal_mat (mat_of_cols n ws)", "."], ["proof (state)\nthis:\n  corthogonal_mat W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have W: \"W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "using ws"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. W \\<in> carrier_mat n n", "unfolding W_def"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n\ngoal (1 subgoal):\n 1. mat_of_cols n ws \\<in> carrier_mat n n", "using mat_of_cols_carrier(1)[of n ws]"], ["proof (prove)\nusing this:\n  set ws \\<subseteq> carrier_vec n\n  corthogonal ws\n  length ws = n\n  mat_of_cols n ws \\<in> carrier_mat n (length ws)\n\ngoal (1 subgoal):\n 1. mat_of_cols n ws \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have W': \"W' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W' \\<in> carrier_mat n n", "unfolding W'_def corthogonal_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows (dim_row W) (map vec_inv (cols W)) \\<in> carrier_mat n n", "using W"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_of_rows (dim_row W) (map vec_inv (cols W)) \\<in> carrier_mat n n", "by (auto simp: mat_of_rows_def)"], ["proof (state)\nthis:\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from corthogonal_inv_result[OF orth_W]"], ["proof (chain)\npicking this:\n  inverts_mat (corthogonal_inv W) W", "have W'W: \"inverts_mat W' W\""], ["proof (prove)\nusing this:\n  inverts_mat (corthogonal_inv W) W\n\ngoal (1 subgoal):\n 1. inverts_mat W' W", "unfolding W'_def"], ["proof (prove)\nusing this:\n  inverts_mat (corthogonal_inv W) W\n\ngoal (1 subgoal):\n 1. inverts_mat (corthogonal_inv W) W", "."], ["proof (state)\nthis:\n  inverts_mat W' W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "hence WW': \"inverts_mat W W'\""], ["proof (prove)\nusing this:\n  inverts_mat W' W\n\ngoal (1 subgoal):\n 1. inverts_mat W W'", "using mat_mult_left_right_inverse[OF W' W] W' W"], ["proof (prove)\nusing this:\n  inverts_mat W' W\n  W' * W = 1\\<^sub>m n \\<Longrightarrow> W * W' = 1\\<^sub>m n\n  W' \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat W W'", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  W' * W = 1\\<^sub>m (dim_row W')\n  W' * W = 1\\<^sub>m n \\<Longrightarrow> W * W' = 1\\<^sub>m n\n  W' \\<in> carrier_mat n n\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W * W' = 1\\<^sub>m (dim_row W)", "by auto"], ["proof (state)\nthis:\n  inverts_mat W W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A': \"A' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "using W W' A"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "unfolding A'_def"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W' * A * W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A'A_wit: \"similar_mat_wit A' A W' W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A' A W' W", "by (rule similar_mat_witI[of _ _ n], insert W W' A A' W'W WW', auto simp: A'_def\n    inverts_mat_def)"], ["proof (state)\nthis:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "hence A'A: \"similar_mat A' A\""], ["proof (prove)\nusing this:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. similar_mat A' A", "unfolding similar_mat_def"], ["proof (prove)\nusing this:\n  similar_mat_wit A' A W' W\n\ngoal (1 subgoal):\n 1. \\<exists>P. Ex (similar_mat_wit A' A P)", "by blast"], ["proof (state)\nthis:\n  similar_mat A' A\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from similar_mat_wit_sym[OF A'A_wit]"], ["proof (chain)\npicking this:\n  similar_mat_wit A A' W W'", "have simAA': \"similar_mat_wit A A' W W'\""], ["proof (prove)\nusing this:\n  similar_mat_wit A A' W W'\n\ngoal (1 subgoal):\n 1. similar_mat_wit A A' W W'", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A A' W W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have eigen[simp]: \"A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\" and v0: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "using v_def v'_def find_eigenvector[OF A e] A normalize_keep_eigenvector"], ["proof (prove)\nusing this:\n  v = vec_normalize v'\n  v' = find_eigenvector A e\n  eigenvector A (find_eigenvector A e) e\n  A \\<in> carrier_mat n n\n  \\<lbrakk>eigenvector ?A ?v ?e; ?A \\<in> carrier_mat ?n ?n;\n   ?v \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> eigenvector ?A (vec_normalize ?v) ?e\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  v = vec_normalize v'\n  v' = find_eigenvector A e\n  find_eigenvector A e \\<in> carrier_vec (dim_row A) \\<and>\n  find_eigenvector A e \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v find_eigenvector A e = e \\<cdot>\\<^sub>v find_eigenvector A e\n  A \\<in> carrier_mat n n\n  \\<lbrakk>?v \\<in> carrier_vec (dim_row ?A) \\<and>\n           ?v \\<noteq> 0\\<^sub>v (dim_row ?A) \\<and>\n           ?A *\\<^sub>v ?v = ?e \\<cdot>\\<^sub>v ?v;\n   ?A \\<in> carrier_mat ?n ?n; ?v \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> vec_normalize ?v \\<in> carrier_vec (dim_row ?A) \\<and>\n                    vec_normalize ?v \\<noteq> 0\\<^sub>v (dim_row ?A) \\<and>\n                    ?A *\\<^sub>v vec_normalize ?v =\n                    ?e \\<cdot>\\<^sub>v vec_normalize ?v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v &&& v \\<noteq> 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "let ?f = \"(\\<lambda> i. if i = 0 then e else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have col0: \"col A' 0 = vec n ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A' 0 = vec n (\\<lambda>i. if i = 0 then e else 0)", "unfolding A'_def W'_def W_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n    vec n (\\<lambda>i. if i = 0 then e else 0)", "using corthogonal_col_ev_0[OF A v v0 eigen n hdws ws]"], ["proof (prove)\nusing this:\n  col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n  vec n (\\<lambda>i. if i = 0 then e else 0)\n\ngoal (1 subgoal):\n 1. col (corthogonal_inv (mat_of_cols n ws) * A * mat_of_cols n ws) 0 =\n    vec n (\\<lambda>i. if i = 0 then e else 0)", "."], ["proof (state)\nthis:\n  col A' 0 = vec n (\\<lambda>i. if i = 0 then e else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from A' n"], ["proof (chain)\npicking this:\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0", "have \"dim_row A' = 1 + ?n1\" \"dim_col A' = 1 + ?n1\""], ["proof (prove)\nusing this:\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dim_row A' = 1 + (n - 1) &&& dim_col A' = 1 + (n - 1)", "by auto"], ["proof (state)\nthis:\n  dim_row A' = 1 + (n - 1)\n  dim_col A' = 1 + (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from split_block[OF splitA' this]"], ["proof (chain)\npicking this:\n  A1 \\<in> carrier_mat 1 1\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A0 \\<in> carrier_mat (n - 1) 1\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3", "have A2: \"A2 \\<in> carrier_mat 1 ?n1\"\n    and A3: \"A3 \\<in> carrier_mat ?n1 ?n1\" \n    and A'block: \"A' = four_block_mat A1 A2 A0 A3\""], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat 1 1\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A0 \\<in> carrier_mat (n - 1) 1\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3\n\ngoal (1 subgoal):\n 1. A2 \\<in> carrier_mat 1 (n - 1) &&&\n    A3 \\<in> carrier_mat (n - 1) (n - 1) &&& A' = four_block_mat A1 A2 A0 A3", "by auto"], ["proof (state)\nthis:\n  A2 \\<in> carrier_mat 1 (n - 1)\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  A' = four_block_mat A1 A2 A0 A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A1id: \"A1 = mat 1 1 (\\<lambda> _. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 = mat 1 1 (\\<lambda>_. e)", "using splitA'[unfolded split_block_def Let_def] arg_cong[OF col0, of \"\\<lambda> v. v $ 0\"] A' n"], ["proof (prove)\nusing this:\n  (mat 1 1 (($$) A'),\n   mat 1 (dim_col A' - 1) (\\<lambda>(i, j). A' $$ (i, j + 1)),\n   mat (dim_row A' - 1) 1 (\\<lambda>(i, j). A' $$ (i + 1, j)),\n   mat (dim_row A' - 1) (dim_col A' - 1)\n    (\\<lambda>(i, j). A' $$ (i + 1, j + 1))) =\n  (A1, A2, A0, A3)\n  col A' 0 $ 0 = vec n (\\<lambda>i. if i = 0 then e else 0) $ 0\n  A' \\<in> carrier_mat n n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A1 = mat 1 1 (\\<lambda>_. e)", "by (auto simp: col_def)"], ["proof (state)\nthis:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A1: \"A1 \\<in> carrier_mat 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 \\<in> carrier_mat 1 1", "unfolding A1id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 (\\<lambda>_. e) \\<in> carrier_mat 1 1", "by auto"], ["proof (state)\nthis:\n  A1 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "{"], ["proof (state)\nthis:\n  A1 \\<in> carrier_mat 1 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "assume \"i < ?n1\""], ["proof (state)\nthis:\n  i < n - 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with arg_cong[OF col0, of \"\\<lambda> v. v $ Suc i\"] A'"], ["proof (chain)\npicking this:\n  col A' 0 $ Suc i = vec n (\\<lambda>i. if i = 0 then e else 0) $ Suc i\n  A' \\<in> carrier_mat n n\n  i < n - 1", "have \"A' $$ (Suc i, 0) = 0\""], ["proof (prove)\nusing this:\n  col A' 0 $ Suc i = vec n (\\<lambda>i. if i = 0 then e else 0) $ Suc i\n  A' \\<in> carrier_mat n n\n  i < n - 1\n\ngoal (1 subgoal):\n 1. A' $$ (Suc i, 0) = 0", "by auto"], ["proof (state)\nthis:\n  A' $$ (Suc i, 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "}"], ["proof (state)\nthis:\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "note A'0 = this"], ["proof (state)\nthis:\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A0id: \"A0 = 0\\<^sub>m ?n1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 = 0\\<^sub>m (n - 1) 1", "using splitA'[unfolded split_block_def Let_def] A'0 A'"], ["proof (prove)\nusing this:\n  (mat 1 1 (($$) A'),\n   mat 1 (dim_col A' - 1) (\\<lambda>(i, j). A' $$ (i, j + 1)),\n   mat (dim_row A' - 1) 1 (\\<lambda>(i, j). A' $$ (i + 1, j)),\n   mat (dim_row A' - 1) (dim_col A' - 1)\n    (\\<lambda>(i, j). A' $$ (i + 1, j + 1))) =\n  (A1, A2, A0, A3)\n  ?i4 < n - 1 \\<Longrightarrow> A' $$ (Suc ?i4, 0) = 0\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A0 = 0\\<^sub>m (n - 1) 1", "by auto"], ["proof (state)\nthis:\n  A0 = 0\\<^sub>m (n - 1) 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A0: \"A0 \\<in> carrier_mat ?n1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 \\<in> carrier_mat (n - 1) 1", "unfolding A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 \\<in> carrier_mat (n - 1) 1", "by auto"], ["proof (state)\nthis:\n  A0 \\<in> carrier_mat (n - 1) 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from cp char_poly_similar[OF A'A]"], ["proof (chain)\npicking this:\n  char_poly A = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  char_poly A' = char_poly A", "have cp: \"char_poly A' = [: -e,1 :] * (\\<Prod> e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  char_poly A = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  char_poly A' = char_poly A\n\ngoal (1 subgoal):\n 1. char_poly A' = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])", "by simp"], ["proof (state)\nthis:\n  char_poly A' = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "also"], ["proof (state)\nthis:\n  char_poly A' = [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"char_poly A' = char_poly A1 * char_poly A3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A' = char_poly A1 * char_poly A3", "unfolding A'block A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m (n - 1) 1) A3) =\n    char_poly A1 * char_poly A3", "by (rule char_poly_four_block_zeros_col[OF A1 A2 A3])"], ["proof (state)\nthis:\n  char_poly A' = char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "also"], ["proof (state)\nthis:\n  char_poly A' = char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"char_poly A1 = [: -e,1 :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A1 = [:- e, 1:]", "by (simp add: A1id char_poly_defs det_def signof_def sign_def)"], ["proof (state)\nthis:\n  char_poly A1 = [:- e, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "finally"], ["proof (chain)\npicking this:\n  [:- e, 1:] * char_poly A3 =\n  [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])", "have cp: \"char_poly A3 = (\\<Prod> e \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\nusing this:\n  [:- e, 1:] * char_poly A3 =\n  [:- e, 1:] * (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. char_poly A3 = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])", "by (metis mult_cancel_left pCons_eq_0_iff zero_neq_one)"], ["proof (state)\nthis:\n  char_poly A3 = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from Cons(1)[OF A3 cp schur]"], ["proof (chain)\npicking this:\n  similar_mat_wit A3 B P' Q' \\<and>\n  upper_triangular B \\<and>\n  diag_mat B = es \\<and> unitary P' \\<and> Q' = adjoint P'", "have simIH: \"similar_mat_wit A3 B P' Q'\" and ut: \"upper_triangular B\" and diag: \"diag_mat B = es\"\n    and uP': \"unitary P'\" and Q'P': \"Q' = adjoint P'\""], ["proof (prove)\nusing this:\n  similar_mat_wit A3 B P' Q' \\<and>\n  upper_triangular B \\<and>\n  diag_mat B = es \\<and> unitary P' \\<and> Q' = adjoint P'\n\ngoal (1 subgoal):\n 1. (similar_mat_wit A3 B P' Q' &&& upper_triangular B) &&&\n    diag_mat B = es &&& unitary P' &&& Q' = adjoint P'", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A3 B P' Q'\n  upper_triangular B\n  diag_mat B = es\n  unitary P'\n  Q' = adjoint P'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from similar_mat_witD2[OF A3 simIH]"], ["proof (chain)\npicking this:\n  P' * Q' = 1\\<^sub>m (n - 1)\n  Q' * P' = 1\\<^sub>m (n - 1)\n  A3 = P' * B * Q'\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)", "have B: \"B \\<in> carrier_mat ?n1 ?n1\" and P': \"P' \\<in> carrier_mat ?n1 ?n1\" and Q': \"Q' \\<in> carrier_mat ?n1 ?n1\" \n    and PQ': \"P' * Q' = 1\\<^sub>m ?n1\""], ["proof (prove)\nusing this:\n  P' * Q' = 1\\<^sub>m (n - 1)\n  Q' * P' = 1\\<^sub>m (n - 1)\n  A3 = P' * B * Q'\n  A3 \\<in> carrier_mat (n - 1) (n - 1)\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. (B \\<in> carrier_mat (n - 1) (n - 1) &&&\n     P' \\<in> carrier_mat (n - 1) (n - 1)) &&&\n    Q' \\<in> carrier_mat (n - 1) (n - 1) &&& P' * Q' = 1\\<^sub>m (n - 1)", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat (n - 1) (n - 1)\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n  Q' \\<in> carrier_mat (n - 1) (n - 1)\n  P' * Q' = 1\\<^sub>m (n - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have A0_eq: \"A0 = P' * A0 * 1\\<^sub>m 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 = P' * A0 * 1\\<^sub>m 1", "unfolding A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 = P' * 0\\<^sub>m (n - 1) 1 * 1\\<^sub>m 1", "using P'"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (n - 1) 1 = P' * 0\\<^sub>m (n - 1) 1 * 1\\<^sub>m 1", "by auto"], ["proof (state)\nthis:\n  A0 = P' * A0 * 1\\<^sub>m 1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have simA'C: \"similar_mat_wit A' C ?P' ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A' C\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P')\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) Q')", "unfolding A'block C"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (four_block_mat A1 A2 A0 A3)\n     (four_block_mat A1 (A2 * P') A0 B)\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P')\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) Q')", "by (rule similar_mat_wit_four_block[OF similar_mat_wit_refl[OF A1] simIH _ A0_eq A1 A3 A0],\n    insert PQ' A2 P' Q', auto)"], ["proof (state)\nthis:\n  similar_mat_wit A' C\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P')\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have ut1: \"upper_triangular A1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular A1", "unfolding A1id"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (mat 1 1 (\\<lambda>_. e))", "by auto"], ["proof (state)\nthis:\n  upper_triangular A1\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have ut: \"upper_triangular C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular C", "unfolding C A0id"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (four_block_mat A1 (A2 * P') (0\\<^sub>m (n - 1) 1) B)", "by (intro upper_triangular_four_block[OF _ B ut1 ut], auto simp: A1id)"], ["proof (state)\nthis:\n  upper_triangular C\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from A1id"], ["proof (chain)\npicking this:\n  A1 = mat 1 1 (\\<lambda>_. e)", "have diagA1: \"diag_mat A1 = [e]\""], ["proof (prove)\nusing this:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. diag_mat A1 = [e]", "unfolding diag_mat_def"], ["proof (prove)\nusing this:\n  A1 = mat 1 1 (\\<lambda>_. e)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. A1 $$ (i, i)) [0..<dim_row A1] = [e]", "by auto"], ["proof (state)\nthis:\n  diag_mat A1 = [e]\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from diag_four_block_mat[OF A1 B]"], ["proof (chain)\npicking this:\n  diag_mat (four_block_mat A1 ?B ?C B) = diag_mat A1 @ diag_mat B", "have diag: \"diag_mat C = e # es\""], ["proof (prove)\nusing this:\n  diag_mat (four_block_mat A1 ?B ?C B) = diag_mat A1 @ diag_mat B\n\ngoal (1 subgoal):\n 1. diag_mat C = e # es", "unfolding diag diagA1 C"], ["proof (prove)\nusing this:\n  diag_mat (four_block_mat A1 ?B ?C B) = [e] @ es\n\ngoal (1 subgoal):\n 1. diag_mat (four_block_mat A1 (A2 * P') A0 B) = e # es", "by simp"], ["proof (state)\nthis:\n  diag_mat C = e # es\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have aW: \"adjoint W \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "using W"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have aW': \"adjoint W' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint W' \\<in> carrier_mat n n", "using W'"], ["proof (prove)\nusing this:\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint W' \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"unitary W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary W", "using W_def ws_def ws0 normalized_corthogonal_mat_is_unitary"], ["proof (prove)\nusing this:\n  W = mat_of_cols n ws\n  ws = map vec_normalize ws0\n  set ws0 \\<subseteq> carrier_vec n\n  corthogonal ws0\n  length ws0 = n\n  \\<lbrakk>set ?ws \\<subseteq> carrier_vec ?n; corthogonal ?ws;\n   length ?ws = ?n\\<rbrakk>\n  \\<Longrightarrow> unitary (mat_of_cols ?n (map vec_normalize ?ws))\n\ngoal (1 subgoal):\n 1. unitary W", "by auto"], ["proof (state)\nthis:\n  unitary W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  unitary W", "have ivWaW: \"inverts_mat W (adjoint W)\""], ["proof (prove)\nusing this:\n  unitary W\n\ngoal (1 subgoal):\n 1. inverts_mat W (adjoint W)", "using unitary_def W aW"], ["proof (prove)\nusing this:\n  unitary W\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n  W \\<in> carrier_mat n n\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat W (adjoint W)", "by auto"], ["proof (state)\nthis:\n  inverts_mat W (adjoint W)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with WW'"], ["proof (chain)\npicking this:\n  inverts_mat W W'\n  inverts_mat W (adjoint W)", "have W'aW: \"W' = (adjoint W)\""], ["proof (prove)\nusing this:\n  inverts_mat W W'\n  inverts_mat W (adjoint W)\n\ngoal (1 subgoal):\n 1. W' = adjoint W", "using inverts_mat_unique W W' aW"], ["proof (prove)\nusing this:\n  inverts_mat W W'\n  inverts_mat W (adjoint W)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?C \\<in> carrier_mat ?n ?n; inverts_mat ?A ?B; inverts_mat ?A ?C\\<rbrakk>\n  \\<Longrightarrow> ?B = ?C\n  W \\<in> carrier_mat n n\n  W' \\<in> carrier_mat n n\n  adjoint W \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. W' = adjoint W", "by auto"], ["proof (state)\nthis:\n  W' = adjoint W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  W' = adjoint W", "have \"adjoint W' = W\""], ["proof (prove)\nusing this:\n  W' = adjoint W\n\ngoal (1 subgoal):\n 1. adjoint W' = W", "using adjoint_adjoint"], ["proof (prove)\nusing this:\n  W' = adjoint W\n  adjoint (adjoint ?A) = ?A\n\ngoal (1 subgoal):\n 1. adjoint W' = W", "by auto"], ["proof (state)\nthis:\n  adjoint W' = W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "with ivWaW"], ["proof (chain)\npicking this:\n  inverts_mat W (adjoint W)\n  adjoint W' = W", "have \"inverts_mat W' (adjoint W')\""], ["proof (prove)\nusing this:\n  inverts_mat W (adjoint W)\n  adjoint W' = W\n\ngoal (1 subgoal):\n 1. inverts_mat W' (adjoint W')", "using inverts_mat_symm W aW W'aW"], ["proof (prove)\nusing this:\n  inverts_mat W (adjoint W)\n  adjoint W' = W\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   inverts_mat ?A ?B\\<rbrakk>\n  \\<Longrightarrow> inverts_mat ?B ?A\n  W \\<in> carrier_mat n n\n  adjoint W \\<in> carrier_mat n n\n  W' = adjoint W\n\ngoal (1 subgoal):\n 1. inverts_mat W' (adjoint W')", "by auto"], ["proof (state)\nthis:\n  inverts_mat W' (adjoint W')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  inverts_mat W' (adjoint W')", "have \"unitary W'\""], ["proof (prove)\nusing this:\n  inverts_mat W' (adjoint W')\n\ngoal (1 subgoal):\n 1. unitary W'", "using unitary_def W'"], ["proof (prove)\nusing this:\n  inverts_mat W' (adjoint W')\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n  W' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary W'", "by auto"], ["proof (state)\nthis:\n  unitary W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have newP': \"P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0)", "using P'"], ["proof (prove)\nusing this:\n  P' \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0)", "by auto"], ["proof (state)\nthis:\n  P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have rl: \"\\<And> x1 x2 x3 x4 y1 y2 y3 y4 f. x1 = y1 \\<Longrightarrow> x2 = y2 \\<Longrightarrow> x3 = y3 \\<Longrightarrow> x4 = y4 \\<Longrightarrow> f x1 x2 x3 x4 = f y1 y2 y3 y4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4 y1 y2 y3 y4 f.\n       \\<lbrakk>x1 = y1; x2 = y2; x3 = y3; x4 = y4\\<rbrakk>\n       \\<Longrightarrow> f x1 x2 x3 x4 = f y1 y2 y3 y4", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.2 = ?y1.2; ?x2.2 = ?y2.2; ?x3.2 = ?y3.2;\n   ?x4.2 = ?y4.2\\<rbrakk>\n  \\<Longrightarrow> ?f2 ?x1.2 ?x2.2 ?x3.2 ?x4.2 =\n                    ?f2 ?y1.2 ?y2.2 ?y3.2 ?y4.2\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have Q'aP': \"?Q' = adjoint ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' =\n    adjoint\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P')", "apply (subst four_block_mat_adjoint, auto simp add: newP')"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat (1\\<^sub>m (Suc 0)) (0\\<^sub>m (Suc 0) (n - Suc 0))\n     (0\\<^sub>m (n - Suc 0) (Suc 0)) Q' =\n    four_block_mat (adjoint (1\\<^sub>m (Suc 0)))\n     (adjoint (0\\<^sub>m (n - Suc 0) (Suc 0)))\n     (adjoint (0\\<^sub>m (Suc 0) (n - Suc 0))) (adjoint P')", "apply (rule rl[where f2 = four_block_mat])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m (Suc 0) = adjoint (1\\<^sub>m (Suc 0))\n 2. 0\\<^sub>m (Suc 0) (n - Suc 0) = adjoint (0\\<^sub>m (n - Suc 0) (Suc 0))\n 3. 0\\<^sub>m (n - Suc 0) (Suc 0) = adjoint (0\\<^sub>m (Suc 0) (n - Suc 0))\n 4. Q' = adjoint P'", "apply (auto simp add: eq_matI adjoint_eval Q'P')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' =\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P')\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"adjoint P = adjoint ?P' * adjoint W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P =\n    adjoint\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P') *\n    adjoint W", "using W newP' n"], ["proof (prove)\nusing this:\n  W \\<in> carrier_mat n n\n  P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. adjoint P =\n    adjoint\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P') *\n    adjoint W", "apply (simp add: P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>W \\<in> carrier_mat n n;\n     P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0); 0 < n\\<rbrakk>\n    \\<Longrightarrow> adjoint\n                       (W *\n                        four_block_mat (1\\<^sub>m (Suc 0))\n                         (0\\<^sub>m (Suc 0) (n - Suc 0))\n                         (0\\<^sub>m (n - Suc 0) (Suc 0)) P') =\n                      adjoint\n                       (four_block_mat (1\\<^sub>m (Suc 0))\n                         (0\\<^sub>m (Suc 0) (n - Suc 0))\n                         (0\\<^sub>m (n - Suc 0) (Suc 0)) P') *\n                      adjoint W", "apply (subst adjoint_mult[of W, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>W \\<in> carrier_mat n n;\n     P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0); 0 < n\\<rbrakk>\n    \\<Longrightarrow> W \\<in> carrier_mat ?n3 ?m3\n 2. \\<lbrakk>W \\<in> carrier_mat n n;\n     P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0); 0 < n\\<rbrakk>\n    \\<Longrightarrow> four_block_mat (1\\<^sub>m (Suc 0))\n                       (0\\<^sub>m (Suc 0) (n - Suc 0))\n                       (0\\<^sub>m (n - Suc 0) (Suc 0)) P'\n                      \\<in> carrier_mat ?m3 ?l3\n 3. \\<lbrakk>W \\<in> carrier_mat n n;\n     P' \\<in> carrier_mat (n - Suc 0) (n - Suc 0); 0 < n\\<rbrakk>\n    \\<Longrightarrow> adjoint\n                       (W *\n                        four_block_mat (1\\<^sub>m (Suc 0))\n                         (0\\<^sub>m (Suc 0) (n - Suc 0))\n                         (0\\<^sub>m (n - Suc 0) (Suc 0)) P') =\n                      adjoint\n                       (W *\n                        four_block_mat (1\\<^sub>m (Suc 0))\n                         (0\\<^sub>m (Suc 0) (n - Suc 0))\n                         (0\\<^sub>m (n - Suc 0) (Suc 0)) P')", "apply (auto simp add: W P' carrier_matD[of W n n])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  adjoint P =\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P') *\n  adjoint W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "also"], ["proof (state)\nthis:\n  adjoint P =\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P') *\n  adjoint W\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"\\<dots> = ?Q' * W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P') *\n    adjoint W =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "using Q'aP' W'aW"], ["proof (prove)\nusing this:\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' =\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P')\n  W' = adjoint W\n\ngoal (1 subgoal):\n 1. adjoint\n     (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1))\n       (0\\<^sub>m (n - 1) 1) P') *\n    adjoint W =\n    four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W'", "by auto"], ["proof (state)\nthis:\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P') *\n  adjoint W =\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "also"], ["proof (state)\nthis:\n  adjoint\n   (four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     P') *\n  adjoint W =\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W'\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "have \"\\<dots> = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W' =\n    Q", "using Q"], ["proof (prove)\nusing this:\n  Q =\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W'\n\ngoal (1 subgoal):\n 1. four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n     Q' *\n    W' =\n    Q", "by auto"], ["proof (state)\nthis:\n  four_block_mat (1\\<^sub>m 1) (0\\<^sub>m 1 (n - 1)) (0\\<^sub>m (n - 1) 1)\n   Q' *\n  W' =\n  Q\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "finally"], ["proof (chain)\npicking this:\n  adjoint P = Q", "have QaP: \"Q = adjoint P\""], ["proof (prove)\nusing this:\n  adjoint P = Q\n\ngoal (1 subgoal):\n 1. Q = adjoint P", ".."], ["proof (state)\nthis:\n  Q = adjoint P\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from similar_mat_wit_trans[OF simAA' simA'C, folded P Q]"], ["proof (chain)\npicking this:\n  similar_mat_wit A C P Q", "have smw: \"similar_mat_wit A C P Q\""], ["proof (prove)\nusing this:\n  similar_mat_wit A C P Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit A C P Q", "by blast"], ["proof (state)\nthis:\n  similar_mat_wit A C P Q\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A C P Q", "have dimP: \"P \\<in> carrier_mat n n\" and dimQ: \"Q \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A C P Q\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "unfolding similar_mat_wit_def"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, C, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * C * Q\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, C, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * C * Q\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from smw"], ["proof (chain)\npicking this:\n  similar_mat_wit A C P Q", "have \"P * Q = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A C P Q\n\ngoal (1 subgoal):\n 1. P * Q = 1\\<^sub>m n", "unfolding similar_mat_wit_def"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, C, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * C * Q\n\ngoal (1 subgoal):\n 1. P * Q = 1\\<^sub>m n", "using A"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, C, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * C * Q\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * Q = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  P * Q = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  P * Q = 1\\<^sub>m n", "have \"inverts_mat P Q\""], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inverts_mat P Q", "using inverts_mat_def dimP"], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat P Q", "by auto"], ["proof (state)\nthis:\n  inverts_mat P Q\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "then"], ["proof (chain)\npicking this:\n  inverts_mat P Q", "have uP: \"unitary P\""], ["proof (prove)\nusing this:\n  inverts_mat P Q\n\ngoal (1 subgoal):\n 1. unitary P", "using QaP unitary_def dimP"], ["proof (prove)\nusing this:\n  inverts_mat P Q\n  Q = adjoint P\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary P", "by auto"], ["proof (state)\nthis:\n  unitary P\n\ngoal (1 subgoal):\n 1. \\<And>a es n A B P Q.\n       \\<lbrakk>\\<And>n A B P Q.\n                   \\<lbrakk>A \\<in> carrier_mat n n;\n                    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]);\n                    unitary_schur_decomposition A es = (B, P, Q)\\<rbrakk>\n                   \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                                     upper_triangular B \\<and>\n                                     diag_mat B = es \\<and>\n                                     unitary P \\<and> Q = adjoint P;\n        A \\<in> carrier_mat n n;\n        char_poly A = (\\<Prod>e\\<leftarrow>a # es. [:- e, 1:]);\n        unitary_schur_decomposition A (a # es) = (B, P, Q)\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit A B P Q \\<and>\n                         upper_triangular B \\<and>\n                         diag_mat B = a # es \\<and>\n                         unitary P \\<and> Q = adjoint P", "from ut similar_mat_wit_trans[OF simAA' simA'C, folded P Q] diag uP QaP"], ["proof (chain)\npicking this:\n  upper_triangular C\n  similar_mat_wit A C P Q\n  diag_mat C = e # es\n  unitary P\n  Q = adjoint P", "show ?case"], ["proof (prove)\nusing this:\n  upper_triangular C\n  similar_mat_wit A C P Q\n  diag_mat C = e # es\n  unitary P\n  Q = adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A C P Q \\<and>\n    upper_triangular C \\<and>\n    diag_mat C = e # es \\<and> unitary P \\<and> Q = adjoint P", "by blast"], ["proof (state)\nthis:\n  similar_mat_wit A C P Q \\<and>\n  upper_triangular C \\<and>\n  diag_mat C = e # es \\<and> unitary P \\<and> Q = adjoint P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_mat_char_poly_factorizable:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>as. char_poly A =  (\\<Prod> a \\<leftarrow> as. [:- a, 1:]) \\<and> length as = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "let ?ca = \"char_poly A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "have ex0: \"\\<exists>bs. Polynomial.smult (lead_coeff ?ca) (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) = ?ca \\<and>\n     length bs = degree ?ca\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       Polynomial.smult (lead_coeff (char_poly A))\n        (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n       char_poly A \\<and>\n       length bs = degree (char_poly A)", "by (simp add: fundamental_theorem_algebra_factorized)"], ["proof (state)\nthis:\n  \\<exists>bs.\n     Polynomial.smult (lead_coeff (char_poly A))\n      (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n     char_poly A \\<and>\n     length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs.\n     Polynomial.smult (lead_coeff (char_poly A))\n      (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n     char_poly A \\<and>\n     length bs = degree (char_poly A)", "obtain bs where \" Polynomial.smult (lead_coeff ?ca) (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) = ?ca \\<and>\n     length bs = degree ?ca\""], ["proof (prove)\nusing this:\n  \\<exists>bs.\n     Polynomial.smult (lead_coeff (char_poly A))\n      (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n     char_poly A \\<and>\n     length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        Polynomial.smult (lead_coeff (char_poly A))\n         (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n        char_poly A \\<and>\n        length bs = degree (char_poly A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n  char_poly A \\<and>\n  length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n  char_poly A \\<and>\n  length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "have \"lead_coeff ?ca = (1::complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (char_poly A)", "using assms degree_monic_char_poly"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  degree (char_poly ?A) = ?n \\<and> coeff (char_poly ?A) ?n = (1::?'a)\n\ngoal (1 subgoal):\n 1. monic (char_poly A)", "by blast"], ["proof (state)\nthis:\n  monic (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "ultimately"], ["proof (chain)\npicking this:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n  char_poly A \\<and>\n  length bs = degree (char_poly A)\n  monic (char_poly A)", "have ex1: \"?ca = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and> length bs = degree ?ca\""], ["proof (prove)\nusing this:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) =\n  char_poly A \\<and>\n  length bs = degree (char_poly A)\n  monic (char_poly A)\n\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and>\n    length bs = degree (char_poly A)", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and>\n  length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "moreover"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and>\n  length bs = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "have \"degree ?ca = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly A) = n", "by (simp add: assms degree_monic_char_poly)"], ["proof (state)\nthis:\n  degree (char_poly A) = n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "ultimately"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and>\n  length bs = degree (char_poly A)\n  degree (char_poly A) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>b\\<leftarrow>bs. [:- b, 1:]) \\<and>\n  length bs = degree (char_poly A)\n  degree (char_poly A) = n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "by auto"], ["proof (state)\nthis:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_mat_has_unitary_schur_decomposition:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>B P es. similar_mat_wit A B P (adjoint P) \\<and> unitary P \n    \\<and> char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:]) \\<and> diag_mat B = es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "have \"\\<exists>es. char_poly A =  (\\<Prod> e \\<leftarrow> es. [:- e, 1:]) \\<and> length es = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>es.\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       length es = n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>es.\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       length es = n", "by (simp add: complex_mat_char_poly_factorizable)"], ["proof (state)\nthis:\n  \\<exists>es.\n     char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> length es = n\n\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "then"], ["proof (chain)\npicking this:\n  \\<exists>es.\n     char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> length es = n", "obtain es where es: \"char_poly A =  (\\<Prod> e \\<leftarrow> es. [:- e, 1:]) \\<and> length es = n\""], ["proof (prove)\nusing this:\n  \\<exists>es.\n     char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> length es = n\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n        length es = n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> length es = n\n\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "obtain B P Q where B: \"unitary_schur_decomposition A es = (B,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P Q.\n        unitary_schur_decomposition A es = (B, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "have \"similar_mat_wit A B P Q \\<and> upper_triangular B \\<and> unitary P \\<and> (Q = adjoint P) \\<and> \n   char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:]) \\<and> diag_mat B = es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and>\n    upper_triangular B \\<and>\n    unitary P \\<and>\n    Q = adjoint P \\<and>\n    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n    diag_mat B = es", "using assms es B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> length es = n\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P Q \\<and>\n    upper_triangular B \\<and>\n    unitary P \\<and>\n    Q = adjoint P \\<and>\n    char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n    diag_mat B = es", "by (auto simp add: unitary_schur_decomposition)"], ["proof (state)\nthis:\n  similar_mat_wit A B P Q \\<and>\n  upper_triangular B \\<and>\n  unitary P \\<and>\n  Q = adjoint P \\<and>\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> diag_mat B = es\n\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P Q \\<and>\n  upper_triangular B \\<and>\n  unitary P \\<and>\n  Q = adjoint P \\<and>\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> diag_mat B = es", "show ?thesis"], ["proof (prove)\nusing this:\n  similar_mat_wit A B P Q \\<and>\n  upper_triangular B \\<and>\n  unitary P \\<and>\n  Q = adjoint P \\<and>\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and> diag_mat B = es\n\ngoal (1 subgoal):\n 1. \\<exists>B P es.\n       similar_mat_wit A B P (adjoint P) \\<and>\n       unitary P \\<and>\n       char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n       diag_mat B = es", "by auto"], ["proof (state)\nthis:\n  \\<exists>B P es.\n     similar_mat_wit A B P (adjoint P) \\<and>\n     unitary P \\<and>\n     char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<and>\n     diag_mat B = es\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_upper_triangular_matrix_is_diagonal:\n  fixes A :: \"'a::conjugatable_ordered_field mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n    and tri: \"upper_triangular A\"\n    and norm: \"A * adjoint A = adjoint A * A\"\n  shows \"diagonal_mat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_mat A", "proof (rule disjE[of \"n = 0\" \"n > 0\"], blast)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A\n 2. 0 < n \\<Longrightarrow> diagonal_mat A", "have dim: \"dim_row A = n\" \"dim_col A = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  upper_triangular A\n  A * adjoint A = adjoint A * A\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A\n 2. 0 < n \\<Longrightarrow> diagonal_mat A", "from norm"], ["proof (chain)\npicking this:\n  A * adjoint A = adjoint A * A", "have eq0: \"\\<And>i j. (A * adjoint A)$$(i,j) = (adjoint A * A)$$(i,j)\""], ["proof (prove)\nusing this:\n  A * adjoint A = adjoint A * A\n\ngoal (1 subgoal):\n 1. \\<And>i j. (A * adjoint A) $$ (i, j) = (adjoint A * A) $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  (A * adjoint A) $$ (?i, ?j) = (adjoint A * A) $$ (?i, ?j)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A\n 2. 0 < n \\<Longrightarrow> diagonal_mat A", "have nat_induct_strong: \n    \"\\<And>P. (P::nat\\<Rightarrow>bool) 0 \\<Longrightarrow> (\\<And>i. i < n \\<Longrightarrow> (\\<And>k. k < i \\<Longrightarrow> P k) \\<Longrightarrow> P i) \\<Longrightarrow> (\\<And>i. i < n \\<Longrightarrow> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>P 0;\n        \\<And>i.\n           \\<lbrakk>i < n; \\<And>k. k < i \\<Longrightarrow> P k\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> (\\<And>i. i < n \\<Longrightarrow> P i)", "by (metis dual_order.strict_trans infinite_descent0 linorder_neqE_nat)"], ["proof (state)\nthis:\n  \\<lbrakk>?P 0;\n   \\<And>i.\n      \\<lbrakk>i < n; \\<And>k. k < i \\<Longrightarrow> ?P k\\<rbrakk>\n      \\<Longrightarrow> ?P i;\n   ?i < n\\<rbrakk>\n  \\<Longrightarrow> ?P ?i\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A\n 2. 0 < n \\<Longrightarrow> diagonal_mat A", "show \"n = 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A", "using dim"], ["proof (prove)\nusing this:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> diagonal_mat A", "unfolding diagonal_mat_def"], ["proof (prove)\nusing this:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    \\<forall>i<dim_row A.\n       \\<forall>j<dim_col A.\n          i \\<noteq> j \\<longrightarrow> A $$ (i, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> diagonal_mat A\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> diagonal_mat A", "show \"n > 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> diagonal_mat A", "unfolding diagonal_mat_def dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    \\<forall>i<n.\n       \\<forall>j<n. i \\<noteq> j \\<longrightarrow> A $$ (i, j) = (0::'a)", "apply (rule allI, rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < n; i < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            i \\<noteq> j \\<longrightarrow>\n                            A $$ (i, j) = (0::'a)", "apply (rule nat_induct_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < n; i < n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            0 \\<noteq> j \\<longrightarrow>\n                            A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "proof (rule allI, rule impI, rule impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "assume asm: \"n > 0\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "from tri upper_triangularD[of A 0 j] dim"], ["proof (chain)\npicking this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; 0 < j; j < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (j, 0) = (0::'a)\n  dim_row A = n\n  dim_col A = n", "have z0: \"\\<And>j. 0< j \\<Longrightarrow> j < n \\<Longrightarrow> A$$(j, 0) = 0\""], ["proof (prove)\nusing this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; 0 < j; j < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (j, 0) = (0::'a)\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < j; j < n\\<rbrakk>\n       \\<Longrightarrow> A $$ (j, 0) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?j; ?j < n\\<rbrakk> \\<Longrightarrow> A $$ (?j, 0) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?j; ?j < n\\<rbrakk> \\<Longrightarrow> A $$ (?j, 0) = (0::'a)", "have ada00: \"(adjoint A * A)$$(0,0) = conjugate (A$$(0,0)) * A$$(0,0)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?j; ?j < n\\<rbrakk> \\<Longrightarrow> A $$ (?j, 0) = (0::'a)\n\ngoal (1 subgoal):\n 1. (adjoint A * A) $$ (0, 0) = conjugate (A $$ (0, 0)) * A $$ (0, 0)", "using asm dim"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?j; ?j < n\\<rbrakk> \\<Longrightarrow> A $$ (?j, 0) = (0::'a)\n  0 < n\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. (adjoint A * A) $$ (0, 0) = conjugate (A $$ (0, 0)) * A $$ (0, 0)", "by (auto simp add: scalar_prod_def adjoint_eval sum.atLeast_Suc_lessThan)"], ["proof (state)\nthis:\n  (adjoint A * A) $$ (0, 0) = conjugate (A $$ (0, 0)) * A $$ (0, 0)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "have aad00: \"(A * adjoint A)$$(0,0) = (\\<Sum>k=0..<n. A$$(0, k) * conjugate (A$$(0, k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * adjoint A) $$ (0, 0) =\n    (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))", "using asm dim"], ["proof (prove)\nusing this:\n  0 < n\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. (A * adjoint A) $$ (0, 0) =\n    (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))", "by (auto simp add: scalar_prod_def adjoint_eval)"], ["proof (state)\nthis:\n  (A * adjoint A) $$ (0, 0) =\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "moreover"], ["proof (state)\nthis:\n  (A * adjoint A) $$ (0, 0) =\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "have \n      \"\\<dots> = A$$(0,0) * conjugate (A$$(0,0))\n          + (\\<Sum>k=1..<n. A$$(0, k) * conjugate (A$$(0, k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n    A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n    (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))", "using dim asm"], ["proof (prove)\nusing this:\n  dim_row A = n\n  dim_col A = n\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n    A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n    (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))", "by (subst sum.atLeast_Suc_lessThan[of 0 n \"\\<lambda>k. A$$(0, k) * conjugate (A$$(0, k))\"], auto)"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n  A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n  (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "ultimately"], ["proof (chain)\npicking this:\n  (A * adjoint A) $$ (0, 0) =\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n  A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n  (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))", "have f1tneq0: \"(\\<Sum>k=(Suc 0)..<n. A$$(0, k) * conjugate (A$$(0, k))) = 0\""], ["proof (prove)\nusing this:\n  (A * adjoint A) $$ (0, 0) =\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n  A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n  (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) = (0::'a)", "using eq0 ada00"], ["proof (prove)\nusing this:\n  (A * adjoint A) $$ (0, 0) =\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n  (\\<Sum>k = 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) =\n  A $$ (0, 0) * conjugate (A $$ (0, 0)) +\n  (\\<Sum>k = 1..<n. A $$ (0, k) * conjugate (A $$ (0, k)))\n  (A * adjoint A) $$ (?i, ?j) = (adjoint A * A) $$ (?i, ?j)\n  (adjoint A * A) $$ (0, 0) = conjugate (A $$ (0, 0)) * A $$ (0, 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) = (0::'a)", "by (simp)"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc 0..<n. A $$ (0, k) * conjugate (A $$ (0, k))) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "have geq0: \"\\<And>k. k < n \\<Longrightarrow> A$$(0, k) * conjugate (A$$(0, k)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < n \\<Longrightarrow>\n       (0::'a) \\<le> A $$ (0, k) * conjugate (A $$ (0, k))", "using conjugate_square_positive"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?a * conjugate ?a\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < n \\<Longrightarrow>\n       (0::'a) \\<le> A $$ (0, k) * conjugate (A $$ (0, k))", "by auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  (0::'a) \\<le> A $$ (0, ?k) * conjugate (A $$ (0, ?k))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "have \"\\<And>k. 1 \\<le> k \\<Longrightarrow> k < n \\<Longrightarrow> A$$(0, k) * conjugate (A$$(0, k)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>1 \\<le> k; k < n\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, k) * conjugate (A $$ (0, k)) = (0::'a)", "by (rule sum_nonneg_0[of \"{1..<n}\"], auto, rule geq0, auto, rule f1tneq0)"], ["proof (state)\nthis:\n  \\<lbrakk>1 \\<le> ?k; ?k < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?k) * conjugate (A $$ (0, ?k)) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 < n; i < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)\n 2. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 3. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "with dim asm"], ["proof (chain)\npicking this:\n  dim_row A = n\n  dim_col A = n\n  0 < n\n  \\<lbrakk>1 \\<le> ?k; ?k < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?k) * conjugate (A $$ (0, ?k)) = (0::'a)", "show \n      case0: \"\\<And>j. 0 < n \\<Longrightarrow> j < n \\<Longrightarrow> 0 \\<noteq> j \\<Longrightarrow> A $$ (0, j) = 0\""], ["proof (prove)\nusing this:\n  dim_row A = n\n  dim_col A = n\n  0 < n\n  \\<lbrakk>1 \\<le> ?k; ?k < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?k) * conjugate (A $$ (0, ?k)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 < n; j < n; 0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (0, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; ?j < n; 0 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; ?j < n; 0 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "assume asm: \"n > 0\" \"i < n\" \"i > 0\"\n        and ih: \"\\<And>k. k < i \\<Longrightarrow> \\<forall>j<n. k \\<noteq> j \\<longrightarrow> A $$ (k, j) = 0\""], ["proof (state)\nthis:\n  0 < n\n  i < n\n  0 < i\n  ?k < i \\<Longrightarrow>\n  \\<forall>j<n. ?k \\<noteq> j \\<longrightarrow> A $$ (?k, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "then"], ["proof (chain)\npicking this:\n  0 < n\n  i < n\n  0 < i\n  ?k < i \\<Longrightarrow>\n  \\<forall>j<n. ?k \\<noteq> j \\<longrightarrow> A $$ (?k, j) = (0::'a)", "have \"\\<And>j. j<n \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n  ?k < i \\<Longrightarrow>\n  \\<forall>j<n. ?k \\<noteq> j \\<longrightarrow> A $$ (?k, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have inter_part: \"\\<And>b m e. (b::nat) < e \\<Longrightarrow> b < m \\<Longrightarrow> m < e \\<Longrightarrow> {b..<m} \\<union> {m..<e} = {b..<e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b m e.\n       \\<lbrakk>b < e; b < m; m < e\\<rbrakk>\n       \\<Longrightarrow> {b..<m} \\<union> {m..<e} = {b..<e}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> {?b..<?m} \\<union> {?m..<?e} = {?b..<?e}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> {?b..<?m} \\<union> {?m..<?e} = {?b..<?e}", "have  \n          \"\\<And>b m e f. (b::nat) < e \\<Longrightarrow> b < m \\<Longrightarrow> m < e \n            \\<Longrightarrow> (\\<Sum>k=b..<e. f k) = (\\<Sum>k\\<in>{b..<m}\\<union>{m..<e}. f k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> {?b..<?m} \\<union> {?m..<?e} = {?b..<?e}\n\ngoal (1 subgoal):\n 1. \\<And>b m e f.\n       \\<lbrakk>b < e; b < m; m < e\\<rbrakk>\n       \\<Longrightarrow> sum f {b..<e} = sum f ({b..<m} \\<union> {m..<e})", "using sum.union_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> {?b..<?m} \\<union> {?m..<?e} = {?b..<?e}\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> sum ?g (?A \\<union> ?B) = sum ?g ?A + sum ?g ?B\n\ngoal (1 subgoal):\n 1. \\<And>b m e f.\n       \\<lbrakk>b < e; b < m; m < e\\<rbrakk>\n       \\<Longrightarrow> sum f {b..<e} = sum f ({b..<m} \\<union> {m..<e})", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> sum ?f {?b..<?e} = sum ?f ({?b..<?m} \\<union> {?m..<?e})\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> sum ?f {?b..<?e} = sum ?f ({?b..<?m} \\<union> {?m..<?e})", "have sum_part:\n          \"\\<And>b m e f. (b::nat) < e \\<Longrightarrow> b < m \\<Longrightarrow> m < e \n                      \\<Longrightarrow> (\\<Sum>k=b..<e. f k) = (\\<Sum>k=b..<m. f k) + (\\<Sum>k=m..<e. f k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b < ?e; ?b < ?m; ?m < ?e\\<rbrakk>\n  \\<Longrightarrow> sum ?f {?b..<?e} = sum ?f ({?b..<?m} \\<union> {?m..<?e})\n\ngoal (1 subgoal):\n 1. \\<And>b m e f.\n       \\<lbrakk>b < e; b < m; m < e\\<rbrakk>\n       \\<Longrightarrow> sum f {b..<e} = sum f {b..<m} + sum f {m..<e}", "by (auto simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  \\<lbrakk>?b1 < ?e1; ?b1 < ?m1; ?m1 < ?e1\\<rbrakk>\n  \\<Longrightarrow> sum ?f1 {?b1..<?e1} =\n                    sum ?f1 {?b1..<?m1} + sum ?f1 {?m1..<?e1}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "from tri upper_triangularD[of A j i] asm dim"], ["proof (chain)\npicking this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; j < i; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n", "have \n            zsi0: \"\\<And>j. j < i \\<Longrightarrow> A$$(i, j) = 0\""], ["proof (prove)\nusing this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; j < i; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. \\<And>j. j < i \\<Longrightarrow> A $$ (i, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?j2 < i \\<Longrightarrow> A $$ (i, ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "from tri upper_triangularD[of A j i] asm dim"], ["proof (chain)\npicking this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; j < i; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n", "have \n            zsi1: \"\\<And>k. i < k \\<Longrightarrow> k < n \\<Longrightarrow> A$$(k, i) = 0\""], ["proof (prove)\nusing this:\n  upper_triangular A\n  \\<lbrakk>upper_triangular A; j < i; i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < n\\<rbrakk>\n       \\<Longrightarrow> A $$ (k, i) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i < ?k2; ?k2 < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?k2, i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have \n          \"(A * adjoint A)$$(i, i) \n          = (\\<Sum>k=0..<n. conjugate (A$$(i, k)) * A$$(i, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * adjoint A) $$ (i, i) =\n    (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "using asm dim"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. (A * adjoint A) $$ (i, i) =\n    (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "apply (auto simp add: scalar_prod_def adjoint_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; 0 < i; dim_col A = dim_row A;\n     n = dim_row A\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>ia = 0..<dim_row A.\n                          A $$ (i, ia) * conjugate (A $$ (i, ia))) =\n                      (\\<Sum>k = 0..<dim_row A.\n                          conjugate (A $$ (i, k)) * A $$ (i, k))", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (A * adjoint A) $$ (i, i) =\n  (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (A * adjoint A) $$ (i, i) =\n  (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have\n          \"\\<dots> = (\\<Sum>k=0..<i. conjugate (A$$(i, k)) * A$$(i, k))\n              + (\\<Sum>k=i..<n. conjugate (A$$(i, k)) * A$$(i, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "using asm"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "by (auto simp add: sum_part[of 0 n i])"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n  (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n  (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have\n          \"\\<dots> = (\\<Sum>k=i..<n. conjugate (A$$(i, k)) * A$$(i, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "using zsi0"], ["proof (prove)\nusing this:\n  ?j2 < i \\<Longrightarrow> A $$ (i, ?j2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<i. conjugate (A $$ (i, k)) * A $$ (i, k)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have\n          \"\\<dots> = conjugate (A$$(i, i)) * A$$(i, i) \n            + (\\<Sum>k=(Suc i)..<n. conjugate (A$$(i, k)) * A$$(i, k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    conjugate (A $$ (i, i)) * A $$ (i, i) +\n    (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "using asm"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n    conjugate (A $$ (i, i)) * A $$ (i, i) +\n    (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "by (auto simp add: sum.atLeast_Suc_lessThan)"], ["proof (state)\nthis:\n  (\\<Sum>k = i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (A * adjoint A) $$ (i, i) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "have\n          adaii: \"(A * adjoint A)$$(i, i) \n            = conjugate (A$$(i, i)) * A$$(i, i) \n            + (\\<Sum>k=(Suc i)..<n. conjugate (A$$(i, k)) * A$$(i, k))\""], ["proof (prove)\nusing this:\n  (A * adjoint A) $$ (i, i) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. (A * adjoint A) $$ (i, i) =\n    conjugate (A $$ (i, i)) * A $$ (i, i) +\n    (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))", "."], ["proof (state)\nthis:\n  (A * adjoint A) $$ (i, i) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have \n          \"(adjoint A * A)$$(i, i) = (\\<Sum>k=0..<n. conjugate (A$$(k, i)) * A$$(k, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adjoint A * A) $$ (i, i) =\n    (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "using asm dim"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. (adjoint A * A) $$ (i, i) =\n    (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "by (auto simp add: scalar_prod_def adjoint_eval)"], ["proof (state)\nthis:\n  (adjoint A * A) $$ (i, i) =\n  (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (adjoint A * A) $$ (i, i) =\n  (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have\n          \"\\<dots> = (\\<Sum>k=0..<i. conjugate (A$$(k, i)) * A$$(k, i))\n              + (\\<Sum>k=i..<n. conjugate (A$$(k, i)) * A$$(k, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "using asm"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "by (auto simp add: sum_part[of 0 n i])"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n  (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n  (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have \n            \"\\<dots> = (\\<Sum>k=i..<n. conjugate (A$$(k, i)) * A$$(k, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "using asm ih"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n  ?k < i \\<Longrightarrow>\n  \\<forall>j<n. ?k \\<noteq> j \\<longrightarrow> A $$ (?k, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<i. conjugate (A $$ (k, i)) * A $$ (k, i)) +\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have\n            \"\\<dots> = conjugate (A$$(i, i)) * A$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    conjugate (A $$ (i, i)) * A $$ (i, i)", "using asm zsi1"], ["proof (prove)\nusing this:\n  0 < n\n  i < n\n  0 < i\n  \\<lbrakk>i < ?k2; ?k2 < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?k2, i) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n    conjugate (A $$ (i, i)) * A $$ (i, i)", "by (auto simp add: sum.atLeast_Suc_lessThan)"], ["proof (state)\nthis:\n  (\\<Sum>k = i..<n. conjugate (A $$ (k, i)) * A $$ (k, i)) =\n  conjugate (A $$ (i, i)) * A $$ (i, i)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)", "have \"(adjoint A * A)$$(i, i) = conjugate (A$$(i, i)) * A$$(i, i)\""], ["proof (prove)\nusing this:\n  (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)\n\ngoal (1 subgoal):\n 1. (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)", "."], ["proof (state)\nthis:\n  (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "with adaii eq0"], ["proof (chain)\npicking this:\n  (A * adjoint A) $$ (i, i) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n  (A * adjoint A) $$ (?i, ?j) = (adjoint A * A) $$ (?i, ?j)\n  (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)", "have \n          fsitoneq0: \"(\\<Sum>k=(Suc i)..<n. conjugate (A$$(i, k)) * A$$(i, k)) = 0\""], ["proof (prove)\nusing this:\n  (A * adjoint A) $$ (i, i) =\n  conjugate (A $$ (i, i)) * A $$ (i, i) +\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k))\n  (A * adjoint A) $$ (?i, ?j) = (adjoint A * A) $$ (?i, ?j)\n  (adjoint A * A) $$ (i, i) = conjugate (A $$ (i, i)) * A $$ (i, i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc i..<n. conjugate (A $$ (i, k)) * A $$ (i, k)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "have \"\\<And>k. k<n \\<Longrightarrow> i < k \\<Longrightarrow> conjugate (A$$(i, k)) * A$$(i, k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n; i < k\\<rbrakk>\n       \\<Longrightarrow> conjugate (A $$ (i, k)) * A $$ (i, k) = (0::'a)", "by (rule sum_nonneg_0[of \"{(Suc i)..<n}\"], auto, subst mult.commute, \n              rule conjugate_square_positive, rule fsitoneq0)"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> conjugate (A $$ (i, ?k2)) * A $$ (i, ?k2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> conjugate (A $$ (i, ?k2)) * A $$ (i, ?k2) = (0::'a)", "have \"\\<And>k. k<n  \\<Longrightarrow> i<k \\<Longrightarrow> A $$ (i, k) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> conjugate (A $$ (i, ?k2)) * A $$ (i, ?k2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < n; i < k\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, k) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, ?k2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j; 0 < n; i < n; 0 < i;\n        \\<And>k.\n           k < i \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "with zsi0"], ["proof (chain)\npicking this:\n  ?j2 < i \\<Longrightarrow> A $$ (i, ?j2) = (0::'a)\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, ?k2) = (0::'a)", "show \"\\<And>j. j<n \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  ?j2 < i \\<Longrightarrow> A $$ (i, ?j2) = (0::'a)\n  \\<lbrakk>?k2 < n; i < ?k2\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, ?k2) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)", "by (metis linorder_neqE_nat)"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < n; i \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, ?j2) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j < n; i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; ?i3 < n; 0 < ?i3;\n   \\<And>k.\n      k < ?i3 \\<Longrightarrow>\n      \\<forall>j<n. k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a);\n   ?j < n; ?i3 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i3, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)\n 2. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "with case0"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < n; ?j < n; 0 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?j) = (0::'a)\n  \\<lbrakk>0 < n; ?i3 < n; 0 < ?i3;\n   \\<And>k.\n      k < ?i3 \\<Longrightarrow>\n      \\<forall>j<n. k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a);\n   ?j < n; ?i3 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i3, ?j) = (0::'a)", "show \"\\<And>i ia.\n       0 < n \\<Longrightarrow>\n       i < n \\<Longrightarrow>\n       ia < n \\<Longrightarrow>\n       (\\<And>k. k < ia \\<Longrightarrow> \\<forall>j<n. k \\<noteq> j \\<longrightarrow> A $$ (k, j) = 0) \\<Longrightarrow>\n       \\<forall>j<n. ia \\<noteq> j \\<longrightarrow> A $$ (ia, j) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; ?j < n; 0 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (0, ?j) = (0::'a)\n  \\<lbrakk>0 < n; ?i3 < n; 0 < ?i3;\n   \\<And>k.\n      k < ?i3 \\<Longrightarrow>\n      \\<forall>j<n. k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a);\n   ?j < n; ?i3 \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i3, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>0 < n; i < n; ia < n;\n        \\<And>k.\n           k < ia \\<Longrightarrow>\n           \\<forall>j<n.\n              k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<n.\n                            ia \\<noteq> j \\<longrightarrow>\n                            A $$ (ia, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; ?i < n; ?ia < n;\n   \\<And>k.\n      k < ?ia \\<Longrightarrow>\n      \\<forall>j<n.\n         k \\<noteq> j \\<longrightarrow> A $$ (k, j) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j<n.\n                       ?ia \\<noteq> j \\<longrightarrow>\n                       A $$ (?ia, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<lbrakk>0 < n; i < n\\<rbrakk> \\<Longrightarrow> i < n", "qed"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> diagonal_mat A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_complex_mat_has_spectral_decomposition:\n  assumes A: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and normal: \"A * adjoint A  = adjoint A * A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have smw: \"similar_mat_wit A B P (adjoint P)\" \n    and ut: \"upper_triangular B\"\n    and uP: \"unitary P\" \n    and dB: \"diag_mat B = es\"\n    and \"(Q = adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (similar_mat_wit A B P (adjoint P) &&& upper_triangular B) &&&\n    unitary P &&& diag_mat B = es &&& Q = adjoint P", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  A * adjoint A = adjoint A * A\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. (similar_mat_wit A B P (adjoint P) &&& upper_triangular B) &&&\n    unitary P &&& diag_mat B = es &&& Q = adjoint P", "by (auto simp add: unitary_schur_decomposition)"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P)\n  upper_triangular B\n  unitary P\n  diag_mat B = es\n  Q = adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "from smw"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P)", "have dimP: \"P \\<in> carrier_mat n n\" and dimB: \"B \\<in> carrier_mat n n\" \n    and dimaP: \"adjoint P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&&\n    B \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "unfolding similar_mat_wit_def"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, B, P, adjoint P} \\<subseteq> carrier_mat n n \\<and>\n     P * adjoint P = 1\\<^sub>m n \\<and>\n     adjoint P * P = 1\\<^sub>m n \\<and> A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&&\n    B \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  let n = dim_row A\n  in {A, B, P, adjoint P} \\<subseteq> carrier_mat n n \\<and>\n     P * adjoint P = 1\\<^sub>m n \\<and>\n     adjoint P * P = 1\\<^sub>m n \\<and> A = P * B * adjoint P\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n &&&\n    B \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have dimaB: \"adjoint B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint B \\<in> carrier_mat n n", "using dimB"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "note dims = dimP dimB dimaP dimaB"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"inverts_mat P (adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat P (adjoint P)", "using unitary_def uP dims"], ["proof (prove)\nusing this:\n  unitary ?A =\n  (?A \\<in> carrier_mat (dim_row ?A) (dim_row ?A) \\<and>\n   inverts_mat ?A (adjoint ?A))\n  unitary P\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat P (adjoint P)", "by auto"], ["proof (state)\nthis:\n  inverts_mat P (adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "then"], ["proof (chain)\npicking this:\n  inverts_mat P (adjoint P)", "have iaPP: \"inverts_mat (adjoint P) P\""], ["proof (prove)\nusing this:\n  inverts_mat P (adjoint P)\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint P) P", "using inverts_mat_symm"], ["proof (prove)\nusing this:\n  inverts_mat P (adjoint P)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   inverts_mat ?A ?B\\<rbrakk>\n  \\<Longrightarrow> inverts_mat ?B ?A\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint P) P", "using dims"], ["proof (prove)\nusing this:\n  inverts_mat P (adjoint P)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   inverts_mat ?A ?B\\<rbrakk>\n  \\<Longrightarrow> inverts_mat ?B ?A\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint P) P", "by auto"], ["proof (state)\nthis:\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have aPP: \"adjoint P * P = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "using dims iaPP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  adjoint P * P = 1\\<^sub>m (dim_row (adjoint P))\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "from smw"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P)", "have A: \"A = P * B * (adjoint P)\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P)\n\ngoal (1 subgoal):\n 1. A = P * B * adjoint P", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\nusing this:\n  {A, B, P, adjoint P}\n  \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n  P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n  adjoint P * P = 1\\<^sub>m (dim_row A) \\<and> A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. A = P * B * adjoint P", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "then"], ["proof (chain)\npicking this:\n  A = P * B * adjoint P", "have aA: \"adjoint A = P * adjoint B * adjoint P\""], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint A = P * adjoint B * adjoint P", "by (insert A dimP dimB dimaP, auto simp add: adjoint_mult[of _ n n _ n] adjoint_adjoint)"], ["proof (state)\nthis:\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"A * adjoint A = (P * B * adjoint P) * (P * adjoint B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * adjoint A = P * B * adjoint P * (P * adjoint B * adjoint P)", "using A aA"], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. A * adjoint A = P * B * adjoint P * (P * adjoint B * adjoint P)", "by auto"], ["proof (state)\nthis:\n  A * adjoint A = P * B * adjoint P * (P * adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  A * adjoint A = P * B * adjoint P * (P * adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * B * (adjoint P * P) * (adjoint B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B * adjoint P * (P * adjoint B * adjoint P) =\n    P * B * (adjoint P * P) * (adjoint B * adjoint P)", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * B * adjoint P * (P * adjoint B * adjoint P) =\n    P * B * (adjoint P * P) * (adjoint B * adjoint P)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * B * adjoint P * (P * adjoint B * adjoint P) =\n  P * B * (adjoint P * P) * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  P * B * adjoint P * (P * adjoint B * adjoint P) =\n  P * B * (adjoint P * P) * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * B * 1\\<^sub>m n * (adjoint B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B * (adjoint P * P) * (adjoint B * adjoint P) =\n    P * B * 1\\<^sub>m n * (adjoint B * adjoint P)", "using dims aPP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. P * B * (adjoint P * P) * (adjoint B * adjoint P) =\n    P * B * 1\\<^sub>m n * (adjoint B * adjoint P)", "by (auto)"], ["proof (state)\nthis:\n  P * B * (adjoint P * P) * (adjoint B * adjoint P) =\n  P * B * 1\\<^sub>m n * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  P * B * (adjoint P * P) * (adjoint B * adjoint P) =\n  P * B * 1\\<^sub>m n * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * B * adjoint B * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B * 1\\<^sub>m n * (adjoint B * adjoint P) =\n    P * B * adjoint B * adjoint P", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * B * 1\\<^sub>m n * (adjoint B * adjoint P) =\n    P * B * adjoint B * adjoint P", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * B * 1\\<^sub>m n * (adjoint B * adjoint P) =\n  P * B * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "finally"], ["proof (chain)\npicking this:\n  A * adjoint A = P * B * adjoint B * adjoint P", "have \"A * adjoint A = P * B * adjoint B * adjoint P\""], ["proof (prove)\nusing this:\n  A * adjoint A = P * B * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. A * adjoint A = P * B * adjoint B * adjoint P", "."], ["proof (state)\nthis:\n  A * adjoint A = P * B * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "then"], ["proof (chain)\npicking this:\n  A * adjoint A = P * B * adjoint B * adjoint P", "have \"adjoint P * (A * adjoint A) * P = (adjoint P * P) * B * adjoint B * (adjoint P * P)\""], ["proof (prove)\nusing this:\n  A * adjoint A = P * B * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint P * (A * adjoint A) * P =\n    adjoint P * P * B * adjoint B * (adjoint P * P)", "using dims"], ["proof (prove)\nusing this:\n  A * adjoint A = P * B * adjoint B * adjoint P\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P * (A * adjoint A) * P =\n    adjoint P * P * B * adjoint B * (adjoint P * P)", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  adjoint P * (A * adjoint A) * P =\n  adjoint P * P * B * adjoint B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  adjoint P * (A * adjoint A) * P =\n  adjoint P * P * B * adjoint B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = 1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * P * B * adjoint B * (adjoint P * P) =\n    1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n", "using aPP"], ["proof (prove)\nusing this:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P * B * adjoint B * (adjoint P * P) =\n    1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P * B * adjoint B * (adjoint P * P) =\n  1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  adjoint P * P * B * adjoint B * (adjoint P * P) =\n  1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = B * adjoint B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n = B * adjoint B", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n = B * adjoint B", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * B * adjoint B * 1\\<^sub>m n = B * adjoint B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "finally"], ["proof (chain)\npicking this:\n  adjoint P * (A * adjoint A) * P = B * adjoint B", "have eq0: \"adjoint P * (A * adjoint A) * P = B * adjoint B\""], ["proof (prove)\nusing this:\n  adjoint P * (A * adjoint A) * P = B * adjoint B\n\ngoal (1 subgoal):\n 1. adjoint P * (A * adjoint A) * P = B * adjoint B", "."], ["proof (state)\nthis:\n  adjoint P * (A * adjoint A) * P = B * adjoint B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"adjoint A * A = (P * adjoint B * adjoint P) * (P * B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint A * A = P * adjoint B * adjoint P * (P * B * adjoint P)", "using A aA"], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint A * A = P * adjoint B * adjoint P * (P * B * adjoint P)", "by auto"], ["proof (state)\nthis:\n  adjoint A * A = P * adjoint B * adjoint P * (P * B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  adjoint A * A = P * adjoint B * adjoint P * (P * B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * adjoint B * (adjoint P * P) * (B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * adjoint B * adjoint P * (P * B * adjoint P) =\n    P * adjoint B * (adjoint P * P) * (B * adjoint P)", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * adjoint B * adjoint P * (P * B * adjoint P) =\n    P * adjoint B * (adjoint P * P) * (B * adjoint P)", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * adjoint B * adjoint P * (P * B * adjoint P) =\n  P * adjoint B * (adjoint P * P) * (B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  P * adjoint B * adjoint P * (P * B * adjoint P) =\n  P * adjoint B * (adjoint P * P) * (B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * adjoint B * 1\\<^sub>m n * (B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * adjoint B * (adjoint P * P) * (B * adjoint P) =\n    P * adjoint B * 1\\<^sub>m n * (B * adjoint P)", "using dims aPP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. P * adjoint B * (adjoint P * P) * (B * adjoint P) =\n    P * adjoint B * 1\\<^sub>m n * (B * adjoint P)", "by (auto)"], ["proof (state)\nthis:\n  P * adjoint B * (adjoint P * P) * (B * adjoint P) =\n  P * adjoint B * 1\\<^sub>m n * (B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  P * adjoint B * (adjoint P * P) * (B * adjoint P) =\n  P * adjoint B * 1\\<^sub>m n * (B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = P * adjoint B * B * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * adjoint B * 1\\<^sub>m n * (B * adjoint P) =\n    P * adjoint B * B * adjoint P", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * adjoint B * 1\\<^sub>m n * (B * adjoint P) =\n    P * adjoint B * B * adjoint P", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * adjoint B * 1\\<^sub>m n * (B * adjoint P) =\n  P * adjoint B * B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "finally"], ["proof (chain)\npicking this:\n  adjoint A * A = P * adjoint B * B * adjoint P", "have \"adjoint A * A = P * adjoint B * B * adjoint P\""], ["proof (prove)\nusing this:\n  adjoint A * A = P * adjoint B * B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint A * A = P * adjoint B * B * adjoint P", "by auto"], ["proof (state)\nthis:\n  adjoint A * A = P * adjoint B * B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "then"], ["proof (chain)\npicking this:\n  adjoint A * A = P * adjoint B * B * adjoint P", "have \"adjoint P * (adjoint A * A) * P = (adjoint P * P) * adjoint B * B * (adjoint P * P)\""], ["proof (prove)\nusing this:\n  adjoint A * A = P * adjoint B * B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint P * (adjoint A * A) * P =\n    adjoint P * P * adjoint B * B * (adjoint P * P)", "using dims"], ["proof (prove)\nusing this:\n  adjoint A * A = P * adjoint B * B * adjoint P\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P * (adjoint A * A) * P =\n    adjoint P * P * adjoint B * B * (adjoint P * P)", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  adjoint P * (adjoint A * A) * P =\n  adjoint P * P * adjoint B * B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  adjoint P * (adjoint A * A) * P =\n  adjoint P * P * adjoint B * B * (adjoint P * P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = 1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P * P * adjoint B * B * (adjoint P * P) =\n    1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n", "using aPP"], ["proof (prove)\nusing this:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. adjoint P * P * adjoint B * B * (adjoint P * P) =\n    1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P * adjoint B * B * (adjoint P * P) =\n  1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "also"], ["proof (state)\nthis:\n  adjoint P * P * adjoint B * B * (adjoint P * P) =\n  1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"\\<dots> = adjoint B * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n = adjoint B * B", "using dims"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n = adjoint B * B", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * adjoint B * B * 1\\<^sub>m n = adjoint B * B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "finally"], ["proof (chain)\npicking this:\n  adjoint P * (adjoint A * A) * P = adjoint B * B", "have eq1: \"adjoint P * (adjoint A * A) * P = adjoint B * B\""], ["proof (prove)\nusing this:\n  adjoint P * (adjoint A * A) * P = adjoint B * B\n\ngoal (1 subgoal):\n 1. adjoint P * (adjoint A * A) * P = adjoint B * B", "."], ["proof (state)\nthis:\n  adjoint P * (adjoint A * A) * P = adjoint B * B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "from normal"], ["proof (chain)\npicking this:\n  A * adjoint A = adjoint A * A", "have \"adjoint P * (adjoint A * A) * P = adjoint P * (A * adjoint A) * P\""], ["proof (prove)\nusing this:\n  A * adjoint A = adjoint A * A\n\ngoal (1 subgoal):\n 1. adjoint P * (adjoint A * A) * P = adjoint P * (A * adjoint A) * P", "by auto"], ["proof (state)\nthis:\n  adjoint P * (adjoint A * A) * P = adjoint P * (A * adjoint A) * P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "with eq0 eq1"], ["proof (chain)\npicking this:\n  adjoint P * (A * adjoint A) * P = B * adjoint B\n  adjoint P * (adjoint A * A) * P = adjoint B * B\n  adjoint P * (adjoint A * A) * P = adjoint P * (A * adjoint A) * P", "have \"B * adjoint B = adjoint B * B\""], ["proof (prove)\nusing this:\n  adjoint P * (A * adjoint A) * P = B * adjoint B\n  adjoint P * (adjoint A * A) * P = adjoint B * B\n  adjoint P * (adjoint A * A) * P = adjoint P * (A * adjoint A) * P\n\ngoal (1 subgoal):\n 1. B * adjoint B = adjoint B * B", "by auto"], ["proof (state)\nthis:\n  B * adjoint B = adjoint B * B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "with ut dims"], ["proof (chain)\npicking this:\n  upper_triangular B\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  B * adjoint B = adjoint B * B", "have \"diagonal_mat B\""], ["proof (prove)\nusing this:\n  upper_triangular B\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  B * adjoint B = adjoint B * B\n\ngoal (1 subgoal):\n 1. diagonal_mat B", "using normal_upper_triangular_matrix_is_diagonal"], ["proof (prove)\nusing this:\n  upper_triangular B\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  adjoint B \\<in> carrier_mat n n\n  B * adjoint B = adjoint B * B\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; upper_triangular ?A;\n   ?A * adjoint ?A = adjoint ?A * ?A\\<rbrakk>\n  \\<Longrightarrow> diagonal_mat ?A\n\ngoal (1 subgoal):\n 1. diagonal_mat B", "by auto"], ["proof (state)\nthis:\n  diagonal_mat B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "with smw uP dB"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P)\n  unitary P\n  diag_mat B = es\n  diagonal_mat B", "show \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P)\n  unitary P\n  diag_mat B = es\n  diagonal_mat B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_mat_has_jordan_nf:\n  fixes A :: \"complex mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>n_as. jordan_nf A n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n_as. jordan_nf A n_as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n_as. jordan_nf A n_as", "have \"\\<exists>as. char_poly A =  (\\<Prod> a \\<leftarrow> as. [:- a, 1:]) \\<and> length as = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "by (simp add: complex_mat_char_poly_factorizable)"], ["proof (state)\nthis:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n\n\ngoal (1 subgoal):\n 1. \\<exists>n_as. jordan_nf A n_as", "then"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n\n\ngoal (1 subgoal):\n 1. \\<exists>n_as. jordan_nf A n_as", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>n_as. jordan_nf A n_as", "by (auto simp add: jordan_nf_iff_linear_factorization)"], ["proof (state)\nthis:\n  \\<exists>n_as. jordan_nf A n_as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_is_normal:\n  assumes \"hermitian A\"\n  shows \"A * adjoint A = adjoint A * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * adjoint A = adjoint A * A", "using assms"], ["proof (prove)\nusing this:\n  hermitian A\n\ngoal (1 subgoal):\n 1. A * adjoint A = adjoint A * A", "by (auto simp add: hermitian_def)"], ["", "lemma hermitian_eigenvalue_real:\n  assumes dim: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and hA: \"hermitian A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have normal: \"A * adjoint A = adjoint A * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * adjoint A = adjoint A * A", "using hA hermitian_is_normal"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian ?A \\<Longrightarrow> ?A * adjoint ?A = adjoint ?A * ?A\n\ngoal (1 subgoal):\n 1. A * adjoint A = adjoint A * A", "by auto"], ["proof (state)\nthis:\n  A * adjoint A = adjoint A * A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  A * adjoint A = adjoint A * A", "have schur: \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\""], ["proof (prove)\nusing this:\n  A * adjoint A = adjoint A * A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "using normal_complex_mat_has_spectral_decomposition[OF dim normal c B]"], ["proof (prove)\nusing this:\n  A * adjoint A = adjoint A * A\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "by (simp)"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P", "have \"similar_mat_wit A B P (adjoint P)\" \n    and uP: \"unitary P\" and dB: \"diag_mat B = es\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) &&& unitary P &&& diag_mat B = es", "using assms"], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n  A \\<in> carrier_mat n n\n  hermitian A\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) &&& unitary P &&& diag_mat B = es", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P)\n  unitary P\n  diag_mat B = es\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P)\n  unitary P\n  diag_mat B = es", "have A: \"A = P * B * (adjoint P)\" \n    and dimB: \"B \\<in> carrier_mat n n\" and dimP: \"P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P)\n  unitary P\n  diag_mat B = es\n\ngoal (1 subgoal):\n 1. A = P * B * adjoint P &&&\n    B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\nusing this:\n  {A, B, P, adjoint P}\n  \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n  P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n  adjoint P * P = 1\\<^sub>m (dim_row A) \\<and> A = P * B * adjoint P\n  unitary P\n  diag_mat B = es\n\ngoal (1 subgoal):\n 1. A = P * B * adjoint P &&&\n    B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n", "using dim"], ["proof (prove)\nusing this:\n  {A, B, P, adjoint P}\n  \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n  P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n  adjoint P * P = 1\\<^sub>m (dim_row A) \\<and> A = P * B * adjoint P\n  unitary P\n  diag_mat B = es\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = P * B * adjoint P &&&\n    B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  A = P * B * adjoint P\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n", "have dimaB: \"adjoint B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have \"adjoint A = adjoint (adjoint P) * adjoint (P * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint A = adjoint (adjoint P) * adjoint (P * B)", "apply (subst A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (P * B * adjoint P) = adjoint (adjoint P) * adjoint (P * B)", "apply (subst adjoint_mult[of \"P * B\" n n \"adjoint P\" n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. P * B \\<in> carrier_mat n n\n 2. adjoint P \\<in> carrier_mat n n\n 3. adjoint (adjoint P) * adjoint (P * B) =\n    adjoint (adjoint P) * adjoint (P * B)", "apply (insert dimB dimP, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  adjoint A = adjoint (adjoint P) * adjoint (P * B)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "also"], ["proof (state)\nthis:\n  adjoint A = adjoint (adjoint P) * adjoint (P * B)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have \"\\<dots> = P * adjoint (P * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (adjoint P) * adjoint (P * B) = P * adjoint (P * B)", "by (auto simp add: adjoint_adjoint)"], ["proof (state)\nthis:\n  adjoint (adjoint P) * adjoint (P * B) = P * adjoint (P * B)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "also"], ["proof (state)\nthis:\n  adjoint (adjoint P) * adjoint (P * B) = P * adjoint (P * B)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have \"\\<dots> = P * (adjoint B * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * adjoint (P * B) = P * (adjoint B * adjoint P)", "using dimB dimP"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * adjoint (P * B) = P * (adjoint B * adjoint P)", "by (auto simp add: adjoint_mult)"], ["proof (state)\nthis:\n  P * adjoint (P * B) = P * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "also"], ["proof (state)\nthis:\n  P * adjoint (P * B) = P * (adjoint B * adjoint P)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have \"\\<dots> = P * adjoint B * adjoint P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (adjoint B * adjoint P) = P * adjoint B * adjoint P", "using dimB dimP"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * (adjoint B * adjoint P) = P * adjoint B * adjoint P", "by (subst assoc_mult_mat[symmetric, of P n n \"adjoint B\" n \"adjoint P\" n], auto)"], ["proof (state)\nthis:\n  P * (adjoint B * adjoint P) = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "finally"], ["proof (chain)\npicking this:\n  adjoint A = P * adjoint B * adjoint P", "have aA: \"adjoint A = P * adjoint B * adjoint P\""], ["proof (prove)\nusing this:\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. adjoint A = P * adjoint B * adjoint P", "."], ["proof (state)\nthis:\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have \"A = adjoint A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = adjoint A", "using hA hermitian_def[of A]"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian A = (adjoint A = A)\n\ngoal (1 subgoal):\n 1. A = adjoint A", "by auto"], ["proof (state)\nthis:\n  A = adjoint A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  A = adjoint A", "have \"P * B * adjoint P = P * adjoint B * adjoint P\""], ["proof (prove)\nusing this:\n  A = adjoint A\n\ngoal (1 subgoal):\n 1. P * B * adjoint P = P * adjoint B * adjoint P", "using A aA"], ["proof (prove)\nusing this:\n  A = adjoint A\n  A = P * B * adjoint P\n  adjoint A = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. P * B * adjoint P = P * adjoint B * adjoint P", "by auto"], ["proof (state)\nthis:\n  P * B * adjoint P = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  P * B * adjoint P = P * adjoint B * adjoint P", "have BaB: \"B = adjoint B\""], ["proof (prove)\nusing this:\n  P * B * adjoint P = P * adjoint B * adjoint P\n\ngoal (1 subgoal):\n 1. B = adjoint B", "using unitary_elim[OF dimB dimaB dimP] uP"], ["proof (prove)\nusing this:\n  P * B * adjoint P = P * adjoint B * adjoint P\n  \\<lbrakk>unitary P; P * B * adjoint P = P * adjoint B * adjoint P\\<rbrakk>\n  \\<Longrightarrow> B = adjoint B\n  unitary P\n\ngoal (1 subgoal):\n 1. B = adjoint B", "by auto"], ["proof (state)\nthis:\n  B = adjoint B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "{"], ["proof (state)\nthis:\n  B = adjoint B\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  i < n", "have \"B$$(i, i) = conjugate (B$$(i, i))\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. B $$ (i, i) = conjugate (B $$ (i, i))", "apply (subst BaB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> adjoint B $$ (i, i) = conjugate (B $$ (i, i))", "by (insert dimB, simp add: adjoint_eval)"], ["proof (state)\nthis:\n  B $$ (i, i) = conjugate (B $$ (i, i))\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  B $$ (i, i) = conjugate (B $$ (i, i))", "have \"B$$(i, i) \\<in> Reals\""], ["proof (prove)\nusing this:\n  B $$ (i, i) = conjugate (B $$ (i, i))\n\ngoal (1 subgoal):\n 1. B $$ (i, i) \\<in> \\<real>", "unfolding conjugate_complex_def"], ["proof (prove)\nusing this:\n  B $$ (i, i) = cnj (B $$ (i, i))\n\ngoal (1 subgoal):\n 1. B $$ (i, i) \\<in> \\<real>", "using Reals_cnj_iff"], ["proof (prove)\nusing this:\n  B $$ (i, i) = cnj (B $$ (i, i))\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n\ngoal (1 subgoal):\n 1. B $$ (i, i) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  B $$ (i, i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "then"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) \\<in> \\<real>", "have \"\\<forall>i<n. B$$(i, i) \\<in> Reals\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. B $$ (i, i) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. B $$ (i, i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "with schur"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n  \\<forall>i<n. B $$ (i, i) \\<in> \\<real>", "show ?thesis"], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and> diag_mat B = es \\<and> unitary P\n  \\<forall>i<n. B $$ (i, i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_inner_prod_real:\n  assumes dimA: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and dimv: \"v \\<in> carrier_vec n\"\n    and hA: \"hermitian A\"\n  shows \"inner_prod v (A *\\<^sub>v v) \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "obtain es where es: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complex_mat_char_poly_factorizable dimA"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  \\<exists>as.\n     char_poly ?A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n     length as = ?n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "obtain B P Q where \"unitary_schur_decomposition A es = (B,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P Q.\n        unitary_schur_decomposition A es = (B, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "then"], ["proof (chain)\npicking this:\n  unitary_schur_decomposition A es = (B, P, Q)", "have \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\""], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "using hermitian_eigenvalue_real dimA es hA"], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P (adjoint ?P) \\<and>\n                    diagonal_mat ?B \\<and>\n                    diag_mat ?B = ?es \\<and>\n                    unitary ?P \\<and>\n                    (\\<forall>i<?n. ?B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  hermitian A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have A: \"A = P * B * (adjoint P)\" and dB: \"diagonal_mat B\"\n    and Bii: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<in> Reals\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimP: \"P \\<in> carrier_mat n n\" and dimaP: \"adjoint P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "using dimA"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "define w where \"w = (adjoint P) *\\<^sub>v v\""], ["proof (state)\nthis:\n  w = adjoint P *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "then"], ["proof (chain)\npicking this:\n  w = adjoint P *\\<^sub>v v", "have dimw: \"w \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  w = adjoint P *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "using dimaP dimv"], ["proof (prove)\nusing this:\n  w = adjoint P *\\<^sub>v v\n  adjoint P \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "from A"], ["proof (chain)\npicking this:\n  A = P * B * adjoint P", "have \"inner_prod v (A *\\<^sub>v v) = inner_prod v ((P * B * (adjoint P)) *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    inner_prod v (P * B * adjoint P *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (P * B * adjoint P *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "also"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (P * B * adjoint P *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<dots> = inner_prod v ((P * B) *\\<^sub>v ((adjoint P) *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n    inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))", "using dimP dimB dimv"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n    inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))", "by (subst assoc_mult_mat_vec[of _ n n \"adjoint P\" n], auto)"], ["proof (state)\nthis:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "also"], ["proof (state)\nthis:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<dots> = inner_prod v (P *\\<^sub>v (B *\\<^sub>v ((adjoint P) *\\<^sub>v v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))", "using dimP dimB dimv dimaP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))", "by (subst assoc_mult_mat_vec[of _ n n \"B\" n], auto)"], ["proof (state)\nthis:\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "also"], ["proof (state)\nthis:\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<dots> = inner_prod w (B *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n    inner_prod w (B *\\<^sub>v w)", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n    inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v))", "apply (rule adjoint_def_alter[OF _ _ dimP])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> carrier_vec n\n 2. B *\\<^sub>v (adjoint P *\\<^sub>v v) \\<in> carrier_vec n", "apply (insert mult_mat_vec_carrier[OF dimB mult_mat_vec_carrier[OF dimaP dimv]], auto simp add: dimv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n  inner_prod w (B *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "also"], ["proof (state)\nthis:\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n  inner_prod w (B *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<dots> = (\\<Sum>i=0..<n. (\\<Sum>j=0..<n.\n                conjugate (w$i) * B$$(i, j) * w$j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w (B *\\<^sub>v w) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j)", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (conjugate w).\n        (B *\\<^sub>v w) $ i * conjugate w $ i) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j)", "using dimw dimB"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (conjugate w).\n        (B *\\<^sub>v w) $ i * conjugate w $ i) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j)", "apply (simp add: scalar_prod_def sum_distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> carrier_vec n; B \\<in> carrier_mat n n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                          \\<Sum>n = 0..<n.\n                             B $$ (i, n) * w $ n * cnj (w $ i)) =\n                      (\\<Sum>i = 0..<n.\n                          \\<Sum>j = 0..<n.\n                             cnj (w $ i) * B $$ (i, j) * w $ j)", "apply (rule sum.cong, auto, rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod w (B *\\<^sub>v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "also"], ["proof (state)\nthis:\n  inner_prod w (B *\\<^sub>v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<dots> = (\\<Sum>i=0..<n. B$$(i, i) *  conjugate (w$i) * w$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j) =\n    (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < n \\<Longrightarrow>\n       (\\<Sum>j = 0..<n. cnj (w $ x) * B $$ (x, j) * w $ j) =\n       B $$ (x, x) * cnj (w $ x) * w $ x", "apply (simp add: sum.remove)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < n \\<Longrightarrow>\n       (\\<Sum>j\\<in>{0..<n} - {x}. cnj (w $ x) * B $$ (x, j) * w $ j) = 0", "apply (insert dB[unfolded diagonal_mat_def] dimB, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. conjugate (w $ i) * B $$ (i, j) * w $ j) =\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "finally"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)", "have sum: \"inner_prod v (A *\\<^sub>v v) = (\\<Sum>i=0..<n. B$$(i, i) *  conjugate (w$i) * w$i)\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)", "."], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) *  conjugate (w$i) * w$i \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       B $$ (i, i) * conjugate (w $ i) * w $ i \\<in> \\<real>", "using Bii"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       B $$ (i, i) * conjugate (w $ i) * w $ i \\<in> \\<real>", "by (simp add: Reals_cnj_iff)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  B $$ (?i, ?i) * conjugate (w $ ?i) * w $ ?i \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow>\n  B $$ (?i, ?i) * conjugate (w $ ?i) * w $ ?i \\<in> \\<real>", "have \"(\\<Sum>i=0..<n. B$$(i, i) *  conjugate (w$i) * w$i) \\<in> Reals\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  B $$ (?i, ?i) * conjugate (w $ ?i) * w $ ?i \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i) \\<in> \\<real>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i) \\<in> \\<real>\n  inner_prod v (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n. B $$ (i, i) * conjugate (w $ i) * w $ i)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<in> \\<real>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unit_vec_bracket:\n  fixes A :: \"complex mat\"\n  assumes dimA: \"A \\<in> carrier_mat n n\" and i: \"i < n\"\n  shows \"inner_prod (unit_vec n i) (A *\\<^sub>v (unit_vec n i)) = A$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "define w where \"(w::complex vec) = unit_vec n i\""], ["proof (state)\nthis:\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "have \"A *\\<^sub>v w = col A i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v w = col A i", "using i dimA w_def"], ["proof (prove)\nusing this:\n  i < n\n  A \\<in> carrier_mat n n\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v w = col A i", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v w = col A i\n\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  A *\\<^sub>v w = col A i", "have 1: \"inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v w = col A i\n\ngoal (1 subgoal):\n 1. inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)", "using w_def"], ["proof (prove)\nusing this:\n  A *\\<^sub>v w = col A i\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)", "by auto"], ["proof (state)\nthis:\n  inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)\n\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "have \"conjugate w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate w = w", "unfolding w_def unit_vec_def conjugate_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_vec (vec n (\\<lambda>j. if j = i then 1 else 0)))\n     (\\<lambda>ia.\n         conjugate (vec n (\\<lambda>j. if j = i then 1 else 0) $ ia)) =\n    vec n (\\<lambda>j. if j = i then 1 else 0)", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. vec (dim_vec (vec n (\\<lambda>j. if j = i then 1 else 0)))\n     (\\<lambda>ia.\n         conjugate (vec n (\\<lambda>j. if j = i then 1 else 0) $ ia)) =\n    vec n (\\<lambda>j. if j = i then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  conjugate w = w\n\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  conjugate w = w", "have 2: \"inner_prod w (col A i) = A$$(i, i)\""], ["proof (prove)\nusing this:\n  conjugate w = w\n\ngoal (1 subgoal):\n 1. inner_prod w (col A i) = A $$ (i, i)", "using i dimA w_def"], ["proof (prove)\nusing this:\n  conjugate w = w\n  i < n\n  A \\<in> carrier_mat n n\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. inner_prod w (col A i) = A $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod w (col A i) = A $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod (unit_vec n i) (A *\\<^sub>v unit_vec n i) = A $$ (i, i)", "from 1 2"], ["proof (chain)\npicking this:\n  inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)\n  inner_prod w (col A i) = A $$ (i, i)", "show \"inner_prod w (A *\\<^sub>v w) = A$$(i, i)\""], ["proof (prove)\nusing this:\n  inner_prod w (A *\\<^sub>v w) = inner_prod w (col A i)\n  inner_prod w (col A i) = A $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod w (A *\\<^sub>v w) = A $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod w (A *\\<^sub>v w) = A $$ (i, i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spectral_decomposition_extract_diag:\n  fixes P B :: \"complex mat\"\n  assumes dimP: \"P \\<in> carrier_mat n n\" and dimB: \"B \\<in> carrier_mat n n\"\n    and uP: \"unitary P\" and dB: \"diagonal_mat B\" and i: \"i < n\"\n  shows \"inner_prod (col P i) (P * B * (adjoint P) *\\<^sub>v (col P i)) = B$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have dimaP: \"adjoint P\\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P \\<in> carrier_mat n n", "using dimP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have uaP: \"unitary (adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (adjoint P)", "using unitary_adjoint uP dimP"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; unitary ?A\\<rbrakk>\n  \\<Longrightarrow> unitary (adjoint ?A)\n  unitary P\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. unitary (adjoint P)", "by auto"], ["proof (state)\nthis:\n  unitary (adjoint P)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  unitary (adjoint P)", "have \"inverts_mat (adjoint P) P\""], ["proof (prove)\nusing this:\n  unitary (adjoint P)\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint P) P", "by (simp add: unitary_def adjoint_adjoint)"], ["proof (state)\nthis:\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  inverts_mat (adjoint P) P", "have iv: \"(adjoint P) * P = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "using dimaP inverts_mat_def"], ["proof (prove)\nusing this:\n  inverts_mat (adjoint P) P\n  adjoint P \\<in> carrier_mat n n\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "define v where \"v = col P i\""], ["proof (state)\nthis:\n  v = col P i\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  v = col P i", "have dimv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v = col P i\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using dimP"], ["proof (prove)\nusing this:\n  v = col P i\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "define w where \"(w::complex vec) = unit_vec n i\""], ["proof (state)\nthis:\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  w = unit_vec n i", "have dimw: \"w \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  w = unit_vec n i\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have BaPv: \"B *\\<^sub>v (adjoint P *\\<^sub>v v) \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>v (adjoint P *\\<^sub>v v) \\<in> carrier_vec n", "using dimB dimaP dimv"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. B *\\<^sub>v (adjoint P *\\<^sub>v v) \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  B *\\<^sub>v (adjoint P *\\<^sub>v v) \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"(adjoint P) *\\<^sub>v v = (col (adjoint P * P) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint P *\\<^sub>v v = col (adjoint P * P) i", "by (simp add: col_mult2[OF dimaP dimP i, symmetric] v_def)"], ["proof (state)\nthis:\n  adjoint P *\\<^sub>v v = col (adjoint P * P) i\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  adjoint P *\\<^sub>v v = col (adjoint P * P) i", "have aPv: \"(adjoint P) *\\<^sub>v v = w\""], ["proof (prove)\nusing this:\n  adjoint P *\\<^sub>v v = col (adjoint P * P) i\n\ngoal (1 subgoal):\n 1. adjoint P *\\<^sub>v v = w", "by (auto simp add: iv i w_def)"], ["proof (state)\nthis:\n  adjoint P *\\<^sub>v v = w\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"inner_prod v (P * B * (adjoint P) *\\<^sub>v v) = inner_prod v ((P * B) *\\<^sub>v ((adjoint P) *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n    inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))", "using dimP dimB dimv"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n    inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))", "by (subst assoc_mult_mat_vec[of _ n n \"adjoint P\" n], auto)"], ["proof (state)\nthis:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "also"], ["proof (state)\nthis:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) =\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"\\<dots> = inner_prod v (P *\\<^sub>v (B *\\<^sub>v ((adjoint P) *\\<^sub>v v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))", "using dimP dimB dimv dimaP"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))", "by (subst assoc_mult_mat_vec[of _ n n \"B\" n], auto)"], ["proof (state)\nthis:\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "also"], ["proof (state)\nthis:\n  inner_prod v (P * B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"\\<dots> = inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n    inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v))", "by (simp add: adjoint_def_alter[OF dimv BaPv dimP])"], ["proof (state)\nthis:\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n  inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "also"], ["proof (state)\nthis:\n  inner_prod v (P *\\<^sub>v (B *\\<^sub>v (adjoint P *\\<^sub>v v))) =\n  inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"\\<dots> = inner_prod w (B *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (adjoint P *\\<^sub>v v)\n     (B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod w (B *\\<^sub>v w)", "using aPv"], ["proof (prove)\nusing this:\n  adjoint P *\\<^sub>v v = w\n\ngoal (1 subgoal):\n 1. inner_prod (adjoint P *\\<^sub>v v)\n     (B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n    inner_prod w (B *\\<^sub>v w)", "by auto"], ["proof (state)\nthis:\n  inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod w (B *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "also"], ["proof (state)\nthis:\n  inner_prod (adjoint P *\\<^sub>v v) (B *\\<^sub>v (adjoint P *\\<^sub>v v)) =\n  inner_prod w (B *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "have \"\\<dots> = B$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w (B *\\<^sub>v w) = B $$ (i, i)", "using w_def unit_vec_bracket dimB i"], ["proof (prove)\nusing this:\n  w = unit_vec n i\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> inner_prod (unit_vec ?n ?i)\n                     (?A *\\<^sub>v unit_vec ?n ?i) =\n                    ?A $$ (?i, ?i)\n  B \\<in> carrier_mat n n\n  i < n\n\ngoal (1 subgoal):\n 1. inner_prod w (B *\\<^sub>v w) = B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod w (B *\\<^sub>v w) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "finally"], ["proof (chain)\npicking this:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) = B $$ (i, i)", "show \"inner_prod v (P * B * (adjoint P) *\\<^sub>v v) = B$$(i, i)\""], ["proof (prove)\nusing this:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod v (P * B * adjoint P *\\<^sub>v v) = B $$ (i, i)", "."], ["proof (state)\nthis:\n  inner_prod v (P * B * adjoint P *\\<^sub>v v) = B $$ (i, i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hermitian_inner_prod_zero:\n  fixes A :: \"complex mat\"\n  assumes dimA: \"A \\<in> carrier_mat n n\" and hA: \"hermitian A\"\n    and zero: \"\\<forall>v\\<in>carrier_vec n. inner_prod v (A *\\<^sub>v v) = 0\"\n  shows \"A = 0\\<^sub>m n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "obtain es where es: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complex_mat_char_poly_factorizable dimA"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  \\<exists>as.\n     char_poly ?A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n     length as = ?n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "obtain B P Q where \"unitary_schur_decomposition A es = (B,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P Q.\n        unitary_schur_decomposition A es = (B, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  unitary_schur_decomposition A es = (B, P, Q)", "have \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\""], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "using hermitian_eigenvalue_real dimA es hA"], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P (adjoint ?P) \\<and>\n                    diagonal_mat ?B \\<and>\n                    diag_mat ?B = ?es \\<and>\n                    unitary ?P \\<and>\n                    (\\<forall>i<?n. ?B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  hermitian A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have A: \"A = P * B * (adjoint P)\" and dB: \"diagonal_mat B\"\n    and Bii: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<in> Reals\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimP: \"P \\<in> carrier_mat n n\" and dimaP: \"adjoint P \\<in> carrier_mat n n\"\n    and uP: \"unitary P\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&& unitary P", "unfolding similar_mat_wit_def Let_def unitary_def"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  (P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n   inverts_mat P (adjoint P)) \\<and>\n  (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n    inverts_mat P (adjoint P)", "using dimA"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  (P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n   inverts_mat P (adjoint P)) \\<and>\n  (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n    inverts_mat P (adjoint P)", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P", "have uaP: \"unitary (adjoint P)\""], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P\n\ngoal (1 subgoal):\n 1. unitary (adjoint P)", "using unitary_adjoint"], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; unitary ?A\\<rbrakk>\n  \\<Longrightarrow> unitary (adjoint ?A)\n\ngoal (1 subgoal):\n 1. unitary (adjoint P)", "by auto"], ["proof (state)\nthis:\n  unitary (adjoint P)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  unitary (adjoint P)", "have \"inverts_mat (adjoint P) P\""], ["proof (prove)\nusing this:\n  unitary (adjoint P)\n\ngoal (1 subgoal):\n 1. inverts_mat (adjoint P) P", "by (simp add: unitary_def adjoint_adjoint)"], ["proof (state)\nthis:\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  inverts_mat (adjoint P) P", "have iv: \"adjoint P * P = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  inverts_mat (adjoint P) P\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "using dimaP inverts_mat_def"], ["proof (prove)\nusing this:\n  inverts_mat (adjoint P) P\n  adjoint P \\<in> carrier_mat n n\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n\ngoal (1 subgoal):\n 1. adjoint P * P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint P * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "have \"B = 0\\<^sub>m n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "define v where \"v = col P i\""], ["proof (state)\nthis:\n  v = col P i\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  v = col P i", "have dimv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v = col P i\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using v_def dimP"], ["proof (prove)\nusing this:\n  v = col P i\n  v = col P i\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "have \"inner_prod v (A *\\<^sub>v v) = B$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = B $$ (i, i)", "unfolding A v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "using spectral_decomposition_extract_diag[OF dimP dimB uP dB i]"], ["proof (prove)\nusing this:\n  inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "moreover"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "have \"inner_prod v (A *\\<^sub>v v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = 0", "using dimv zero"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  \\<forall>v\\<in>carrier_vec n. inner_prod v (A *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = 0", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n  inner_prod v (A *\\<^sub>v v) = 0", "have \"B$$(i, i) = 0\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n  inner_prod v (A *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. B $$ (i, i) = 0", "by auto"], ["proof (state)\nthis:\n  B $$ (i, i) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "note zB = this"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "show \"B = 0\\<^sub>m n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "by (insert zB dB dimB, rule eq_matI, auto simp add: diagonal_mat_def)"], ["proof (state)\nthis:\n  B = 0\\<^sub>m n n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "then"], ["proof (chain)\npicking this:\n  B = 0\\<^sub>m n n", "show \"A = 0\\<^sub>m n n\""], ["proof (prove)\nusing this:\n  B = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "using A dimB dimP dimaP"], ["proof (prove)\nusing this:\n  B = 0\\<^sub>m n n\n  A = P * B * adjoint P\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "by auto"], ["proof (state)\nthis:\n  A = 0\\<^sub>m n n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_mat_decomposition_to_hermitian:\n  fixes A :: \"complex mat\"\n  assumes dim: \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists>B C. hermitian B \\<and> hermitian C \\<and> A = B + \\<i> \\<cdot>\\<^sub>m C \\<and> B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "obtain B C where B: \"B = (1 / 2) \\<cdot>\\<^sub>m (A + adjoint A)\" \n    and C: \"C = (-\\<i> / 2) \\<cdot>\\<^sub>m (A - adjoint A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        \\<lbrakk>B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A);\n         C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)\n  C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "then"], ["proof (chain)\npicking this:\n  B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)\n  C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)", "have dimB: \"B \\<in> carrier_mat n n\" and dimC: \"C \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)\n  C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n &&& C \\<in> carrier_mat n n", "using dim"], ["proof (prove)\nusing this:\n  B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)\n  C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n &&& C \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "have \"hermitian B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian B", "unfolding B hermitian_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)) =\n    1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)", "using dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint (1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)) =\n    1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)", "by (auto simp add: adjoint_eval)"], ["proof (state)\nthis:\n  hermitian B\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "moreover"], ["proof (state)\nthis:\n  hermitian B\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "have \"hermitian C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian C", "unfolding C hermitian_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (- \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)) =\n    - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)", "using dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint (- \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)) =\n    - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)", "apply (subst eq_matI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat n n; i < dim_row ?y1;\n        j < dim_col ?y1\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (- \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)) $$\n                         (i, j) =\n                         ?y1 $$ (i, j)\n 2. A \\<in> carrier_mat n n \\<Longrightarrow>\n    dim_row (adjoint (- \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A))) =\n    dim_row ?y1\n 3. A \\<in> carrier_mat n n \\<Longrightarrow>\n    dim_col (adjoint (- \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A))) =\n    dim_col ?y1\n 4. A \\<in> carrier_mat n n \\<Longrightarrow>\n    ?y1 = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)", "apply (auto simp add: adjoint_eval algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hermitian C\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "moreover"], ["proof (state)\nthis:\n  hermitian C\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "have \"A = B + \\<i> \\<cdot>\\<^sub>m C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B + \\<i> \\<cdot>\\<^sub>m C", "using dim B C"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A)\n  C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\n\ngoal (1 subgoal):\n 1. A = B + \\<i> \\<cdot>\\<^sub>m C", "apply (subst eq_matI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat n n;\n        B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A);\n        C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A); i < dim_row ?y3;\n        j < dim_col ?y3\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = ?y3 $$ (i, j)\n 2. \\<lbrakk>A \\<in> carrier_mat n n;\n     B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A);\n     C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\\<rbrakk>\n    \\<Longrightarrow> dim_row A = dim_row ?y3\n 3. \\<lbrakk>A \\<in> carrier_mat n n;\n     B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A);\n     C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\\<rbrakk>\n    \\<Longrightarrow> dim_col A = dim_col ?y3\n 4. \\<lbrakk>A \\<in> carrier_mat n n;\n     B = 1 / 2 \\<cdot>\\<^sub>m (A + adjoint A);\n     C = - \\<i> / 2 \\<cdot>\\<^sub>m (A - adjoint A)\\<rbrakk>\n    \\<Longrightarrow> ?y3 = B + \\<i> \\<cdot>\\<^sub>m C", "apply (auto simp add: adjoint_eval algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "ultimately"], ["proof (chain)\npicking this:\n  hermitian B\n  hermitian C\n  A = B + \\<i> \\<cdot>\\<^sub>m C", "show ?thesis"], ["proof (prove)\nusing this:\n  hermitian B\n  hermitian C\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "using dimB dimC"], ["proof (prove)\nusing this:\n  hermitian B\n  hermitian C\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>B C.\n       hermitian B \\<and>\n       hermitian C \\<and>\n       A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n       B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  \\<exists>B C.\n     hermitian B \\<and>\n     hermitian C \\<and>\n     A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n     B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Outer product\\<close>"], ["", "definition outer_prod :: \"'a::conjugatable_field vec \\<Rightarrow> 'a vec \\<Rightarrow> 'a mat\" where\n  \"outer_prod v w = mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) * mat 1 (dim_vec w) (\\<lambda>(i, j). (conjugate w) $ j)\""], ["", "lemma outer_prod_dim[simp]:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec m\"\n  shows \"outer_prod v w \\<in> carrier_mat n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v w \\<in> carrier_mat n m", "unfolding outer_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n    mat 1 (dim_vec w) (\\<lambda>(i, y). conjugate w $ y)\n    \\<in> carrier_mat n m", "using assms mat_of_cols_carrier mat_of_rows_carrier"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  mat_of_cols ?n ?vs \\<in> carrier_mat ?n (length ?vs)\n  dim_row (mat_of_cols ?n ?vs) = ?n\n  dim_col (mat_of_cols ?n ?vs) = length ?vs\n  mat_of_rows ?n ?vs \\<in> carrier_mat (length ?vs) ?n\n  dim_row (mat_of_rows ?n ?vs) = length ?vs\n  dim_col (mat_of_rows ?n ?vs) = ?n\n\ngoal (1 subgoal):\n 1. mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n    mat 1 (dim_vec w) (\\<lambda>(i, y). conjugate w $ y)\n    \\<in> carrier_mat n m", "by auto"], ["", "lemma mat_of_vec_mult_eq_scalar_prod:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes \"v \\<in> carrier_vec n\" and \"w \\<in> carrier_vec n\"\n  shows \"mat 1 (dim_vec v) (\\<lambda>(i, j). (conjugate v) $ j) * mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i) \n    = mat 1 1 (\\<lambda>k. inner_prod v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n    mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i) =\n    mat 1 1 (\\<lambda>k. inner_prod v w)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat 1 1 (\\<lambda>k. inner_prod v w));\n        j < dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))\\<rbrakk>\n       \\<Longrightarrow> (mat 1 (dim_vec v)\n                           (\\<lambda>(i, j). conjugate v $ j) *\n                          mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) $$\n                         (i, j) =\n                         mat 1 1 (\\<lambda>k. inner_prod v w) $$ (i, j)\n 2. dim_row\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_row (mat 1 1 (\\<lambda>k. inner_prod v w))\n 3. dim_col\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat 1 1 (\\<lambda>k. inner_prod v w));\n        j < dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))\\<rbrakk>\n       \\<Longrightarrow> (mat 1 (dim_vec v)\n                           (\\<lambda>(i, j). conjugate v $ j) *\n                          mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) $$\n                         (i, j) =\n                         mat 1 1 (\\<lambda>k. inner_prod v w) $$ (i, j)\n 2. dim_row\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_row (mat 1 1 (\\<lambda>k. inner_prod v w))\n 3. dim_col\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))", "apply (simp add: scalar_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i = 0; j = 0; v \\<in> carrier_vec n;\n        w \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i = 0..<n. conjugate (v $ i) * w $ i) =\n                         (\\<Sum>i = 0..<n. w $ i * conjugate (v $ i))\n 2. dim_row\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_row (mat 1 1 (\\<lambda>k. inner_prod v w))\n 3. dim_col\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i = 0; j = 0; v \\<in> carrier_vec n;\n        w \\<in> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> {0..<n} = {0..<n}\n 2. \\<And>i j x.\n       \\<lbrakk>i = 0; j = 0; v \\<in> carrier_vec n; w \\<in> carrier_vec n;\n        x \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> conjugate (v $ x) * w $ x =\n                         w $ x * conjugate (v $ x)\n 3. dim_row\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_row (mat 1 1 (\\<lambda>k. inner_prod v w))\n 4. dim_col\n     (mat 1 (dim_vec v) (\\<lambda>(i, j). conjugate v $ j) *\n      mat (dim_vec w) 1 (\\<lambda>(i, j). w $ i)) =\n    dim_col (mat 1 1 (\\<lambda>k. inner_prod v w))", "by auto"], ["", "lemma one_dim_mat_mult_is_scale:\n  fixes A B :: \"('a::conjugatable_field mat)\"\n  assumes \"B \\<in> carrier_mat 1 n\"\n  shows \"(mat 1 1 (\\<lambda>k. a)) * B = a \\<cdot>\\<^sub>m B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 1 (\\<lambda>k. a) * B = a \\<cdot>\\<^sub>m B", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (a \\<cdot>\\<^sub>m B);\n        j < dim_col (a \\<cdot>\\<^sub>m B)\\<rbrakk>\n       \\<Longrightarrow> (mat 1 1 (\\<lambda>k. a) * B) $$ (i, j) =\n                         (a \\<cdot>\\<^sub>m B) $$ (i, j)\n 2. dim_row (mat 1 1 (\\<lambda>k. a) * B) = dim_row (a \\<cdot>\\<^sub>m B)\n 3. dim_col (mat 1 1 (\\<lambda>k. a) * B) = dim_col (a \\<cdot>\\<^sub>m B)", "using assms"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat 1 n\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (a \\<cdot>\\<^sub>m B);\n        j < dim_col (a \\<cdot>\\<^sub>m B)\\<rbrakk>\n       \\<Longrightarrow> (mat 1 1 (\\<lambda>k. a) * B) $$ (i, j) =\n                         (a \\<cdot>\\<^sub>m B) $$ (i, j)\n 2. dim_row (mat 1 1 (\\<lambda>k. a) * B) = dim_row (a \\<cdot>\\<^sub>m B)\n 3. dim_col (mat 1 1 (\\<lambda>k. a) * B) = dim_col (a \\<cdot>\\<^sub>m B)", "by (auto simp add: scalar_prod_def)"], ["", "lemma outer_prod_mult_outer_prod:\n  fixes a b c d :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d1\" and b: \"b \\<in> carrier_vec d2\"\n    and c: \"c \\<in> carrier_vec d2\" and d: \"d \\<in> carrier_vec d3\"\n  shows \"outer_prod a b * outer_prod c d = inner_prod b c \\<cdot>\\<^sub>m outer_prod a d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "let ?ma = \"mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "let ?mb = \"mat 1 (dim_vec b) (\\<lambda>(i, j). (conjugate b) $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "let ?mc = \"mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "let ?md = \"mat 1 (dim_vec d) (\\<lambda>(i, j). (conjugate d) $ j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "have \"(?ma * ?mb) * (?mc * ?md) = ?ma * (?mb * (?mc * ?md))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n    (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)))", "apply (subst assoc_mult_mat[of \"?ma\" d1 1 \"?mb\" d2 \"?mc * ?md\" d3] )"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) \\<in> carrier_mat d1 1\n 2. mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat 1 d2\n 3. mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat d2 d3\n 4. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)))", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n  d \\<in> carrier_vec d3\n\ngoal (4 subgoals):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) \\<in> carrier_mat d1 1\n 2. mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat 1 d2\n 3. mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat d2 d3\n 4. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)))", "by auto"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n  (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "also"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n  (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "have \"\\<dots> = ?ma * ((?mb * ?mc) * ?md)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n     (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n      mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "apply (subst assoc_mult_mat[symmetric, of \"?mb\" 1 d2 \"?mc\" 1 \"?md\" d3])"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat 1 d2\n 2. mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) \\<in> carrier_mat d2 1\n 3. mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat 1 d3\n 4. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n  d \\<in> carrier_vec d3\n\ngoal (4 subgoals):\n 1. mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat 1 d2\n 2. mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) \\<in> carrier_mat d2 1\n 3. mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat 1 d3\n 4. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "by auto"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "also"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n    mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "have \"\\<dots> = ?ma * ((mat 1 1 (\\<lambda>k. inner_prod b c)) * ?md)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n     mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "apply (subst mat_of_vec_mult_eq_scalar_prod[of b d2 c])"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<in> carrier_vec d2\n 2. c \\<in> carrier_vec d2\n 3. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n  d \\<in> carrier_vec d3\n\ngoal (3 subgoals):\n 1. b \\<in> carrier_vec d2\n 2. c \\<in> carrier_vec d2\n 3. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "by auto"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 1 (\\<lambda>k. inner_prod b c) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "also"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n   mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 1 (\\<lambda>k. inner_prod b c) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "have \"\\<dots> = ?ma * (inner_prod b c \\<cdot>\\<^sub>m ?md)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (mat 1 1 (\\<lambda>k. inner_prod b c) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "apply (subst one_dim_mat_mult_is_scale)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat 1 ?n\n 2. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n  d \\<in> carrier_vec d3\n\ngoal (2 subgoals):\n 1. mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)\n    \\<in> carrier_mat 1 ?n\n 2. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "by auto"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 1 (\\<lambda>k. inner_prod b c) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (inner_prod b c \\<cdot>\\<^sub>m\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "also"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (mat 1 1 (\\<lambda>k. inner_prod b c) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (inner_prod b c \\<cdot>\\<^sub>m\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "have \"\\<dots> = (inner_prod b c) \\<cdot>\\<^sub>m (?ma * ?md)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n    inner_prod b c \\<cdot>\\<^sub>m\n    (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n  d \\<in> carrier_vec d3\n\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    (inner_prod b c \\<cdot>\\<^sub>m\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n    inner_prod b c \\<cdot>\\<^sub>m\n    (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "by auto"], ["proof (state)\nthis:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  (inner_prod b c \\<cdot>\\<^sub>m\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  inner_prod b c \\<cdot>\\<^sub>m\n  (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "finally"], ["proof (chain)\npicking this:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n  (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  inner_prod b c \\<cdot>\\<^sub>m\n  (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))", "show ?thesis"], ["proof (prove)\nusing this:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n  (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  inner_prod b c \\<cdot>\\<^sub>m\n  (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. outer_prod a b * outer_prod c d =\n    inner_prod b c \\<cdot>\\<^sub>m outer_prod a d", "unfolding outer_prod_def"], ["proof (prove)\nusing this:\n  mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 (dim_vec b) (\\<lambda>(i, j). conjugate b $ j) *\n  (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j)) =\n  inner_prod b c \\<cdot>\\<^sub>m\n  (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n   mat 1 (dim_vec d) (\\<lambda>(i, j). conjugate d $ j))\n\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\n    (mat (dim_vec c) 1 (\\<lambda>(i, j). c $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y)) =\n    inner_prod b c \\<cdot>\\<^sub>m\n    (mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n     mat 1 (dim_vec d) (\\<lambda>(i, y). conjugate d $ y))", "by auto"], ["proof (state)\nthis:\n  outer_prod a b * outer_prod c d =\n  inner_prod b c \\<cdot>\\<^sub>m outer_prod a d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_outer_prod:\n  fixes v w :: \"'a::conjugatable_field vec\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec m\"\n    and ij: \"i < n\" \"j < m\"\n  shows \"(outer_prod v w)$$(i, j) = v $ i * conjugate (w $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v w $$ (i, j) = v $ i * conjugate (w $ j)", "unfolding outer_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n     mat 1 (dim_vec w) (\\<lambda>(i, y). conjugate w $ y)) $$\n    (i, j) =\n    v $ i * conjugate (w $ j)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec m\n  i < n\n  j < m\n\ngoal (1 subgoal):\n 1. (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n     mat 1 (dim_vec w) (\\<lambda>(i, y). conjugate w $ y)) $$\n    (i, j) =\n    v $ i * conjugate (w $ j)", "by (simp add: scalar_prod_def)"], ["", "lemma mat_of_vec_mult_vec:\n  fixes a b c :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d\" and b: \"b \\<in> carrier_vec d\"\n  shows \"mat 1 d (\\<lambda>(i, j). (conjugate a) $ j) *\\<^sub>v b = vec 1 (\\<lambda>k. inner_prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 d (\\<lambda>(i, j). conjugate a $ j) *\\<^sub>v b =\n    vec 1 (\\<lambda>k. inner_prod a b)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (vec 1 (\\<lambda>k. inner_prod a b)) \\<Longrightarrow>\n       (mat 1 d (\\<lambda>(i, j). conjugate a $ j) *\\<^sub>v b) $ i =\n       vec 1 (\\<lambda>k. inner_prod a b) $ i\n 2. dim_vec (mat 1 d (\\<lambda>(i, j). conjugate a $ j) *\\<^sub>v b) =\n    dim_vec (vec 1 (\\<lambda>k. inner_prod a b))", "apply (simp add: scalar_prod_def carrier_vecD[OF a] carrier_vecD[OF b])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<d. conjugate (a $ i) * b $ i) =\n    (\\<Sum>i = 0..<d. b $ i * conjugate (a $ i))\n 2. dim_vec (mat 1 d (\\<lambda>(i, j). conjugate a $ j) *\\<^sub>v b) =\n    dim_vec (vec 1 (\\<lambda>k. inner_prod a b))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {0..<d} = {0..<d}\n 2. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       conjugate (a $ x) * b $ x = b $ x * conjugate (a $ x)\n 3. dim_vec (mat 1 d (\\<lambda>(i, j). conjugate a $ j) *\\<^sub>v b) =\n    dim_vec (vec 1 (\\<lambda>k. inner_prod a b))", "by auto"], ["", "lemma mat_of_vec_mult_one_dim_vec:\n  fixes a b :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d\" \n  shows \"mat d 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v vec 1 (\\<lambda>k. c) = c \\<cdot>\\<^sub>v a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat d 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v vec 1 (\\<lambda>k. c) =\n    c \\<cdot>\\<^sub>v a", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (c \\<cdot>\\<^sub>v a) \\<Longrightarrow>\n       (mat d 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v vec 1 (\\<lambda>k. c)) $\n       i =\n       (c \\<cdot>\\<^sub>v a) $ i\n 2. dim_vec\n     (mat d 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v vec 1 (\\<lambda>k. c)) =\n    dim_vec (c \\<cdot>\\<^sub>v a)", "by (auto simp add: scalar_prod_def carrier_vecD[OF a])"], ["", "lemma outer_prod_mult_vec:\n  fixes a b c :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec d1\" and b: \"b \\<in> carrier_vec d2\"\n    and c: \"c \\<in> carrier_vec d2\"\n  shows \"outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "have \"outer_prod a b *\\<^sub>v c \n    = mat d1 1 (\\<lambda>(i, j). a $ i) \n    * mat 1 d2 (\\<lambda>(i, j). (conjugate b) $ j)\n    *\\<^sub>v c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n    c", "unfolding outer_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v\n    c =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n    c", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n\ngoal (1 subgoal):\n 1. mat (dim_vec a) 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 (dim_vec b) (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v\n    c =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n    c", "by auto"], ["proof (state)\nthis:\n  outer_prod a b *\\<^sub>v c =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n  c\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "also"], ["proof (state)\nthis:\n  outer_prod a b *\\<^sub>v c =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n  c\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "have \"\\<dots> = mat d1 1 (\\<lambda>(i, j). a $ i) \n    *\\<^sub>v (mat 1 d2 (\\<lambda>(i, j). (conjugate b) $ j)\n    *\\<^sub>v c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i) *\n    mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n    c =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c)", "apply (subst assoc_mult_mat_vec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i)\n    \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2\n 2. mat 1 d2 (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3\n 3. c \\<in> carrier_vec ?n\\<^sub>3\n 4. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v c) =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v c)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n\ngoal (4 subgoals):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i)\n    \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2\n 2. mat 1 d2 (\\<lambda>(i, y). conjugate b $ y)\n    \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3\n 3. c \\<in> carrier_vec ?n\\<^sub>3\n 4. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v c) =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, y). conjugate b $ y) *\\<^sub>v c)", "by auto"], ["proof (state)\nthis:\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n  c =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "also"], ["proof (state)\nthis:\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\n  mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n  c =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c)\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "have \"\\<dots> = mat d1 1 (\\<lambda>(i, j). a $ i) \n    *\\<^sub>v vec 1 (\\<lambda>k. inner_prod b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c) =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    vec 1 (\\<lambda>k. inner_prod b c)", "using mat_of_vec_mult_vec[of b] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<in> carrier_vec ?d; ?b \\<in> carrier_vec ?d\\<rbrakk>\n  \\<Longrightarrow> mat 1 ?d (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v\n                    ?b =\n                    vec 1 (\\<lambda>k. inner_prod b ?b)\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n\ngoal (1 subgoal):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c) =\n    mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    vec 1 (\\<lambda>k. inner_prod b c)", "by auto"], ["proof (state)\nthis:\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c) =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  vec 1 (\\<lambda>k. inner_prod b c)\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "also"], ["proof (state)\nthis:\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  (mat 1 d2 (\\<lambda>(i, j). conjugate b $ j) *\\<^sub>v c) =\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  vec 1 (\\<lambda>k. inner_prod b c)\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "have \"\\<dots> = inner_prod b c \\<cdot>\\<^sub>v a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    vec 1 (\\<lambda>k. inner_prod b c) =\n    inner_prod b c \\<cdot>\\<^sub>v a", "using mat_of_vec_mult_one_dim_vec assms"], ["proof (prove)\nusing this:\n  ?a \\<in> carrier_vec ?d \\<Longrightarrow>\n  mat ?d 1 (\\<lambda>(i, j). ?a $ i) *\\<^sub>v vec 1 (\\<lambda>k. ?c) =\n  ?c \\<cdot>\\<^sub>v ?a\n  a \\<in> carrier_vec d1\n  b \\<in> carrier_vec d2\n  c \\<in> carrier_vec d2\n\ngoal (1 subgoal):\n 1. mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n    vec 1 (\\<lambda>k. inner_prod b c) =\n    inner_prod b c \\<cdot>\\<^sub>v a", "by auto"], ["proof (state)\nthis:\n  mat d1 1 (\\<lambda>(i, j). a $ i) *\\<^sub>v\n  vec 1 (\\<lambda>k. inner_prod b c) =\n  inner_prod b c \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "finally"], ["proof (chain)\npicking this:\n  outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "show ?thesis"], ["proof (prove)\nusing this:\n  outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a\n\ngoal (1 subgoal):\n 1. outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a", "by auto"], ["proof (state)\nthis:\n  outer_prod a b *\\<^sub>v c = inner_prod b c \\<cdot>\\<^sub>v a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_outer_prod_right:\n  fixes A :: \"'a::conjugatable_field mat\" and v w :: \"'a vec\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\"\n  shows \"trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "define B where \"B = outer_prod v w\""], ["proof (state)\nthis:\n  B = outer_prod v w\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  B = outer_prod v w", "have B: \"B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  B = outer_prod v w\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  B = outer_prod v w\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "have \"trace(A * B) = (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i,j) * B $$ (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A * B) =\n    (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A * B). (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (A * B). (A * B) $$ (i, i)) =\n    (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))", "by (simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  trace (A * B) =\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  trace (A * B) =\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "have \"\\<dots> = (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i,j) * v $ j * conjugate (w $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * outer_prod v w $$ (j, i)) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "apply (rule sum.cong, simp, rule sum.cong, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {0..<n}; xa \\<in> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> A $$ (x, xa) * outer_prod v w $$ (xa, x) =\n                         A $$ (x, xa) * v $ xa * conjugate (w $ x)", "by (insert v w, auto simp add: index_outer_prod)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i, j) * B $$ (j, i)) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  trace (A * B) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "have \"?lhs = (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i,j) * v $ j * conjugate (w $ i))\""], ["proof (prove)\nusing this:\n  trace (A * B) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "using B_def"], ["proof (prove)\nusing this:\n  trace (A * B) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n  B = outer_prod v w\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "by auto"], ["proof (state)\nthis:\n  trace (A * outer_prod v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "moreover"], ["proof (state)\nthis:\n  trace (A * outer_prod v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "have \"?rhs = (\\<Sum>i = 0..<n. \\<Sum>j = 0..<n. A $$ (i,j) * v $ j * conjugate (w $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w (A *\\<^sub>v v) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "using A v w"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w (A *\\<^sub>v v) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "by (simp add: scalar_prod_def sum_distrib_right)"], ["proof (state)\nthis:\n  inner_prod w (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "ultimately"], ["proof (chain)\npicking this:\n  trace (A * outer_prod v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n  inner_prod w (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (A * outer_prod v w) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n  inner_prod w (A *\\<^sub>v v) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<n. A $$ (i, j) * v $ j * conjugate (w $ i))\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  trace (A * outer_prod v w) = inner_prod w (A *\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_outer_prod:\n  fixes v w :: \"('a::conjugatable_field vec)\"\n  assumes v: \"v \\<in> carrier_vec n\" and w: \"w \\<in> carrier_vec n\"\n  shows \"trace (outer_prod v w) = inner_prod w v\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "have \"(1\\<^sub>m n) * (outer_prod v w) = outer_prod v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * outer_prod v w = outer_prod v w", "apply (subst left_mult_one_mat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. outer_prod v w \\<in> carrier_mat n ?nc\n 2. outer_prod v w = outer_prod v w", "using outer_prod_dim assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> outer_prod ?v ?w \\<in> carrier_mat ?n ?m\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (2 subgoals):\n 1. outer_prod v w \\<in> carrier_mat n ?nc\n 2. outer_prod v w = outer_prod v w", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * outer_prod v w = outer_prod v w\n\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "moreover"], ["proof (state)\nthis:\n  1\\<^sub>m n * outer_prod v w = outer_prod v w\n\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "have \"1\\<^sub>m n *\\<^sub>v v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n *\\<^sub>v v = v", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n *\\<^sub>v v = v", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "ultimately"], ["proof (chain)\npicking this:\n  1\\<^sub>m n * outer_prod v w = outer_prod v w\n  1\\<^sub>m n *\\<^sub>v v = v", "show ?thesis"], ["proof (prove)\nusing this:\n  1\\<^sub>m n * outer_prod v w = outer_prod v w\n  1\\<^sub>m n *\\<^sub>v v = v\n\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "using trace_outer_prod_right[of \"1\\<^sub>m n\" n v w] assms"], ["proof (prove)\nusing this:\n  1\\<^sub>m n * outer_prod v w = outer_prod v w\n  1\\<^sub>m n *\\<^sub>v v = v\n  \\<lbrakk>1\\<^sub>m n \\<in> carrier_mat n n; v \\<in> carrier_vec n;\n   w \\<in> carrier_vec n\\<rbrakk>\n  \\<Longrightarrow> trace (1\\<^sub>m n * outer_prod v w) =\n                    inner_prod w (1\\<^sub>m n *\\<^sub>v v)\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. trace (outer_prod v w) = inner_prod w v", "by auto"], ["proof (state)\nthis:\n  trace (outer_prod v w) = inner_prod w v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inner_prod_outer_prod:\n  fixes a b c d :: \"'a::conjugatable_field vec\"\n  assumes a: \"a \\<in> carrier_vec n\" and b: \"b \\<in> carrier_vec n\"\n    and c: \"c \\<in> carrier_vec m\" and d: \"d \\<in> carrier_vec m\"\n  shows \"inner_prod a (outer_prod b c *\\<^sub>v d) = inner_prod a b * inner_prod c d\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "define P where \"P = outer_prod b c\""], ["proof (state)\nthis:\n  P = outer_prod b c\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "then"], ["proof (chain)\npicking this:\n  P = outer_prod b c", "have dimP: \"P \\<in> carrier_mat n m\""], ["proof (prove)\nusing this:\n  P = outer_prod b c\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n m", "using assms"], ["proof (prove)\nusing this:\n  P = outer_prod b c\n  a \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  c \\<in> carrier_vec m\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n m", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "have \"inner_prod a (P *\\<^sub>v d) = (\\<Sum>i=0..<n. (\\<Sum>j=0..<m. conjugate (a$i) * P$$(i, j) * d$j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod a (P *\\<^sub>v d) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j)", "using assms dimP"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  c \\<in> carrier_vec m\n  d \\<in> carrier_vec m\n  P \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. inner_prod a (P *\\<^sub>v d) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j)", "apply (simp add: scalar_prod_def sum_distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> carrier_vec n; b \\<in> carrier_vec n;\n     c \\<in> carrier_vec m; d \\<in> carrier_vec m;\n     P \\<in> carrier_mat n m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                          \\<Sum>n = 0..<m.\n                             P $$ (i, n) * d $ n * conjugate (a $ i)) =\n                      (\\<Sum>i = 0..<n.\n                          \\<Sum>j = 0..<m.\n                             conjugate (a $ i) * P $$ (i, j) * d $ j)", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<in> carrier_vec n; b \\<in> carrier_vec n;\n        c \\<in> carrier_vec m; d \\<in> carrier_vec m;\n        P \\<in> carrier_mat n m; x < n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n = 0..<m.\n                             P $$ (x, n) * d $ n * conjugate (a $ x)) =\n                         (\\<Sum>j = 0..<m.\n                             conjugate (a $ x) * P $$ (x, j) * d $ j)", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod a (P *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "also"], ["proof (state)\nthis:\n  inner_prod a (P *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "have \"\\<dots> = (\\<Sum>i=0..<n. (\\<Sum>j=0..<m. conjugate (a$i) * b$i * conjugate(c$j) * d$j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "using P_def b c"], ["proof (prove)\nusing this:\n  P = outer_prod b c\n  b \\<in> carrier_vec n\n  c \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "by(simp add: index_outer_prod algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m. conjugate (a $ i) * P $$ (i, j) * d $ j) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "finally"], ["proof (chain)\npicking this:\n  inner_prod a (P *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "have eq: \"?lhs = (\\<Sum>i=0..<n. (\\<Sum>j=0..<m. conjugate (a$i) * b$i * conjugate(c$j) * d$j))\""], ["proof (prove)\nusing this:\n  inner_prod a (P *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "using P_def"], ["proof (prove)\nusing this:\n  inner_prod a (P *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n  P = outer_prod b c\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "by auto"], ["proof (state)\nthis:\n  inner_prod a (outer_prod b c *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "have \"?rhs = (\\<Sum>i=0..<n. conjugate (a$i) * b$i) * (\\<Sum>j=0..<m. conjugate(c$j) * d$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod a b * inner_prod c d =\n    (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n    (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  c \\<in> carrier_vec m\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. inner_prod a b * inner_prod c d =\n    (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n    (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j)", "by (auto simp add: scalar_prod_def algebra_simps)"], ["proof (state)\nthis:\n  inner_prod a b * inner_prod c d =\n  (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n  (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "also"], ["proof (state)\nthis:\n  inner_prod a b * inner_prod c d =\n  (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n  (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "have \"\\<dots> = (\\<Sum>i=0..<n. (\\<Sum>j=0..<m. conjugate (a$i) * b$i * conjugate(c$j) * d$j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n    (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier_vec n\n  b \\<in> carrier_vec n\n  c \\<in> carrier_vec m\n  d \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n    (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j) =\n    (\\<Sum>i = 0..<n.\n        \\<Sum>j = 0..<m.\n           conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "by (simp add: sum_product algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. conjugate (a $ i) * b $ i) *\n  (\\<Sum>j = 0..<m. conjugate (c $ j) * d $ j) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "finally"], ["proof (chain)\npicking this:\n  inner_prod a b * inner_prod c d =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)", "show \"?lhs = ?rhs\""], ["proof (prove)\nusing this:\n  inner_prod a b * inner_prod c d =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "using eq"], ["proof (prove)\nusing this:\n  inner_prod a b * inner_prod c d =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n  inner_prod a (outer_prod b c *\\<^sub>v d) =\n  (\\<Sum>i = 0..<n.\n      \\<Sum>j = 0..<m.\n         conjugate (a $ i) * b $ i * conjugate (c $ j) * d $ j)\n\ngoal (1 subgoal):\n 1. inner_prod a (outer_prod b c *\\<^sub>v d) =\n    inner_prod a b * inner_prod c d", "by auto"], ["proof (state)\nthis:\n  inner_prod a (outer_prod b c *\\<^sub>v d) =\n  inner_prod a b * inner_prod c d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Semi-definite matrices\\<close>"], ["", "definition positive :: \"complex mat \\<Rightarrow> bool\" where\n  \"positive A \\<longleftrightarrow>\n     A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n     (\\<forall>v. dim_vec v = dim_col A \\<longrightarrow> inner_prod v (A *\\<^sub>v v) \\<ge> 0)\""], ["", "lemma positive_iff_normalized_vec:\n  \"positive A \\<longleftrightarrow>\n    A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v. (dim_vec v = dim_col A \\<and> vec_norm v = 1) \\<longrightarrow> inner_prod v (A *\\<^sub>v v) \\<ge> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A =\n    (A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n     (\\<forall>v.\n         dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n         0 \\<le> inner_prod v (A *\\<^sub>v v)))", "proof (rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. positive A \\<Longrightarrow>\n    A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v))\n 2. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "assume \"positive A\""], ["proof (state)\nthis:\n  positive A\n\ngoal (2 subgoals):\n 1. positive A \\<Longrightarrow>\n    A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v))\n 2. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  positive A", "show \"A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and> \n    (\\<forall>v. dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v))\""], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v))", "unfolding positive_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v))", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "define n where \"n = dim_col A\""], ["proof (state)\nthis:\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "assume \"A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and> (\\<forall>v. dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v))\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))", "have A: \"A \\<in> carrier_mat (dim_col A) (dim_col A)\" and geq0: \"\\<forall>v. dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) &&&\n    \\<forall>v.\n       dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n       0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_col A) (dim_col A)\n  \\<forall>v.\n     dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A)\n  \\<forall>v.\n     dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)", "have dimA: \"A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A)\n  \\<forall>v.\n     dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "using n_def[symmetric]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A)\n  \\<forall>v.\n     dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "{"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "assume dimv: \"(v::complex vec) \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "have \"0 \\<le> inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "proof (cases \"v = 0\\<^sub>v n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v n \\<Longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v)\n 2. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "case True"], ["proof (state)\nthis:\n  v = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. v = 0\\<^sub>v n \\<Longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v)\n 2. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  v = 0\\<^sub>v n", "show \"0 \\<le> inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "using dimA"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "case False"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> 0\\<^sub>v n", "have 1: \"vec_norm v > 0\""], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "using vec_norm_ge_0 dimv"], ["proof (prove)\nusing this:\n  v \\<noteq> 0\\<^sub>v n\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?v \\<noteq> 0\\<^sub>v ?n\\<rbrakk>\n  \\<Longrightarrow> 0 < vec_norm ?v\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 < vec_norm v", "by auto"], ["proof (state)\nthis:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  0 < vec_norm v", "have cnv: \"cnj (vec_norm v) = vec_norm v\""], ["proof (prove)\nusing this:\n  0 < vec_norm v\n\ngoal (1 subgoal):\n 1. cnj (vec_norm v) = vec_norm v", "using Reals_cnj_iff complex_is_Real_iff"], ["proof (prove)\nusing this:\n  0 < vec_norm v\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. cnj (vec_norm v) = vec_norm v", "by auto"], ["proof (state)\nthis:\n  cnj (vec_norm v) = vec_norm v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "define w where \"w = vec_normalize v\""], ["proof (state)\nthis:\n  w = vec_normalize v\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  w = vec_normalize v", "have dimw: \"w \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  w = vec_normalize v\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "using dimv"], ["proof (prove)\nusing this:\n  w = vec_normalize v\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "have nvw: \"v = vec_norm v \\<cdot>\\<^sub>v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v w", "using w_def vec_eq_norm_smult_normalized"], ["proof (prove)\nusing this:\n  w = vec_normalize v\n  ?v = vec_norm ?v \\<cdot>\\<^sub>v vec_normalize ?v\n\ngoal (1 subgoal):\n 1. v = vec_norm v \\<cdot>\\<^sub>v w", "by auto"], ["proof (state)\nthis:\n  v = vec_norm v \\<cdot>\\<^sub>v w\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "have \"vec_norm w = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm w = 1", "using normalized_vec_norm[OF dimv False] vec_norm_def w_def"], ["proof (prove)\nusing this:\n  inner_prod (vec_normalize v) (vec_normalize v) = 1\n  vec_norm ?v \\<equiv> csqrt (inner_prod ?v ?v)\n  w = vec_normalize v\n\ngoal (1 subgoal):\n 1. vec_norm w = 1", "by auto"], ["proof (state)\nthis:\n  vec_norm w = 1\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  vec_norm w = 1", "have 2: \"0 \\<le> inner_prod w (A *\\<^sub>v w)\""], ["proof (prove)\nusing this:\n  vec_norm w = 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod w (A *\\<^sub>v w)", "using geq0 dimw dimA"], ["proof (prove)\nusing this:\n  vec_norm w = 1\n  \\<forall>v.\n     dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)\n  w \\<in> carrier_vec n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod w (A *\\<^sub>v w)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod w (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "have \"inner_prod v (A *\\<^sub>v v) = vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "using dimA dimv dimw"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "apply (subst (1 2) nvw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; v \\<in> carrier_vec n;\n     w \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> inner_prod (vec_norm v \\<cdot>\\<^sub>v w)\n                       (A *\\<^sub>v (vec_norm v \\<cdot>\\<^sub>v w)) =\n                      vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "apply (subst mult_mat_vec, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; v \\<in> carrier_vec n;\n     w \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> inner_prod (vec_norm v \\<cdot>\\<^sub>v w)\n                       (vec_norm v \\<cdot>\\<^sub>v (A *\\<^sub>v w)) =\n                      vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "apply (subst scalar_prod_smult_left[of \"(A *\\<^sub>v w)\" \"conjugate (vec_norm v \\<cdot>\\<^sub>v w)\" \"vec_norm v\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; v \\<in> carrier_vec n;\n     w \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> vec_norm v *\n                      inner_prod (vec_norm v \\<cdot>\\<^sub>v w)\n                       (A *\\<^sub>v w) =\n                      vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "apply (simp add: conjugate_smult_vec cnv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "using 1 2"], ["proof (prove)\nusing this:\n  0 < vec_norm v\n  0 \\<le> inner_prod w (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. 0 \\<le> vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> vec_norm v * vec_norm v * inner_prod w (A *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n \\<Longrightarrow>\n    0 \\<le> inner_prod v (A *\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)", "show \"0 \\<le> inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)", "have geq: \"\\<forall>v. dim_vec v = dim_col A \\<longrightarrow> 0 \\<le> inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col A \\<longrightarrow>\n       0 \\<le> inner_prod v (A *\\<^sub>v v)", "using dimA"], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col A \\<longrightarrow>\n       0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     dim_vec v = dim_col A \\<longrightarrow>\n     0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<and> vec_norm v = 1 \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)) \\<Longrightarrow>\n    positive A", "show \"positive A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A", "unfolding positive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col A \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v))", "by (rule, simp add: A, rule geq)"], ["proof (state)\nthis:\n  positive A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_is_hermitian:\n  fixes A :: \"complex mat\"\n  assumes pA: \"positive A\"\n  shows \"hermitian A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian A", "define n where \"n = dim_col A\""], ["proof (state)\nthis:\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. hermitian A", "then"], ["proof (chain)\npicking this:\n  n = dim_col A", "have dimA: \"A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "using positive_def pA"], ["proof (prove)\nusing this:\n  n = dim_col A\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n  positive A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. hermitian A", "obtain B C where B: \"hermitian B\" and C: \"hermitian C\" and A: \"A = B + \\<i> \\<cdot>\\<^sub>m C\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimC: \"C \\<in> carrier_mat n n\" and dimiC: \"\\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        \\<lbrakk>hermitian B; hermitian C; A = B + \\<i> \\<cdot>\\<^sub>m C;\n         B \\<in> carrier_mat n n; C \\<in> carrier_mat n n;\n         \\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using complex_mat_decomposition_to_hermitian[OF dimA]"], ["proof (prove)\nusing this:\n  \\<exists>B C.\n     hermitian B \\<and>\n     hermitian C \\<and>\n     A = B + \\<i> \\<cdot>\\<^sub>m C \\<and>\n     B \\<in> carrier_mat n n \\<and> C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        \\<lbrakk>hermitian B; hermitian C; A = B + \\<i> \\<cdot>\\<^sub>m C;\n         B \\<in> carrier_mat n n; C \\<in> carrier_mat n n;\n         \\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hermitian B\n  hermitian C\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  \\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. hermitian A", "{"], ["proof (state)\nthis:\n  hermitian B\n  hermitian C\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  \\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. hermitian A", "fix v :: \"complex vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian A", "assume dimv: \"v \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. hermitian A", "have dimvA: \"dim_vec v = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = dim_col A", "using dimv dimA"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_vec v = dim_col A", "by auto"], ["proof (state)\nthis:\n  dim_vec v = dim_col A\n\ngoal (1 subgoal):\n 1. hermitian A", "have \"inner_prod v (A *\\<^sub>v v) = inner_prod v (B *\\<^sub>v v) + inner_prod v ((\\<i> \\<cdot>\\<^sub>m C) *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) +\n    inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v ((B + \\<i> \\<cdot>\\<^sub>m C) *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) +\n    inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)", "using dimB dimiC dimv"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  \\<i> \\<cdot>\\<^sub>m C \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v ((B + \\<i> \\<cdot>\\<^sub>m C) *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) +\n    inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)", "by (simp add: add_mult_distrib_mat_vec inner_prod_distrib_right)"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) +\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. hermitian A", "moreover"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) +\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. hermitian A", "have \"inner_prod v ((\\<i> \\<cdot>\\<^sub>m C) *\\<^sub>v v) = \\<i> * inner_prod v (C *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) =\n    \\<i> * inner_prod v (C *\\<^sub>v v)", "using dimv dimC"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) =\n    \\<i> * inner_prod v (C *\\<^sub>v v)", "apply (simp add: scalar_prod_def sum_distrib_left cong: sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> carrier_vec n; C \\<in> carrier_mat n n\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x = 0..<n.\n                          (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) $ x *\n                          conjugate v $ x) =\n                      (\\<Sum>x = 0..<n.\n                          \\<i> * ((C *\\<^sub>v v) $ x * conjugate v $ x))", "apply (rule sum.cong, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) =\n  \\<i> * inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. hermitian A", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) +\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) =\n  \\<i> * inner_prod v (C *\\<^sub>v v)", "have ABC: \"inner_prod v (A *\\<^sub>v v) = inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) +\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v)\n  inner_prod v (\\<i> \\<cdot>\\<^sub>m C *\\<^sub>v v) =\n  \\<i> * inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. hermitian A", "moreover"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. hermitian A", "have \"inner_prod v (B *\\<^sub>v v) \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (B *\\<^sub>v v) \\<in> \\<real>", "using B dimB dimv hermitian_inner_prod_real"], ["proof (prove)\nusing this:\n  hermitian B\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?v \\<in> carrier_vec ?n;\n   hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?v (?A *\\<^sub>v ?v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (B *\\<^sub>v v) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  inner_prod v (B *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. hermitian A", "moreover"], ["proof (state)\nthis:\n  inner_prod v (B *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. hermitian A", "have \"inner_prod v (C *\\<^sub>v v) \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (C *\\<^sub>v v) \\<in> \\<real>", "using C dimC dimv hermitian_inner_prod_real"], ["proof (prove)\nusing this:\n  hermitian C\n  C \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?v \\<in> carrier_vec ?n;\n   hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?v (?A *\\<^sub>v ?v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (C *\\<^sub>v v) \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  inner_prod v (C *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. hermitian A", "moreover"], ["proof (state)\nthis:\n  inner_prod v (C *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. hermitian A", "have \"inner_prod v (A *\\<^sub>v v) \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "using pA"], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "unfolding positive_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat (dim_col A) (dim_col A);\n     \\<forall>v.\n        dim_vec v = dim_col A \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "apply (fold n_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n;\n     \\<forall>v.\n        dim_vec v = n \\<longrightarrow>\n        0 \\<le> inner_prod v (A *\\<^sub>v v)\\<rbrakk>\n    \\<Longrightarrow> inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "apply (simp add: complex_is_Real_iff[of \"inner_prod v (A *\\<^sub>v v)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n;\n     \\<forall>v.\n        dim_vec v = n \\<longrightarrow>\n        Im (inner_prod v (A *\\<^sub>v v)) = 0 \\<and>\n        0 \\<le> Re (inner_prod v (A *\\<^sub>v v))\\<rbrakk>\n    \\<Longrightarrow> Im (inner_prod v (A *\\<^sub>v v)) = 0", "apply (auto simp add: dimvA)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. hermitian A", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\n  inner_prod v (B *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (C *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (A *\\<^sub>v v) \\<in> \\<real>", "have \"inner_prod v (C *\\<^sub>v v) = 0\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\n  inner_prod v (B *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (C *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (A *\\<^sub>v v) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. inner_prod v (C *\\<^sub>v v) = 0", "using of_real_Re"], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) + \\<i> * inner_prod v (C *\\<^sub>v v)\n  inner_prod v (B *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (C *\\<^sub>v v) \\<in> \\<real>\n  inner_prod v (A *\\<^sub>v v) \\<in> \\<real>\n  ?z \\<in> \\<real> \\<Longrightarrow> complex_of_real (Re ?z) = ?z\n\ngoal (1 subgoal):\n 1. inner_prod v (C *\\<^sub>v v) = 0", "by fastforce"], ["proof (state)\nthis:\n  inner_prod v (C *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. hermitian A", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  inner_prod ?v2 (C *\\<^sub>v ?v2) = 0\n\ngoal (1 subgoal):\n 1. hermitian A", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  inner_prod ?v2 (C *\\<^sub>v ?v2) = 0", "have \"C = 0\\<^sub>m n n\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  inner_prod ?v2 (C *\\<^sub>v ?v2) = 0\n\ngoal (1 subgoal):\n 1. C = 0\\<^sub>m n n", "using hermitian_inner_prod_zero dimC C"], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  inner_prod ?v2 (C *\\<^sub>v ?v2) = 0\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   \\<forall>v\\<in>carrier_vec ?n. inner_prod v (?A *\\<^sub>v v) = 0\\<rbrakk>\n  \\<Longrightarrow> ?A = 0\\<^sub>m ?n ?n\n  C \\<in> carrier_mat n n\n  hermitian C\n\ngoal (1 subgoal):\n 1. C = 0\\<^sub>m n n", "by auto"], ["proof (state)\nthis:\n  C = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. hermitian A", "then"], ["proof (chain)\npicking this:\n  C = 0\\<^sub>m n n", "have \"A = B\""], ["proof (prove)\nusing this:\n  C = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = B", "using A dimC dimB"], ["proof (prove)\nusing this:\n  C = 0\\<^sub>m n n\n  A = B + \\<i> \\<cdot>\\<^sub>m C\n  C \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal (1 subgoal):\n 1. hermitian A", "then"], ["proof (chain)\npicking this:\n  A = B", "show \"hermitian A\""], ["proof (prove)\nusing this:\n  A = B\n\ngoal (1 subgoal):\n 1. hermitian A", "using B"], ["proof (prove)\nusing this:\n  A = B\n  hermitian B\n\ngoal (1 subgoal):\n 1. hermitian A", "by auto"], ["proof (state)\nthis:\n  hermitian A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_eigenvalue_positive:\n  assumes dimA: \"(A::complex mat) \\<in> carrier_mat n n\"\n    and pA: \"positive A\"\n    and c: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\"\n    and B: \"unitary_schur_decomposition A es = (B,P,Q)\"\n  shows \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "have hA: \"hermitian A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian A", "using positive_is_hermitian pA"], ["proof (prove)\nusing this:\n  positive ?A \\<Longrightarrow> hermitian ?A\n  positive A\n\ngoal (1 subgoal):\n 1. hermitian A", "by auto"], ["proof (state)\nthis:\n  hermitian A\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "have \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "using hermitian_eigenvalue_real dimA hA B c"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P (adjoint ?P) \\<and>\n                    diagonal_mat ?B \\<and>\n                    diag_mat ?B = ?es \\<and>\n                    unitary ?P \\<and>\n                    (\\<forall>i<?n. ?B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n  hermitian A\n  unitary_schur_decomposition A es = (B, P, Q)\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have A: \"A = P * B * (adjoint P)\" and dB: \"diagonal_mat B\"\n    and Bii: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<in> Reals\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimP: \"P \\<in> carrier_mat n n\" and dimaP: \"adjoint P \\<in> carrier_mat n n\"\n    and uP: \"unitary P\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&& unitary P", "unfolding similar_mat_wit_def Let_def unitary_def"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  (P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n   inverts_mat P (adjoint P)) \\<and>\n  (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n    inverts_mat P (adjoint P)", "using dimA"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  (P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n   inverts_mat P (adjoint P)) \\<and>\n  (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    (B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    adjoint P \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat (dim_row P) (dim_row P) \\<and>\n    inverts_mat P (adjoint P)", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "{"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n  unitary P\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "define v where \"v = col P i\""], ["proof (state)\nthis:\n  v = col P i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "then"], ["proof (chain)\npicking this:\n  v = col P i", "have dimv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v = col P i\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using v_def dimP"], ["proof (prove)\nusing this:\n  v = col P i\n  v = col P i\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "have \"inner_prod v (A *\\<^sub>v v) = B$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = B $$ (i, i)", "unfolding A v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "using spectral_decomposition_extract_diag[OF dimP dimB uP dB i]"], ["proof (prove)\nusing this:\n  inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * B * adjoint P *\\<^sub>v col P i) = B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "moreover"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "have \"inner_prod v (A *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "using dimv pA dimA positive_def"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  positive A\n  A \\<in> carrier_mat n n\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n  0 \\<le> inner_prod v (A *\\<^sub>v v)", "show \"B$$(i, i) \\<ge> 0\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) = B $$ (i, i)\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> B $$ (i, i)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> 0 \\<le> B $$ (?i2, ?i2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diag_mat_mult_diag_mat:\n  fixes B D :: \"'a::semiring_0 mat\"\n  assumes dimB: \"B \\<in> carrier_mat n n\" and dimD: \"D \\<in> carrier_mat n n\"\n    and dB: \"diagonal_mat B\" and dD: \"diagonal_mat D\"\n  shows \"B * D = mat n n (\\<lambda>(i,j). (if i = j then (B$$(i, i)) * (D$$(i, i)) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B * D =\n    mat n n\n     (\\<lambda>(i, j). if i = j then B $$ (i, i) * D $$ (i, i) else (0::'a))", "proof(rule eq_matI, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "have Bij: \"\\<And>x y. x < n \\<Longrightarrow> y < n \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> B$$(x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < n; y < n; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> B $$ (x, y) = (0::'a)", "using dB diagonal_mat_def dimB"], ["proof (prove)\nusing this:\n  diagonal_mat B\n  diagonal_mat ?A \\<equiv>\n  \\<forall>i<dim_row ?A.\n     \\<forall>j<dim_col ?A.\n        i \\<noteq> j \\<longrightarrow> ?A $$ (i, j) = (0::?'a)\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < n; y < n; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> B $$ (x, y) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x < n; ?y < n; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> B $$ (?x, ?y) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "have Dij: \"\\<And>x y. x < n \\<Longrightarrow> y < n \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> D$$(x, y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < n; y < n; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> D $$ (x, y) = (0::'a)", "using dD diagonal_mat_def dimD"], ["proof (prove)\nusing this:\n  diagonal_mat D\n  diagonal_mat ?A \\<equiv>\n  \\<forall>i<dim_row ?A.\n     \\<forall>j<dim_col ?A.\n        i \\<noteq> j \\<longrightarrow> ?A $$ (i, j) = (0::?'a)\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < n; y < n; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> D $$ (x, y) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x < n; ?y < n; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> D $$ (?x, ?y) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x < n; ?y < n; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> D $$ (?x, ?y) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "fix i j"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "assume ij: \"i < n\" \"j < n\""], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "have \"(B * D) $$ (i, j) = (\\<Sum>k=0..<n. (B $$ (i, k)) * (D $$ (k, j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B * D) $$ (i, j) = (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j))", "using dimB dimD"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (B * D) $$ (i, j) = (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j))", "by (auto simp add: scalar_prod_def ij)"], ["proof (state)\nthis:\n  (B * D) $$ (i, j) = (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j))\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "also"], ["proof (state)\nthis:\n  (B * D) $$ (i, j) = (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j))\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "have \"\\<dots> = B$$(i, i) * D$$(i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j)) = B $$ (i, i) * D $$ (i, j)", "apply (simp add: sum.remove[of _i] ij)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B $$ (i, i) * D $$ (i, j) +\n    (\\<Sum>k\\<in>{0..<n} - {i}. B $$ (i, k) * D $$ (k, j)) =\n    B $$ (i, i) * D $$ (i, j)", "apply (simp add: Bij Dij ij)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..<n. B $$ (i, k) * D $$ (k, j)) = B $$ (i, i) * D $$ (i, j)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "finally"], ["proof (chain)\npicking this:\n  (B * D) $$ (i, j) = B $$ (i, i) * D $$ (i, j)", "have \"(B * D) $$ (i, j) = B$$(i, i) * D$$(i, j)\""], ["proof (prove)\nusing this:\n  (B * D) $$ (i, j) = B $$ (i, i) * D $$ (i, j)\n\ngoal (1 subgoal):\n 1. (B * D) $$ (i, j) = B $$ (i, i) * D $$ (i, j)", "."], ["proof (state)\nthis:\n  (B * D) $$ (i, j) = B $$ (i, i) * D $$ (i, j)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "note BDij = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 3. dim_row B = n\n 4. dim_col D = n", "from BDij"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)", "show \"\\<And>j. j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < n \\<Longrightarrow> (B * D) $$ (j, j) = B $$ (j, j) * D $$ (j, j)", "by auto"], ["proof (state)\nthis:\n  ?j < n \\<Longrightarrow>\n  (B * D) $$ (?j, ?j) = B $$ (?j, ?j) * D $$ (?j, ?j)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)\n 2. dim_row B = n\n 3. dim_col D = n", "from BDij"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)", "show \"\\<And>i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> (B * D) $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)", "using Bij Dij"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < n; ?j2 < n\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i2, ?j2) =\n                    B $$ (?i2, ?i2) * D $$ (?i2, ?j2)\n  \\<lbrakk>?x < n; ?y < n; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> B $$ (?x, ?y) = (0::'a)\n  \\<lbrakk>?x < n; ?y < n; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> D $$ (?x, ?y) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (B * D) $$ (i, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; ?j < n; ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> (B * D) $$ (?i, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. dim_row B = n\n 2. dim_col D = n", "from assms"], ["proof (chain)\npicking this:\n  B \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  diagonal_mat B\n  diagonal_mat D", "show \"dim_row B = n\" \"dim_col D = n\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  diagonal_mat B\n  diagonal_mat D\n\ngoal (1 subgoal):\n 1. dim_row B = n &&& dim_col D = n", "by auto"], ["proof (state)\nthis:\n  dim_row B = n\n  dim_col D = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_only_if_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\" and pA: \"positive A\"\n  shows \"\\<exists>M \\<in> carrier_mat n n. M * adjoint M = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "from pA"], ["proof (chain)\npicking this:\n  positive A", "have hA: \"hermitian A\""], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. hermitian A", "using positive_is_hermitian"], ["proof (prove)\nusing this:\n  positive A\n  positive ?A \\<Longrightarrow> hermitian ?A\n\ngoal (1 subgoal):\n 1. hermitian A", "by auto"], ["proof (state)\nthis:\n  hermitian A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "obtain es where es: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complex_mat_char_poly_factorizable dimA"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  \\<exists>as.\n     char_poly ?A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n     length as = ?n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "obtain B P Q where schur: \"unitary_schur_decomposition A es = (B,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P Q.\n        unitary_schur_decomposition A es = (B, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  unitary_schur_decomposition A es = (B, P, Q)", "have \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> diag_mat B = es \n    \\<and> unitary P \\<and> (\\<forall>i < n. B$$(i, i) \\<in> Reals)\""], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "using hermitian_eigenvalue_real dimA es hA"], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P (adjoint ?P) \\<and>\n                    diagonal_mat ?B \\<and>\n                    diag_mat ?B = ?es \\<and>\n                    unitary ?P \\<and>\n                    (\\<forall>i<?n. ?B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  hermitian A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and>\n    diagonal_mat B \\<and>\n    diag_mat B = es \\<and>\n    unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)", "have A: \"A = P * B * (adjoint P)\" and dB: \"diagonal_mat B\"\n    and Bii: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<in> Reals\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimP: \"P \\<in> carrier_mat n n\" and dimaP: \"adjoint P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "using dimA"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and>\n  diag_mat B = es \\<and>\n  unitary P \\<and> (\\<forall>i<n. B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&&\n     diagonal_mat B &&&\n     (\\<And>i. i < n \\<Longrightarrow> B $$ (i, i) \\<in> \\<real>)) &&&\n    B \\<in> carrier_mat n n &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  ?i < n \\<Longrightarrow> B $$ (?i, ?i) \\<in> \\<real>\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have Bii: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "using pA dimA es schur positive_eigenvalue_positive"], ["proof (prove)\nusing this:\n  positive A\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q); ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> ?B $$ (?i, ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> 0 \\<le> B $$ (?i, ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "define D where \"D = mat n n (\\<lambda>(i, j). (if (i = j) then csqrt (B$$(i, i)) else 0))\""], ["proof (state)\nthis:\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)", "have dimD: \"D \\<in> carrier_mat n n\" and dimaD: \"adjoint D \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n\ngoal (1 subgoal):\n 1. D \\<in> carrier_mat n n &&& adjoint D \\<in> carrier_mat n n", "using dimB"], ["proof (prove)\nusing this:\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. D \\<in> carrier_mat n n &&& adjoint D \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  D \\<in> carrier_mat n n\n  adjoint D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have dD: \"diagonal_mat D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonal_mat D", "using dB D_def"], ["proof (prove)\nusing this:\n  diagonal_mat B\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n\ngoal (1 subgoal):\n 1. diagonal_mat D", "unfolding diagonal_mat_def"], ["proof (prove)\nusing this:\n  \\<forall>i<dim_row B.\n     \\<forall>j<dim_col B. i \\<noteq> j \\<longrightarrow> B $$ (i, j) = 0\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_row D.\n       \\<forall>j<dim_col D. i \\<noteq> j \\<longrightarrow> D $$ (i, j) = 0", "by auto"], ["proof (state)\nthis:\n  diagonal_mat D\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  diagonal_mat D", "have daD: \"diagonal_mat (adjoint D)\""], ["proof (prove)\nusing this:\n  diagonal_mat D\n\ngoal (1 subgoal):\n 1. diagonal_mat (adjoint D)", "by (simp add: adjoint_eval diagonal_mat_def)"], ["proof (state)\nthis:\n  diagonal_mat (adjoint D)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have Dii: \"\\<And>i. i < n \\<Longrightarrow> D$$(i, i) = csqrt (B$$(i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> D $$ (i, i) = csqrt (B $$ (i, i))", "using dimD D_def"], ["proof (prove)\nusing this:\n  D \\<in> carrier_mat n n\n  D = mat n n (\\<lambda>(i, j). if i = j then csqrt (B $$ (i, i)) else 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> D $$ (i, i) = csqrt (B $$ (i, i))", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> D $$ (?i, ?i) = csqrt (B $$ (?i, ?i))\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "{"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> D $$ (?i, ?i) = csqrt (B $$ (?i, ?i))\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "define c where \"c = csqrt (B$$(i, i))\""], ["proof (state)\nthis:\n  c = csqrt (B $$ (i, i))\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have c: \"c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c", "using Bii i c_def"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> 0 \\<le> B $$ (?i, ?i)\n  i < n\n  c = csqrt (B $$ (i, i))\n\ngoal (1 subgoal):\n 1. 0 \\<le> c", "by auto"], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  0 \\<le> c", "have \"conjugate c = c\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. conjugate c = c", "using Reals_cnj_iff complex_is_Real_iff"], ["proof (prove)\nusing this:\n  0 \\<le> c\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. conjugate c = c", "by auto"], ["proof (state)\nthis:\n  conjugate c = c\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  conjugate c = c", "have \"c * cnj c = B$$(i, i)\""], ["proof (prove)\nusing this:\n  conjugate c = c\n\ngoal (1 subgoal):\n 1. c * cnj c = B $$ (i, i)", "using c_def c"], ["proof (prove)\nusing this:\n  conjugate c = c\n  c = csqrt (B $$ (i, i))\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * cnj c = B $$ (i, i)", "unfolding conjugate_complex_def"], ["proof (prove)\nusing this:\n  cnj c = c\n  c = csqrt (B $$ (i, i))\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * cnj c = B $$ (i, i)", "by (metis power2_csqrt power2_eq_square)"], ["proof (state)\nthis:\n  c * cnj c = B $$ (i, i)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow>\n  csqrt (B $$ (?i2, ?i2)) * cnj (csqrt (B $$ (?i2, ?i2))) = B $$ (?i2, ?i2)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "note cBii = this"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow>\n  csqrt (B $$ (?i2, ?i2)) * cnj (csqrt (B $$ (?i2, ?i2))) = B $$ (?i2, ?i2)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have \"D * adjoint D = mat n n (\\<lambda>(i,j). (if (i = j) then B$$(i, i) else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D * adjoint D =\n    mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0)", "apply (simp add: diag_mat_mult_diag_mat[OF dimD dimaD dD daD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i = j then D $$ (i, i) * adjoint D $$ (i, i) else 0) =\n    mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0)", "apply (rule eq_matI, auto simp add: D_def adjoint_eval cBii)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  D * adjoint D =\n  mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "also"], ["proof (state)\nthis:\n  D * adjoint D =\n  mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0) = B", "using dimB dB[unfolded diagonal_mat_def]"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  \\<forall>i<dim_row B.\n     \\<forall>j<dim_col B. i \\<noteq> j \\<longrightarrow> B $$ (i, j) = 0\n\ngoal (1 subgoal):\n 1. mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0) = B", "by auto"], ["proof (state)\nthis:\n  mat n n (\\<lambda>(i, j). if i = j then B $$ (i, i) else 0) = B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "finally"], ["proof (chain)\npicking this:\n  D * adjoint D = B", "have DaDB: \"D * adjoint D = B\""], ["proof (prove)\nusing this:\n  D * adjoint D = B\n\ngoal (1 subgoal):\n 1. D * adjoint D = B", "."], ["proof (state)\nthis:\n  D * adjoint D = B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "define M where \"M = P * D\""], ["proof (state)\nthis:\n  M = P * D\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "then"], ["proof (chain)\npicking this:\n  M = P * D", "have dimM: \"M \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  M = P * D\n\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat n n", "using dimP dimD"], ["proof (prove)\nusing this:\n  M = P * D\n  P \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have \"M * adjoint M = (P * D) * (adjoint D * adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * adjoint M = P * D * (adjoint D * adjoint P)", "using M_def adjoint_mult[OF dimP dimD]"], ["proof (prove)\nusing this:\n  M = P * D\n  adjoint (P * D) = adjoint D * adjoint P\n\ngoal (1 subgoal):\n 1. M * adjoint M = P * D * (adjoint D * adjoint P)", "by auto"], ["proof (state)\nthis:\n  M * adjoint M = P * D * (adjoint D * adjoint P)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "also"], ["proof (state)\nthis:\n  M * adjoint M = P * D * (adjoint D * adjoint P)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have \"\\<dots> = P * (D * adjoint D) * (adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * D * (adjoint D * adjoint P) = P * (D * adjoint D) * adjoint P", "using dimP dimD"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * D * (adjoint D * adjoint P) = P * (D * adjoint D) * adjoint P", "by (mat_assoc n)"], ["proof (state)\nthis:\n  P * D * (adjoint D * adjoint P) = P * (D * adjoint D) * adjoint P\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "also"], ["proof (state)\nthis:\n  P * D * (adjoint D * adjoint P) = P * (D * adjoint D) * adjoint P\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "have \"\\<dots> = P * B * (adjoint P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (D * adjoint D) * adjoint P = P * B * adjoint P", "using DaDB"], ["proof (prove)\nusing this:\n  D * adjoint D = B\n\ngoal (1 subgoal):\n 1. P * (D * adjoint D) * adjoint P = P * B * adjoint P", "by auto"], ["proof (state)\nthis:\n  P * (D * adjoint D) * adjoint P = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "finally"], ["proof (chain)\npicking this:\n  M * adjoint M = P * B * adjoint P", "have \"M * adjoint M = A\""], ["proof (prove)\nusing this:\n  M * adjoint M = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. M * adjoint M = A", "using A"], ["proof (prove)\nusing this:\n  M * adjoint M = P * B * adjoint P\n  A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. M * adjoint M = A", "by auto"], ["proof (state)\nthis:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "with dimM"], ["proof (chain)\npicking this:\n  M \\<in> carrier_mat n n\n  M * adjoint M = A", "show \"\\<exists>M \\<in> carrier_mat n n. M * adjoint M = A\""], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "by auto"], ["proof (state)\nthis:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_if_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\" and \"\\<exists>M. M * adjoint M = A\"\n  shows \"positive A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive A", "from assms"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  \\<exists>M. M * adjoint M = A", "obtain M where M: \"M * adjoint M = A\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  \\<exists>M. M * adjoint M = A\n\ngoal (1 subgoal):\n 1. (\\<And>M. M * adjoint M = A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. positive A", "define m where \"m = dim_col M\""], ["proof (state)\nthis:\n  m = dim_col M\n\ngoal (1 subgoal):\n 1. positive A", "have dimM: \"M \\<in> carrier_mat n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat n m", "using M dimA m_def"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n  A \\<in> carrier_mat n n\n  m = dim_col M\n\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat n m", "by auto"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. positive A", "{"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. positive A", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. positive A", "assume dimv: \"(v::complex vec) \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. positive A", "have dimaM: \"adjoint M \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat m n", "using dimM"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat m n", "by auto"], ["proof (state)\nthis:\n  adjoint M \\<in> carrier_mat m n\n\ngoal (1 subgoal):\n 1. positive A", "have dimaMv: \"(adjoint M) *\\<^sub>v v \\<in> carrier_vec m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M *\\<^sub>v v \\<in> carrier_vec m", "using dimaM dimv"], ["proof (prove)\nusing this:\n  adjoint M \\<in> carrier_mat m n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. adjoint M *\\<^sub>v v \\<in> carrier_vec m", "by auto"], ["proof (state)\nthis:\n  adjoint M *\\<^sub>v v \\<in> carrier_vec m\n\ngoal (1 subgoal):\n 1. positive A", "have \"inner_prod v (A *\\<^sub>v v) = inner_prod v (M * adjoint M *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = inner_prod v (M * adjoint M *\\<^sub>v v)", "using M"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) = inner_prod v (M * adjoint M *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = inner_prod v (M * adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "also"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) = inner_prod v (M * adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "have \"\\<dots> = inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (M * adjoint M *\\<^sub>v v) =\n    inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v))", "using assoc_mult_mat_vec dimM dimaM dimv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2;\n   ?B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3;\n   ?v \\<in> carrier_vec ?n\\<^sub>3\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B *\\<^sub>v ?v = ?A *\\<^sub>v (?B *\\<^sub>v ?v)\n  M \\<in> carrier_mat n m\n  adjoint M \\<in> carrier_mat m n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (M * adjoint M *\\<^sub>v v) =\n    inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v))", "by auto"], ["proof (state)\nthis:\n  inner_prod v (M * adjoint M *\\<^sub>v v) =\n  inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. positive A", "also"], ["proof (state)\nthis:\n  inner_prod v (M * adjoint M *\\<^sub>v v) =\n  inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. positive A", "have \"\\<dots> = inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n    inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)", "using adjoint_def_alter[OF dimv dimaMv dimM]"], ["proof (prove)\nusing this:\n  inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n  inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n    inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n  inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "also"], ["proof (state)\nthis:\n  inner_prod v (M *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n  inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)", "using self_cscalar_prod_geq_0"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> inner_prod ?v ?v\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod (adjoint M *\\<^sub>v v) (adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)", "have \"inner_prod v (A *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "."], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive A", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive A", "note geq0 = this"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive A", "from dimA geq0"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)", "show \"positive A\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive A", "using positive_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 (A *\\<^sub>v ?v2)\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. positive A", "by auto"], ["proof (state)\nthis:\n  positive A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_iff_decomp:\n  assumes dimA: \"A \\<in> carrier_mat n n\"\n  shows \"positive A \\<longleftrightarrow> (\\<exists>M\\<in>carrier_mat n n. M * adjoint M = A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A = (\\<exists>M\\<in>carrier_mat n n. M * adjoint M = A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. positive A \\<Longrightarrow>\n    \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n 2. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "assume pA: \"positive A\""], ["proof (state)\nthis:\n  positive A\n\ngoal (2 subgoals):\n 1. positive A \\<Longrightarrow>\n    \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n 2. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  positive A", "show \"\\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\""], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "using positive_only_if_decomp assms"], ["proof (prove)\nusing this:\n  positive A\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = ?A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "by auto"], ["proof (state)\nthis:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "assume \"\\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\""], ["proof (state)\nthis:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A", "obtain M where M: \"M * adjoint M = A\""], ["proof (prove)\nusing this:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A\n\ngoal (1 subgoal):\n 1. (\\<And>M. M * adjoint M = A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = A \\<Longrightarrow>\n    positive A", "then"], ["proof (chain)\npicking this:\n  M * adjoint M = A", "show \"positive A\""], ["proof (prove)\nusing this:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. positive A", "using M positive_if_decomp assms"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n  M * adjoint M = A\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   \\<exists>M. M * adjoint M = ?A\\<rbrakk>\n  \\<Longrightarrow> positive ?A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive A", "by auto"], ["proof (state)\nthis:\n  positive A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_dim_eq:\n  assumes \"positive A\"\n  shows \"dim_row A = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_col A", "using carrier_matD(1)[of A \"dim_col A\" \"dim_col A\"]  assms[unfolded positive_def]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<Longrightarrow>\n  dim_row A = dim_col A\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. dim_row A = dim_col A", "by simp"], ["", "lemma positive_zero:\n  \"positive (0\\<^sub>m n n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (0\\<^sub>m n n)", "by (simp add: positive_def zero_mat_def mult_mat_vec_def scalar_prod_def)"], ["", "lemma positive_one:\n  \"positive (1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m n)", "proof (rule positive_if_decomp)"], ["proof (state)\ngoal (2 subgoals):\n 1. 1\\<^sub>m n \\<in> carrier_mat ?n ?n\n 2. \\<exists>M. M * adjoint M = 1\\<^sub>m n", "show \"1\\<^sub>m n \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m n", "have \"adjoint (1\\<^sub>m n) = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "using hermitian_one hermitian_def"], ["proof (prove)\nusing this:\n  hermitian (1\\<^sub>m ?n)\n  hermitian ?A = (adjoint ?A = ?A)\n\ngoal (1 subgoal):\n 1. adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  adjoint (1\\<^sub>m n) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "have \"1\\<^sub>m n * adjoint (1\\<^sub>m n) = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  adjoint (1\\<^sub>m n) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n * adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  1\\<^sub>m n * adjoint (1\\<^sub>m n) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  1\\<^sub>m n * adjoint (1\\<^sub>m n) = 1\\<^sub>m n", "show \"\\<exists>M. M * adjoint M = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  1\\<^sub>m n * adjoint (1\\<^sub>m n) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = 1\\<^sub>m n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_antisym:\n  assumes pA: \"positive A\" and pnA: \"positive (-A)\"\n  shows \"A = 0\\<^sub>m (dim_col A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "define n where \"n = dim_col A\""], ["proof (state)\nthis:\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "from pA"], ["proof (chain)\npicking this:\n  positive A", "have dimA: \"A \\<in> carrier_mat n n\" and dimnA: \"-A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& - A \\<in> carrier_mat n n", "using positive_def n_def"], ["proof (prove)\nusing this:\n  positive A\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n  n = dim_col A\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n &&& - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "from pA"], ["proof (chain)\npicking this:\n  positive A", "have hA: \"hermitian A\""], ["proof (prove)\nusing this:\n  positive A\n\ngoal (1 subgoal):\n 1. hermitian A", "using positive_is_hermitian"], ["proof (prove)\nusing this:\n  positive A\n  positive ?A \\<Longrightarrow> hermitian ?A\n\ngoal (1 subgoal):\n 1. hermitian A", "by auto"], ["proof (state)\nthis:\n  hermitian A\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "obtain es where es: \"char_poly A = (\\<Prod> (e :: complex) \\<leftarrow> es. [:- e, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complex_mat_char_poly_factorizable dimA"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  \\<exists>as.\n     char_poly ?A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n     length as = ?n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "obtain B P Q where schur: \"unitary_schur_decomposition A es = (B,P,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B P Q.\n        unitary_schur_decomposition A es = (B, P, Q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"unitary_schur_decomposition A es\", auto)"], ["proof (state)\nthis:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "then"], ["proof (chain)\npicking this:\n  unitary_schur_decomposition A es = (B, P, Q)", "have \"similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P\""], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P", "using hermitian_eigenvalue_real dimA es hA"], ["proof (prove)\nusing this:\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; hermitian ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q)\\<rbrakk>\n  \\<Longrightarrow> similar_mat_wit ?A ?B ?P (adjoint ?P) \\<and>\n                    diagonal_mat ?B \\<and>\n                    diag_mat ?B = ?es \\<and>\n                    unitary ?P \\<and>\n                    (\\<forall>i<?n. ?B $$ (i, i) \\<in> \\<real>)\n  A \\<in> carrier_mat n n\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  hermitian A\n\ngoal (1 subgoal):\n 1. similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "then"], ["proof (chain)\npicking this:\n  similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P", "have A: \"A = P * B * (adjoint P)\" and dB: \"diagonal_mat B\" and uP: \"unitary P\"\n    and dimB: \"B \\<in> carrier_mat n n\" and dimnB: \"-B \\<in> carrier_mat n n\"\n    and dimP: \"P \\<in> carrier_mat n n\" and dimaP: \"adjoint P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  similar_mat_wit A B P (adjoint P) \\<and> diagonal_mat B \\<and> unitary P\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&& diagonal_mat B &&& unitary P) &&&\n    (B \\<in> carrier_mat n n &&& - B \\<in> carrier_mat n n) &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "unfolding similar_mat_wit_def Let_def"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and> unitary P\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&& diagonal_mat B &&& unitary P) &&&\n    (B \\<in> carrier_mat n n &&& - B \\<in> carrier_mat n n) &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "using dimA"], ["proof (prove)\nusing this:\n  ({A, B, P, adjoint P}\n   \\<subseteq> carrier_mat (dim_row A) (dim_row A) \\<and>\n   P * adjoint P = 1\\<^sub>m (dim_row A) \\<and>\n   adjoint P * P = 1\\<^sub>m (dim_row A) \\<and>\n   A = P * B * adjoint P) \\<and>\n  diagonal_mat B \\<and> unitary P\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A = P * B * adjoint P &&& diagonal_mat B &&& unitary P) &&&\n    (B \\<in> carrier_mat n n &&& - B \\<in> carrier_mat n n) &&&\n    P \\<in> carrier_mat n n &&& adjoint P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A = P * B * adjoint P\n  diagonal_mat B\n  unitary P\n  B \\<in> carrier_mat n n\n  - B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "from es schur"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)", "have geq0: \"\\<And>i. i < n \\<Longrightarrow> B$$(i, i) \\<ge> 0\""], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "using positive_eigenvalue_positive dimA pA"], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>e\\<leftarrow>es. [:- e, 1:])\n  unitary_schur_decomposition A es = (B, P, Q)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A;\n   char_poly ?A = (\\<Prod>e\\<leftarrow>?es. [:- e, 1:]);\n   unitary_schur_decomposition ?A ?es = (?B, ?P, ?Q); ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> ?B $$ (?i, ?i)\n  A \\<in> carrier_mat n n\n  positive A\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> 0 \\<le> B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> 0 \\<le> B $$ (?i, ?i)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "from A"], ["proof (chain)\npicking this:\n  A = P * B * adjoint P", "have nA: \"-A = P * (-B) * (adjoint P)\""], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n\ngoal (1 subgoal):\n 1. - A = P * - B * adjoint P", "using mult_smult_assoc_mat dimB dimP dimaP"], ["proof (prove)\nusing this:\n  A = P * B * adjoint P\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?k \\<cdot>\\<^sub>m ?A * ?B =\n                    ?k \\<cdot>\\<^sub>m (?A * ?B)\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. - A = P * - B * adjoint P", "by auto"], ["proof (state)\nthis:\n  - A = P * - B * adjoint P\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "from dB"], ["proof (chain)\npicking this:\n  diagonal_mat B", "have dnB: \"diagonal_mat (-B)\""], ["proof (prove)\nusing this:\n  diagonal_mat B\n\ngoal (1 subgoal):\n 1. diagonal_mat (- B)", "by (simp add: diagonal_mat_def)"], ["proof (state)\nthis:\n  diagonal_mat (- B)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "{"], ["proof (state)\nthis:\n  diagonal_mat (- B)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "define v where \"v = col P i\""], ["proof (state)\nthis:\n  v = col P i\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "then"], ["proof (chain)\npicking this:\n  v = col P i", "have dimv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v = col P i\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using v_def dimP"], ["proof (prove)\nusing this:\n  v = col P i\n  v = col P i\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "have \"inner_prod v ((-A) *\\<^sub>v v) = (-B)$$(i, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)", "unfolding nA v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * - B * adjoint P *\\<^sub>v col P i) =\n    (- B) $$ (i, i)", "using spectral_decomposition_extract_diag[OF dimP dimnB uP dnB i]"], ["proof (prove)\nusing this:\n  inner_prod (col P i) (P * - B * adjoint P *\\<^sub>v col P i) =\n  (- B) $$ (i, i)\n\ngoal (1 subgoal):\n 1. inner_prod (col P i) (P * - B * adjoint P *\\<^sub>v col P i) =\n    (- B) $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "moreover"], ["proof (state)\nthis:\n  inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "have \"inner_prod v ((-A) *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (- A *\\<^sub>v v)", "using dimv pnA dimnA positive_def"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  positive (- A)\n  - A \\<in> carrier_mat n n\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (- A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (- A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "ultimately"], ["proof (chain)\npicking this:\n  inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)\n  0 \\<le> inner_prod v (- A *\\<^sub>v v)", "have \"B$$(i, i) \\<le> 0\""], ["proof (prove)\nusing this:\n  inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)\n  0 \\<le> inner_prod v (- A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. B $$ (i, i) \\<le> 0", "using dimB i"], ["proof (prove)\nusing this:\n  inner_prod v (- A *\\<^sub>v v) = (- B) $$ (i, i)\n  0 \\<le> inner_prod v (- A *\\<^sub>v v)\n  B \\<in> carrier_mat n n\n  i < n\n\ngoal (1 subgoal):\n 1. B $$ (i, i) \\<le> 0", "by auto"], ["proof (state)\nthis:\n  B $$ (i, i) \\<le> 0\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "moreover"], ["proof (state)\nthis:\n  B $$ (i, i) \\<le> 0\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "have \"B$$(i, i) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> B $$ (i, i)", "using i geq0"], ["proof (prove)\nusing this:\n  i < n\n  ?i < n \\<Longrightarrow> 0 \\<le> B $$ (?i, ?i)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B $$ (i, i)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> B $$ (i, i)\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "ultimately"], ["proof (chain)\npicking this:\n  B $$ (i, i) \\<le> 0\n  0 \\<le> B $$ (i, i)", "have \"B$$(i, i) = 0\""], ["proof (prove)\nusing this:\n  B $$ (i, i) \\<le> 0\n  0 \\<le> B $$ (i, i)\n\ngoal (1 subgoal):\n 1. B $$ (i, i) = 0", "by (metis no_atp(10))"], ["proof (state)\nthis:\n  B $$ (i, i) = 0\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "then"], ["proof (chain)\npicking this:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0", "have \"B = 0\\<^sub>m n n\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "using dimB dB[unfolded diagonal_mat_def]"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow> B $$ (?i2, ?i2) = 0\n  B \\<in> carrier_mat n n\n  \\<forall>i<dim_row B.\n     \\<forall>j<dim_col B. i \\<noteq> j \\<longrightarrow> B $$ (i, j) = 0\n\ngoal (1 subgoal):\n 1. B = 0\\<^sub>m n n", "by (subst eq_matI, auto)"], ["proof (state)\nthis:\n  B = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m (dim_col A) (dim_col A)", "then"], ["proof (chain)\npicking this:\n  B = 0\\<^sub>m n n", "show \"A = 0\\<^sub>m n n\""], ["proof (prove)\nusing this:\n  B = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "using A dimB dimP dimaP"], ["proof (prove)\nusing this:\n  B = 0\\<^sub>m n n\n  A = P * B * adjoint P\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  adjoint P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = 0\\<^sub>m n n", "by auto"], ["proof (state)\nthis:\n  A = 0\\<^sub>m n n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_add:\n  assumes pA: \"positive A\" and pB: \"positive B\"\n    and dimA: \"A \\<in> carrier_mat n n\" and dimB: \"B \\<in> carrier_mat n n\"\n  shows \"positive (A + B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (A + B)", "unfolding positive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B)) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col (A + B) \\<longrightarrow>\n        0 \\<le> inner_prod v ((A + B) *\\<^sub>v v))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))\n 2. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have dimApB: \"A + B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<in> carrier_mat n n", "using dimA dimB"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A + B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A + B \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))\n 2. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  A + B \\<in> carrier_mat n n", "show \"A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))\""], ["proof (prove)\nusing this:\n  A + B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))", "using carrier_matD[of \"A+B\"]"], ["proof (prove)\nusing this:\n  A + B \\<in> carrier_mat n n\n  A + B \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row (A + B) = ?nr\n  A + B \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_col (A + B) = ?nc\n\ngoal (1 subgoal):\n 1. A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))", "by auto"], ["proof (state)\nthis:\n  A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "{"], ["proof (state)\nthis:\n  A + B \\<in> carrier_mat (dim_col (A + B)) (dim_col (A + B))\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "assume dimv: \"(v::complex vec) \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have 1: \"inner_prod v (A *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "using dimv pA[unfolded positive_def] dimA"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  A \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col A \\<longrightarrow>\n      0 \\<le> inner_prod v (A *\\<^sub>v v))\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have 2: \"inner_prod v (B *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (B *\\<^sub>v v)", "using dimv pB[unfolded positive_def] dimB"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  B \\<in> carrier_mat (dim_col B) (dim_col B) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col B \\<longrightarrow>\n      0 \\<le> inner_prod v (B *\\<^sub>v v))\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (B *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have \"inner_prod v ((A + B) *\\<^sub>v v) = inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v ((A + B) *\\<^sub>v v) =\n    inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)", "using dimA dimB dimv"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v ((A + B) *\\<^sub>v v) =\n    inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)", "by (simp add: add_mult_distrib_mat_vec inner_prod_distrib_right)"], ["proof (state)\nthis:\n  inner_prod v ((A + B) *\\<^sub>v v) =\n  inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  inner_prod v ((A + B) *\\<^sub>v v) =\n  inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)", "using 1 2"], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (A *\\<^sub>v v)\n  0 \\<le> inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (A *\\<^sub>v v) + inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "have \"inner_prod v ((A + B) *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "."], ["proof (state)\nthis:\n  0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((A + B) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "note geq0 = this"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((A + B) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((A + B) *\\<^sub>v ?v2)", "have \"\\<And>v. dim_vec v = n \\<Longrightarrow> 0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((A + B) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = n \\<Longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  dim_vec ?v = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v ((A + B) *\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  dim_vec ?v = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v ((A + B) *\\<^sub>v ?v)", "show \"\\<forall>v. dim_vec v = dim_col (A + B) \\<longrightarrow> 0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  dim_vec ?v = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v ((A + B) *\\<^sub>v ?v)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "using dimApB"], ["proof (prove)\nusing this:\n  dim_vec ?v = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v ((A + B) *\\<^sub>v ?v)\n  A + B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (A + B) \\<longrightarrow>\n       0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     dim_vec v = dim_col (A + B) \\<longrightarrow>\n     0 \\<le> inner_prod v ((A + B) *\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_trace:\n  assumes \"A \\<in> carrier_mat n n\" and \"positive A\"\n  shows \"trace A \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> trace A", "using assms positive_iff_decomp trace_adjoint_positive"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  positive A\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  positive ?A = (\\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = ?A)\n  0 \\<le> trace (?A * adjoint ?A)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace A", "by auto"], ["", "lemma positive_close_under_left_right_mult_adjoint:\n  fixes M A :: \"complex mat\"\n  assumes dM: \"M \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" \n    and pA: \"positive A\"\n  shows \"positive (M * A * adjoint M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (M * A * adjoint M)", "unfolding positive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M * A * adjoint M\n    \\<in> carrier_mat (dim_col (M * A * adjoint M))\n           (dim_col (M * A * adjoint M)) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col (M * A * adjoint M) \\<longrightarrow>\n        0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v))", "proof (rule, simp add: mult_carrier_mat[OF mult_carrier_mat[OF dM dA] adjoint_dim[OF dM]] carrier_matD[OF dM], rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "have daM: \"adjoint M \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat n n", "using dM"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "fix v::\"complex vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "assume \"dim_vec v = dim_col (M * A * adjoint M)\""], ["proof (state)\nthis:\n  dim_vec v = dim_col (M * A * adjoint M)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  dim_vec v = dim_col (M * A * adjoint M)", "have dv: \"v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  dim_vec v = dim_col (M * A * adjoint M)\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  dim_vec v = dim_col (M * A * adjoint M)\n  M \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  positive A\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n", "have \"adjoint M *\\<^sub>v v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. adjoint M *\\<^sub>v v \\<in> carrier_vec n", "using daM"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  adjoint M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint M *\\<^sub>v v \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  adjoint M *\\<^sub>v v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "have assoc: \"M * A * adjoint M *\\<^sub>v v = M *\\<^sub>v (A *\\<^sub>v (adjoint M *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * A * adjoint M *\\<^sub>v v =\n    M *\\<^sub>v (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "using dA dM daM dv"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  M \\<in> carrier_mat n n\n  adjoint M \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. M * A * adjoint M *\\<^sub>v v =\n    M *\\<^sub>v (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "by (auto simp add: assoc_mult_mat_vec[of _ n n _ n])"], ["proof (state)\nthis:\n  M * A * adjoint M *\\<^sub>v v =\n  M *\\<^sub>v (A *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "have \"inner_prod v (M * A * adjoint M *\\<^sub>v v) = inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (M * A * adjoint M *\\<^sub>v v) =\n    inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "apply (subst assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (M *\\<^sub>v (A *\\<^sub>v (adjoint M *\\<^sub>v v))) =\n    inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "apply (subst adjoint_def_alter[where ?A = \"M\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec ?n\n 2. A *\\<^sub>v (adjoint M *\\<^sub>v v) \\<in> carrier_vec ?m\n 3. M \\<in> carrier_mat ?n ?m\n 4. inner_prod (adjoint M *\\<^sub>v v)\n     (A *\\<^sub>v (adjoint M *\\<^sub>v v)) =\n    inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "by (auto simp add: dv dA daM dM carrier_matD[OF dM] mult_mat_vec_carrier[of _ n n])"], ["proof (state)\nthis:\n  inner_prod v (M * A * adjoint M *\\<^sub>v v) =\n  inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "also"], ["proof (state)\nthis:\n  inner_prod v (M * A * adjoint M *\\<^sub>v v) =\n  inner_prod (adjoint M *\\<^sub>v v) (A *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod (adjoint M *\\<^sub>v v)\n             (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "using dA dv daM pA positive_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  adjoint M \\<in> carrier_mat n n\n  positive A\n  positive ?A =\n  (?A \\<in> carrier_mat (dim_col ?A) (dim_col ?A) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col ?A \\<longrightarrow>\n       0 \\<le> inner_prod v (?A *\\<^sub>v v)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod (adjoint M *\\<^sub>v v)\n             (A *\\<^sub>v (adjoint M *\\<^sub>v v))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod (adjoint M *\\<^sub>v v)\n           (A *\\<^sub>v (adjoint M *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       dim_vec v = dim_col (M * A * adjoint M) \\<Longrightarrow>\n       0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "show \"inner_prod v (M * A * adjoint M *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (M * A * adjoint M *\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_same_outer_prod:\n  fixes v w :: \"complex vec\"\n  assumes v: \"v \\<in> carrier_vec n\" \n  shows \"positive (outer_prod v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "have d1: \"adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)) \\<in> carrier_mat 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n    \\<in> carrier_mat 1 n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n    \\<in> carrier_mat 1 n", "by auto"], ["proof (state)\nthis:\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)) \\<in> carrier_mat 1 n\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "have d2: \"mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) \\<in> carrier_mat 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)\n    \\<in> carrier_mat 1 n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)\n    \\<in> carrier_mat 1 n", "by auto"], ["proof (state)\nthis:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) \\<in> carrier_mat 1 n\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "have dv: \"dim_vec v = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec v = n", "by auto"], ["proof (state)\nthis:\n  dim_vec v = n\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "have \"mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) = adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\" (is \"?r = adjoint ?l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n    adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)));\n        j < dim_col\n             (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))\\<rbrakk>\n       \\<Longrightarrow> mat 1 (dim_vec v)\n                          (\\<lambda>(i, y). conjugate v $ y) $$\n                         (i, j) =\n                         adjoint\n                          (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)) $$\n                         (i, j)\n 2. dim_row (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_row (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))\n 3. dim_col (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_col (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row\n                  (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)));\n     j < dim_col\n          (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))\\<rbrakk>\n    \\<Longrightarrow> mat 1 (dim_vec v)\n                       (\\<lambda>(i, y). conjugate v $ y) $$\n                      (i, j) =\n                      adjoint\n                       (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)) $$\n                      (i, j)", "by (simp add: dv adjoint_eval)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_row (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))\n 2. dim_col (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_col (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))", "using d1 d2"], ["proof (prove)\nusing this:\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)) \\<in> carrier_mat 1 n\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) \\<in> carrier_mat 1 n\n\ngoal (2 subgoals):\n 1. dim_row (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_row (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))\n 2. dim_col (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) =\n    dim_col (adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i)))", "by auto"], ["proof (state)\nthis:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "then"], ["proof (chain)\npicking this:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))", "have \"outer_prod v v = ?l * adjoint ?l\""], ["proof (prove)\nusing this:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n\ngoal (1 subgoal):\n 1. outer_prod v v =\n    mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n    adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))", "unfolding outer_prod_def"], ["proof (prove)\nusing this:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n\ngoal (1 subgoal):\n 1. mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n    mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n    adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))", "by auto"], ["proof (state)\nthis:\n  outer_prod v v =\n  mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "then"], ["proof (chain)\npicking this:\n  outer_prod v v =\n  mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))", "have \"\\<exists>M. M * adjoint M = outer_prod v v\""], ["proof (prove)\nusing this:\n  outer_prod v v =\n  mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i) *\n  adjoint (mat (dim_vec v) 1 (\\<lambda>(i, j). v $ i))\n\ngoal (1 subgoal):\n 1. \\<exists>M. M * adjoint M = outer_prod v v", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. M * adjoint M = outer_prod v v\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. M * adjoint M = outer_prod v v", "show \"positive (outer_prod v v)\""], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = outer_prod v v\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "using positive_if_decomp[OF outer_prod_dim[OF v v]]"], ["proof (prove)\nusing this:\n  \\<exists>M. M * adjoint M = outer_prod v v\n  \\<exists>M. M * adjoint M = outer_prod v v \\<Longrightarrow>\n  positive (outer_prod v v)\n\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "by auto"], ["proof (state)\nthis:\n  positive (outer_prod v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_smult_mat: \n  fixes k :: complex and l :: complex\n  assumes \"A \\<in> carrier_mat nr n\"\n  shows \"k \\<cdot>\\<^sub>m (l \\<cdot>\\<^sub>m A) = (k * l) \\<cdot>\\<^sub>m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot>\\<^sub>m (l \\<cdot>\\<^sub>m A) = k * l \\<cdot>\\<^sub>m A", "by auto"], ["", "lemma positive_smult: \n  assumes \"A \\<in> carrier_mat n n\"\n    and \"positive A\"\n    and \"c \\<ge> 0\"\n  shows \"positive (c \\<cdot>\\<^sub>m A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have sc: \"csqrt c \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> csqrt c", "using assms(3)"], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. 0 \\<le> csqrt c", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> csqrt c\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "obtain M where dimM: \"M \\<in> carrier_mat n n\" and A: \"M * adjoint M = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> carrier_mat n n; M * adjoint M = A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1-2) positive_iff_decomp"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  positive A\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  positive ?A = (\\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> carrier_mat n n; M * adjoint M = A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n n\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"c \\<cdot>\\<^sub>m A  = c \\<cdot>\\<^sub>m (M * adjoint M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A = c \\<cdot>\\<^sub>m (M * adjoint M)", "using A"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A = c \\<cdot>\\<^sub>m (M * adjoint M)", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A = c \\<cdot>\\<^sub>m (M * adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have ccsq: \"conjugate (csqrt c) = (csqrt c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (csqrt c) = csqrt c", "using sc Reals_cnj_iff[of \"csqrt c\"] complex_is_Real_iff"], ["proof (prove)\nusing this:\n  0 \\<le> csqrt c\n  (csqrt c \\<in> \\<real>) = (cnj (csqrt c) = csqrt c)\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. conjugate (csqrt c) = csqrt c", "by auto"], ["proof (state)\nthis:\n  conjugate (csqrt c) = csqrt c\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have MM: \"(M * adjoint M) \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * adjoint M \\<in> carrier_mat n n", "using A assms"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n  A \\<in> carrier_mat n n\n  positive A\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. M * adjoint M \\<in> carrier_mat n n", "by fastforce"], ["proof (state)\nthis:\n  M * adjoint M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have leftd: \"c  \\<cdot>\\<^sub>m (M * adjoint M) \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (M * adjoint M) \\<in> carrier_mat n n", "using A assms"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n  A \\<in> carrier_mat n n\n  positive A\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (M * adjoint M) \\<in> carrier_mat n n", "by fastforce"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m (M * adjoint M) \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have rightd: \"(csqrt c \\<cdot>\\<^sub>m M) * (adjoint (csqrt c \\<cdot>\\<^sub>m M))\\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M)\n    \\<in> carrier_mat n n", "using A assms"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n  A \\<in> carrier_mat n n\n  positive A\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M)\n    \\<in> carrier_mat n n", "by fastforce"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M)\n  \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"(csqrt c \\<cdot>\\<^sub>m M) * (adjoint (csqrt c \\<cdot>\\<^sub>m M)) = (csqrt c \\<cdot>\\<^sub>m M) * ((conjugate (csqrt c)) \\<cdot>\\<^sub>m  adjoint M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n    csqrt c \\<cdot>\\<^sub>m M *\n    (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M)", "using adjoint_scale assms(1)"], ["proof (prove)\nusing this:\n  adjoint (?a \\<cdot>\\<^sub>m ?A) = conjugate ?a \\<cdot>\\<^sub>m adjoint ?A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n    csqrt c \\<cdot>\\<^sub>m M *\n    (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M)", "by (metis adjoint_scale)"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  csqrt c \\<cdot>\\<^sub>m M *\n  (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "also"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  csqrt c \\<cdot>\\<^sub>m M *\n  (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"\\<dots> = (csqrt c \\<cdot>\\<^sub>m M) * (csqrt c \\<cdot>\\<^sub>m adjoint M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M *\n    (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M) =\n    csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M)", "using sc ccsq"], ["proof (prove)\nusing this:\n  0 \\<le> csqrt c\n  conjugate (csqrt c) = csqrt c\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M *\n    (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M) =\n    csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M)", "by fastforce"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M *\n  (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M) =\n  csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "also"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M *\n  (conjugate (csqrt c) \\<cdot>\\<^sub>m adjoint M) =\n  csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"\\<dots> = csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M) =\n    csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M))", "using mult_smult_assoc_mat index_smult_mat(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?k \\<cdot>\\<^sub>m ?A * ?B =\n                    ?k \\<cdot>\\<^sub>m (?A * ?B)\n  dim_row (?a \\<cdot>\\<^sub>m ?A) = dim_row ?A\n  dim_col (?a \\<cdot>\\<^sub>m ?A) = dim_col ?A\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M) =\n    csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M))", "by fastforce"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M) =\n  csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M))\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "also"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * (csqrt c \\<cdot>\\<^sub>m adjoint M) =\n  csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M))\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"\\<dots> =  csqrt c \\<cdot>\\<^sub>m ((csqrt c) \\<cdot>\\<^sub>m (M * adjoint M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M)) =\n    csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M))", "using mult_smult_distrib"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A * (?k \\<cdot>\\<^sub>m ?B) =\n                    ?k \\<cdot>\\<^sub>m (?A * ?B)\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M)) =\n    csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M))", "by fastforce"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M)) =\n  csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M))\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "also"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m (M * (csqrt c \\<cdot>\\<^sub>m adjoint M)) =\n  csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M))\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"\\<dots> = c \\<cdot>\\<^sub>m (M * adjoint M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M)) =\n    c \\<cdot>\\<^sub>m (M * adjoint M)", "using smult_smult_mat[of \"M * adjoint M\" n n \"(csqrt c)\" \"(csqrt c)\"]  MM sc"], ["proof (prove)\nusing this:\n  M * adjoint M \\<in> carrier_mat n n \\<Longrightarrow>\n  csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M)) =\n  csqrt c * csqrt c \\<cdot>\\<^sub>m (M * adjoint M)\n  M * adjoint M \\<in> carrier_mat n n\n  0 \\<le> csqrt c\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M)) =\n    c \\<cdot>\\<^sub>m (M * adjoint M)", "by (metis power2_csqrt power2_eq_square )"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M)) =\n  c \\<cdot>\\<^sub>m (M * adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "also"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m (csqrt c \\<cdot>\\<^sub>m (M * adjoint M)) =\n  c \\<cdot>\\<^sub>m (M * adjoint M)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"\\<dots> = c \\<cdot>\\<^sub>m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (M * adjoint M) = c \\<cdot>\\<^sub>m A", "using A"], ["proof (prove)\nusing this:\n  M * adjoint M = A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (M * adjoint M) = c \\<cdot>\\<^sub>m A", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m (M * adjoint M) = c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "finally"], ["proof (chain)\npicking this:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A", "have \"(csqrt c \\<cdot>\\<^sub>m M) * (adjoint (csqrt c \\<cdot>\\<^sub>m M)) = c \\<cdot>\\<^sub>m A\""], ["proof (prove)\nusing this:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n    c \\<cdot>\\<^sub>m A", "by auto"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "moreover"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n", "using assms(1)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "moreover"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "have \"csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n", "using dimM"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "ultimately"], ["proof (chain)\npicking this:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n", "show ?thesis"], ["proof (prove)\nusing this:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "using positive_iff_decomp"], ["proof (prove)\nusing this:\n  csqrt c \\<cdot>\\<^sub>m M * adjoint (csqrt c \\<cdot>\\<^sub>m M) =\n  c \\<cdot>\\<^sub>m A\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  csqrt c \\<cdot>\\<^sub>m M \\<in> carrier_mat n n\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  positive ?A = (\\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = ?A)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m A)", "by auto"], ["proof (state)\nthis:\n  positive (c \\<cdot>\\<^sub>m A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Version of previous theorem for real numbers\\<close>"], ["", "lemma positive_scale: \n  fixes c :: real\n  assumes  \"A \\<in> carrier_mat n n\"\n    and \"positive A\"\n    and \"c \\<ge> 0\"\n  shows \"positive (c \\<cdot>\\<^sub>m A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (complex_of_real c \\<cdot>\\<^sub>m A)", "apply (rule positive_smult)"], ["proof (prove)\ngoal (3 subgoals):\n 1. A \\<in> carrier_mat ?n ?n\n 2. positive A\n 3. 0 \\<le> complex_of_real c", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  positive A\n  0 \\<le> c\n\ngoal (3 subgoals):\n 1. A \\<in> carrier_mat ?n ?n\n 2. positive A\n 3. 0 \\<le> complex_of_real c", "by auto"], ["", "subsection \\<open>L\\\"{o}wner partial order\\<close>"], ["", "definition lowner_le :: \"complex mat \\<Rightarrow> complex mat \\<Rightarrow> bool\"  (infix \"\\<le>\\<^sub>L\" 50) where\n  \"A \\<le>\\<^sub>L B \\<longleftrightarrow> dim_row A = dim_row B \\<and> dim_col A = dim_col B \\<and> positive (B - A)\""], ["", "lemma lowner_le_refl:\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"A \\<le>\\<^sub>L A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L A", "unfolding lowner_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_row A \\<and>\n    dim_col A = dim_col A \\<and> positive (A - A)", "apply (simp add: minus_r_inv_mat[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (0\\<^sub>m n n)", "by (rule positive_zero)"], ["", "lemma lowner_le_antisym:\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n    and L1: \"A \\<le>\\<^sub>L B\" and L2: \"B \\<le>\\<^sub>L A\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "from L1"], ["proof (chain)\npicking this:\n  A \\<le>\\<^sub>L B", "have P1: \"positive (B - A)\""], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by (simp add: lowner_le_def)"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. A = B", "from L2"], ["proof (chain)\npicking this:\n  B \\<le>\\<^sub>L A", "have P2: \"positive (A - B)\""], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. positive (A - B)", "by (simp add: lowner_le_def)"], ["proof (state)\nthis:\n  positive (A - B)\n\ngoal (1 subgoal):\n 1. A = B", "have \"A - B = - (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B = - (B - A)", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A - B = - (B - A)", "by auto"], ["proof (state)\nthis:\n  A - B = - (B - A)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  A - B = - (B - A)", "have P3: \"positive (- (B - A))\""], ["proof (prove)\nusing this:\n  A - B = - (B - A)\n\ngoal (1 subgoal):\n 1. positive (- (B - A))", "using P2"], ["proof (prove)\nusing this:\n  A - B = - (B - A)\n  positive (A - B)\n\ngoal (1 subgoal):\n 1. positive (- (B - A))", "by auto"], ["proof (state)\nthis:\n  positive (- (B - A))\n\ngoal (1 subgoal):\n 1. A = B", "have BA: \"B - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = B", "have \"B - A = 0\\<^sub>m n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A = 0\\<^sub>m n n", "using BA"], ["proof (prove)\nusing this:\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B - A = 0\\<^sub>m n n", "by (subst positive_antisym[OF P1 P3], auto)"], ["proof (state)\nthis:\n  B - A = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  B - A = 0\\<^sub>m n n", "have \"B + (-A) + A = 0\\<^sub>m n n + A\""], ["proof (prove)\nusing this:\n  B - A = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. B + - A + A = 0\\<^sub>m n n + A", "using A B minus_add_uminus_mat[OF B A]"], ["proof (prove)\nusing this:\n  B - A = 0\\<^sub>m n n\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  B - A = B + - A\n\ngoal (1 subgoal):\n 1. B + - A + A = 0\\<^sub>m n n + A", "by auto"], ["proof (state)\nthis:\n  B + - A + A = 0\\<^sub>m n n + A\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  B + - A + A = 0\\<^sub>m n n + A", "have \"B + (-A + A) = 0\\<^sub>m n n + A\""], ["proof (prove)\nusing this:\n  B + - A + A = 0\\<^sub>m n n + A\n\ngoal (1 subgoal):\n 1. B + (- A + A) = 0\\<^sub>m n n + A", "using A B"], ["proof (prove)\nusing this:\n  B + - A + A = 0\\<^sub>m n n + A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B + (- A + A) = 0\\<^sub>m n n + A", "by auto"], ["proof (state)\nthis:\n  B + (- A + A) = 0\\<^sub>m n n + A\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  B + (- A + A) = 0\\<^sub>m n n + A", "show \"A = B\""], ["proof (prove)\nusing this:\n  B + (- A + A) = 0\\<^sub>m n n + A\n\ngoal (1 subgoal):\n 1. A = B", "using A B BA uminus_l_inv_mat[OF A]"], ["proof (prove)\nusing this:\n  B + (- A + A) = 0\\<^sub>m n n + A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  B - A \\<in> carrier_mat n n\n  - A + A = 0\\<^sub>m n n\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_inner_prod_le:\n  fixes A B :: \"complex mat\" and v :: \"complex vec\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n    and v: \"v \\<in> carrier_vec n\"\n    and \"A \\<le>\\<^sub>L B\"\n  shows \"inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "from assms"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A \\<le>\\<^sub>L B", "have \"positive (B-A)\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by (auto simp add: lowner_le_def)"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "with assms"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A \\<le>\\<^sub>L B\n  positive (B - A)", "have geq: \"inner_prod v ((B-A) *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A \\<le>\\<^sub>L B\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)", "unfolding positive_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  A \\<le>\\<^sub>L B\n  B - A \\<in> carrier_mat (dim_col (B - A)) (dim_col (B - A)) \\<and>\n  (\\<forall>v.\n      dim_vec v = dim_col (B - A) \\<longrightarrow>\n      0 \\<le> inner_prod v ((B - A) *\\<^sub>v v))\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "have \"inner_prod v ((B-A) *\\<^sub>v v) = inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v ((B - A) *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)", "unfolding minus_add_uminus_mat[OF B A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod v ((B + - A) *\\<^sub>v v) =\n    inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)", "by (subst add_mult_distrib_mat_vec[OF B _ v], insert A B v, auto simp add: inner_prod_distrib_right[OF v])"], ["proof (state)\nthis:\n  inner_prod v ((B - A) *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  inner_prod v ((B - A) *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)", "show ?thesis"], ["proof (prove)\nusing this:\n  inner_prod v ((B - A) *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "using geq"], ["proof (prove)\nusing this:\n  inner_prod v ((B - A) *\\<^sub>v v) =\n  inner_prod v (B *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n  0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_trans:\n  fixes A B C :: \"complex mat\"\n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\" and C: \"C \\<in> carrier_mat n n\"\n    and L1: \"A \\<le>\\<^sub>L B\" and L2: \"B \\<le>\\<^sub>L C\"\n  shows \"A \\<le>\\<^sub>L C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L C", "unfolding lowner_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_row C \\<and>\n    dim_col A = dim_col C \\<and> positive (C - A)", "proof (auto simp add: carrier_matD[OF A] carrier_matD[OF C])"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (C - A)", "have dim: \"C - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C - A \\<in> carrier_mat n n", "using A C"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. C - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  C - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (C - A)", "{"], ["proof (state)\nthis:\n  C - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (C - A)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (C - A)", "assume v: \"(v::complex vec) \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. positive (C - A)", "from L1"], ["proof (chain)\npicking this:\n  A \\<le>\\<^sub>L B", "have \"inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "using lowner_le_inner_prod_le A B v"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?v \\<in> carrier_vec ?n; ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?v (?A *\\<^sub>v ?v)\n                    \\<le> inner_prod ?v (?B *\\<^sub>v ?v)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "also"], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (B *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "from L2"], ["proof (chain)\npicking this:\n  B \\<le>\\<^sub>L C", "have \"\\<dots> \\<le> inner_prod v (C *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L C\n\ngoal (1 subgoal):\n 1. inner_prod v (B *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)", "using lowner_le_inner_prod_le B C v"], ["proof (prove)\nusing this:\n  B \\<le>\\<^sub>L C\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?v \\<in> carrier_vec ?n; ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?v (?A *\\<^sub>v ?v)\n                    \\<le> inner_prod ?v (?B *\\<^sub>v ?v)\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod v (B *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  inner_prod v (B *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "finally"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)", "have \"inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)", "."], ["proof (state)\nthis:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "then"], ["proof (chain)\npicking this:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)", "have \"inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  inner_prod v (A *\\<^sub>v v) \\<le> inner_prod v (C *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)", "have \"inner_prod v ((C - A) *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((C - A) *\\<^sub>v v)", "using A C v"], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod v (C *\\<^sub>v v) - inner_prod v (A *\\<^sub>v v)\n  A \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((C - A) *\\<^sub>v v)", "apply (subst minus_add_uminus_mat[OF C A])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> inner_prod v (C *\\<^sub>v v) -\n                     inner_prod v (A *\\<^sub>v v);\n     A \\<in> carrier_mat n n; C \\<in> carrier_mat n n;\n     v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> inner_prod v ((C + - A) *\\<^sub>v v)", "apply (subst add_mult_distrib_mat_vec[OF C _ v], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> inner_prod v (C *\\<^sub>v v) -\n                     inner_prod v (A *\\<^sub>v v);\n     A \\<in> carrier_mat n n; C \\<in> carrier_mat n n;\n     v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> inner_prod v (C *\\<^sub>v v + - A *\\<^sub>v v)", "apply (simp add: inner_prod_distrib_right[OF v])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v ((C - A) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((C - A) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "note leq = this"], ["proof (state)\nthis:\n  ?v2 \\<in> carrier_vec n \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((C - A) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive (C - A)", "show \"positive (C - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (C - A)", "unfolding positive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C - A \\<in> carrier_mat (dim_col (C - A)) (dim_col (C - A)) \\<and>\n    (\\<forall>v.\n        dim_vec v = dim_col (C - A) \\<longrightarrow>\n        0 \\<le> inner_prod v ((C - A) *\\<^sub>v v))", "apply (rule, simp add: carrier_matD[OF A] dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       dim_vec v = dim_col (C - A) \\<longrightarrow>\n       0 \\<le> inner_prod v ((C - A) *\\<^sub>v v)", "apply (subst carrier_matD[OF dim], insert leq, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  positive (C - A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_imp_trace_le:\n  assumes \"A \\<in> carrier_mat n n\" and \"B \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\"\n  shows \"trace A \\<le> trace B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "have \"positive (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (B - A)", "using assms lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by auto"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "moreover"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "have \"B - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "ultimately"], ["proof (chain)\npicking this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n", "have \"trace (B - A) \\<ge> 0\""], ["proof (prove)\nusing this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (B - A)", "using positive_trace"], ["proof (prove)\nusing this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace ?A\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (B - A)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace (B - A)\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "moreover"], ["proof (state)\nthis:\n  0 \\<le> trace (B - A)\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "have \"trace (B - A) = trace B - trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (B - A) = trace B - trace A", "using trace_minus_linear assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> trace (?A - ?B) = trace ?A - trace ?B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. trace (B - A) = trace B - trace A", "by auto"], ["proof (state)\nthis:\n  trace (B - A) = trace B - trace A\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> trace (B - A)\n  trace (B - A) = trace B - trace A", "have \"trace B - trace A \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> trace (B - A)\n  trace (B - A) = trace B - trace A\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace B - trace A", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace B - trace A\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "then"], ["proof (chain)\npicking this:\n  0 \\<le> trace B - trace A", "show \"trace A \\<le> trace B\""], ["proof (prove)\nusing this:\n  0 \\<le> trace B - trace A\n\ngoal (1 subgoal):\n 1. trace A \\<le> trace B", "by auto"], ["proof (state)\nthis:\n  trace A \\<le> trace B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_add:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\" \"C \\<le>\\<^sub>L D\"\n  shows \"A + C \\<le>\\<^sub>L B + D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + C \\<le>\\<^sub>L B + D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A + C \\<le>\\<^sub>L B + D", "have \"B + D - (A + C) = B - A + (D - C) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. B + D - (A + C) = B - A + (D - C)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n\ngoal (1 subgoal):\n 1. B + D - (A + C) = B - A + (D - C)", "by auto"], ["proof (state)\nthis:\n  B + D - (A + C) = B - A + (D - C)\n\ngoal (1 subgoal):\n 1. A + C \\<le>\\<^sub>L B + D", "then"], ["proof (chain)\npicking this:\n  B + D - (A + C) = B - A + (D - C)", "have \"positive (B + D - (A + C))\""], ["proof (prove)\nusing this:\n  B + D - (A + C) = B - A + (D - C)\n\ngoal (1 subgoal):\n 1. positive (B + D - (A + C))", "using assms"], ["proof (prove)\nusing this:\n  B + D - (A + C) = B - A + (D - C)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n\ngoal (1 subgoal):\n 1. positive (B + D - (A + C))", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  B + D - (A + C) = B - A + (D - C)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  dim_row A = dim_row B \\<and> dim_col A = dim_col B \\<and> positive (B - A)\n  dim_row C = dim_row D \\<and> dim_col C = dim_col D \\<and> positive (D - C)\n\ngoal (1 subgoal):\n 1. positive (B + D - (A + C))", "using positive_add"], ["proof (prove)\nusing this:\n  B + D - (A + C) = B - A + (D - C)\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  dim_row A = dim_row B \\<and> dim_col A = dim_col B \\<and> positive (B - A)\n  dim_row C = dim_row D \\<and> dim_col C = dim_col D \\<and> positive (D - C)\n  \\<lbrakk>positive ?A; positive ?B; ?A \\<in> carrier_mat ?n ?n;\n   ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> positive (?A + ?B)\n\ngoal (1 subgoal):\n 1. positive (B + D - (A + C))", "by (metis minus_carrier_mat)"], ["proof (state)\nthis:\n  positive (B + D - (A + C))\n\ngoal (1 subgoal):\n 1. A + C \\<le>\\<^sub>L B + D", "then"], ["proof (chain)\npicking this:\n  positive (B + D - (A + C))", "show \"A + C \\<le>\\<^sub>L B + D\""], ["proof (prove)\nusing this:\n  positive (B + D - (A + C))\n\ngoal (1 subgoal):\n 1. A + C \\<le>\\<^sub>L B + D", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (B + D - (A + C))\n\ngoal (1 subgoal):\n 1. dim_row (A + C) = dim_row (B + D) \\<and>\n    dim_col (A + C) = dim_col (B + D) \\<and> positive (B + D - (A + C))", "using assms"], ["proof (prove)\nusing this:\n  positive (B + D - (A + C))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n\ngoal (1 subgoal):\n 1. dim_row (A + C) = dim_row (B + D) \\<and>\n    dim_col (A + C) = dim_col (B + D) \\<and> positive (B + D - (A + C))", "by fastforce"], ["proof (state)\nthis:\n  A + C \\<le>\\<^sub>L B + D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_swap:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \n    and \"A \\<le>\\<^sub>L B\" \n  shows \"-B \\<le>\\<^sub>L -A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "have \"positive (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (B - A)", "using assms lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by fastforce"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "moreover"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "have \"B - A = (-A) - (-B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A = - A - - B", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. B - A = - A - - B", "by fastforce"], ["proof (state)\nthis:\n  B - A = - A - - B\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "ultimately"], ["proof (chain)\npicking this:\n  positive (B - A)\n  B - A = - A - - B", "have \"positive ((-A) - (-B))\""], ["proof (prove)\nusing this:\n  positive (B - A)\n  B - A = - A - - B\n\ngoal (1 subgoal):\n 1. positive (- A - - B)", "by auto"], ["proof (state)\nthis:\n  positive (- A - - B)\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "then"], ["proof (chain)\npicking this:\n  positive (- A - - B)", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (- A - - B)\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "using lowner_le_def assms"], ["proof (prove)\nusing this:\n  positive (- A - - B)\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. - B \\<le>\\<^sub>L - A", "by fastforce"], ["proof (state)\nthis:\n  - B \\<le>\\<^sub>L - A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_minus:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"C \\<in> carrier_mat n n\" \"D \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\" \"C \\<le>\\<^sub>L D\"\n  shows \"A - D \\<le>\\<^sub>L B - C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "have \"positive (D - C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (D - C)", "using assms lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (D - C)", "by auto"], ["proof (state)\nthis:\n  positive (D - C)\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "then"], ["proof (chain)\npicking this:\n  positive (D - C)", "have \"-D \\<le>\\<^sub>L -C\""], ["proof (prove)\nusing this:\n  positive (D - C)\n\ngoal (1 subgoal):\n 1. - D \\<le>\\<^sub>L - C", "using lowner_le_swap assms"], ["proof (prove)\nusing this:\n  positive (D - C)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?A \\<le>\\<^sub>L ?B\\<rbrakk>\n  \\<Longrightarrow> - ?B \\<le>\\<^sub>L - ?A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n\ngoal (1 subgoal):\n 1. - D \\<le>\\<^sub>L - C", "by auto"], ["proof (state)\nthis:\n  - D \\<le>\\<^sub>L - C\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "then"], ["proof (chain)\npicking this:\n  - D \\<le>\\<^sub>L - C", "have \"A + (-D) \\<le>\\<^sub>L B + (-C)\""], ["proof (prove)\nusing this:\n  - D \\<le>\\<^sub>L - C\n\ngoal (1 subgoal):\n 1. A + - D \\<le>\\<^sub>L B + - C", "using lowner_le_add[of \"A\" n  \"B\"] assms"], ["proof (prove)\nusing this:\n  - D \\<le>\\<^sub>L - C\n  \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n   ?C \\<in> carrier_mat n n; ?D \\<in> carrier_mat n n; A \\<le>\\<^sub>L B;\n   ?C \\<le>\\<^sub>L ?D\\<rbrakk>\n  \\<Longrightarrow> A + ?C \\<le>\\<^sub>L B + ?D\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  C \\<le>\\<^sub>L D\n\ngoal (1 subgoal):\n 1. A + - D \\<le>\\<^sub>L B + - C", "by auto"], ["proof (state)\nthis:\n  A + - D \\<le>\\<^sub>L B + - C\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "moreover"], ["proof (state)\nthis:\n  A + - D \\<le>\\<^sub>L B + - C\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "have \"A + (-D) = A - D\" and \"B + (-C) = B - C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + - D = A - D &&& B + - C = B - C", "by auto"], ["proof (state)\nthis:\n  A + - D = A - D\n  B + - C = B - C\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "ultimately"], ["proof (chain)\npicking this:\n  A + - D \\<le>\\<^sub>L B + - C\n  A + - D = A - D\n  B + - C = B - C", "show ?thesis"], ["proof (prove)\nusing this:\n  A + - D \\<le>\\<^sub>L B + - C\n  A + - D = A - D\n  B + - C = B - C\n\ngoal (1 subgoal):\n 1. A - D \\<le>\\<^sub>L B - C", "by auto"], ["proof (state)\nthis:\n  A - D \\<le>\\<^sub>L B - C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma outer_prod_le_one:\n  assumes \"v \\<in> carrier_vec n\"\n    and \"inner_prod v v \\<le> 1\"\n  shows \"outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "let ?o = \"outer_prod v v\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have do: \"?o \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  inner_prod v v \\<le> 1\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "{"], ["proof (state)\nthis:\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "fix u :: \"complex vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "assume \"dim_vec u = n\""], ["proof (state)\nthis:\n  dim_vec u = n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  dim_vec u = n", "have du: \"u \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  dim_vec u = n\n\ngoal (1 subgoal):\n 1. u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have r: \"inner_prod u u \\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u u \\<in> \\<real>", "apply (simp add: scalar_prod_def carrier_vecD[OF du])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. u $ i * cnj (u $ i)) \\<in> \\<real>", "using complex_In_mult_cnj_zero complex_is_Real_iff"], ["proof (prove)\nusing this:\n  Im (?z * cnj ?z) = 0\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. u $ i * cnj (u $ i)) \\<in> \\<real>", "by blast"], ["proof (state)\nthis:\n  inner_prod u u \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have geq0: \"inner_prod u u \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod u u", "using self_cscalar_prod_geq_0"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> inner_prod ?v ?v\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod u u", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"inner_prod u (?o *\\<^sub>v u) = inner_prod u v * inner_prod v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (outer_prod v v *\\<^sub>v u) =\n    inner_prod u v * inner_prod v u", "apply (subst inner_prod_outer_prod)"], ["proof (prove)\ngoal (5 subgoals):\n 1. u \\<in> carrier_vec ?n\n 2. v \\<in> carrier_vec ?n\n 3. v \\<in> carrier_vec ?m\n 4. u \\<in> carrier_vec ?m\n 5. inner_prod u v * inner_prod v u = inner_prod u v * inner_prod v u", "using du assms"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  inner_prod v v \\<le> 1\n\ngoal (5 subgoals):\n 1. u \\<in> carrier_vec ?n\n 2. v \\<in> carrier_vec ?n\n 3. v \\<in> carrier_vec ?m\n 4. u \\<in> carrier_vec ?m\n 5. inner_prod u v * inner_prod v u = inner_prod u v * inner_prod v u", "by auto"], ["proof (state)\nthis:\n  inner_prod u (outer_prod v v *\\<^sub>v u) =\n  inner_prod u v * inner_prod v u\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  inner_prod u (outer_prod v v *\\<^sub>v u) =\n  inner_prod u v * inner_prod v u\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"\\<dots> \\<le> inner_prod u u * inner_prod v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u v * inner_prod v u \\<le> inner_prod u u * inner_prod v v", "using Cauchy_Schwarz_complex_vec du assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier_vec ?n; ?y \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?x ?y * inner_prod ?y ?x\n                    \\<le> inner_prod ?x ?x * inner_prod ?y ?y\n  u \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n  inner_prod v v \\<le> 1\n\ngoal (1 subgoal):\n 1. inner_prod u v * inner_prod v u \\<le> inner_prod u u * inner_prod v v", "by auto"], ["proof (state)\nthis:\n  inner_prod u v * inner_prod v u \\<le> inner_prod u u * inner_prod v v\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  inner_prod u v * inner_prod v u \\<le> inner_prod u u * inner_prod v v\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"\\<dots> \\<le> inner_prod u u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u u * inner_prod v v \\<le> inner_prod u u", "using assms(2) r geq0"], ["proof (prove)\nusing this:\n  inner_prod v v \\<le> 1\n  inner_prod u u \\<in> \\<real>\n  0 \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. inner_prod u u * inner_prod v v \\<le> inner_prod u u", "by (simp add: mult_right_le_one_le)"], ["proof (state)\nthis:\n  inner_prod u u * inner_prod v v \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  inner_prod u (outer_prod v v *\\<^sub>v u) \\<le> inner_prod u u", "have le: \"inner_prod u (?o *\\<^sub>v u) \\<le> inner_prod u u\""], ["proof (prove)\nusing this:\n  inner_prod u (outer_prod v v *\\<^sub>v u) \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. inner_prod u (outer_prod v v *\\<^sub>v u) \\<le> inner_prod u u", "."], ["proof (state)\nthis:\n  inner_prod u (outer_prod v v *\\<^sub>v u) \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"inner_prod u ((1\\<^sub>m n - ?o) *\\<^sub>v u) = inner_prod u ((1\\<^sub>m n *\\<^sub>v u) - ?o *\\<^sub>v u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u) =\n    inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u)", "apply (subst minus_mult_distrib_mat_vec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1\\<^sub>m n \\<in> carrier_mat ?nr ?nc\n 2. outer_prod v v \\<in> carrier_mat ?nr ?nc\n 3. u \\<in> carrier_vec ?nc\n 4. inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u) =\n    inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u)", "using do du"], ["proof (prove)\nusing this:\n  outer_prod v v \\<in> carrier_mat n n\n  u \\<in> carrier_vec n\n\ngoal (4 subgoals):\n 1. 1\\<^sub>m n \\<in> carrier_mat ?nr ?nc\n 2. outer_prod v v \\<in> carrier_mat ?nr ?nc\n 3. u \\<in> carrier_vec ?nc\n 4. inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u) =\n    inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u) =\n  inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u) =\n  inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"\\<dots> = inner_prod u u - inner_prod u (?o *\\<^sub>v u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u) =\n    inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)", "apply (subst inner_prod_minus_distrib_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. u \\<in> carrier_vec ?n\n 2. 1\\<^sub>m n *\\<^sub>v u \\<in> carrier_vec ?n\n 3. outer_prod v v *\\<^sub>v u \\<in> carrier_vec ?n\n 4. inner_prod u (1\\<^sub>m n *\\<^sub>v u) -\n    inner_prod u (outer_prod v v *\\<^sub>v u) =\n    inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)", "using du do"], ["proof (prove)\nusing this:\n  u \\<in> carrier_vec n\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (4 subgoals):\n 1. u \\<in> carrier_vec ?n\n 2. 1\\<^sub>m n *\\<^sub>v u \\<in> carrier_vec ?n\n 3. outer_prod v v *\\<^sub>v u \\<in> carrier_vec ?n\n 4. inner_prod u (1\\<^sub>m n *\\<^sub>v u) -\n    inner_prod u (outer_prod v v *\\<^sub>v u) =\n    inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u) =\n  inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  inner_prod u (1\\<^sub>m n *\\<^sub>v u - outer_prod v v *\\<^sub>v u) =\n  inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)", "using le"], ["proof (prove)\nusing this:\n  inner_prod u (outer_prod v v *\\<^sub>v u) \\<le> inner_prod u u\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod u u - inner_prod u (outer_prod v v *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u)", "have \"inner_prod u ((1\\<^sub>m n - ?o) *\\<^sub>v u) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod u ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v u)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "}"], ["proof (state)\nthis:\n  dim_vec ?u2 = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?u2 ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v ?u2)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  dim_vec ?u2 = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?u2 ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v ?u2)", "have \"positive (1\\<^sub>m n - outer_prod v v)\""], ["proof (prove)\nusing this:\n  dim_vec ?u2 = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?u2 ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v ?u2)\n\ngoal (1 subgoal):\n 1. positive (1\\<^sub>m n - outer_prod v v)", "unfolding positive_def"], ["proof (prove)\nusing this:\n  dim_vec ?u2 = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?u2 ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v ?u2)\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n - outer_prod v v\n    \\<in> carrier_mat (dim_col (1\\<^sub>m n - outer_prod v v))\n           (dim_col (1\\<^sub>m n - outer_prod v v)) \\<and>\n    (\\<forall>va.\n        dim_vec va =\n        dim_col (1\\<^sub>m n - outer_prod v v) \\<longrightarrow>\n        0 \\<le> inner_prod va ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v va))", "using do"], ["proof (prove)\nusing this:\n  dim_vec ?u2 = n \\<Longrightarrow>\n  0 \\<le> inner_prod ?u2 ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v ?u2)\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m n - outer_prod v v\n    \\<in> carrier_mat (dim_col (1\\<^sub>m n - outer_prod v v))\n           (dim_col (1\\<^sub>m n - outer_prod v v)) \\<and>\n    (\\<forall>va.\n        dim_vec va =\n        dim_col (1\\<^sub>m n - outer_prod v v) \\<longrightarrow>\n        0 \\<le> inner_prod va ((1\\<^sub>m n - outer_prod v v) *\\<^sub>v va))", "by auto"], ["proof (state)\nthis:\n  positive (1\\<^sub>m n - outer_prod v v)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "then"], ["proof (chain)\npicking this:\n  positive (1\\<^sub>m n - outer_prod v v)", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m n - outer_prod v v)\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m n - outer_prod v v)\n\ngoal (1 subgoal):\n 1. dim_row (outer_prod v v) = dim_row (1\\<^sub>m n) \\<and>\n    dim_col (outer_prod v v) = dim_col (1\\<^sub>m n) \\<and>\n    positive (1\\<^sub>m n - outer_prod v v)", "using do"], ["proof (prove)\nusing this:\n  positive (1\\<^sub>m n - outer_prod v v)\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row (outer_prod v v) = dim_row (1\\<^sub>m n) \\<and>\n    dim_col (outer_prod v v) = dim_col (1\\<^sub>m n) \\<and>\n    positive (1\\<^sub>m n - outer_prod v v)", "by auto"], ["proof (state)\nthis:\n  outer_prod v v \\<le>\\<^sub>L 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_lowner_le_positiveD:\n  fixes A :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and le: \"0\\<^sub>m n n \\<le>\\<^sub>L A\"\n  shows \"positive A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  0\\<^sub>m n n \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. positive A", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  dim_row (0\\<^sub>m n n) = dim_row A \\<and>\n  dim_col (0\\<^sub>m n n) = dim_col A \\<and> positive (A - 0\\<^sub>m n n)\n\ngoal (1 subgoal):\n 1. positive A", "by (subgoal_tac \"A - 0\\<^sub>m n n = A\", auto)"], ["", "lemma zero_lowner_le_positiveI:\n  fixes A :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and le: \"positive A\"\n  shows \"0\\<^sub>m n n \\<le>\\<^sub>L A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  positive A\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L A", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  positive A\n\ngoal (1 subgoal):\n 1. dim_row (0\\<^sub>m n n) = dim_row A \\<and>\n    dim_col (0\\<^sub>m n n) = dim_col A \\<and> positive (A - 0\\<^sub>m n n)", "by (subgoal_tac \"A - 0\\<^sub>m n n = A\", auto)"], ["", "lemma lowner_le_trans_positiveI:\n  fixes A B :: \"complex mat\"\n  assumes dA: \"A \\<in> carrier_mat n n\" and pA: \"positive A\" and le: \"A \\<le>\\<^sub>L B\"\n  shows \"positive B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive B", "have dB: \"B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "using le dA lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  A \\<in> carrier_mat n n\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive B", "have \"0\\<^sub>m n n \\<le>\\<^sub>L A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L A", "using zero_lowner_le_positiveI dA pA"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; positive ?A\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>m ?n ?n \\<le>\\<^sub>L ?A\n  A \\<in> carrier_mat n n\n  positive A\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L A", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>m n n \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. positive B", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>m n n \\<le>\\<^sub>L A", "have \"0\\<^sub>m n n \\<le>\\<^sub>L B\""], ["proof (prove)\nusing this:\n  0\\<^sub>m n n \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L B", "using dA dB le"], ["proof (prove)\nusing this:\n  0\\<^sub>m n n \\<le>\\<^sub>L A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m n n \\<le>\\<^sub>L B", "by (simp add: lowner_le_trans[of _ n A B])"], ["proof (state)\nthis:\n  0\\<^sub>m n n \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive B", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>m n n \\<le>\\<^sub>L B", "show ?thesis"], ["proof (prove)\nusing this:\n  0\\<^sub>m n n \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive B", "using dB zero_lowner_le_positiveD"], ["proof (prove)\nusing this:\n  0\\<^sub>m n n \\<le>\\<^sub>L B\n  B \\<in> carrier_mat n n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   0\\<^sub>m ?n ?n \\<le>\\<^sub>L ?A\\<rbrakk>\n  \\<Longrightarrow> positive ?A\n\ngoal (1 subgoal):\n 1. positive B", "by auto"], ["proof (state)\nthis:\n  positive B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_keep_under_measurement:\n  fixes M A B :: \"complex mat\"\n  assumes dM: \"M \\<in> carrier_mat n n\" and dA: \"A \\<in> carrier_mat n n\" and dB: \"B \\<in> carrier_mat n n\"\n    and le: \"A \\<le>\\<^sub>L B\"\n  shows \"adjoint M * A * M \\<le>\\<^sub>L adjoint M * B * M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M * A * M \\<le>\\<^sub>L adjoint M * B * M", "unfolding lowner_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (adjoint M * A * M) = dim_row (adjoint M * B * M) \\<and>\n    dim_col (adjoint M * A * M) = dim_col (adjoint M * B * M) \\<and>\n    positive (adjoint M * B * M - adjoint M * A * M)", "proof (rule conjI, fastforce)+"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "have daM: \"adjoint M \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat n n", "using dM"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint M \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  adjoint M \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "have dBmA: \"B - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "using dB dA"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "by fastforce"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "have \"positive (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (B - A)", "using le lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by auto"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "then"], ["proof (chain)\npicking this:\n  positive (B - A)", "have p: \"positive (adjoint M * (B - A) * M)\""], ["proof (prove)\nusing this:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. positive (adjoint M * (B - A) * M)", "using positive_close_under_left_right_mult_adjoint[OF daM dBmA] adjoint_adjoint[of M]"], ["proof (prove)\nusing this:\n  positive (B - A)\n  positive (B - A) \\<Longrightarrow>\n  positive (adjoint M * (B - A) * adjoint (adjoint M))\n  adjoint (adjoint M) = M\n\ngoal (1 subgoal):\n 1. positive (adjoint M * (B - A) * M)", "by auto"], ["proof (state)\nthis:\n  positive (adjoint M * (B - A) * M)\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "moreover"], ["proof (state)\nthis:\n  positive (adjoint M * (B - A) * M)\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "have e: \"adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M", "using dM dB dA"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M", "by (mat_assoc n)"], ["proof (state)\nthis:\n  adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "ultimately"], ["proof (chain)\npicking this:\n  positive (adjoint M * (B - A) * M)\n  adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M", "show \"positive (adjoint M * B * M - adjoint M * A * M)\""], ["proof (prove)\nusing this:\n  positive (adjoint M * (B - A) * M)\n  adjoint M * (B - A) * M = adjoint M * B * M - adjoint M * A * M\n\ngoal (1 subgoal):\n 1. positive (adjoint M * B * M - adjoint M * A * M)", "by auto"], ["proof (state)\nthis:\n  positive (adjoint M * B * M - adjoint M * A * M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_distrib_left_minus_mat:\n  fixes A B :: \"'a::comm_ring_1 mat\"\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A", "by (auto simp add: minus_add_uminus_mat add_smult_distrib_left_mat)"], ["", "lemma lowner_le_smultc:\n  fixes c :: complex\n  assumes \"c \\<ge> 0\" \"A \\<le>\\<^sub>L B\" \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "have eqBA: \"c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> c\n  A \\<le>\\<^sub>L B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A", "by (auto simp add: smult_distrib_left_minus_mat)"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "have \"positive (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (B - A)", "using assms(2)"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive (B - A)", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  dim_row A = dim_row B \\<and> dim_col A = dim_col B \\<and> positive (B - A)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by auto"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "then"], ["proof (chain)\npicking this:\n  positive (B - A)", "have \"positive (c \\<cdot>\\<^sub>m (B - A))\""], ["proof (prove)\nusing this:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m (B - A))", "using positive_smult[of \"B-A\" n c] assms"], ["proof (prove)\nusing this:\n  positive (B - A)\n  \\<lbrakk>B - A \\<in> carrier_mat n n; positive (B - A); 0 \\<le> c\\<rbrakk>\n  \\<Longrightarrow> positive (c \\<cdot>\\<^sub>m (B - A))\n  0 \\<le> c\n  A \\<le>\\<^sub>L B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (c \\<cdot>\\<^sub>m (B - A))", "by fastforce"], ["proof (state)\nthis:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "moreover"], ["proof (state)\nthis:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "have \"c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n", "using index_smult_mat(2,3) assms(3)"], ["proof (prove)\nusing this:\n  dim_row (?a \\<cdot>\\<^sub>m ?A) = dim_row ?A\n  dim_col (?a \\<cdot>\\<^sub>m ?A) = dim_col ?A\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "moreover"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "have \"c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n", "using index_smult_mat(2,3) assms(4)"], ["proof (prove)\nusing this:\n  dim_row (?a \\<cdot>\\<^sub>m ?A) = dim_row ?A\n  dim_col (?a \\<cdot>\\<^sub>m ?A) = dim_col ?A\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "ultimately"], ["proof (chain)\npicking this:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n", "show ?thesis"], ["proof (prove)\nusing this:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B", "unfolding lowner_le_def"], ["proof (prove)\nusing this:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row (c \\<cdot>\\<^sub>m A) = dim_row (c \\<cdot>\\<^sub>m B) \\<and>\n    dim_col (c \\<cdot>\\<^sub>m A) = dim_col (c \\<cdot>\\<^sub>m B) \\<and>\n    positive (c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A)", "using eqBA"], ["proof (prove)\nusing this:\n  positive (c \\<cdot>\\<^sub>m (B - A))\n  c \\<cdot>\\<^sub>m A \\<in> carrier_mat n n\n  c \\<cdot>\\<^sub>m B \\<in> carrier_mat n n\n  c \\<cdot>\\<^sub>m (B - A) = c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A\n\ngoal (1 subgoal):\n 1. dim_row (c \\<cdot>\\<^sub>m A) = dim_row (c \\<cdot>\\<^sub>m B) \\<and>\n    dim_col (c \\<cdot>\\<^sub>m A) = dim_col (c \\<cdot>\\<^sub>m B) \\<and>\n    positive (c \\<cdot>\\<^sub>m B - c \\<cdot>\\<^sub>m A)", "by fastforce"], ["proof (state)\nthis:\n  c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_smult:\n  fixes c :: real\n  assumes \"c \\<ge> 0\" \"A \\<le>\\<^sub>L B\" \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\"\n  shows \"c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L c \\<cdot>\\<^sub>m B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real c \\<cdot>\\<^sub>m A \\<le>\\<^sub>L\n    complex_of_real c \\<cdot>\\<^sub>m B", "apply (rule lowner_le_smultc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> complex_of_real c\n 2. A \\<le>\\<^sub>L B\n 3. A \\<in> carrier_mat ?n ?n\n 4. B \\<in> carrier_mat ?n ?n", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> c\n  A \\<le>\\<^sub>L B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (4 subgoals):\n 1. 0 \\<le> complex_of_real c\n 2. A \\<le>\\<^sub>L B\n 3. A \\<in> carrier_mat ?n ?n\n 4. B \\<in> carrier_mat ?n ?n", "by auto"], ["", "lemma minus_smult_vec_distrib:\n  fixes w :: \"'a::comm_ring_1 vec\"\n  shows \"(a - b) \\<cdot>\\<^sub>v w = a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - b) \\<cdot>\\<^sub>v w = a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w) \\<Longrightarrow>\n       ((a - b) \\<cdot>\\<^sub>v w) $ i =\n       (a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w) $ i\n 2. dim_vec ((a - b) \\<cdot>\\<^sub>v w) =\n    dim_vec (a \\<cdot>\\<^sub>v w - b \\<cdot>\\<^sub>v w)", "by (auto simp add: scalar_prod_def algebra_simps)"], ["", "lemma smult_mat_mult_mat_vec_assoc:\n  fixes A :: \"'a::comm_ring_1 mat\"\n  assumes A: \"A \\<in> carrier_mat n m\" and w: \"w \\<in> carrier_vec m\"\n  shows \"a \\<cdot>\\<^sub>m A *\\<^sub>v w = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m A *\\<^sub>v w = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w)) \\<Longrightarrow>\n       (a \\<cdot>\\<^sub>m A *\\<^sub>v w) $ i =\n       (a \\<cdot>\\<^sub>v (A *\\<^sub>v w)) $ i\n 2. dim_vec (a \\<cdot>\\<^sub>m A *\\<^sub>v w) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (simp add: scalar_prod_def carrier_matD[OF A] carrier_vecD[OF w])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       (\\<Sum>ia = 0..<m. a * A $$ (i, ia) * w $ ia) =\n       a * (\\<Sum>ia = 0..<m. A $$ (i, ia) * w $ ia)\n 2. dim_vec (a \\<cdot>\\<^sub>m A *\\<^sub>v w) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (subst sum_distrib_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       (\\<Sum>ia = 0..<m. a * A $$ (i, ia) * w $ ia) =\n       (\\<Sum>n = 0..<m. a * (A $$ (i, n) * w $ n))\n 2. dim_vec (a \\<cdot>\\<^sub>m A *\\<^sub>v w) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (rule sum.cong, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < n; x \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> a * A $$ (i, x) * w $ x = a * (A $$ (i, x) * w $ x)\n 2. dim_vec (a \\<cdot>\\<^sub>m A *\\<^sub>v w) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "by auto"], ["", "lemma mult_mat_vec_smult_vec_assoc:\n  fixes A :: \"'a::comm_ring_1 mat\"\n  assumes A: \"A \\<in> carrier_mat n m\" and w: \"w \\<in> carrier_vec m\"\n  shows \"A *\\<^sub>v (a \\<cdot>\\<^sub>v w) = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v (a \\<cdot>\\<^sub>v w) = a \\<cdot>\\<^sub>v (A *\\<^sub>v w)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w)) \\<Longrightarrow>\n       (A *\\<^sub>v (a \\<cdot>\\<^sub>v w)) $ i =\n       (a \\<cdot>\\<^sub>v (A *\\<^sub>v w)) $ i\n 2. dim_vec (A *\\<^sub>v (a \\<cdot>\\<^sub>v w)) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (simp add: scalar_prod_def carrier_matD[OF A] carrier_vecD[OF w])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       (\\<Sum>ia = 0..<m. A $$ (i, ia) * (a * w $ ia)) =\n       a * (\\<Sum>ia = 0..<m. A $$ (i, ia) * w $ ia)\n 2. dim_vec (A *\\<^sub>v (a \\<cdot>\\<^sub>v w)) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (subst sum_distrib_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       (\\<Sum>ia = 0..<m. A $$ (i, ia) * (a * w $ ia)) =\n       (\\<Sum>n = 0..<m. a * (A $$ (i, n) * w $ n))\n 2. dim_vec (A *\\<^sub>v (a \\<cdot>\\<^sub>v w)) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "apply (rule sum.cong, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < n; x \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, x) * (a * w $ x) =\n                         a * (A $$ (i, x) * w $ x)\n 2. dim_vec (A *\\<^sub>v (a \\<cdot>\\<^sub>v w)) =\n    dim_vec (a \\<cdot>\\<^sub>v (A *\\<^sub>v w))", "by auto"], ["", "lemma outer_prod_left_right_mat:\n  fixes A B :: \"complex mat\"\n  assumes du: \"u \\<in> carrier_vec d2\" and dv: \"v \\<in> carrier_vec d3\"\n    and dA: \"A \\<in> carrier_mat d1 d2\" and dB: \"B \\<in> carrier_mat d3 d4\"\n  shows \"A * (outer_prod u v) * B = (outer_prod (A *\\<^sub>v u) (adjoint B *\\<^sub>v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * outer_prod u v * B =\n    outer_prod (A *\\<^sub>v u) (adjoint B *\\<^sub>v v)", "unfolding outer_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "have eq1: \"A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)) = mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat (dim_vec (A *\\<^sub>v u)) 1\n                       (\\<lambda>(i, j). (A *\\<^sub>v u) $ i));\n        j < dim_col\n             (mat (dim_vec (A *\\<^sub>v u)) 1\n               (\\<lambda>(i, j). (A *\\<^sub>v u) $ i))\\<rbrakk>\n       \\<Longrightarrow> (A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)) $$\n                         (i, j) =\n                         mat (dim_vec (A *\\<^sub>v u)) 1\n                          (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) $$\n                         (i, j)\n 2. dim_row (A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)) =\n    dim_row\n     (mat (dim_vec (A *\\<^sub>v u)) 1\n       (\\<lambda>(i, j). (A *\\<^sub>v u) $ i))\n 3. dim_col (A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)) =\n    dim_col\n     (mat (dim_vec (A *\\<^sub>v u)) 1\n       (\\<lambda>(i, j). (A *\\<^sub>v u) $ i))", "by (auto simp add: dA du scalar_prod_def)"], ["proof (state)\nthis:\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) =\n  mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "have conj: \"conjugate a * b = conjugate ((a::complex) * conjugate b) \" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate a * b = conjugate (a * conjugate b)", "by auto"], ["proof (state)\nthis:\n  conjugate ?a * ?b = conjugate (?a * conjugate ?b)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "have eq2: \"mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B = mat 1 (dim_vec (adjoint B *\\<^sub>v v)) (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B =\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n                       (\\<lambda>(i, y).\n                           conjugate (adjoint B *\\<^sub>v v) $ y));\n        j < dim_col\n             (mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n               (\\<lambda>(i, y).\n                   conjugate (adjoint B *\\<^sub>v v) $ y))\\<rbrakk>\n       \\<Longrightarrow> (mat 1 (dim_vec v)\n                           (\\<lambda>(i, y). conjugate v $ y) *\n                          B) $$\n                         (i, j) =\n                         mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n                          (\\<lambda>(i, y).\n                              conjugate (adjoint B *\\<^sub>v v) $ y) $$\n                         (i, j)\n 2. dim_row (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B) =\n    dim_row\n     (mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n       (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y))\n 3. dim_col (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B) =\n    dim_col\n     (mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n       (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y))", "apply (auto simp add: carrier_matD[OF dB] carrier_vecD[OF dv] scalar_prod_def adjoint_def conjugate_vec_def sum_conjugate )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < d4 \\<Longrightarrow>\n       (\\<Sum>i = 0..<d3. cnj (v $ i) * B $$ (i, j)) =\n       (\\<Sum>x = 0..<d3. B $$ (x, j) * cnj (v $ x))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j. j < d4 \\<Longrightarrow> {0..<d3} = {0..<d3}\n 2. \\<And>j x.\n       \\<lbrakk>j < d4; x \\<in> {0..<d3}\\<rbrakk>\n       \\<Longrightarrow> cnj (v $ x) * B $$ (x, j) =\n                         B $$ (x, j) * cnj (v $ x)", "by (auto simp add: conj)"], ["proof (state)\nthis:\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B =\n  mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n   (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "have \"A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) * mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) * B =\n       (A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i))) *(mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n    B", "using dA du dv dB assoc_mult_mat[OF dA, of \"mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)\" 1 \"mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)\"]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat d1 d2\n  u \\<in> carrier_vec d2\n  v \\<in> carrier_vec d3\n  B \\<in> carrier_mat d3 d4\n  \\<lbrakk>mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)\n           \\<in> carrier_mat d2 1;\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)\n   \\<in> carrier_mat 1 ?n\\<^sub>4\\<rbrakk>\n  \\<Longrightarrow> A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n                    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) =\n                    A *\n                    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n                     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y))\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n    B", "by fastforce"], ["proof (state)\nthis:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n  B\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "also"], ["proof (state)\nthis:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n  B\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "have \"\\<dots> = (A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i))) *((mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n    B =\n    A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)", "using dA du dv dB assoc_mult_mat[OF _ _ dB, of \"(A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)))\" d1 1]"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat d1 d2\n  u \\<in> carrier_vec d2\n  v \\<in> carrier_vec d3\n  B \\<in> carrier_mat d3 d4\n  \\<lbrakk>A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i)\n           \\<in> carrier_mat d1 1;\n   ?B \\<in> carrier_mat 1 d3\\<rbrakk>\n  \\<Longrightarrow> A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) * ?B *\n                    B =\n                    A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n                    (?B * B)\n\ngoal (1 subgoal):\n 1. A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n    B =\n    A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n    (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)", "by fastforce"], ["proof (state)\nthis:\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "finally"], ["proof (chain)\npicking this:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)", "show \"A * (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) * mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) * B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) * mat 1 (dim_vec (adjoint B *\\<^sub>v v)) (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)\""], ["proof (prove)\nusing this:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "using eq1 eq2"], ["proof (prove)\nusing this:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n  (mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B)\n  A * mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) =\n  mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i)\n  mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y) * B =\n  mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n   (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)\n\ngoal (1 subgoal):\n 1. A *\n    (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n     mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n    B =\n    mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n    mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n     (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)", "by auto"], ["proof (state)\nthis:\n  A *\n  (mat (dim_vec u) 1 (\\<lambda>(i, j). u $ i) *\n   mat 1 (dim_vec v) (\\<lambda>(i, y). conjugate v $ y)) *\n  B =\n  mat (dim_vec (A *\\<^sub>v u)) 1 (\\<lambda>(i, j). (A *\\<^sub>v u) $ i) *\n  mat 1 (dim_vec (adjoint B *\\<^sub>v v))\n   (\\<lambda>(i, y). conjugate (adjoint B *\\<^sub>v v) $ y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Density operators\\<close>"], ["", "definition density_operator :: \"complex mat \\<Rightarrow> bool\" where\n  \"density_operator A \\<longleftrightarrow> positive A \\<and> trace A = 1\""], ["", "definition partial_density_operator :: \"complex mat \\<Rightarrow> bool\" where\n  \"partial_density_operator A \\<longleftrightarrow> positive A \\<and> trace A \\<le> 1\""], ["", "lemma pure_state_self_outer_prod_is_partial_density_operator:\n  fixes v :: \"complex vec\"\n  assumes dimv: \"v \\<in> carrier_vec n\" and nv: \"vec_norm v = 1\"\n  shows \"partial_density_operator (outer_prod v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_density_operator (outer_prod v v)", "unfolding partial_density_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (outer_prod v v) \\<and> trace (outer_prod v v) \\<le> 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. positive (outer_prod v v)\n 2. trace (outer_prod v v) \\<le> 1", "have dimov: \"outer_prod v v \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "using dimv"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. positive (outer_prod v v)\n 2. trace (outer_prod v v) \\<le> 1", "show \"positive (outer_prod v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (outer_prod v v)", "unfolding positive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v v\n    \\<in> carrier_mat (dim_col (outer_prod v v))\n           (dim_col (outer_prod v v)) \\<and>\n    (\\<forall>va.\n        dim_vec va = dim_col (outer_prod v v) \\<longrightarrow>\n        0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va))", "proof (rule, simp add: carrier_matD(2)[OF dimov] dimov, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "assume \"dim_vec (w::complex vec) = dim_col (outer_prod v v)\""], ["proof (state)\nthis:\n  dim_vec w = dim_col (outer_prod v v)\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "then"], ["proof (chain)\npicking this:\n  dim_vec w = dim_col (outer_prod v v)", "have dimw: \"w \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  dim_vec w = dim_col (outer_prod v v)\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "using dimov carrier_vecI"], ["proof (prove)\nusing this:\n  dim_vec w = dim_col (outer_prod v v)\n  outer_prod v v \\<in> carrier_mat n n\n  dim_vec ?v = ?n \\<Longrightarrow> ?v \\<in> carrier_vec ?n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "then"], ["proof (chain)\npicking this:\n  w \\<in> carrier_vec n", "have \"inner_prod w ((outer_prod v v) *\\<^sub>v w) = inner_prod w v * inner_prod v w\""], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w (outer_prod v v *\\<^sub>v w) =\n    inner_prod w v * inner_prod v w", "using inner_prod_outer_prod dimw dimv"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  \\<lbrakk>?a \\<in> carrier_vec ?n; ?b \\<in> carrier_vec ?n;\n   ?c \\<in> carrier_vec ?m; ?d \\<in> carrier_vec ?m\\<rbrakk>\n  \\<Longrightarrow> inner_prod ?a (outer_prod ?b ?c *\\<^sub>v ?d) =\n                    inner_prod ?a ?b * inner_prod ?c ?d\n  w \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w (outer_prod v v *\\<^sub>v w) =\n    inner_prod w v * inner_prod v w", "by auto"], ["proof (state)\nthis:\n  inner_prod w (outer_prod v v *\\<^sub>v w) =\n  inner_prod w v * inner_prod v w\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "also"], ["proof (state)\nthis:\n  inner_prod w (outer_prod v v *\\<^sub>v w) =\n  inner_prod w v * inner_prod v w\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "have \"\\<dots> = inner_prod w v * conjugate (inner_prod w v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_prod w v * inner_prod v w =\n    inner_prod w v * conjugate (inner_prod w v)", "using dimw dimv"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. inner_prod w v * inner_prod v w =\n    inner_prod w v * conjugate (inner_prod w v)", "apply (subst conjugate_scalar_prod[of v \"conjugate w\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> inner_prod w v * inner_prod v w =\n                      inner_prod w v *\n                      inner_prod (conjugate w) (conjugate v)", "apply (subst conjugate_vec_sprod_comm[of \"conjugate v\" _ \"conjugate w\"], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate v \\<in> carrier_vec ?n4\n 2. \\<lbrakk>w \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate w \\<in> carrier_vec ?n4", "apply (rule carrier_vec_conjugate[OF dimv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> carrier_vec n; v \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate w \\<in> carrier_vec n", "apply (rule carrier_vec_conjugate[OF dimw])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inner_prod w v * inner_prod v w =\n  inner_prod w v * conjugate (inner_prod w v)\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "also"], ["proof (state)\nthis:\n  inner_prod w v * inner_prod v w =\n  inner_prod w v * conjugate (inner_prod w v)\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod w v * conjugate (inner_prod w v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod w v * conjugate (inner_prod w v)\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       dim_vec va = dim_col (outer_prod v v) \\<Longrightarrow>\n       0 \\<le> inner_prod va (outer_prod v v *\\<^sub>v va)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> inner_prod w (outer_prod v v *\\<^sub>v w)", "show \"inner_prod w ((outer_prod v v) *\\<^sub>v w) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> inner_prod w (outer_prod v v *\\<^sub>v w)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod w (outer_prod v v *\\<^sub>v w)", "."], ["proof (state)\nthis:\n  0 \\<le> inner_prod w (outer_prod v v *\\<^sub>v w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  positive (outer_prod v v)\n\ngoal (1 subgoal):\n 1. trace (outer_prod v v) \\<le> 1", "have eq: \"trace (outer_prod v v) = (\\<Sum>i=0..<n. v$i * conjugate(v$i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (outer_prod v v) = (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "unfolding trace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_row (outer_prod v v). outer_prod v v $$ (i, i)) =\n    (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "apply (subst carrier_matD(1)[OF dimov])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. outer_prod v v $$ (i, i)) =\n    (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "apply (simp add: index_outer_prod[OF dimv dimv])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace (outer_prod v v) = (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n\ngoal (1 subgoal):\n 1. trace (outer_prod v v) \\<le> 1", "have \"vec_norm v = csqrt (\\<Sum>i=0..<n. v$i * conjugate(v$i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_norm v = csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "unfolding vec_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt (inner_prod v v) =\n    csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "using dimv"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. csqrt (inner_prod v v) =\n    csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "by (simp add: scalar_prod_def)"], ["proof (state)\nthis:\n  vec_norm v = csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n\ngoal (1 subgoal):\n 1. trace (outer_prod v v) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  vec_norm v = csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))", "have \"(\\<Sum>i=0..<n. v$i * conjugate(v$i)) = 1\""], ["proof (prove)\nusing this:\n  vec_norm v = csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i)) = 1", "using nv"], ["proof (prove)\nusing this:\n  vec_norm v = csqrt (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n  vec_norm v = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i)) = 1", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i)) = 1\n\ngoal (1 subgoal):\n 1. trace (outer_prod v v) \\<le> 1", "with eq"], ["proof (chain)\npicking this:\n  trace (outer_prod v v) = (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n  (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i)) = 1", "show \"trace (outer_prod v v) \\<le> 1\""], ["proof (prove)\nusing this:\n  trace (outer_prod v v) = (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i))\n  (\\<Sum>i = 0..<n. v $ i * conjugate (v $ i)) = 1\n\ngoal (1 subgoal):\n 1. trace (outer_prod v v) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  trace (outer_prod v v) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Lemma 2.1 *)"], ["", "lemma lowner_le_trace:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and B: \"B \\<in> carrier_mat n n\"\n  shows \"A \\<le>\\<^sub>L B \\<longleftrightarrow> (\\<forall>\\<rho>\\<in>carrier_mat n n. partial_density_operator \\<rho> \\<longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<le>\\<^sub>L B) =\n    (\\<forall>\\<rho>\\<in>carrier_mat n n.\n        partial_density_operator \\<rho> \\<longrightarrow>\n        trace (A * \\<rho>) \\<le> trace (B * \\<rho>))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have dimBmA: \"B - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "using A B"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "{"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "assume \"A \\<le>\\<^sub>L B\""], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  A \\<le>\\<^sub>L B", "have pBmA: \"positive (B - A)\""], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. positive (B - A)", "using lowner_le_def"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by auto"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "moreover"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have \"B - A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B - A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B - A \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "ultimately"], ["proof (chain)\npicking this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n", "have \"\\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A\""], ["proof (prove)\nusing this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A", "using positive_iff_decomp[of \"B - A\"]"], ["proof (prove)\nusing this:\n  positive (B - A)\n  B - A \\<in> carrier_mat n n\n  B - A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  positive (B - A) =\n  (\\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = B - A)\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A", "by auto"], ["proof (state)\nthis:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A", "obtain M where dimM: \"M \\<in> carrier_mat n n\" and M: \"M * adjoint M = B - A\""], ["proof (prove)\nusing this:\n  \\<exists>M\\<in>carrier_mat n n. M * adjoint M = B - A\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> carrier_mat n n; M * adjoint M = B - A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n n\n  M * adjoint M = B - A\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "{"], ["proof (state)\nthis:\n  M \\<in> carrier_mat n n\n  M * adjoint M = B - A\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "fix \\<rho>"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "assume dimr: \"\\<rho> \\<in> carrier_mat n n\" and pdr: \"partial_density_operator \\<rho>\""], ["proof (state)\nthis:\n  \\<rho> \\<in> carrier_mat n n\n  partial_density_operator \\<rho>\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have eq: \"trace(B * \\<rho>) - trace(A * \\<rho>) = trace((B - A) * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (B * \\<rho>) - trace (A * \\<rho>) = trace ((B - A) * \\<rho>)", "using A B dimr"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  \\<rho> \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (B * \\<rho>) - trace (A * \\<rho>) = trace ((B - A) * \\<rho>)", "apply (subst minus_mult_distrib_mat, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n     \\<rho> \\<in> carrier_mat n n\\<rbrakk>\n    \\<Longrightarrow> trace (B * \\<rho>) - trace (A * \\<rho>) =\n                      trace (B * \\<rho> - A * \\<rho>)", "apply (subst trace_minus_linear, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace (B * \\<rho>) - trace (A * \\<rho>) = trace ((B - A) * \\<rho>)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have pr: \"positive \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive \\<rho>", "using pdr partial_density_operator_def"], ["proof (prove)\nusing this:\n  partial_density_operator \\<rho>\n  partial_density_operator ?A = (positive ?A \\<and> trace ?A \\<le> 1)\n\ngoal (1 subgoal):\n 1. positive \\<rho>", "by auto"], ["proof (state)\nthis:\n  positive \\<rho>\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  positive \\<rho>", "have \"\\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P\""], ["proof (prove)\nusing this:\n  positive \\<rho>\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P", "using positive_iff_decomp dimr"], ["proof (prove)\nusing this:\n  positive \\<rho>\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  positive ?A = (\\<exists>M\\<in>carrier_mat ?n ?n. M * adjoint M = ?A)\n  \\<rho> \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P", "by auto"], ["proof (state)\nthis:\n  \\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P", "obtain P where dimP: \"P \\<in> carrier_mat n n\" and P: \"\\<rho> = P * adjoint P\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>carrier_mat n n. \\<rho> = P * adjoint P\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> carrier_mat n n; \\<rho> = P * adjoint P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n  \\<rho> = P * adjoint P\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have \"trace((B - A) * \\<rho>) = trace(M * adjoint M * (P * adjoint P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace ((B - A) * \\<rho>) = trace (M * adjoint M * (P * adjoint P))", "using P M"], ["proof (prove)\nusing this:\n  \\<rho> = P * adjoint P\n  M * adjoint M = B - A\n\ngoal (1 subgoal):\n 1. trace ((B - A) * \\<rho>) = trace (M * adjoint M * (P * adjoint P))", "by auto"], ["proof (state)\nthis:\n  trace ((B - A) * \\<rho>) = trace (M * adjoint M * (P * adjoint P))\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "also"], ["proof (state)\nthis:\n  trace ((B - A) * \\<rho>) = trace (M * adjoint M * (P * adjoint P))\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have \"\\<dots> = trace((adjoint P * M) * adjoint (adjoint P * M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (M * adjoint M * (P * adjoint P)) =\n    trace (adjoint P * M * adjoint (adjoint P * M))", "using dimM dimP"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (M * adjoint M * (P * adjoint P)) =\n    trace (adjoint P * M * adjoint (adjoint P * M))", "by (mat_assoc n)"], ["proof (state)\nthis:\n  trace (M * adjoint M * (P * adjoint P)) =\n  trace (adjoint P * M * adjoint (adjoint P * M))\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "also"], ["proof (state)\nthis:\n  trace (M * adjoint M * (P * adjoint P)) =\n  trace (adjoint P * M * adjoint (adjoint P * M))\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have \"\\<dots> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> trace (adjoint P * M * adjoint (adjoint P * M))", "using trace_adjoint_positive"], ["proof (prove)\nusing this:\n  0 \\<le> trace (?A * adjoint ?A)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (adjoint P * M * adjoint (adjoint P * M))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace (adjoint P * M * adjoint (adjoint P * M))\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> trace ((B - A) * \\<rho>)", "have \"trace((B - A) * \\<rho>) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> trace ((B - A) * \\<rho>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace ((B - A) * \\<rho>)", "."], ["proof (state)\nthis:\n  0 \\<le> trace ((B - A) * \\<rho>)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "with eq"], ["proof (chain)\npicking this:\n  trace (B * \\<rho>) - trace (A * \\<rho>) = trace ((B - A) * \\<rho>)\n  0 \\<le> trace ((B - A) * \\<rho>)", "have \" trace (B * \\<rho>) - trace (A * \\<rho>) \\<ge> 0\""], ["proof (prove)\nusing this:\n  trace (B * \\<rho>) - trace (A * \\<rho>) = trace ((B - A) * \\<rho>)\n  0 \\<le> trace ((B - A) * \\<rho>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace (B * \\<rho>) - trace (A * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace (B * \\<rho>) - trace (A * \\<rho>)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<rho>2 \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>2\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace (B * ?\\<rho>2) - trace (A * ?\\<rho>2)\n\ngoal (2 subgoals):\n 1. A \\<le>\\<^sub>L B \\<Longrightarrow>\n    \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n 2. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<rho>2 \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>2\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace (B * ?\\<rho>2) - trace (A * ?\\<rho>2)", "show \"\\<forall>\\<rho>\\<in>carrier_mat n n. partial_density_operator \\<rho> \\<longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho>2 \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>2\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> trace (B * ?\\<rho>2) - trace (A * ?\\<rho>2)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "}"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B \\<Longrightarrow>\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "{"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B \\<Longrightarrow>\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "assume asm: \"\\<forall>\\<rho>\\<in>carrier_mat n n. partial_density_operator \\<rho> \\<longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\""], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "have \"positive (B - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive (B - A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (B - A)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (B - A)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. positive (B - A)", "assume \"dim_vec (v::complex vec) = dim_col (B - A) \\<and> vec_norm v = 1\""], ["proof (state)\nthis:\n  dim_vec v = dim_col (B - A) \\<and> vec_norm v = 1\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  dim_vec v = dim_col (B - A) \\<and> vec_norm v = 1", "have dimv: \"v \\<in> carrier_vec n\" and nv: \"vec_norm v = 1\""], ["proof (prove)\nusing this:\n  dim_vec v = dim_col (B - A) \\<and> vec_norm v = 1\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& vec_norm v = 1", "using carrier_matD[OF dimBmA]"], ["proof (prove)\nusing this:\n  dim_vec v = dim_col (B - A) \\<and> vec_norm v = 1\n  dim_row (B - A) = n\n  dim_col (B - A) = n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& vec_norm v = 1", "by (auto intro: carrier_vecI)"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  vec_norm v = 1\n\ngoal (1 subgoal):\n 1. positive (B - A)", "have dimov: \"outer_prod v v \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "using dimv"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. outer_prod v v \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  outer_prod v v \\<in> carrier_mat n n", "have \"partial_density_operator (outer_prod v v)\""], ["proof (prove)\nusing this:\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. partial_density_operator (outer_prod v v)", "using dimv nv pure_state_self_outer_prod_is_partial_density_operator"], ["proof (prove)\nusing this:\n  outer_prod v v \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n  vec_norm v = 1\n  \\<lbrakk>?v \\<in> carrier_vec ?n; vec_norm ?v = 1\\<rbrakk>\n  \\<Longrightarrow> partial_density_operator (outer_prod ?v ?v)\n\ngoal (1 subgoal):\n 1. partial_density_operator (outer_prod v v)", "by auto"], ["proof (state)\nthis:\n  partial_density_operator (outer_prod v v)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  partial_density_operator (outer_prod v v)", "have leq: \"trace(A * (outer_prod v v)) \\<le> trace(B * (outer_prod v v))\""], ["proof (prove)\nusing this:\n  partial_density_operator (outer_prod v v)\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v v) \\<le> trace (B * outer_prod v v)", "using asm dimov"], ["proof (prove)\nusing this:\n  partial_density_operator (outer_prod v v)\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace (A * outer_prod v v) \\<le> trace (B * outer_prod v v)", "by auto"], ["proof (state)\nthis:\n  trace (A * outer_prod v v) \\<le> trace (B * outer_prod v v)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "have \"trace((B - A) * (outer_prod v v)) = trace(B * (outer_prod v v)) - trace(A * (outer_prod v v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace ((B - A) * outer_prod v v) =\n    trace (B * outer_prod v v) - trace (A * outer_prod v v)", "using A B dimov"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  outer_prod v v \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. trace ((B - A) * outer_prod v v) =\n    trace (B * outer_prod v v) - trace (A * outer_prod v v)", "apply (subst minus_mult_distrib_mat, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n     outer_prod v v \\<in> carrier_mat n n\\<rbrakk>\n    \\<Longrightarrow> trace (B * outer_prod v v - A * outer_prod v v) =\n                      trace (B * outer_prod v v) -\n                      trace (A * outer_prod v v)", "apply (subst trace_minus_linear, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace ((B - A) * outer_prod v v) =\n  trace (B * outer_prod v v) - trace (A * outer_prod v v)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  trace ((B - A) * outer_prod v v) =\n  trace (B * outer_prod v v) - trace (A * outer_prod v v)", "have \"trace((B - A) * (outer_prod v v)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  trace ((B - A) * outer_prod v v) =\n  trace (B * outer_prod v v) - trace (A * outer_prod v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace ((B - A) * outer_prod v v)", "using leq"], ["proof (prove)\nusing this:\n  trace ((B - A) * outer_prod v v) =\n  trace (B * outer_prod v v) - trace (A * outer_prod v v)\n  trace (A * outer_prod v v) \\<le> trace (B * outer_prod v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> trace ((B - A) * outer_prod v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> trace ((B - A) * outer_prod v v)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> trace ((B - A) * outer_prod v v)", "have \"inner_prod v ((B - A) *\\<^sub>v v) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> trace ((B - A) * outer_prod v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)", "using trace_outer_prod_right[OF dimBmA dimv dimv]"], ["proof (prove)\nusing this:\n  0 \\<le> trace ((B - A) * outer_prod v v)\n  trace ((B - A) * outer_prod v v) = inner_prod v ((B - A) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. 0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "}"], ["proof (state)\nthis:\n  dim_vec ?v2 = dim_col (B - A) \\<and> vec_norm ?v2 = 1 \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((B - A) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "then"], ["proof (chain)\npicking this:\n  dim_vec ?v2 = dim_col (B - A) \\<and> vec_norm ?v2 = 1 \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((B - A) *\\<^sub>v ?v2)", "show \"positive (B - A)\""], ["proof (prove)\nusing this:\n  dim_vec ?v2 = dim_col (B - A) \\<and> vec_norm ?v2 = 1 \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((B - A) *\\<^sub>v ?v2)\n\ngoal (1 subgoal):\n 1. positive (B - A)", "using positive_iff_normalized_vec[of \"B - A\"] dimBmA A"], ["proof (prove)\nusing this:\n  dim_vec ?v2 = dim_col (B - A) \\<and> vec_norm ?v2 = 1 \\<Longrightarrow>\n  0 \\<le> inner_prod ?v2 ((B - A) *\\<^sub>v ?v2)\n  positive (B - A) =\n  (B - A \\<in> carrier_mat (dim_col (B - A)) (dim_col (B - A)) \\<and>\n   (\\<forall>v.\n       dim_vec v = dim_col (B - A) \\<and> vec_norm v = 1 \\<longrightarrow>\n       0 \\<le> inner_prod v ((B - A) *\\<^sub>v v)))\n  B - A \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. positive (B - A)", "by simp"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>carrier_mat n n.\n       partial_density_operator \\<rho> \\<longrightarrow>\n       trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n    A \\<le>\\<^sub>L B", "then"], ["proof (chain)\npicking this:\n  positive (B - A)", "show \"A \\<le>\\<^sub>L B\""], ["proof (prove)\nusing this:\n  positive (B - A)\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "using lowner_le_def A B"], ["proof (prove)\nusing this:\n  positive (B - A)\n  (?A \\<le>\\<^sub>L ?B) =\n  (dim_row ?A = dim_row ?B \\<and>\n   dim_col ?A = dim_col ?B \\<and> positive (?B - ?A))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "by auto"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<forall>\\<rho>\\<in>carrier_mat n n.\n     partial_density_operator \\<rho> \\<longrightarrow>\n     trace (A * \\<rho>) \\<le> trace (B * \\<rho>) \\<Longrightarrow>\n  A \\<le>\\<^sub>L B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_traceI:\n  assumes \"A \\<in> carrier_mat n n\"\n    and \"B \\<in> carrier_mat n n\"\n    and \"\\<And>\\<rho>. \\<rho> \\<in> carrier_mat n n \\<Longrightarrow> partial_density_operator \\<rho> \\<Longrightarrow> trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\"\n  shows \"A \\<le>\\<^sub>L B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "using lowner_le_trace assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> (?A \\<le>\\<^sub>L ?B) =\n                    (\\<forall>\\<rho>\\<in>carrier_mat ?n ?n.\n                        partial_density_operator \\<rho> \\<longrightarrow>\n                        trace (?A * \\<rho>) \\<le> trace (?B * \\<rho>))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) \\<le> trace (B * ?\\<rho>)\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "by auto"], ["", "lemma trace_pdo_eq_imp_eq:\n  assumes A: \"A \\<in> carrier_mat n n\"\n    and B: \"B \\<in> carrier_mat n n\"\n    and teq: \"\\<And>\\<rho>. \\<rho> \\<in> carrier_mat n n \\<Longrightarrow> partial_density_operator \\<rho> \\<Longrightarrow> trace (A * \\<rho>) = trace (B * \\<rho>)\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "from teq"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)", "have \"A \\<le>\\<^sub>L B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "using lowner_le_trace[OF A B] teq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n  (A \\<le>\\<^sub>L B) =\n  (\\<forall>\\<rho>\\<in>carrier_mat n n.\n      partial_density_operator \\<rho> \\<longrightarrow>\n      trace (A * \\<rho>) \\<le> trace (B * \\<rho>))\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n\ngoal (1 subgoal):\n 1. A \\<le>\\<^sub>L B", "by auto"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. A = B", "moreover"], ["proof (state)\nthis:\n  A \\<le>\\<^sub>L B\n\ngoal (1 subgoal):\n 1. A = B", "from teq"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)", "have \"B \\<le>\\<^sub>L A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n\ngoal (1 subgoal):\n 1. B \\<le>\\<^sub>L A", "using lowner_le_trace[OF B A] teq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n  (B \\<le>\\<^sub>L A) =\n  (\\<forall>\\<rho>\\<in>carrier_mat n n.\n      partial_density_operator \\<rho> \\<longrightarrow>\n      trace (B * \\<rho>) \\<le> trace (A * \\<rho>))\n  \\<lbrakk>?\\<rho> \\<in> carrier_mat n n;\n   partial_density_operator ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> trace (A * ?\\<rho>) = trace (B * ?\\<rho>)\n\ngoal (1 subgoal):\n 1. B \\<le>\\<^sub>L A", "by auto"], ["proof (state)\nthis:\n  B \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. A = B", "ultimately"], ["proof (chain)\npicking this:\n  A \\<le>\\<^sub>L B\n  B \\<le>\\<^sub>L A", "show \"A = B\""], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  B \\<le>\\<^sub>L A\n\ngoal (1 subgoal):\n 1. A = B", "using lowner_le_antisym A B"], ["proof (prove)\nusing this:\n  A \\<le>\\<^sub>L B\n  B \\<le>\\<^sub>L A\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   ?A \\<le>\\<^sub>L ?B; ?B \\<le>\\<^sub>L ?A\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowner_le_traceD:\n  assumes \"A \\<in> carrier_mat n n\" \"B \\<in> carrier_mat n n\" \"\\<rho> \\<in> carrier_mat n n\"\n    and \"A \\<le>\\<^sub>L B\"\n    and \"partial_density_operator \\<rho>\"\n  shows \"trace (A * \\<rho>) \\<le> trace (B * \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (A * \\<rho>) \\<le> trace (B * \\<rho>)", "using lowner_le_trace assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> (?A \\<le>\\<^sub>L ?B) =\n                    (\\<forall>\\<rho>\\<in>carrier_mat ?n ?n.\n                        partial_density_operator \\<rho> \\<longrightarrow>\n                        trace (?A * \\<rho>) \\<le> trace (?B * \\<rho>))\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  \\<rho> \\<in> carrier_mat n n\n  A \\<le>\\<^sub>L B\n  partial_density_operator \\<rho>\n\ngoal (1 subgoal):\n 1. trace (A * \\<rho>) \\<le> trace (B * \\<rho>)", "by blast"], ["", "lemma sum_only_one_neq_0:\n  assumes \"finite A\" and \"j \\<in> A\" and \"\\<And>i. i \\<in> A \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> g i = 0\"\n  shows \"sum g A = g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g A = g j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum g A = g j", "have \"{j} \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j} \\<subseteq> A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  j \\<in> A\n  \\<lbrakk>?i \\<in> A; ?i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> g ?i = (0::'b)\n\ngoal (1 subgoal):\n 1. {j} \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  {j} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. sum g A = g j", "moreover"], ["proof (state)\nthis:\n  {j} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. sum g A = g j", "have \"\\<forall>i\\<in>A - {j}. g i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A - {j}. g i = (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  j \\<in> A\n  \\<lbrakk>?i \\<in> A; ?i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> g ?i = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A - {j}. g i = (0::'b)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A - {j}. g i = (0::'b)\n\ngoal (1 subgoal):\n 1. sum g A = g j", "ultimately"], ["proof (chain)\npicking this:\n  {j} \\<subseteq> A\n  \\<forall>i\\<in>A - {j}. g i = (0::'b)", "have \"sum g A = sum g {j}\""], ["proof (prove)\nusing this:\n  {j} \\<subseteq> A\n  \\<forall>i\\<in>A - {j}. g i = (0::'b)\n\ngoal (1 subgoal):\n 1. sum g A = sum g {j}", "using assms"], ["proof (prove)\nusing this:\n  {j} \\<subseteq> A\n  \\<forall>i\\<in>A - {j}. g i = (0::'b)\n  finite A\n  j \\<in> A\n  \\<lbrakk>?i \\<in> A; ?i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> g ?i = (0::'b)\n\ngoal (1 subgoal):\n 1. sum g A = sum g {j}", "by (auto simp add: comm_monoid_add_class.sum.mono_neutral_right[of A \"{j}\" g])"], ["proof (state)\nthis:\n  sum g A = sum g {j}\n\ngoal (1 subgoal):\n 1. sum g A = g j", "moreover"], ["proof (state)\nthis:\n  sum g A = sum g {j}\n\ngoal (1 subgoal):\n 1. sum g A = g j", "have \"sum g {j} = g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {j} = g j", "by simp"], ["proof (state)\nthis:\n  sum g {j} = g j\n\ngoal (1 subgoal):\n 1. sum g A = g j", "ultimately"], ["proof (chain)\npicking this:\n  sum g A = sum g {j}\n  sum g {j} = g j", "show ?thesis"], ["proof (prove)\nusing this:\n  sum g A = sum g {j}\n  sum g {j} = g j\n\ngoal (1 subgoal):\n 1. sum g A = g j", "by auto"], ["proof (state)\nthis:\n  sum g A = g j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}