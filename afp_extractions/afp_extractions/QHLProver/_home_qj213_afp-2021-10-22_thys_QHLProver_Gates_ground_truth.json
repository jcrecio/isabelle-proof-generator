{"file_name": "/home/qj213/afp-2021-10-22/thys/QHLProver/Gates.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/QHLProver", "problem_names": ["lemma hadamard_dim:\n  \"hadamard \\<in> carrier_mat 2 2\"", "lemma hermitian_hadamard:\n  \"hermitian hadamard\"", "lemma csqrt_2_sq:\n  \"complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\"", "lemma sum_le_2:\n  \"\\<And>(f::nat\\<Rightarrow>complex). sum f {0..<2} = f 0 + f 1\"", "lemma unitary_hadamard:\n  \"unitary hadamard\"", "lemma mat_incr_dim:\n  \"mat_incr n \\<in> carrier_mat n n\"", "lemma adjoint_mat_incr:\n  \"adjoint (mat_incr n) = mat n n (\\<lambda>(i,j). if j = 0 then (if i = n - 1 then 1 else 0) else (if j = i + 1 then 1 else 0))\"", "lemma mat_incr_mult_adjoint_mat_incr:\n  shows \"mat_incr n * (adjoint (mat_incr n)) = 1\\<^sub>m n\"", "lemma unitary_mat_incr:\n  \"unitary (mat_incr n)\""], "translations": [["", "lemma hadamard_dim:\n  \"hadamard \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat 2 2", "unfolding hadamard_def mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2))\n    \\<in> carrier_mat 2 2", "by auto"], ["", "lemma hermitian_hadamard:\n  \"hermitian hadamard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian hadamard", "unfolding hermitian_def hadamard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2))) =\n    mat 2 2\n     (\\<lambda>(i, j).\n         if i = 0 \\<or> j = 0 then 1 / csqrt 2\n         else complex_of_real (- 1 / sqrt 2))", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat 2 2\n                       (\\<lambda>(i, j).\n                           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                           else complex_of_real (- 1 / sqrt 2)));\n        j < dim_col\n             (mat 2 2\n               (\\<lambda>(i, j).\n                   if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                   else complex_of_real (- 1 / sqrt 2)))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat 2 2\n                            (\\<lambda>(i, j).\n                                if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                                else complex_of_real (- 1 / sqrt 2))) $$\n                         (i, j) =\n                         mat 2 2\n                          (\\<lambda>(i, j).\n                              if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                              else complex_of_real (- 1 / sqrt 2)) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_row\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))\n 3. dim_col\n     (adjoint\n       (mat 2 2\n         (\\<lambda>(i, j).\n             if i = 0 \\<or> j = 0 then 1 / csqrt 2\n             else complex_of_real (- 1 / sqrt 2)))) =\n    dim_col\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)))", "by (auto simp add: adjoint_eval adjoint_dim)"], ["", "lemma csqrt_2_sq:\n  \"complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2", "by (smt of_real_add of_real_hom.hom_one of_real_power one_add_one power2_eq_square real_sqrt_pow2)"], ["", "lemma sum_le_2:\n  \"\\<And>(f::nat\\<Rightarrow>complex). sum f {0..<2} = f 0 + f 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. sum f {0..<2} = f 0 + f 1", "by (simp add: numeral_2_eq_2)"], ["", "lemma unitary_hadamard:\n  \"unitary hadamard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary hadamard", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat (dim_row hadamard) (dim_row hadamard) \\<and>\n    inverts_mat hadamard (adjoint hadamard)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hadamard \\<in> carrier_mat (dim_row hadamard) (dim_row hadamard)\n 2. inverts_mat hadamard (adjoint hadamard)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat (dim_row hadamard) (dim_row hadamard)", "using carrier_matD[OF hadamard_dim] hadamard_def"], ["proof (prove)\nusing this:\n  dim_row hadamard = 2\n  dim_col hadamard = 2\n  hadamard =\n  mat 2 2\n   (\\<lambda>(i, j).\n       if i = 0 \\<or> j = 0 then 1 / csqrt 2\n       else complex_of_real (- 1 / sqrt 2))\n\ngoal (1 subgoal):\n 1. hadamard \\<in> carrier_mat (dim_row hadamard) (dim_row hadamard)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat hadamard (adjoint hadamard)", "apply (subst hermitian_hadamard[unfolded hermitian_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat hadamard hadamard", "unfolding inverts_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hadamard * hadamard = 1\\<^sub>m (dim_row hadamard)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (dim_row hadamard));\n        j < dim_col (1\\<^sub>m (dim_row hadamard))\\<rbrakk>\n       \\<Longrightarrow> (hadamard * hadamard) $$ (i, j) =\n                         1\\<^sub>m (dim_row hadamard) $$ (i, j)\n 2. dim_row (hadamard * hadamard) = dim_row (1\\<^sub>m (dim_row hadamard))\n 3. dim_col (hadamard * hadamard) = dim_col (1\\<^sub>m (dim_row hadamard))", "unfolding hadamard_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (1\\<^sub>m\n                       (dim_row\n                         (mat 2 2\n                           (\\<lambda>(i, j).\n                               if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                               else complex_of_real (- 1 / sqrt 2)))));\n        j < dim_col\n             (1\\<^sub>m\n               (dim_row\n                 (mat 2 2\n                   (\\<lambda>(i, j).\n                       if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                       else complex_of_real (- 1 / sqrt 2)))))\\<rbrakk>\n       \\<Longrightarrow> (mat 2 2\n                           (\\<lambda>(i, j).\n                               if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                               else complex_of_real (- 1 / sqrt 2)) *\n                          mat 2 2\n                           (\\<lambda>(i, j).\n                               if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                               else complex_of_real (- 1 / sqrt 2))) $$\n                         (i, j) =\n                         1\\<^sub>m\n                          (dim_row\n                            (mat 2 2\n                              (\\<lambda>(i, j).\n                                  if i = 0 \\<or> j = 0 then 1 / csqrt 2\n                                  else complex_of_real (- 1 / sqrt 2)))) $$\n                         (i, j)\n 2. dim_row\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)) *\n      mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2))) =\n    dim_row\n     (1\\<^sub>m\n       (dim_row\n         (mat 2 2\n           (\\<lambda>(i, j).\n               if i = 0 \\<or> j = 0 then 1 / csqrt 2\n               else complex_of_real (- 1 / sqrt 2)))))\n 3. dim_col\n     (mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2)) *\n      mat 2 2\n       (\\<lambda>(i, j).\n           if i = 0 \\<or> j = 0 then 1 / csqrt 2\n           else complex_of_real (- 1 / sqrt 2))) =\n    dim_col\n     (1\\<^sub>m\n       (dim_row\n         (mat 2 2\n           (\\<lambda>(i, j).\n               if i = 0 \\<or> j = 0 then 1 / csqrt 2\n               else complex_of_real (- 1 / sqrt 2)))))", "apply (auto simp add: carrier_matD[OF hadamard_dim] scalar_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < 2 \\<Longrightarrow>\n       (\\<Sum>i = 0..<2.\n           (if j = 0 \\<or> i = 0 then 1 / csqrt 2\n            else complex_of_real (- 1 / sqrt 2)) *\n           (if i = 0 \\<or> j = 0 then 1 / csqrt 2\n            else complex_of_real (- 1 / sqrt 2))) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < 2; j < 2; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>ia = 0..<2.\n                             (if i = 0 \\<or> ia = 0 then 1 / csqrt 2\n                              else complex_of_real (- 1 / sqrt 2)) *\n                             (if ia = 0 \\<or> j = 0 then 1 / csqrt 2\n                              else complex_of_real (- 1 / sqrt 2))) =\n                         0", "by (auto simp add: sum_le_2 csqrt_2_sq)"], ["", "text \\<open>The matrix\n  [0 0 .. 0 1\n   1 0 .. 0 0\n   0 1 .. 0 0\n   . . .. . .\n   0 0 .. 1 0]\n  implements i := i + 1 in the last variable.\n\\<close>"], ["", "definition mat_incr :: \"nat \\<Rightarrow> complex mat\" where\n  \"mat_incr n = mat n n (\\<lambda>(i,j). if i = 0 then (if j = n - 1 then 1 else 0) else (if i = j + 1 then 1 else 0))\""], ["", "lemma mat_incr_dim:\n  \"mat_incr n \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_incr n \\<in> carrier_mat n n", "unfolding mat_incr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n\n     (\\<lambda>(i, j).\n         if i = 0 then if j = n - 1 then 1 else 0\n         else if i = j + 1 then 1 else 0)\n    \\<in> carrier_mat n n", "by auto"], ["", "lemma adjoint_mat_incr:\n  \"adjoint (mat_incr n) = mat n n (\\<lambda>(i,j). if j = 0 then (if i = n - 1 then 1 else 0) else (if j = i + 1 then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjoint (mat_incr n) =\n    mat n n\n     (\\<lambda>(i, j).\n         if j = 0 then if i = n - 1 then 1 else 0\n         else if j = i + 1 then 1 else 0)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat n n\n                       (\\<lambda>(i, j).\n                           if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0));\n        j < dim_col\n             (mat n n\n               (\\<lambda>(i, j).\n                   if j = 0 then if i = n - 1 then 1 else 0\n                   else if j = i + 1 then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> adjoint (mat_incr n) $$ (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0) $$\n                         (i, j)\n 2. dim_row (adjoint (mat_incr n)) =\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j = 0 then if i = n - 1 then 1 else 0\n           else if j = i + 1 then 1 else 0))\n 3. dim_col (adjoint (mat_incr n)) =\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j = 0 then if i = n - 1 then 1 else 0\n           else if j = i + 1 then 1 else 0))", "unfolding mat_incr_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (mat n n\n                       (\\<lambda>(i, j).\n                           if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0));\n        j < dim_col\n             (mat n n\n               (\\<lambda>(i, j).\n                   if j = 0 then if i = n - 1 then 1 else 0\n                   else if j = i + 1 then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> adjoint\n                          (mat n n\n                            (\\<lambda>(i, j).\n                                if i = 0 then if j = n - 1 then 1 else 0\n                                else if i = j + 1 then 1 else 0)) $$\n                         (i, j) =\n                         mat n n\n                          (\\<lambda>(i, j).\n                              if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0) $$\n                         (i, j)\n 2. dim_row\n     (adjoint\n       (mat n n\n         (\\<lambda>(i, j).\n             if i = 0 then if j = n - 1 then 1 else 0\n             else if i = j + 1 then 1 else 0))) =\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if j = 0 then if i = n - 1 then 1 else 0\n           else if j = i + 1 then 1 else 0))\n 3. dim_col\n     (adjoint\n       (mat n n\n         (\\<lambda>(i, j).\n             if i = 0 then if j = n - 1 then 1 else 0\n             else if i = j + 1 then 1 else 0))) =\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if j = 0 then if i = n - 1 then 1 else 0\n           else if j = i + 1 then 1 else 0))", "by (auto simp add: adjoint_eval)"], ["", "lemma mat_incr_mult_adjoint_mat_incr:\n  shows \"mat_incr n * (adjoint (mat_incr n)) = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_incr n * adjoint (mat_incr n) = 1\\<^sub>m n", "apply (rule eq_matI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < n; j < n\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          (mat_incr n * adjoint (mat_incr n)) $$ (j, j) =\n                          1) \\<and>\n                         (i \\<noteq> j \\<longrightarrow>\n                          (mat_incr n * adjoint (mat_incr n)) $$ (i, j) = 0)\n 2. dim_row (mat_incr n * adjoint (mat_incr n)) = dim_row (1\\<^sub>m n)\n 3. dim_col (mat_incr n * adjoint (mat_incr n)) = dim_col (1\\<^sub>m n)", "apply (auto simp add: carrier_matD[OF mat_incr_dim] scalar_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow>\n       (\\<Sum>i = 0..<n.\n           mat_incr n $$ (j, i) * adjoint (mat_incr n) $$ (i, j)) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>ia = 0..<n.\n                             mat_incr n $$ (i, ia) *\n                             adjoint (mat_incr n) $$ (ia, j)) =\n                         0", "unfolding adjoint_mat_incr"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow>\n       (\\<Sum>i = 0..<n.\n           mat_incr n $$ (j, i) *\n           mat n n\n            (\\<lambda>(i, j).\n                if j = 0 then if i = n - 1 then 1 else 0\n                else if j = i + 1 then 1 else 0) $$\n           (i, j)) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>ia = 0..<n.\n                             mat_incr n $$ (i, ia) *\n                             mat n n\n                              (\\<lambda>(i, j).\n                                  if j = 0 then if i = n - 1 then 1 else 0\n                                  else if j = i + 1 then 1 else 0) $$\n                             (ia, j)) =\n                         0", "unfolding mat_incr_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < n \\<Longrightarrow>\n       (\\<Sum>i = 0..<n.\n           mat n n\n            (\\<lambda>(i, j).\n                if i = 0 then if j = n - 1 then 1 else 0\n                else if i = j + 1 then 1 else 0) $$\n           (j, i) *\n           mat n n\n            (\\<lambda>(i, j).\n                if j = 0 then if i = n - 1 then 1 else 0\n                else if j = i + 1 then 1 else 0) $$\n           (i, j)) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < n; j < n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>ia = 0..<n.\n                             mat n n\n                              (\\<lambda>(i, j).\n                                  if i = 0 then if j = n - 1 then 1 else 0\n                                  else if i = j + 1 then 1 else 0) $$\n                             (i, ia) *\n                             mat n n\n                              (\\<lambda>(i, j).\n                                  if j = 0 then if i = n - 1 then 1 else 0\n                                  else if j = i + 1 then 1 else 0) $$\n                             (ia, j)) =\n                         0", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < n \\<Longrightarrow>\n       (\\<Sum>i = 0..<n.\n           (if j = 0 then if i = n - 1 then 1 else 0\n            else if j = i + 1 then 1 else 0) *\n           (if j = 0 then if i = n - 1 then 1 else 0\n            else if j = i + 1 then 1 else 0)) =\n       1", "apply (case_tac \"j = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < n; j = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0) *\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0)) =\n                         1\n 2. \\<And>j.\n       \\<lbrakk>j < n; j \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0) *\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0)) =\n                         1", "subgoal for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < n; j = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                          (if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0) *\n                          (if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0)) =\n                      1", "by (simp add: sum_only_one_neq_0[of _ \"n - Suc 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < n; j \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0) *\n                             (if j = 0 then if i = n - 1 then 1 else 0\n                              else if j = i + 1 then 1 else 0)) =\n                         1", "subgoal for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < n; j \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<n.\n                          (if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0) *\n                          (if j = 0 then if i = n - 1 then 1 else 0\n                           else if j = i + 1 then 1 else 0)) =\n                      1", "by (simp add: sum_only_one_neq_0[of _ \"j - 1\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unitary_mat_incr:\n  \"unitary (mat_incr n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (mat_incr n)", "unfolding unitary_def inverts_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_incr n\n    \\<in> carrier_mat (dim_row (mat_incr n)) (dim_row (mat_incr n)) \\<and>\n    mat_incr n * adjoint (mat_incr n) = 1\\<^sub>m (dim_row (mat_incr n))", "using carrier_matD[OF mat_incr_dim] mat_incr_mult_adjoint_mat_incr"], ["proof (prove)\nusing this:\n  dim_row (mat_incr ?nc) = ?nc\n  dim_col (mat_incr ?nc) = ?nc\n  mat_incr ?n * adjoint (mat_incr ?n) = 1\\<^sub>m ?n\n\ngoal (1 subgoal):\n 1. mat_incr n\n    \\<in> carrier_mat (dim_row (mat_incr n)) (dim_row (mat_incr n)) \\<and>\n    mat_incr n * adjoint (mat_incr n) = 1\\<^sub>m (dim_row (mat_incr n))", "by auto"], ["", "end"]]}