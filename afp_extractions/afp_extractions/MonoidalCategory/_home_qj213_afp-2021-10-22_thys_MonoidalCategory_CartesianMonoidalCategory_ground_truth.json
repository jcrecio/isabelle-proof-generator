{"file_name": "/home/qj213/afp-2021-10-22/thys/MonoidalCategory/CartesianMonoidalCategory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MonoidalCategory", "problem_names": ["lemma sym_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<s>[a, b]\"\n    and \"dom \\<s>[a, b] = a \\<otimes> b\"\n    and \"cod \\<s>[a, b] = b \\<otimes> a\"", "lemma induces_symmetric_monoidal_category:\n    shows \"symmetric_monoidal_category C T \\<alpha> \\<iota> \\<sigma>\"", "lemma induces_elementary_symmetric_monoidal_category:\n    shows \"elementary_symmetric_monoidal_category\n             C tensor unity lunit runit assoc (\\<lambda>a b. \\<sigma> (a, b))\"", "lemma is_functor:\n    shows \"functor C CC.comp map\"", "lemma terminal_unity:\n    shows \"terminal \\<I>\"", "lemma trm_is_terminal_arr:\n    assumes \"ide a\"\n    shows \"terminal_arr \\<t>[a]\"", "lemma induces_elementary_cartesian_monoidal_category:\n    shows \"elementary_cartesian_monoidal_category C tensor \\<I> lunit runit assoc \\<tau> \\<delta>\"", "lemma trm_simps [simp]:\n    assumes \"ide a\"\n    shows \"arr \\<t>[a]\" and \"dom \\<t>[a] = a\" and \"cod \\<t>[a] = \\<I>\"", "lemma dup_simps [simp]:\n    assumes \"ide a\"\n    shows \"arr \\<d>[a]\" and \"dom \\<d>[a] = a\" and \"cod \\<d>[a] = a \\<otimes> a\"", "lemma induces_cartesian_monoidal_category:\n    shows \"cartesian_monoidal_category C T \\<alpha> \\<iota> \\<delta> \\<tau>\"", "lemma unity_agreement:\n    shows \"C.unity = \\<one>\"", "lemma assoc_agreement:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"C.assoc a b c = assoc a b c\"", "lemma assoc'_agreement:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"C.assoc' a b c = assoc' a b c\"", "lemma runit_char_eqn:\n    assumes \"ide a\"\n    shows \"prod (runit a) \\<one> = prod a \\<iota> \\<cdot> assoc a \\<one> \\<one>\"", "lemma runit_agreement:\n    assumes \"ide a\"\n    shows \"runit a = C.runit a\"", "lemma lunit_char_eqn:\n    assumes \"ide a\"\n    shows \"prod \\<one> (lunit a) = prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\"", "lemma lunit_agreement:\n    assumes \"ide a\"\n    shows \"lunit a = C.lunit a\"", "lemma extends_to_cartesian_monoidal_category:\n    shows \"cartesian_monoidal_category C Prod \\<alpha>.map \\<iota> dup trm\"", "lemma pr_in_hom [intro]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a0\\<guillemotright>\"\n    and \"\\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a1\\<guillemotright>\"", "lemma pr_simps [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"arr \\<p>\\<^sub>0[a0, a1]\" and \"dom \\<p>\\<^sub>0[a0, a1] = a0 \\<otimes> a1\" and \"cod \\<p>\\<^sub>0[a0, a1] = a0\"\n    and \"arr \\<p>\\<^sub>1[a0, a1]\" and \"dom \\<p>\\<^sub>1[a0, a1] = a0 \\<otimes> a1\" and \"cod \\<p>\\<^sub>1[a0, a1] = a1\"", "lemma extends_to_elementary_cartesian_category:\n    shows \"elementary_cartesian_category C pr1 pr0 \\<I> \\<tau>\"", "lemma is_cartesian_category:\n    shows \"cartesian_category C\""], "translations": [["", "lemma sym_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<s>[a, b]\"\n    and \"dom \\<s>[a, b] = a \\<otimes> b\"\n    and \"cod \\<s>[a, b] = b \\<otimes> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<s>[a, b] &&&\n    local.dom \\<s>[a, b] = a \\<otimes> b &&& cod \\<s>[a, b] = b \\<otimes> a", "using assms sym_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<s>[a, b] &&&\n    local.dom \\<s>[a, b] = a \\<otimes> b &&& cod \\<s>[a, b] = b \\<otimes> a", "by auto"], ["", "interpretation monoidal_category C T \\<alpha> \\<iota>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) T \\<alpha> \\<iota>", "using induces_monoidal_category"], ["proof (prove)\nusing this:\n  monoidal_category (\\<cdot>) T \\<alpha> \\<iota>\n\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) T \\<alpha> \\<iota>", "by simp"], ["", "interpretation CC: product_category C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) (\\<cdot>)", ".."], ["", "interpretation S: symmetry_functor C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetry_functor (\\<cdot>) (\\<cdot>)", ".."], ["", "interpretation ToS: composite_functor CC.comp CC.comp C S.map T"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor CC.comp CC.comp (\\<cdot>) S.map T", ".."], ["", "definition \\<sigma> :: \"'a * 'a \\<Rightarrow> 'a\"\n    where \"\\<sigma> f \\<equiv> if CC.arr f then \\<s>[cod (fst f), cod (snd f)] \\<cdot> (fst f \\<otimes> snd f) else null\""], ["", "interpretation \\<sigma>: natural_isomorphism CC.comp C T ToS.map \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "interpret \\<sigma>: transformation_by_components CC.comp C T ToS.map \"\\<lambda>a. \\<s>[fst a, snd a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components CC.comp (\\<cdot>) T ToS.map\n     (\\<lambda>a. \\<s>[fst a, snd a])", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       CC.ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<s>[fst a, snd a] : T\n       a \\<rightarrow> ToS.map a\\<guillemotright>\n 2. \\<And>f.\n       CC.arr f \\<Longrightarrow>\n       \\<s>[fst (CC.cod f), snd (CC.cod f)] \\<cdot> T f =\n       ToS.map f \\<cdot> \\<s>[fst (CC.dom f), snd (CC.dom f)]", "using sym_in_hom sym_naturality"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n  \\<lbrakk>arr ?f; arr ?g\\<rbrakk>\n  \\<Longrightarrow> \\<s>[cod ?f, cod ?g] \\<cdot> (?f \\<otimes> ?g) =\n                    (?g \\<otimes> ?f) \\<cdot>\n                    \\<s>[local.dom ?f, local.dom ?g]\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       CC.ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<s>[fst a, snd a] : T\n       a \\<rightarrow> ToS.map a\\<guillemotright>\n 2. \\<And>f.\n       CC.arr f \\<Longrightarrow>\n       \\<s>[fst (CC.cod f), snd (CC.cod f)] \\<cdot> T f =\n       ToS.map f \\<cdot> \\<s>[fst (CC.dom f), snd (CC.dom f)]", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "interpret \\<sigma>: natural_isomorphism CC.comp C T ToS.map \\<sigma>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>.map", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. CC.ide a \\<Longrightarrow> local.iso (\\<sigma>.map a)", "using sym_inverse \\<sigma>.map_simp_ide"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows \\<s>[?a, ?b] \\<s>[?b, ?a]\n  CC.ide ?a \\<Longrightarrow> \\<sigma>.map ?a = \\<s>[fst ?a, snd ?a]\n\ngoal (1 subgoal):\n 1. \\<And>a. CC.ide a \\<Longrightarrow> local.iso (\\<sigma>.map a)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "have \"\\<sigma> = \\<sigma>.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>.map", "using \\<sigma>_def \\<sigma>.map_def sym_naturality"], ["proof (prove)\nusing this:\n  \\<sigma> ?f \\<equiv>\n  if CC.arr ?f\n  then \\<s>[cod (fst ?f), cod (snd ?f)] \\<cdot> (fst ?f \\<otimes> snd ?f)\n  else null\n  \\<sigma>.map ?f =\n  (if CC.arr ?f then \\<s>[fst (CC.cod ?f), snd (CC.cod ?f)] \\<cdot> T ?f\n   else null)\n  \\<lbrakk>arr ?f; arr ?g\\<rbrakk>\n  \\<Longrightarrow> \\<s>[cod ?f, cod ?g] \\<cdot> (?f \\<otimes> ?g) =\n                    (?g \\<otimes> ?f) \\<cdot>\n                    \\<s>[local.dom ?f, local.dom ?g]\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>.map", "by fastforce"], ["proof (state)\nthis:\n  \\<sigma> = \\<sigma>.map\n\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "thus \"natural_isomorphism CC.comp C T ToS.map \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<sigma> = \\<sigma>.map\n\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "using \\<sigma>.natural_isomorphism_axioms"], ["proof (prove)\nusing this:\n  \\<sigma> = \\<sigma>.map\n  natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>.map\n\ngoal (1 subgoal):\n 1. natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>", "by presburger"], ["proof (state)\nthis:\n  natural_isomorphism CC.comp (\\<cdot>) T ToS.map \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation symmetric_monoidal_category C T \\<alpha> \\<iota> \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_monoidal_category (\\<cdot>) T \\<alpha> \\<iota> \\<sigma>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))\n 2. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a\n 3. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "show \"\\<And>a b. \\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "assume a: \"ide a\" and b: \"ide b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "show \"inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "using a b sym_inverse comp_arr_dom \\<sigma>_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows \\<s>[?a, ?b] \\<s>[?b, ?a]\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<sigma> ?f \\<equiv>\n  if CC.arr ?f\n  then \\<s>[cod (fst ?f), cod (snd ?f)] \\<cdot> (fst ?f \\<otimes> snd ?f)\n  else null\n\ngoal (1 subgoal):\n 1. inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))", "by auto"], ["proof (state)\nthis:\n  inverse_arrows (\\<sigma> (a, b)) (\\<sigma> (b, a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows (\\<sigma> (?a4, ?b4))\n                     (\\<sigma> (?b4, ?a4))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a\n 2. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "(*\n       * TODO: Here just using \"lunit\" refers to the locale parameter, rather than\n       * the constant introduced by the interpretation above of monoidal_category.\n       * This is slightly mysterious.\n       *)"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows (\\<sigma> (?a4, ?b4))\n                     (\\<sigma> (?b4, ?a4))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a\n 2. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "show \"\\<And>a. ide a \\<Longrightarrow> local.lunit a \\<cdot> \\<sigma> (a, local.unity) = local.runit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "show \"local.lunit a \\<cdot> \\<sigma> (a, local.unity) = local.runit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "using a lunit_agreement \\<I>_agreement sym_in_hom comp_arr_dom [of \"\\<s>[a, \\<I>]\"]\n                unitor_coherence runit_agreement \\<sigma>_def"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> lunit ?a = \\<l>[?a]\n  unity = \\<I>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n  \\<lbrakk>arr \\<s>[a, \\<I>]; local.dom \\<s>[a, \\<I>] = ?a\\<rbrakk>\n  \\<Longrightarrow> \\<s>[a, \\<I>] \\<cdot> ?a = \\<s>[a, \\<I>]\n  ide ?a \\<Longrightarrow> \\<l>[?a] \\<cdot> \\<s>[?a, \\<I>] = \\<r>[?a]\n  ide ?a \\<Longrightarrow> runit ?a = \\<r>[?a]\n  \\<sigma> ?f \\<equiv>\n  if CC.arr ?f\n  then \\<s>[cod (fst ?f), cod (snd ?f)] \\<cdot> (fst ?f \\<otimes> snd ?f)\n  else null\n\ngoal (1 subgoal):\n 1. lunit a \\<cdot> \\<sigma> (a, unity) = runit a", "by simp"], ["proof (state)\nthis:\n  lunit a \\<cdot> \\<sigma> (a, unity) = runit a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  lunit ?a4 \\<cdot> \\<sigma> (?a4, unity) = runit ?a4\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "show \"\\<And>a b c. \\<lbrakk> ide a; ide b; ide c \\<rbrakk> \\<Longrightarrow>\n                      local.assoc b c a \\<cdot> \\<sigma> (a, local.tensor b c) \\<cdot> local.assoc a b c\n                        = local.tensor b (\\<sigma> (a, c)) \\<cdot> local.assoc b a c \\<cdot> local.tensor (\\<sigma> (a, b)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "assume a: \"ide a\" and b: \"ide b\" and c: \"ide c\""], ["proof (state)\nthis:\n  ide a\n  ide b\n  ide c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>ide a; ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> assoc b c a \\<cdot>\n                         \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n                         tensor b (\\<sigma> (a, c)) \\<cdot>\n                         assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "show \"local.assoc b c a \\<cdot> \\<sigma> (a, local.tensor b c) \\<cdot> local.assoc a b c\n                = local.tensor b (\\<sigma> (a, c)) \\<cdot> local.assoc b a c \\<cdot> local.tensor (\\<sigma> (a, b)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assoc b c a \\<cdot> \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n    tensor b (\\<sigma> (a, c)) \\<cdot>\n    assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "using a b c sym_in_hom tensor_preserves_ide \\<sigma>_def assoc_coherence\n                comp_arr_dom comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (tensor ?a ?b)\n  \\<sigma> ?f \\<equiv>\n  if CC.arr ?f\n  then \\<s>[cod (fst ?f), cod (snd ?f)] \\<cdot> (fst ?f \\<otimes> snd ?f)\n  else null\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<a>[?b, ?c, ?a] \\<cdot>\n                    \\<s>[?a, ?b \\<otimes> ?c] \\<cdot> \\<a>[?a, ?b, ?c] =\n                    (?b \\<otimes> \\<s>[?a, ?c]) \\<cdot>\n                    \\<a>[?b, ?a, ?c] \\<cdot> (\\<s>[?a, ?b] \\<otimes> ?c)\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. assoc b c a \\<cdot> \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n    tensor b (\\<sigma> (a, c)) \\<cdot>\n    assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c", "by simp"], ["proof (state)\nthis:\n  assoc b c a \\<cdot> \\<sigma> (a, tensor b c) \\<cdot> assoc a b c =\n  tensor b (\\<sigma> (a, c)) \\<cdot>\n  assoc b a c \\<cdot> tensor (\\<sigma> (a, b)) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4; ide ?c4\\<rbrakk>\n  \\<Longrightarrow> assoc ?b4 ?c4 ?a4 \\<cdot>\n                    \\<sigma> (?a4, tensor ?b4 ?c4) \\<cdot>\n                    assoc ?a4 ?b4 ?c4 =\n                    tensor ?b4 (\\<sigma> (?a4, ?c4)) \\<cdot>\n                    assoc ?b4 ?a4 ?c4 \\<cdot>\n                    tensor (\\<sigma> (?a4, ?b4)) ?c4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induces_symmetric_monoidal_category:\n    shows \"symmetric_monoidal_category C T \\<alpha> \\<iota> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_monoidal_category (\\<cdot>) T \\<alpha> \\<iota> \\<sigma>", ".."], ["", "end"], ["", "context symmetric_monoidal_category\n  begin"], ["", "interpretation elementary_monoidal_category C tensor unity lunit runit assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit\n     assoc", "using induces_elementary_monoidal_category"], ["proof (prove)\nusing this:\n  elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit assoc\n\ngoal (1 subgoal):\n 1. elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit\n     assoc", "by auto"], ["", "lemma induces_elementary_symmetric_monoidal_category:\n    shows \"elementary_symmetric_monoidal_category\n             C tensor unity lunit runit assoc (\\<lambda>a b. \\<sigma> (a, b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_symmetric_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit\n     runit assoc local.sym", "using \\<sigma>.naturality unitor_coherence assoc_coherence sym_inverse"], ["proof (prove)\nusing this:\n  CC.arr ?f \\<Longrightarrow>\n  \\<sigma> (CC.cod ?f) \\<cdot> T ?f =\n  ToS.map ?f \\<cdot> \\<sigma> (CC.dom ?f)\n  ide ?a \\<Longrightarrow> \\<l>[?a] \\<cdot> \\<s>[?a, \\<I>] = \\<r>[?a]\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<a>[?b, ?c, ?a] \\<cdot>\n                    \\<s>[?a, ?b \\<otimes> ?c] \\<cdot> \\<a>[?a, ?b, ?c] =\n                    (?b \\<otimes> \\<s>[?a, ?c]) \\<cdot>\n                    \\<a>[?b, ?a, ?c] \\<cdot> (\\<s>[?a, ?b] \\<otimes> ?c)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows \\<s>[?a, ?b] \\<s>[?b, ?a]\n\ngoal (1 subgoal):\n 1. elementary_symmetric_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit\n     runit assoc local.sym", "by unfold_locales auto"], ["", "end"], ["", "(* TODO: This definition of \"diagonal_functor\" conflicts with the one in Category3.Limit. *)"], ["", "locale diagonal_functor =\n    C: category C +\n    CC: product_category C C\n  for C :: \"'a comp\"\n  begin"], ["", "abbreviation map\n    where \"map f \\<equiv> if C.arr f then (f, f) else CC.null\""], ["", "lemma is_functor:\n    shows \"functor C CC.comp map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor C CC.comp local.map", "using map_def"], ["proof (prove)\nusing this:\n  Predicate.map ?f ?P = Predicate.bind ?P (Predicate.single \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. functor C CC.comp local.map", "by unfold_locales auto"], ["", "sublocale \"functor\" C CC.comp map"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor C CC.comp local.map", "using is_functor"], ["proof (prove)\nusing this:\n  functor C CC.comp local.map\n\ngoal (1 subgoal):\n 1. functor C CC.comp local.map", "by simp"], ["", "end"], ["", "locale cartesian_monoidal_category =\n    monoidal_category C T \\<alpha> \\<iota> +\n    \\<Omega>: constant_functor C C \\<I> +\n    \\<Delta>: diagonal_functor C +\n    \\<tau>: natural_transformation C C map \\<Omega>.map \\<tau> +\n    \\<delta>: natural_transformation C C map \\<open>T o \\<Delta>.map\\<close> \\<delta>\n  for C :: \"'a comp\"                            (infixr \"\\<cdot>\" 55)\n  and T :: \"'a * 'a \\<Rightarrow> 'a\"\n  and \\<alpha> :: \"'a * 'a * 'a \\<Rightarrow> 'a\"\n  and \\<iota> :: 'a\n  and \\<delta> :: \"'a \\<Rightarrow> 'a\"                           (\"\\<d>[_]\")\n  and \\<tau> :: \"'a \\<Rightarrow> 'a\"                           (\"\\<t>[_]\") +\n  assumes trm_unity: \"\\<t>[\\<I>] = \\<I>\"\n  and pr0_dup: \"ide a \\<Longrightarrow> \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<delta> a = a\"\n  and pr1_dup: \"ide a \\<Longrightarrow> \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<delta> a = a\"\n  and tuple_pr: \"\\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes> \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot> \\<d>[a \\<otimes> b] = a \\<otimes> b\""], ["", "locale elementary_cartesian_monoidal_category =\n    elementary_monoidal_category C tensor unity lunit runit assoc\n  for C :: \"'a comp\"                   (infixr \"\\<cdot>\" 55)\n  and tensor :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"       (infixr \"\\<otimes>\" 53)\n  and unity :: 'a                      (\"\\<I>\")\n  and lunit :: \"'a \\<Rightarrow> 'a\"              (\"\\<l>[_]\")\n  and runit :: \"'a \\<Rightarrow> 'a\"              (\"\\<r>[_]\")\n  and assoc :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"  (\"\\<a>[_, _, _]\")\n  and trm :: \"'a \\<Rightarrow> 'a\"                (\"\\<t>[_]\")\n  and dup :: \"'a \\<Rightarrow> 'a\"                (\"\\<d>[_]\") +\n  assumes trm_in_hom [intro]: \"ide a \\<Longrightarrow> \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\"\n  and trm_unity: \"\\<t>[\\<I>] = \\<I>\"\n  and trm_naturality: \"arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[dom f]\"\n  and dup_in_hom [intro]: \"ide a \\<Longrightarrow> \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes> a\\<guillemotright>\"\n  and dup_naturality: \"arr f \\<Longrightarrow> \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[dom f]\"\n  and prj0_dup: \"ide a \\<Longrightarrow> \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\"\n  and prj1_dup: \"ide a \\<Longrightarrow> \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\"\n  and tuple_prj: \"\\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes> \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot> \\<d>[a \\<otimes> b] = a \\<otimes> b\""], ["", "context cartesian_monoidal_category\n  begin"], ["", "lemma terminal_unity:\n    shows \"terminal \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal \\<I>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide \\<I>\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>", "show \"ide \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide \\<I>", "by simp"], ["proof (state)\nthis:\n  ide \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>", "show \"\\<And>a. ide a \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> \\<I>\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> \\<I>\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> \\<I>\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "show \"\\<guillemotleft>\\<tau> a : a \\<rightarrow> \\<I>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>", "using a"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>f. \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright> \\<Longrightarrow> f = \\<tau> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright> \\<Longrightarrow>\n       f = \\<t>[a]", "using trm_unity \\<tau>.naturality comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<t>[\\<I>] = \\<I>\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright> \\<Longrightarrow>\n       f = \\<t>[a]", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>?f4 : a \\<rightarrow> \\<I>\\<guillemotright> \\<Longrightarrow>\n  ?f4 = \\<t>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<exists>!f. \\<guillemotleft>f : ?a4 \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_is_terminal_arr:\n    assumes \"ide a\"\n    shows \"terminal_arr \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[a]", "using assms terminal_unity"], ["proof (prove)\nusing this:\n  ide a\n  terminal \\<I>\n\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[a]", "by simp"], ["", "interpretation elementary_monoidal_category C tensor unity lunit runit assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit\n     assoc", "using induces_elementary_monoidal_category"], ["proof (prove)\nusing this:\n  elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit assoc\n\ngoal (1 subgoal):\n 1. elementary_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit runit\n     assoc", "by simp"], ["", "interpretation elementary_cartesian_monoidal_category C tensor unity lunit runit assoc \\<tau> \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit\n     runit assoc \\<tau> \\<delta>", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 2. \\<t>[\\<I>] = \\<I>\n 3. \\<And>f.\n       arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]\n 4. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes>\n           a\\<guillemotright>\n 5. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n 6. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 7. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 8. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>a. ide a \\<Longrightarrow> \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>", "using \\<iota>_in_hom"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<iota> : \\<I> \\<otimes>\n                            \\<I> \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>", "by force"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a4] : ?a4 \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal (7 subgoals):\n 1. \\<t>[\\<I>] = \\<I>\n 2. \\<And>f.\n       arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]\n 3. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes>\n           a\\<guillemotright>\n 4. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n 5. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 6. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 7. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<t>[\\<I>] = \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[\\<I>] = \\<I>", "using \\<tau>.preserves_hom \\<iota>_in_hom ide_unity trm_is_terminal_arr terminal_unity"], ["proof (prove)\nusing this:\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?f] : local.map\n                              ?a \\<rightarrow> \\<Omega>.map\n          ?b\\<guillemotright>\n  \\<guillemotleft>\\<iota> : \\<I> \\<otimes>\n                            \\<I> \\<rightarrow> \\<I>\\<guillemotright>\n  ide \\<I>\n  ide ?a \\<Longrightarrow> terminal_arr \\<t>[?a]\n  terminal \\<I>\n\ngoal (1 subgoal):\n 1. \\<t>[\\<I>] = \\<I>", "by (intro terminal_arr_unique) auto"], ["proof (state)\nthis:\n  \\<t>[\\<I>] = \\<I>\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes>\n           a\\<guillemotright>\n 3. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n 4. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 5. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 6. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>f. arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]", "using \\<tau>.naturality comp_cod_arr"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       arr f \\<Longrightarrow> \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  arr ?f4 \\<Longrightarrow> \\<t>[cod ?f4] \\<cdot> ?f4 = \\<t>[local.dom ?f4]\n\ngoal (5 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes>\n           a\\<guillemotright>\n 2. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n 3. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 4. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>a. ide a \\<Longrightarrow> \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<d>[a] : a \\<rightarrow> a \\<otimes>\n           a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<guillemotleft>\\<d>[?a4] : ?a4 \\<rightarrow> ?a4 \\<otimes>\n          ?a4\\<guillemotright>\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 3. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>f. arr f \\<Longrightarrow> \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]", "using \\<delta>.naturality"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow>\n  \\<d>[cod ?f] \\<cdot> local.map ?f =\n  (T \\<circ> \\<Delta>.map) ?f \\<cdot> \\<d>[local.dom ?f]\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       arr f \\<Longrightarrow>\n       \\<d>[cod f] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  arr ?f4 \\<Longrightarrow>\n  \\<d>[cod ?f4] \\<cdot> ?f4 =\n  (?f4 \\<otimes> ?f4) \\<cdot> \\<d>[local.dom ?f4]\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>a. ide a \\<Longrightarrow> \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "using pr1_dup lunit_in_hom"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow>\n  \\<l>[?a] \\<cdot> (\\<t>[?a] \\<otimes> ?a) \\<cdot> \\<d>[?a] = ?a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<l>[?a] : \\<I> \\<otimes>\n                             ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "by simp"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<l>[?a4] \\<cdot> (\\<t>[?a4] \\<otimes> ?a4) \\<cdot> \\<d>[?a4] = ?a4\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>a. ide a \\<Longrightarrow> \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "using pr0_dup runit_in_hom"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow>\n  \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?a]) \\<cdot> \\<d>[?a] = ?a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<r>[?a] : ?a \\<otimes>\n                             \\<I> \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "by simp"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<r>[?a4] \\<cdot> (?a4 \\<otimes> \\<t>[?a4]) \\<cdot> \\<d>[?a4] = ?a4\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) \\<otimes>\n                          \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b)) \\<cdot>\n                         \\<d>[a \\<otimes> b] =\n                         a \\<otimes> b", "show \"\\<And>a0 a1. \\<lbrakk> ide a0; ide a1 \\<rbrakk> \\<Longrightarrow>\n                     (\\<r>[a0] \\<cdot> (a0 \\<otimes> \\<t>[a1]) \\<otimes> \\<l>[a1] \\<cdot> (\\<t>[a0] \\<otimes> a1)) \\<cdot> \\<d>[a0 \\<otimes> a1]\n                       = a0 \\<otimes> a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a0 a1.\n       \\<lbrakk>ide a0; ide a1\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a0] \\<cdot> (a0 \\<otimes> \\<t>[a1]) \\<otimes>\n                          \\<l>[a1] \\<cdot> (\\<t>[a0] \\<otimes> a1)) \\<cdot>\n                         \\<d>[a0 \\<otimes> a1] =\n                         a0 \\<otimes> a1", "using tuple_pr"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> (\\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b]) \\<otimes>\n                     \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)) \\<cdot>\n                    \\<d>[?a \\<otimes> ?b] =\n                    ?a \\<otimes> ?b\n\ngoal (1 subgoal):\n 1. \\<And>a0 a1.\n       \\<lbrakk>ide a0; ide a1\\<rbrakk>\n       \\<Longrightarrow> (\\<r>[a0] \\<cdot> (a0 \\<otimes> \\<t>[a1]) \\<otimes>\n                          \\<l>[a1] \\<cdot> (\\<t>[a0] \\<otimes> a1)) \\<cdot>\n                         \\<d>[a0 \\<otimes> a1] =\n                         a0 \\<otimes> a1", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a0.4; ide ?a1.4\\<rbrakk>\n  \\<Longrightarrow> (\\<r>[?a0.4] \\<cdot>\n                     (?a0.4 \\<otimes> \\<t>[?a1.4]) \\<otimes>\n                     \\<l>[?a1.4] \\<cdot>\n                     (\\<t>[?a0.4] \\<otimes> ?a1.4)) \\<cdot>\n                    \\<d>[?a0.4 \\<otimes> ?a1.4] =\n                    ?a0.4 \\<otimes> ?a1.4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induces_elementary_cartesian_monoidal_category:\n    shows \"elementary_cartesian_monoidal_category C tensor \\<I> lunit runit assoc \\<tau> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_monoidal_category (\\<cdot>) (\\<otimes>) \\<I> lunit\n     runit assoc \\<tau> \\<delta>", ".."], ["", "end"], ["", "context elementary_cartesian_monoidal_category\n  begin"], ["", "lemma trm_simps [simp]:\n    assumes \"ide a\"\n    shows \"arr \\<t>[a]\" and \"dom \\<t>[a] = a\" and \"cod \\<t>[a] = \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<t>[a] &&& local.dom \\<t>[a] = a &&& cod \\<t>[a] = \\<I>", "using assms trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<t>[a] &&& local.dom \\<t>[a] = a &&& cod \\<t>[a] = \\<I>", "by auto"], ["", "lemma dup_simps [simp]:\n    assumes \"ide a\"\n    shows \"arr \\<d>[a]\" and \"dom \\<d>[a] = a\" and \"cod \\<d>[a] = a \\<otimes> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<d>[a] &&& local.dom \\<d>[a] = a &&& cod \\<d>[a] = a \\<otimes> a", "using assms dup_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<d>[?a] : ?a \\<rightarrow> ?a \\<otimes>\n        ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<d>[a] &&& local.dom \\<d>[a] = a &&& cod \\<d>[a] = a \\<otimes> a", "by auto"], ["", "definition \\<tau> :: \"'a \\<Rightarrow> 'a\"\n    where \"\\<tau> f \\<equiv> if arr f then \\<t>[dom f] else null\""], ["", "definition \\<delta> :: \"'a \\<Rightarrow> 'a\"\n    where \"\\<delta> f \\<equiv> if arr f then \\<d>[cod f] \\<cdot> f else null\""], ["", "interpretation CC: product_category C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) (\\<cdot>)", ".."], ["", "interpretation MC: monoidal_category C T \\<alpha> \\<iota>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) T \\<alpha> \\<iota>", "using induces_monoidal_category"], ["proof (prove)\nusing this:\n  monoidal_category (\\<cdot>) T \\<alpha> \\<iota>\n\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) T \\<alpha> \\<iota>", "by auto"], ["", "interpretation I: constant_functor C C MC.unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor (\\<cdot>) (\\<cdot>) MC.unity", "by unfold_locales auto"], ["", "interpretation \\<Delta>: diagonal_functor C"], ["proof (prove)\ngoal (1 subgoal):\n 1. CartesianMonoidalCategory.diagonal_functor (\\<cdot>)", ".."], ["", "interpretation D: composite_functor C CC.comp C \\<Delta>.map T"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>) CC.comp (\\<cdot>) \\<Delta>.map T", ".."], ["", "interpretation \\<tau>: natural_transformation C C map I.map \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map I.map \\<tau>", "using trm_naturality I.map_def \\<tau>_def \\<I>_agreement comp_cod_arr"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow> \\<t>[cod ?f] \\<cdot> ?f = \\<t>[local.dom ?f]\n  I.map ?f = (if arr ?f then MC.unity else null)\n  \\<tau> ?f \\<equiv> if arr ?f then \\<t>[local.dom ?f] else null\n  MC.unity = \\<I>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map I.map \\<tau>", "by unfold_locales auto"], ["", "interpretation \\<delta>: natural_transformation C C map D.map \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map D.map \\<delta>", "using dup_naturality \\<delta>_def comp_arr_dom"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow>\n  \\<d>[cod ?f] \\<cdot> ?f = (?f \\<otimes> ?f) \\<cdot> \\<d>[local.dom ?f]\n  \\<delta> ?f \\<equiv> if arr ?f then \\<d>[cod ?f] \\<cdot> ?f else null\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map D.map \\<delta>", "by unfold_locales auto"], ["", "interpretation MC: cartesian_monoidal_category C T \\<alpha> \\<iota> \\<delta> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_monoidal_category (\\<cdot>) T \\<alpha> \\<iota> \\<delta> \\<tau>", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<tau> MC.unity = MC.unity\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.runit a \\<cdot> MC.tensor a (\\<tau> a) \\<cdot> \\<delta> a = a\n 3. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "show \"\\<tau> MC.unity = MC.unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> MC.unity = MC.unity", "using \\<I>_agreement trm_unity \\<tau>_def"], ["proof (prove)\nusing this:\n  MC.unity = \\<I>\n  \\<t>[\\<I>] = \\<I>\n  \\<tau> ?f \\<equiv> if arr ?f then \\<t>[local.dom ?f] else null\n\ngoal (1 subgoal):\n 1. \\<tau> MC.unity = MC.unity", "by simp"], ["proof (state)\nthis:\n  \\<tau> MC.unity = MC.unity\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.runit a \\<cdot> MC.tensor a (\\<tau> a) \\<cdot> \\<delta> a = a\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "show \"\\<And>a. ide a \\<Longrightarrow> MC.runit a \\<cdot> MC.tensor a (\\<tau> a) \\<cdot> \\<delta> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.runit a \\<cdot> MC.tensor a (\\<tau> a) \\<cdot> \\<delta> a = a", "using runit_agreement \\<tau>_def \\<delta>_def prj0_dup comp_arr_dom"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow> MC.runit ?a = \\<r>[?a]\n  \\<tau> ?f \\<equiv> if arr ?f then \\<t>[local.dom ?f] else null\n  \\<delta> ?f \\<equiv> if arr ?f then \\<d>[cod ?f] \\<cdot> ?f else null\n  ide ?a \\<Longrightarrow>\n  \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?a]) \\<cdot> \\<d>[?a] = ?a\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.runit a \\<cdot> MC.tensor a (\\<tau> a) \\<cdot> \\<delta> a = a", "by auto"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  MC.runit ?a4 \\<cdot> MC.tensor ?a4 (\\<tau> ?a4) \\<cdot> \\<delta> ?a4 = ?a4\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "show \"\\<And>a. ide a \\<Longrightarrow> MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a", "using lunit_agreement \\<tau>_def \\<delta>_def prj1_dup comp_arr_dom"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow> MC.lunit ?a = \\<l>[?a]\n  \\<tau> ?f \\<equiv> if arr ?f then \\<t>[local.dom ?f] else null\n  \\<delta> ?f \\<equiv> if arr ?f then \\<d>[cod ?f] \\<cdot> ?f else null\n  ide ?a \\<Longrightarrow>\n  \\<l>[?a] \\<cdot> (\\<t>[?a] \\<otimes> ?a) \\<cdot> \\<d>[?a] = ?a\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       MC.lunit a \\<cdot> MC.tensor (\\<tau> a) a \\<cdot> \\<delta> a = a", "by auto"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  MC.lunit ?a4 \\<cdot> MC.tensor (\\<tau> ?a4) ?a4 \\<cdot> \\<delta> ?a4 = ?a4\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "show \"\\<And>a b. \\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow>\n                  MC.tensor (MC.runit a \\<cdot> MC.tensor a (\\<tau> b)) (MC.lunit b \\<cdot> MC.tensor (\\<tau> a) b) \\<cdot>\n                  \\<delta> (MC.tensor a b) = MC.tensor a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "assume a: \"ide a\" and b: \"ide b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "have \"seq \\<r>[a] (a \\<otimes> \\<t>[b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<r>[a] (a \\<otimes> \\<t>[b])", "by (metis a b arr_tensor cod_tensor ide_char in_homE runit_in_hom seqI trm_simps(1,3))"], ["proof (state)\nthis:\n  seq \\<r>[a] (a \\<otimes> \\<t>[b])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "moreover"], ["proof (state)\nthis:\n  seq \\<r>[a] (a \\<otimes> \\<t>[b])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "have \"seq \\<l>[b] (\\<t>[a] \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<l>[b] (\\<t>[a] \\<otimes> b)", "by (metis a b arr_tensor cod_tensor ide_char in_homE lunit_in_hom seqI trm_simps(1,3))"], ["proof (state)\nthis:\n  seq \\<l>[b] (\\<t>[a] \\<otimes> b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> MC.tensor\n                          (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                          (MC.lunit b \\<cdot>\n                           MC.tensor (\\<tau> a) b) \\<cdot>\n                         \\<delta> (MC.tensor a b) =\n                         MC.tensor a b", "ultimately"], ["proof (chain)\npicking this:\n  seq \\<r>[a] (a \\<otimes> \\<t>[b])\n  seq \\<l>[b] (\\<t>[a] \\<otimes> b)", "show \"MC.tensor (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n                                   (MC.lunit b \\<cdot> MC.tensor (\\<tau> a) b) \\<cdot> \\<delta> (MC.tensor a b) =\n                         MC.tensor a b\""], ["proof (prove)\nusing this:\n  seq \\<r>[a] (a \\<otimes> \\<t>[b])\n  seq \\<l>[b] (\\<t>[a] \\<otimes> b)\n\ngoal (1 subgoal):\n 1. MC.tensor (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n     (MC.lunit b \\<cdot> MC.tensor (\\<tau> a) b) \\<cdot>\n    \\<delta> (MC.tensor a b) =\n    MC.tensor a b", "using a b lunit_agreement runit_agreement unitor_coincidence \\<tau>_def \\<delta>_def comp_arr_dom\n                tensor_preserves_ide tuple_prj T_def"], ["proof (prove)\nusing this:\n  seq \\<r>[a] (a \\<otimes> \\<t>[b])\n  seq \\<l>[b] (\\<t>[a] \\<otimes> b)\n  ide a\n  ide b\n  ide ?a \\<Longrightarrow> MC.lunit ?a = \\<l>[?a]\n  ide ?a \\<Longrightarrow> MC.runit ?a = \\<r>[?a]\n  \\<l>[\\<I>] = \\<iota>\n  \\<r>[\\<I>] = \\<iota>\n  \\<tau> ?f \\<equiv> if arr ?f then \\<t>[local.dom ?f] else null\n  \\<delta> ?f \\<equiv> if arr ?f then \\<d>[cod ?f] \\<cdot> ?f else null\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (?a \\<otimes> ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> (\\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b]) \\<otimes>\n                     \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)) \\<cdot>\n                    \\<d>[?a \\<otimes> ?b] =\n                    ?a \\<otimes> ?b\n  T ?f \\<equiv> if CC.arr ?f then fst ?f \\<otimes> snd ?f else null\n\ngoal (1 subgoal):\n 1. MC.tensor (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n     (MC.lunit b \\<cdot> MC.tensor (\\<tau> a) b) \\<cdot>\n    \\<delta> (MC.tensor a b) =\n    MC.tensor a b", "by auto"], ["proof (state)\nthis:\n  MC.tensor (MC.runit a \\<cdot> MC.tensor a (\\<tau> b))\n   (MC.lunit b \\<cdot> MC.tensor (\\<tau> a) b) \\<cdot>\n  \\<delta> (MC.tensor a b) =\n  MC.tensor a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> MC.tensor\n                     (MC.runit ?a4 \\<cdot> MC.tensor ?a4 (\\<tau> ?b4))\n                     (MC.lunit ?b4 \\<cdot>\n                      MC.tensor (\\<tau> ?a4) ?b4) \\<cdot>\n                    \\<delta> (MC.tensor ?a4 ?b4) =\n                    MC.tensor ?a4 ?b4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induces_cartesian_monoidal_category:\n    shows \"cartesian_monoidal_category C T \\<alpha> \\<iota> \\<delta> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_monoidal_category (\\<cdot>) T \\<alpha> \\<iota> \\<delta> \\<tau>", ".."], ["", "end"], ["", "text \\<open>\n    A cartesian category extends to a a cartesian monoidal category by using the product\n    structure to obtain the various canonical maps.\n  \\<close>"], ["", "context cartesian_category\n  begin"], ["", "interpretation C: elementary_cartesian_category C pr0 pr1 \\<one> trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm", "using extends_to_elementary_cartesian_category"], ["proof (prove)\nusing this:\n  elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm\n\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm", "by simp"], ["", "interpretation CC: product_category C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) (\\<cdot>)", ".."], ["", "interpretation CCC: product_category C CC.comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) CC.comp", ".."], ["", "interpretation T: binary_functor C C C Prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "using binary_functor_Prod"], ["proof (prove)\nusing this:\n  binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod\n  binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) Prod'\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "by simp"], ["", "interpretation T: binary_endofunctor C Prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_endofunctor (\\<cdot>) local.Prod", ".."], ["", "interpretation ToTC: \"functor\" CCC.comp C T.ToTC"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor CCC.comp (\\<cdot>) T.ToTC", "using T.functor_ToTC"], ["proof (prove)\nusing this:\n  functor CCC.comp (\\<cdot>) T.ToTC\n\ngoal (1 subgoal):\n 1. functor CCC.comp (\\<cdot>) T.ToTC", "by auto"], ["", "interpretation ToCT: \"functor\" CCC.comp C T.ToCT"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor CCC.comp (\\<cdot>) T.ToCT", "using T.functor_ToCT"], ["proof (prove)\nusing this:\n  functor CCC.comp (\\<cdot>) T.ToCT\n\ngoal (1 subgoal):\n 1. functor CCC.comp (\\<cdot>) T.ToCT", "by auto"], ["", "interpretation \\<alpha>: transformation_by_components CCC.comp C T.ToTC T.ToCT\n                        \\<open>\\<lambda>abc. assoc (fst abc) (fst (snd abc)) (snd (snd abc))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components CCC.comp (\\<cdot>) T.ToTC T.ToCT\n     (\\<lambda>abc. assoc (fst abc) (fst (snd abc)) (snd (snd abc)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       CCC.ide a \\<Longrightarrow>\n       \\<guillemotleft>assoc (fst a) (fst (snd a))\n                        (snd (snd a)) : T.ToTC\n   a \\<rightarrow> T.ToCT a\\<guillemotright>\n 2. \\<And>f.\n       CCC.arr f \\<Longrightarrow>\n       assoc (fst (CCC.cod f)) (fst (snd (CCC.cod f)))\n        (snd (snd (CCC.cod f))) \\<cdot>\n       T.ToTC f =\n       T.ToCT f \\<cdot>\n       assoc (fst (CCC.dom f)) (fst (snd (CCC.dom f)))\n        (snd (snd (CCC.dom f)))", "show \"\\<And>abc. CCC.ide abc \\<Longrightarrow>\n                     \\<guillemotleft>assoc (fst abc) (fst (snd abc)) (snd (snd abc)) : T.ToTC abc \\<rightarrow> T.ToCT abc\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>abc.\n       CCC.ide abc \\<Longrightarrow>\n       \\<guillemotleft>assoc (fst abc) (fst (snd abc))\n                        (snd (snd abc)) : T.ToTC\n     abc \\<rightarrow> T.ToCT abc\\<guillemotright>", "using CCC.ide_char CC.ide_char CCC.arr_char CC.arr_char T.ToTC_def T.ToCT_def"], ["proof (prove)\nusing this:\n  CCC.ide ?f = (ide (fst ?f) \\<and> CC.ide (snd ?f))\n  CC.ide ?f = (ide (fst ?f) \\<and> ide (snd ?f))\n  CCC.arr ?f = (arr (fst ?f) \\<and> CC.arr (snd ?f))\n  CC.arr ?f = (arr (fst ?f) \\<and> arr (snd ?f))\n  T.ToTC ?f \\<equiv>\n  if CCC.arr ?f\n  then local.Prod (local.Prod (fst ?f, fst (snd ?f)), snd (snd ?f))\n  else null\n  T.ToCT ?f \\<equiv>\n  if CCC.arr ?f\n  then local.Prod (fst ?f, local.Prod (fst (snd ?f), snd (snd ?f)))\n  else null\n\ngoal (1 subgoal):\n 1. \\<And>abc.\n       CCC.ide abc \\<Longrightarrow>\n       \\<guillemotleft>assoc (fst abc) (fst (snd abc))\n                        (snd (snd abc)) : T.ToTC\n     abc \\<rightarrow> T.ToCT abc\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  CCC.ide ?abc4 \\<Longrightarrow>\n  \\<guillemotleft>assoc (fst ?abc4) (fst (snd ?abc4))\n                   (snd (snd ?abc4)) : T.ToTC\n  ?abc4 \\<rightarrow> T.ToCT ?abc4\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       CCC.arr f \\<Longrightarrow>\n       assoc (fst (CCC.cod f)) (fst (snd (CCC.cod f)))\n        (snd (snd (CCC.cod f))) \\<cdot>\n       T.ToTC f =\n       T.ToCT f \\<cdot>\n       assoc (fst (CCC.dom f)) (fst (snd (CCC.dom f)))\n        (snd (snd (CCC.dom f)))", "show \"\\<And>f. CCC.arr f \\<Longrightarrow>\n                  assoc (fst (CCC.cod f)) (fst (snd (CCC.cod f))) (snd (snd (CCC.cod f)))\n                          \\<cdot> T.ToTC f =\n                  T.ToCT f\n                    \\<cdot> assoc (fst (CCC.dom f)) (fst (snd (CCC.dom f))) (snd (snd (CCC.dom f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       CCC.arr f \\<Longrightarrow>\n       assoc (fst (CCC.cod f)) (fst (snd (CCC.cod f)))\n        (snd (snd (CCC.cod f))) \\<cdot>\n       T.ToTC f =\n       T.ToCT f \\<cdot>\n       assoc (fst (CCC.dom f)) (fst (snd (CCC.dom f)))\n        (snd (snd (CCC.dom f)))", "using CCC.arr_char CC.arr_char CCC.dom_char CCC.cod_char T.ToTC_def T.ToCT_def\n              assoc_naturality"], ["proof (prove)\nusing this:\n  CCC.arr ?f = (arr (fst ?f) \\<and> CC.arr (snd ?f))\n  CC.arr ?f = (arr (fst ?f) \\<and> arr (snd ?f))\n  CCC.dom ?f =\n  (if arr (fst ?f) \\<and> CC.arr (snd ?f)\n   then (local.dom (fst ?f), CC.dom (snd ?f)) else (null, CC.null))\n  CCC.cod ?f =\n  (if arr (fst ?f) \\<and> CC.arr (snd ?f)\n   then (cod (fst ?f), CC.cod (snd ?f)) else (null, CC.null))\n  T.ToTC ?f \\<equiv>\n  if CCC.arr ?f\n  then local.Prod (local.Prod (fst ?f, fst (snd ?f)), snd (snd ?f))\n  else null\n  T.ToCT ?f \\<equiv>\n  if CCC.arr ?f\n  then local.Prod (fst ?f, local.Prod (fst (snd ?f), snd (snd ?f)))\n  else null\n  \\<lbrakk>\\<guillemotleft>?f0.0 : ?a0.0 \\<rightarrow> ?b0.0\\<guillemotright>;\n   \\<guillemotleft>?f1.0 : ?a1.0 \\<rightarrow> ?b1.0\\<guillemotright>;\n   \\<guillemotleft>?f2.0 : ?a2.0 \\<rightarrow> ?b2.0\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> assoc ?b0.0 ?b1.0 ?b2.0 \\<cdot>\n                    local.prod (local.prod ?f0.0 ?f1.0) ?f2.0 =\n                    local.prod ?f0.0 (local.prod ?f1.0 ?f2.0) \\<cdot>\n                    assoc ?a0.0 ?a1.0 ?a2.0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       CCC.arr f \\<Longrightarrow>\n       assoc (fst (CCC.cod f)) (fst (snd (CCC.cod f)))\n        (snd (snd (CCC.cod f))) \\<cdot>\n       T.ToTC f =\n       T.ToCT f \\<cdot>\n       assoc (fst (CCC.dom f)) (fst (snd (CCC.dom f)))\n        (snd (snd (CCC.dom f)))", "by simp blast"], ["proof (state)\nthis:\n  CCC.arr ?f4 \\<Longrightarrow>\n  assoc (fst (CCC.cod ?f4)) (fst (snd (CCC.cod ?f4)))\n   (snd (snd (CCC.cod ?f4))) \\<cdot>\n  T.ToTC ?f4 =\n  T.ToCT ?f4 \\<cdot>\n  assoc (fst (CCC.dom ?f4)) (fst (snd (CCC.dom ?f4)))\n   (snd (snd (CCC.dom ?f4)))\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<alpha>: natural_isomorphism CCC.comp C T.ToTC T.ToCT \\<alpha>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism CCC.comp (\\<cdot>) T.ToTC T.ToCT \\<alpha>.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. CCC.ide a \\<Longrightarrow> local.iso (\\<alpha>.map a)", "show \"\\<And>a. CCC.ide a \\<Longrightarrow> iso (\\<alpha>.map a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. CCC.ide a \\<Longrightarrow> local.iso (\\<alpha>.map a)", "using CCC.ide_char CC.ide_char \\<alpha>.map_simp_ide inverse_arrows_assoc"], ["proof (prove)\nusing this:\n  CCC.ide ?f = (ide (fst ?f) \\<and> CC.ide (snd ?f))\n  CC.ide ?f = (ide (fst ?f) \\<and> ide (snd ?f))\n  CCC.ide ?a \\<Longrightarrow>\n  \\<alpha>.map ?a = assoc (fst ?a) (fst (snd ?a)) (snd (snd ?a))\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows (assoc ?a ?b ?c) (assoc' ?a ?b ?c)\n\ngoal (1 subgoal):\n 1. \\<And>a. CCC.ide a \\<Longrightarrow> local.iso (\\<alpha>.map a)", "by auto"], ["proof (state)\nthis:\n  CCC.ide ?a4 \\<Longrightarrow> local.iso (\\<alpha>.map ?a4)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation L: \"functor\" C C \\<open>\\<lambda>f. Prod (cod \\<iota>, f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>f. local.Prod (cod \\<iota>, f))", "using \\<iota>_is_terminal_arr T.fixing_ide_gives_functor_1"], ["proof (prove)\nusing this:\n  terminal_arr \\<iota>\n  ide ?a1.0 \\<Longrightarrow>\n  functor (\\<cdot>) (\\<cdot>) (\\<lambda>f2. local.Prod (?a1.0, f2))\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>f. local.Prod (cod \\<iota>, f))", "by simp"], ["", "interpretation L: endofunctor C \\<open>\\<lambda>f. Prod (cod \\<iota>, f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. endofunctor (\\<cdot>) (\\<lambda>f. local.Prod (cod \\<iota>, f))", ".."], ["", "interpretation \\<l>: transformation_by_components C C\n                        \\<open>\\<lambda>f. Prod (cod \\<iota>, f)\\<close> map \\<open>\\<lambda>a. pr0 (cod \\<iota>) a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map (pr0 (cod \\<iota>))", "using \\<iota>_is_terminal_arr"], ["proof (prove)\nusing this:\n  terminal_arr \\<iota>\n\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map (pr0 (cod \\<iota>))", "by unfold_locales auto"], ["", "interpretation \\<l>: natural_isomorphism C C \\<open>\\<lambda>f. Prod (cod \\<iota>, f)\\<close> map \\<l>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map \\<l>.map", "using \\<l>.map_simp_ide inverse_arrows_lunit ide_some_terminal"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow> \\<l>.map ?a = pr0 (cod \\<iota>) ?a\n  ide ?a \\<Longrightarrow> inverse_arrows (lunit ?a) (lunit' ?a)\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. natural_isomorphism (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map \\<l>.map", "by unfold_locales auto"], ["", "interpretation L: equivalence_functor C C \\<open>\\<lambda>f. Prod (cod \\<iota>, f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f))", "using \\<l>.natural_isomorphism_axioms naturally_isomorphic_def\n            L.isomorphic_to_identity_is_equivalence"], ["proof (prove)\nusing this:\n  natural_isomorphism (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map \\<l>.map\n  naturally_isomorphic ?A ?B ?F ?G =\n  (\\<exists>\\<tau>. natural_isomorphism ?A ?B ?F ?G \\<tau>)\n  natural_isomorphism (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (cod \\<iota>, f)) local.map\n   ?\\<phi> \\<Longrightarrow>\n  equivalence_functor (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (cod \\<iota>, f))\n\ngoal (1 subgoal):\n 1. equivalence_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (cod \\<iota>, f))", "by blast"], ["", "interpretation R: \"functor\" C C \\<open>\\<lambda>f. Prod (f, cod \\<iota>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>f. local.Prod (f, cod \\<iota>))", "using \\<iota>_is_terminal_arr T.fixing_ide_gives_functor_2"], ["proof (prove)\nusing this:\n  terminal_arr \\<iota>\n  ide ?a2.0 \\<Longrightarrow>\n  functor (\\<cdot>) (\\<cdot>) (\\<lambda>f1. local.Prod (f1, ?a2.0))\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>f. local.Prod (f, cod \\<iota>))", "by simp"], ["", "interpretation R: endofunctor C\\<open>\\<lambda>f. Prod (f, cod \\<iota>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. endofunctor (\\<cdot>) (\\<lambda>f. local.Prod (f, cod \\<iota>))", ".."], ["", "interpretation \\<rho>: transformation_by_components C C\n                        \\<open>\\<lambda>f. Prod (f, cod \\<iota>)\\<close> map \\<open>\\<lambda>a. pr1 a (cod \\<iota>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map\n     (\\<lambda>a. pr1 a (cod \\<iota>))", "using \\<iota>_is_terminal_arr"], ["proof (prove)\nusing this:\n  terminal_arr \\<iota>\n\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map\n     (\\<lambda>a. pr1 a (cod \\<iota>))", "by unfold_locales auto"], ["", "interpretation \\<rho>: natural_isomorphism C C \\<open>\\<lambda>f. Prod (f, cod \\<iota>)\\<close> map \\<rho>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map \\<rho>.map", "using \\<rho>.map_simp_ide inverse_arrows_runit ide_some_terminal"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow> \\<rho>.map ?a = pr1 ?a (cod \\<iota>)\n  ide ?a \\<Longrightarrow> inverse_arrows (runit ?a) (runit' ?a)\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. natural_isomorphism (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map \\<rho>.map", "by unfold_locales auto"], ["", "interpretation R: equivalence_functor C C \\<open>\\<lambda>f. Prod (f, cod \\<iota>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>))", "using \\<rho>.natural_isomorphism_axioms naturally_isomorphic_def\n            R.isomorphic_to_identity_is_equivalence"], ["proof (prove)\nusing this:\n  natural_isomorphism (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map \\<rho>.map\n  naturally_isomorphic ?A ?B ?F ?G =\n  (\\<exists>\\<tau>. natural_isomorphism ?A ?B ?F ?G \\<tau>)\n  natural_isomorphism (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (f, cod \\<iota>)) local.map\n   ?\\<phi> \\<Longrightarrow>\n  equivalence_functor (\\<cdot>) (\\<cdot>)\n   (\\<lambda>f. local.Prod (f, cod \\<iota>))\n\ngoal (1 subgoal):\n 1. equivalence_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>f. local.Prod (f, cod \\<iota>))", "by blast"], ["", "interpretation C: monoidal_category C Prod \\<alpha>.map \\<iota>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) local.Prod \\<alpha>.map \\<iota>", "using ide_some_terminal \\<iota>_is_iso pentagon comp_assoc"], ["proof (prove)\nusing this:\n  ide \\<one>\n  local.iso \\<iota>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c; ide ?d\\<rbrakk>\n  \\<Longrightarrow> (local.prod ?a (assoc ?b ?c ?d) \\<cdot>\n                     assoc ?a (local.prod ?b ?c) ?d) \\<cdot>\n                    local.prod (assoc ?a ?b ?c) ?d =\n                    assoc ?a ?b (local.prod ?c ?d) \\<cdot>\n                    assoc (local.prod ?a ?b) ?c ?d\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. monoidal_category (\\<cdot>) local.Prod \\<alpha>.map \\<iota>", "by unfold_locales auto"], ["", "interpretation \\<Omega>: constant_functor C C C.unity"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor (\\<cdot>) (\\<cdot>) C.unity", "using C.ide_unity"], ["proof (prove)\nusing this:\n  ide C.unity\n\ngoal (1 subgoal):\n 1. constant_functor (\\<cdot>) (\\<cdot>) C.unity", "by unfold_locales auto"], ["", "interpretation \\<tau>: natural_transformation C C map \\<Omega>.map trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Omega>.map trm", "using C.unity_def \\<Omega>.map_def ide_some_terminal trm_naturality comp_cod_arr trm_in_hom"], ["proof (prove)\nusing this:\n  C.unity \\<equiv> cod \\<iota>\n  \\<Omega>.map ?f = (if arr ?f then C.unity else null)\n  ide \\<one>\n  arr ?f \\<Longrightarrow> \\<t>[cod ?f] \\<cdot> ?f = \\<t>[local.dom ?f]\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  arr ?f \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?f] : local.dom\n                              ?f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Omega>.map trm", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[f] = null\n 2. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom \\<t>[f] = local.map (local.dom f)\n 3. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> cod \\<t>[f] = \\<Omega>.map (cod f)\n 4. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<Omega>.map f \\<cdot> \\<t>[local.dom f] = \\<t>[f]\n 5. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "using trm_def"], ["proof (prove)\nusing this:\n  \\<t>[?f] \\<equiv>\n  if arr ?f\n  then THE t.\n          \\<guillemotleft>t : local.dom\n                               ?f \\<rightarrow> \\<one>\\<guillemotright>\n  else null\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[f] = null\n 2. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom \\<t>[f] = local.map (local.dom f)\n 3. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> cod \\<t>[f] = \\<Omega>.map (cod f)\n 4. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<Omega>.map f \\<cdot> \\<t>[local.dom f] = \\<t>[f]\n 5. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "apply auto[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom \\<t>[f] = local.map (local.dom f)\n 2. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> cod \\<t>[f] = \\<Omega>.map (cod f)\n 3. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<Omega>.map f \\<cdot> \\<t>[local.dom f] = \\<t>[f]\n 4. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> cod \\<t>[f] = \\<Omega>.map (cod f)\n 2. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<Omega>.map f \\<cdot> \\<t>[local.dom f] = \\<t>[f]\n 3. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<Omega>.map f \\<cdot> \\<t>[local.dom f] = \\<t>[f]\n 2. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "apply (metis in_homE trm_eqI trm_in_hom cod_pr0 dom_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>C.unity \\<equiv> cod \\<iota>;\n        \\<And>f. \\<Omega>.map f = (if arr f then C.unity else null);\n        ide \\<one>;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f];\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<And>f.\n           arr f \\<Longrightarrow>\n           \\<guillemotleft>\\<t>[f] : local.dom\nf \\<rightarrow> \\<one>\\<guillemotright>;\n        arr f\\<rbrakk>\n       \\<Longrightarrow> \\<t>[cod f] \\<cdot> local.map f = \\<t>[f]", "by (metis trm_eqI trm_in_hom dom_dom map_simp)"], ["", "interpretation \\<Delta>: \"functor\" C CC.comp Diag"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) CC.comp Diag", "using functor_Diag"], ["proof (prove)\nusing this:\n  functor (\\<cdot>) CC.comp Diag\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) CC.comp Diag", "by simp"], ["", "interpretation \\<Pi>o\\<Delta>: composite_functor C CC.comp C Diag Prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>) CC.comp (\\<cdot>) Diag local.Prod", ".."], ["", "interpretation natural_transformation C C map \\<open>Prod o Diag\\<close> dup"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n     dup", "using dup_is_natural_transformation"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n   dup\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n     dup", "by simp"], ["", "lemma unity_agreement:\n    shows \"C.unity = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.unity = \\<one>", "using C.unity_def ide_some_terminal"], ["proof (prove)\nusing this:\n  C.unity \\<equiv> cod \\<iota>\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. C.unity = \\<one>", "by simp"], ["", "lemma assoc_agreement:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"C.assoc a b c = assoc a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.assoc a b c = assoc a b c", "using assms assoc_def \\<alpha>.map_simp_ide"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  assoc ?a ?b ?c \\<equiv>\n  tuple (pr1 ?a ?b \\<cdot> pr1 (local.prod ?a ?b) ?c)\n   (tuple (pr0 ?a ?b \\<cdot> pr1 (local.prod ?a ?b) ?c)\n     (pr0 (local.prod ?a ?b) ?c))\n  CCC.ide ?a \\<Longrightarrow>\n  \\<alpha>.map ?a = assoc (fst ?a) (fst (snd ?a)) (snd (snd ?a))\n\ngoal (1 subgoal):\n 1. C.assoc a b c = assoc a b c", "by simp"], ["", "lemma assoc'_agreement:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"C.assoc' a b c = assoc' a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.assoc' a b c = assoc' a b c", "using assms inverse_arrows_assoc inverse_unique"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> inverse_arrows (assoc ?a ?b ?c) (assoc' ?a ?b ?c)\n  inverse_arrows ?f ?g \\<Longrightarrow> local.inv ?f = ?g\n\ngoal (1 subgoal):\n 1. C.assoc' a b c = assoc' a b c", "by auto"], ["", "lemma runit_char_eqn:\n    assumes \"ide a\"\n    shows \"prod (runit a) \\<one> = prod a \\<iota> \\<cdot> assoc a \\<one> \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prod (runit a) \\<one> =\n    local.prod a \\<iota> \\<cdot> assoc a \\<one> \\<one>", "using assms ide_one assoc_def comp_assoc prod_tuple comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  assoc ?a ?b ?c \\<equiv>\n  tuple (pr1 ?a ?b \\<cdot> pr1 (local.prod ?a ?b) ?c)\n   (tuple (pr0 ?a ?b \\<cdot> pr1 (local.prod ?a ?b) ?c)\n     (pr0 (local.prod ?a ?b) ?c))\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> local.prod ?h ?k \\<cdot> tuple ?f ?g =\n                    tuple (?h \\<cdot> ?f) (?k \\<cdot> ?g)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. local.prod (runit a) \\<one> =\n    local.prod a \\<iota> \\<cdot> assoc a \\<one> \\<one>", "by (intro pr_joint_monic [of a \\<one> \"prod (runit a) \\<one>\" \"prod a \\<iota> \\<cdot> assoc a \\<one> \\<one>\"]) auto"], ["", "lemma runit_agreement:\n    assumes \"ide a\"\n    shows \"runit a = C.runit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runit a = C.runit a", "using assms unity_agreement assoc_agreement C.runit_char(2) runit_char_eqn\n            ide_some_terminal"], ["proof (prove)\nusing this:\n  ide a\n  C.unity = \\<one>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> C.assoc ?a ?b ?c = assoc ?a ?b ?c\n  ide ?a \\<Longrightarrow>\n  C.tensor (C.runit ?a) C.unity =\n  C.tensor ?a \\<iota> \\<cdot> C.assoc ?a C.unity C.unity\n  ide ?a \\<Longrightarrow>\n  local.prod (runit ?a) \\<one> =\n  local.prod ?a \\<iota> \\<cdot> assoc ?a \\<one> \\<one>\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. runit a = C.runit a", "by (intro C.runit_eqI) auto"], ["", "lemma lunit_char_eqn:\n    assumes \"ide a\"\n    shows \"prod \\<one> (lunit a) = prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prod \\<one> (lunit a) =\n    local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "proof (intro pr_joint_monic [of \\<one> a \"prod \\<one> (lunit a)\" \"prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq (lunit a) (local.prod \\<one> (lunit a))\n 2. lunit a \\<cdot> local.prod \\<one> (lunit a) =\n    lunit a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\n 3. pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n    pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "show \"seq (lunit a) (local.prod \\<one> (lunit a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (lunit a) (local.prod \\<one> (lunit a))", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. seq (lunit a) (local.prod \\<one> (lunit a))", "by simp"], ["proof (state)\nthis:\n  seq (lunit a) (local.prod \\<one> (lunit a))\n\ngoal (2 subgoals):\n 1. lunit a \\<cdot> local.prod \\<one> (lunit a) =\n    lunit a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\n 2. pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n    pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "show \"lunit a \\<cdot> prod \\<one> (lunit a) = lunit a \\<cdot> prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunit a \\<cdot> local.prod \\<one> (lunit a) =\n    lunit a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "using assms ide_one assoc'_def comp_assoc prod_tuple comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  assoc' ?a ?b ?c \\<equiv>\n  tuple\n   (tuple (pr1 ?a (local.prod ?b ?c))\n     (pr1 ?b ?c \\<cdot> pr0 ?a (local.prod ?b ?c)))\n   (pr0 ?b ?c \\<cdot> pr0 ?a (local.prod ?b ?c))\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> local.prod ?h ?k \\<cdot> tuple ?f ?g =\n                    tuple (?h \\<cdot> ?f) (?k \\<cdot> ?g)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. lunit a \\<cdot> local.prod \\<one> (lunit a) =\n    lunit a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "by simp"], ["proof (state)\nthis:\n  lunit a \\<cdot> local.prod \\<one> (lunit a) =\n  lunit a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\n\ngoal (1 subgoal):\n 1. pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n    pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "show \"pr1 \\<one> a \\<cdot> prod \\<one> (lunit a) = pr1 \\<one> a \\<cdot> prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n    pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "using assms ide_one assoc'_def comp_cod_arr prod_tuple pr_naturality"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  assoc' ?a ?b ?c \\<equiv>\n  tuple\n   (tuple (pr1 ?a (local.prod ?b ?c))\n     (pr1 ?b ?c \\<cdot> pr0 ?a (local.prod ?b ?c)))\n   (pr0 ?b ?c \\<cdot> pr0 ?a (local.prod ?b ?c))\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> local.prod ?h ?k \\<cdot> tuple ?f ?g =\n                    tuple (?h \\<cdot> ?f) (?k \\<cdot> ?g)\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> pr0 ?c ?d \\<cdot> local.prod ?f ?g =\n                    ?g \\<cdot> pr0 ?a ?b\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> pr1 ?c ?d \\<cdot> local.prod ?f ?g =\n                    ?f \\<cdot> pr1 ?a ?b\n\ngoal (1 subgoal):\n 1. pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n    pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ide a; ide \\<one>;\n     \\<And>a b c.\n        assoc' a b c \\<equiv>\n        tuple\n         (tuple (pr1 a (local.prod b c))\n           (pr1 b c \\<cdot> pr0 a (local.prod b c)))\n         (pr0 b c \\<cdot> pr0 a (local.prod b c));\n     \\<And>f b.\n        \\<lbrakk>arr f; cod f = b\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f;\n     \\<And>f g h k.\n        \\<lbrakk>span f g; seq h f; seq k g\\<rbrakk>\n        \\<Longrightarrow> local.prod h k \\<cdot> tuple f g =\n                          tuple (h \\<cdot> f) (k \\<cdot> g)\\<rbrakk>\n    \\<Longrightarrow> pr1 \\<one> (local.prod \\<one> a) =\n                      pr1 \\<one> a \\<cdot> lunit (local.prod \\<one> a)", "by (metis trm_eqI cod_pr0 cod_pr1 comp_in_homI' ide_prod pr_simps(1,3-6) pr1_in_hom')"], ["proof (state)\nthis:\n  pr1 \\<one> a \\<cdot> local.prod \\<one> (lunit a) =\n  pr1 \\<one> a \\<cdot> local.prod \\<iota> a \\<cdot> assoc' \\<one> \\<one> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunit_agreement:\n    assumes \"ide a\"\n    shows \"lunit a = C.lunit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunit a = C.lunit a", "using assms unity_agreement assoc'_agreement C.lunit_char(2) lunit_char_eqn\n            ide_some_terminal"], ["proof (prove)\nusing this:\n  ide a\n  C.unity = \\<one>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> C.assoc' ?a ?b ?c = assoc' ?a ?b ?c\n  ide ?a \\<Longrightarrow>\n  C.tensor C.unity (C.lunit ?a) =\n  C.tensor \\<iota> ?a \\<cdot> C.assoc' C.unity C.unity ?a\n  ide ?a \\<Longrightarrow>\n  local.prod \\<one> (lunit ?a) =\n  local.prod \\<iota> ?a \\<cdot> assoc' \\<one> \\<one> ?a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. lunit a = C.lunit a", "by (intro C.lunit_eqI) auto"], ["", "interpretation C: cartesian_monoidal_category C Prod \\<alpha>.map \\<iota> dup trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_monoidal_category (\\<cdot>) local.Prod \\<alpha>.map \\<iota>\n     dup trm", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<t>[C.unity] = C.unity\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.runit a \\<cdot> C.tensor a \\<t>[a] \\<cdot> dup a = a\n 3. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "show \"trm C.unity = C.unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[C.unity] = C.unity", "by (simp add: C.unity_def ide_some_terminal trm_one)"], ["proof (state)\nthis:\n  \\<t>[C.unity] = C.unity\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.runit a \\<cdot> C.tensor a \\<t>[a] \\<cdot> dup a = a\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "show \"\\<And>a. ide a \\<Longrightarrow> C.runit a \\<cdot> C.tensor a \\<t>[a] \\<cdot> dup a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.runit a \\<cdot> C.tensor a \\<t>[a] \\<cdot> dup a = a", "using comp_runit_term_dup runit_agreement"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow>\n  runit ?a \\<cdot> local.prod ?a \\<t>[?a] \\<cdot> dup ?a = ?a\n  ide ?a \\<Longrightarrow> runit ?a = C.runit ?a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.runit a \\<cdot> C.tensor a \\<t>[a] \\<cdot> dup a = a", "by simp"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  C.runit ?a4 \\<cdot> C.tensor ?a4 \\<t>[?a4] \\<cdot> dup ?a4 = ?a4\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "show \"\\<And>a. ide a \\<Longrightarrow> C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a", "using comp_lunit_term_dup lunit_agreement"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow>\n  lunit ?a \\<cdot> local.prod \\<t>[?a] ?a \\<cdot> dup ?a = ?a\n  ide ?a \\<Longrightarrow> lunit ?a = C.lunit ?a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       C.lunit a \\<cdot> C.tensor \\<t>[a] a \\<cdot> dup a = a", "by auto"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  C.lunit ?a4 \\<cdot> C.tensor \\<t>[?a4] ?a4 \\<cdot> dup ?a4 = ?a4\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk>\n                     \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                                  (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot> dup (C.tensor a b) =\n                         C.tensor a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "assume a: \"ide a\" and b: \"ide b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                       (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot> dup (C.tensor a b) =\n              prod (C.runit a \\<cdot> prod a \\<t>[b]) (C.lunit b \\<cdot> prod \\<t>[a] b) \\<cdot> dup (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n     (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n    dup (C.tensor a b) =\n    local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n    dup (local.prod a b)", "using a b"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n     (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n    dup (C.tensor a b) =\n    local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n    dup (local.prod a b)", "by simp"], ["proof (state)\nthis:\n  C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n   (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n  dup (C.tensor a b) =\n  local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n  dup (local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n   (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n  dup (C.tensor a b) =\n  local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n  dup (local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = tuple ((C.runit a \\<cdot> prod a \\<t>[b]) \\<cdot> prod a b)\n                               ((C.lunit b \\<cdot> prod \\<t>[a] b) \\<cdot> prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n    dup (local.prod a b) =\n    tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n     ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b)", "using a b ide_one trm_in_hom [of a] trm_in_hom [of b] unity_agreement prod_tuple"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide \\<one>\n  arr a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[a] : local.dom\n                             a \\<rightarrow> \\<one>\\<guillemotright>\n  arr b \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[b] : local.dom\n                             b \\<rightarrow> \\<one>\\<guillemotright>\n  C.unity = \\<one>\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> local.prod ?h ?k \\<cdot> tuple ?f ?g =\n                    tuple (?h \\<cdot> ?f) (?k \\<cdot> ?g)\n\ngoal (1 subgoal):\n 1. local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n    dup (local.prod a b) =\n    tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n     ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b)", "by fastforce"], ["proof (state)\nthis:\n  local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n  dup (local.prod a b) =\n  tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n   ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  local.prod (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot>\n  dup (local.prod a b) =\n  tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n   ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = tuple (C.runit a \\<cdot> prod a \\<t>[b] \\<cdot> prod a b)\n                               (C.lunit b \\<cdot> prod \\<t>[a] b \\<cdot> prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n     ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b) =\n    tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b)", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n     ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b) =\n    tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b)", "by simp"], ["proof (state)\nthis:\n  tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n   ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b) =\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  tuple ((C.runit a \\<cdot> local.prod a \\<t>[b]) \\<cdot> local.prod a b)\n   ((C.lunit b \\<cdot> local.prod \\<t>[a] b) \\<cdot> local.prod a b) =\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = tuple (C.runit a \\<cdot> prod a \\<t>[b]) (C.lunit b \\<cdot> prod \\<t>[a] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b) =\n    tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b)", "using a b comp_arr_dom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b) =\n    tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b)", "by simp"], ["proof (state)\nthis:\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b) =\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b] \\<cdot> local.prod a b)\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b \\<cdot> local.prod a b) =\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = tuple (runit a \\<cdot> prod a \\<t>[b]) (lunit b \\<cdot> prod \\<t>[a] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b)", "using a b lunit_agreement runit_agreement"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide ?a \\<Longrightarrow> lunit ?a = C.lunit ?a\n  ide ?a \\<Longrightarrow> runit ?a = C.runit ?a\n\ngoal (1 subgoal):\n 1. tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n     (C.lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b)", "by simp"], ["proof (state)\nthis:\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) =\n  tuple (runit a \\<cdot> local.prod a \\<t>[b])\n   (lunit b \\<cdot> local.prod \\<t>[a] b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  tuple (C.runit a \\<cdot> local.prod a \\<t>[b])\n   (C.lunit b \\<cdot> local.prod \\<t>[a] b) =\n  tuple (runit a \\<cdot> local.prod a \\<t>[b])\n   (lunit b \\<cdot> local.prod \\<t>[a] b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = tuple (pr1 a b) (pr0 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "have \"runit a \\<cdot> prod a \\<t>[b] = pr1 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b", "using a b pr_naturality(2) trm_in_hom [of b]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> pr1 ?c ?d \\<cdot> local.prod ?f ?g =\n                    ?f \\<cdot> pr1 ?a ?b\n  arr b \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[b] : local.dom\n                             b \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b", "by (metis cod_pr1 comp_ide_arr ide_char in_homE pr_simps(4,6) seqI)"], ["proof (state)\nthis:\n  runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b\n\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "moreover"], ["proof (state)\nthis:\n  runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b\n\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "have \"lunit b \\<cdot> prod \\<t>[a] b = pr0 a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lunit b \\<cdot> local.prod \\<t>[a] b = pr0 a b", "using a b pr_naturality(1) [of b b b \"\\<t>[a]\" a \\<one>] trm_in_hom [of a] comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr b; local.dom b = b; cod b = b; arr \\<t>[a];\n   local.dom \\<t>[a] = a; cod \\<t>[a] = \\<one>\\<rbrakk>\n  \\<Longrightarrow> lunit b \\<cdot> local.prod \\<t>[a] b = b \\<cdot> pr0 a b\n  arr a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[a] : local.dom\n                             a \\<rightarrow> \\<one>\\<guillemotright>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. lunit b \\<cdot> local.prod \\<t>[a] b = pr0 a b", "by (metis cod_pr0 ide_char in_homE pr_simps(1))"], ["proof (state)\nthis:\n  lunit b \\<cdot> local.prod \\<t>[a] b = pr0 a b\n\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "ultimately"], ["proof (chain)\npicking this:\n  runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b\n  lunit b \\<cdot> local.prod \\<t>[a] b = pr0 a b", "show ?thesis"], ["proof (prove)\nusing this:\n  runit a \\<cdot> local.prod a \\<t>[b] = pr1 a b\n  lunit b \\<cdot> local.prod \\<t>[a] b = pr0 a b\n\ngoal (1 subgoal):\n 1. tuple (runit a \\<cdot> local.prod a \\<t>[b])\n     (lunit b \\<cdot> local.prod \\<t>[a] b) =\n    tuple (pr1 a b) (pr0 a b)", "by simp"], ["proof (state)\nthis:\n  tuple (runit a \\<cdot> local.prod a \\<t>[b])\n   (lunit b \\<cdot> local.prod \\<t>[a] b) =\n  tuple (pr1 a b) (pr0 a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tuple (runit a \\<cdot> local.prod a \\<t>[b])\n   (lunit b \\<cdot> local.prod \\<t>[a] b) =\n  tuple (pr1 a b) (pr0 a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "also"], ["proof (state)\nthis:\n  tuple (runit a \\<cdot> local.prod a \\<t>[b])\n   (lunit b \\<cdot> local.prod \\<t>[a] b) =\n  tuple (pr1 a b) (pr0 a b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "have \"... = prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple (pr1 a b) (pr0 a b) = local.prod a b", "using a b"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. tuple (pr1 a b) (pr0 a b) = local.prod a b", "by simp"], ["proof (state)\nthis:\n  tuple (pr1 a b) (pr0 a b) = local.prod a b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                          (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n                         dup (C.tensor a b) =\n                         C.tensor a b", "finally"], ["proof (chain)\npicking this:\n  C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n   (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n  dup (C.tensor a b) =\n  local.prod a b", "show \"C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n                               (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot> dup (C.tensor a b) =\n                      C.tensor a b\""], ["proof (prove)\nusing this:\n  C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n   (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n  dup (C.tensor a b) =\n  local.prod a b\n\ngoal (1 subgoal):\n 1. C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n     (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n    dup (C.tensor a b) =\n    C.tensor a b", "by auto"], ["proof (state)\nthis:\n  C.tensor (C.runit a \\<cdot> C.tensor a \\<t>[b])\n   (C.lunit b \\<cdot> C.tensor \\<t>[a] b) \\<cdot>\n  dup (C.tensor a b) =\n  C.tensor a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> C.tensor (C.runit ?a4 \\<cdot> C.tensor ?a4 \\<t>[?b4])\n                     (C.lunit ?b4 \\<cdot> C.tensor \\<t>[?a4] ?b4) \\<cdot>\n                    dup (C.tensor ?a4 ?b4) =\n                    C.tensor ?a4 ?b4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extends_to_cartesian_monoidal_category:\n    shows \"cartesian_monoidal_category C Prod \\<alpha>.map \\<iota> dup trm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_monoidal_category (\\<cdot>) local.Prod \\<alpha>.map \\<iota>\n     dup trm", ".."], ["", "end"], ["", "text \\<open>\n    In a \\<open>cartesian_monoidal_category\\<close>, the monoidal structure is given by a categorical product\n    and terminal object, so that the underlying category is cartesian.\n  \\<close>"], ["", "context cartesian_monoidal_category\n  begin"], ["", "definition pr0                        (\"\\<p>\\<^sub>0[_, _]\")\n    where \"\\<p>\\<^sub>0[a, b] \\<equiv> if ide a \\<and> ide b then \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[b]) else null\""], ["", "definition pr1                        (\"\\<p>\\<^sub>1[_, _]\")\n    where \"\\<p>\\<^sub>1[a, b] \\<equiv> if ide a \\<and> ide b then \\<l>[b] \\<cdot> (\\<t>[a] \\<otimes> b) else null\""], ["", "lemma pr_in_hom [intro]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a0\\<guillemotright>\"\n    and \"\\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a0\\<guillemotright> &&&\n    \\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a1\\<guillemotright>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a0\\<guillemotright>\n 2. \\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a1\\<guillemotright>", "show \"\\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a0\\<guillemotright>", "unfolding pr0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>if ide a0 \\<and> ide a1\n                    then \\<r>[a0] \\<cdot> (a0 \\<otimes> \\<t>[a1])\n                    else null : a0 \\<otimes>\n                                a1 \\<rightarrow> a0\\<guillemotright>", "using assms runit_in_hom"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<r>[?a] : ?a \\<otimes>\n                             \\<I> \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>if ide a0 \\<and> ide a1\n                    then \\<r>[a0] \\<cdot> (a0 \\<otimes> \\<t>[a1])\n                    else null : a0 \\<otimes>\n                                a1 \\<rightarrow> a0\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<p>\\<^sub>0[a0, a1] : a0 \\<otimes>\n   a1 \\<rightarrow> a0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a1\\<guillemotright>", "show \"\\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes> a1 \\<rightarrow> a1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes>\n     a1 \\<rightarrow> a1\\<guillemotright>", "unfolding pr1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>if ide a0 \\<and> ide a1\n                    then \\<l>[a1] \\<cdot> (\\<t>[a0] \\<otimes> a1)\n                    else null : a0 \\<otimes>\n                                a1 \\<rightarrow> a1\\<guillemotright>", "using assms lunit_in_hom"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<l>[?a] : \\<I> \\<otimes>\n                             ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>if ide a0 \\<and> ide a1\n                    then \\<l>[a1] \\<cdot> (\\<t>[a0] \\<otimes> a1)\n                    else null : a0 \\<otimes>\n                                a1 \\<rightarrow> a1\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<p>\\<^sub>1[a0, a1] : a0 \\<otimes>\n   a1 \\<rightarrow> a1\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr_simps [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"arr \\<p>\\<^sub>0[a0, a1]\" and \"dom \\<p>\\<^sub>0[a0, a1] = a0 \\<otimes> a1\" and \"cod \\<p>\\<^sub>0[a0, a1] = a0\"\n    and \"arr \\<p>\\<^sub>1[a0, a1]\" and \"dom \\<p>\\<^sub>1[a0, a1] = a0 \\<otimes> a1\" and \"cod \\<p>\\<^sub>1[a0, a1] = a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arr \\<p>\\<^sub>0[a0, a1] &&&\n     local.dom \\<p>\\<^sub>0[a0, a1] = a0 \\<otimes> a1 &&&\n     cod \\<p>\\<^sub>0[a0, a1] = a0) &&&\n    arr \\<p>\\<^sub>1[a0, a1] &&&\n    local.dom \\<p>\\<^sub>1[a0, a1] = a0 \\<otimes> a1 &&&\n    cod \\<p>\\<^sub>1[a0, a1] = a1", "using assms pr_in_hom(1-2)"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  \\<lbrakk>ide ?a0.0; ide ?a1.0\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<p>\\<^sub>0[?a0.0, ?a1.0] : ?a0.0 \\<otimes>\n                           ?a1.0 \\<rightarrow> ?a0.0\\<guillemotright>\n  \\<lbrakk>ide ?a0.0; ide ?a1.0\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<p>\\<^sub>1[?a0.0, ?a1.0] : ?a0.0 \\<otimes>\n                           ?a1.0 \\<rightarrow> ?a1.0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (arr \\<p>\\<^sub>0[a0, a1] &&&\n     local.dom \\<p>\\<^sub>0[a0, a1] = a0 \\<otimes> a1 &&&\n     cod \\<p>\\<^sub>0[a0, a1] = a0) &&&\n    arr \\<p>\\<^sub>1[a0, a1] &&&\n    local.dom \\<p>\\<^sub>1[a0, a1] = a0 \\<otimes> a1 &&&\n    cod \\<p>\\<^sub>1[a0, a1] = a1", "by blast+"], ["", "interpretation P: composite_functor CC.comp C CC.comp T \\<Delta>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor CC.comp (\\<cdot>) CC.comp T \\<Delta>.map", ".."], ["", "interpretation ECC: elementary_cartesian_category C pr1 pr0 \\<I> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr1 pr0 \\<I> \\<tau>", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span \\<p>\\<^sub>0[a, b] \\<p>\\<^sub>1[a, b]\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>1[a, b] = b\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>0[a, b] = a\n 6. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 7. ide \\<I>\n 8. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 9. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> span \\<p>\\<^sub>0[a, b] \\<p>\\<^sub>1[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span \\<p>\\<^sub>0[a, b] \\<p>\\<^sub>1[a, b]", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> span \\<p>\\<^sub>0[?a4, ?b4] \\<p>\\<^sub>1[?a4, ?b4]\n\ngoal (8 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>1[a, b] = b\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>0[a, b] = a\n 5. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 6. ide \\<I>\n 7. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 8. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod \\<p>\\<^sub>1[a, b] = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>1[a, b] = b", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> cod \\<p>\\<^sub>1[?a4, ?b4] = ?b4\n\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>0[a, b] = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 5. ide \\<I>\n 6. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 7. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod \\<p>\\<^sub>0[a, b] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> cod \\<p>\\<^sub>0[a, b] = a", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4; ide ?b4\\<rbrakk>\n  \\<Longrightarrow> cod \\<p>\\<^sub>0[?a4, ?b4] = ?a4\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 4. ide \\<I>\n 5. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 6. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"ide \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide \\<I>", "by simp"], ["proof (state)\nthis:\n  ide \\<I>\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 4. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\n 5. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>a. ide a \\<Longrightarrow> \\<guillemotleft>\\<tau> a : a \\<rightarrow> \\<I>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a4] : ?a4 \\<rightarrow> \\<I>\\<guillemotright>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n 4. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "show \"\\<And>a f. \\<lbrakk>ide a; \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk> \\<Longrightarrow> f = \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "using \\<open>\\<And>a. ide a \\<Longrightarrow> \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<I>\\<guillemotright>\\<close> terminalE terminal_unity"], ["proof (prove)\nusing this:\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<I>\\<guillemotright>\n  \\<lbrakk>terminal ?b; ide ?a;\n   \\<And>f.\n      \\<lbrakk>\\<guillemotleft>f : ?a \\<rightarrow> ?b\\<guillemotright>;\n       \\<And>f'.\n          \\<guillemotleft>f' : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n          f' = f\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  terminal \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = \\<t>[a]", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4;\n   \\<guillemotleft>?f4 : ?a4 \\<rightarrow> \\<I>\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f4 = \\<t>[?a4]\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null\n 2. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> \\<p>\\<^sub>1[a, b] = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null", "using pr1_def"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>1[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)\n  else null\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>1[a, b] = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a4 \\<and> ide ?b4) \\<Longrightarrow>\n  \\<p>\\<^sub>1[?a4, ?b4] = null\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null\n 2. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> \\<p>\\<^sub>0[a, b] = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null", "using pr0_def"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b])\n  else null\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<not> (ide a \\<and> ide b) \\<Longrightarrow>\n       \\<p>\\<^sub>0[a, b] = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a4 \\<and> ide ?b4) \\<Longrightarrow>\n  \\<p>\\<^sub>0[?a4, ?b4] = null\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "show \"\\<And>f g. span f g \\<Longrightarrow> \\<exists>!l. \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and> \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "assume fg: \"span f g\""], ["proof (state)\nthis:\n  span f g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "let ?l = \"(f \\<otimes> g) \\<cdot> \\<d>[dom f]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "have \"\\<p>\\<^sub>0[cod f, cod g] \\<cdot> ?l = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"\\<p>\\<^sub>0[cod f, cod g] \\<cdot> ?l = (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot> (f \\<otimes> g) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "using fg pr0_def"], ["proof (prove)\nusing this:\n  span f g\n  \\<p>\\<^sub>0[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b])\n  else null\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = \\<r>[cod f] \\<cdot> ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom f]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod g])) \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = \\<r>[cod f] \\<cdot> (f \\<otimes> \\<t>[dom f]) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f]", "using fg interchange comp_cod_arr \\<tau>.naturality"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>seq ?h ?g; seq ?h' ?g'\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?h') \\<cdot> (?g \\<otimes> ?g') =\n                    ?h \\<cdot> ?g \\<otimes> ?h' \\<cdot> ?g'\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod g]) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = \\<r>[cod f] \\<cdot> ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n    \\<d>[local.dom f]", "using fg interchange comp_cod_arr \\<tau>.naturality"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>seq ?h ?g; seq ?h' ?g'\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?h') \\<cdot> (?g \\<otimes> ?g') =\n                    ?h \\<cdot> ?g \\<otimes> ?h' \\<cdot> ?g'\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n    \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  (f \\<otimes> \\<t>[local.dom f]) \\<cdot> \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = \\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n    \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n    (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n    \\<d>[local.dom f] =\n    \\<r>[cod f] \\<cdot>\n    (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n    (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n  \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n  (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  ((cod f \\<otimes> \\<t>[cod f]) \\<cdot> (f \\<otimes> f)) \\<cdot>\n  \\<d>[local.dom f] =\n  \\<r>[cod f] \\<cdot>\n  (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n  (f \\<otimes> f) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = (\\<r>[cod f] \\<cdot> (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n    (f \\<otimes> f) \\<cdot> \\<d>[local.dom f] =\n    (\\<r>[cod f] \\<cdot>\n     (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n    f", "using fg \\<delta>.naturality comp_assoc"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow>\n  \\<d>[cod ?f] \\<cdot> local.map ?f =\n  (T \\<circ> \\<Delta>.map) ?f \\<cdot> \\<d>[local.dom ?f]\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<r>[cod f] \\<cdot>\n    (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n    (f \\<otimes> f) \\<cdot> \\<d>[local.dom f] =\n    (\\<r>[cod f] \\<cdot>\n     (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n    f", "by simp"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n  (f \\<otimes> f) \\<cdot> \\<d>[local.dom f] =\n  (\\<r>[cod f] \\<cdot>\n   (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n  f\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "also"], ["proof (state)\nthis:\n  \\<r>[cod f] \\<cdot>\n  (cod f \\<otimes> \\<t>[cod f]) \\<cdot>\n  (f \\<otimes> f) \\<cdot> \\<d>[local.dom f] =\n  (\\<r>[cod f] \\<cdot>\n   (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n  f\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "have \"... = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<r>[cod f] \\<cdot>\n     (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n    f =\n    f", "using fg pr0_dup comp_cod_arr"], ["proof (prove)\nusing this:\n  span f g\n  ide ?a \\<Longrightarrow>\n  \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?a]) \\<cdot> \\<d>[?a] = ?a\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. (\\<r>[cod f] \\<cdot>\n     (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n    f =\n    f", "by simp"], ["proof (state)\nthis:\n  (\\<r>[cod f] \\<cdot>\n   (cod f \\<otimes> \\<t>[cod f]) \\<cdot> \\<d>[cod f]) \\<cdot>\n  f =\n  f\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "finally"], ["proof (chain)\npicking this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    f", "by blast"], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "moreover"], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "have \"\\<p>\\<^sub>1[cod f, cod g] \\<cdot> ?l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"\\<p>\\<^sub>1[cod f, cod g] \\<cdot> ?l = \\<l>[cod g] \\<cdot> ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot> \\<d>[dom g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g]", "using fg pr1_def comp_assoc"], ["proof (prove)\nusing this:\n  span f g\n  \\<p>\\<^sub>1[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)\n  else null\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g]", "by simp"], ["proof (state)\nthis:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "also"], ["proof (state)\nthis:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"... = \\<l>[cod g] \\<cdot> (\\<t>[dom f] \\<otimes> g) \\<cdot> \\<d>[dom g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g]", "using fg interchange comp_cod_arr \\<tau>.naturality"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>seq ?h ?g; seq ?h' ?g'\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?h') \\<cdot> (?g \\<otimes> ?g') =\n                    ?h \\<cdot> ?g \\<otimes> ?h' \\<cdot> ?g'\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g]", "by simp"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "also"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod f] \\<otimes> cod g) \\<cdot> (f \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"... = \\<l>[cod g] \\<cdot> ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot> \\<d>[dom g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g]", "using fg interchange comp_cod_arr \\<tau>.naturality"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>seq ?h ?g; seq ?h' ?g'\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?h') \\<cdot> (?g \\<otimes> ?g') =\n                    ?h \\<cdot> ?g \\<otimes> ?h' \\<cdot> ?g'\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  arr ?f \\<Longrightarrow>\n  \\<t>[cod ?f] \\<cdot> local.map ?f =\n  \\<Omega>.map ?f \\<cdot> \\<t>[local.dom ?f]\n\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g]", "by simp"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "also"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[local.dom f] \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"... = \\<l>[cod g] \\<cdot> (\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g) \\<cdot> \\<d>[dom g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n    (g \\<otimes> g) \\<cdot> \\<d>[local.dom g]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n    \\<d>[local.dom g] =\n    \\<l>[cod g] \\<cdot>\n    (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n    (g \\<otimes> g) \\<cdot> \\<d>[local.dom g]", "by simp"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n  (g \\<otimes> g) \\<cdot> \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "also"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  ((\\<t>[cod g] \\<otimes> cod g) \\<cdot> (g \\<otimes> g)) \\<cdot>\n  \\<d>[local.dom g] =\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n  (g \\<otimes> g) \\<cdot> \\<d>[local.dom g]\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"... = (\\<l>[cod g] \\<cdot> (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n    (g \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n    (\\<l>[cod g] \\<cdot>\n     (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n    g", "using fg \\<delta>.naturality comp_assoc"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow>\n  \\<d>[cod ?f] \\<cdot> local.map ?f =\n  (T \\<circ> \\<Delta>.map) ?f \\<cdot> \\<d>[local.dom ?f]\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<l>[cod g] \\<cdot>\n    (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n    (g \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n    (\\<l>[cod g] \\<cdot>\n     (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n    g", "by simp"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n  (g \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n  (\\<l>[cod g] \\<cdot>\n   (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n  g\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "also"], ["proof (state)\nthis:\n  \\<l>[cod g] \\<cdot>\n  (\\<t>[cod g] \\<otimes> cod g) \\<cdot>\n  (g \\<otimes> g) \\<cdot> \\<d>[local.dom g] =\n  (\\<l>[cod g] \\<cdot>\n   (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n  g\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "have \"... = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<l>[cod g] \\<cdot>\n     (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n    g =\n    g", "using fg pr1_dup comp_cod_arr"], ["proof (prove)\nusing this:\n  span f g\n  ide ?a \\<Longrightarrow>\n  \\<l>[?a] \\<cdot> (\\<t>[?a] \\<otimes> ?a) \\<cdot> \\<d>[?a] = ?a\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. (\\<l>[cod g] \\<cdot>\n     (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n    g =\n    g", "by simp"], ["proof (state)\nthis:\n  (\\<l>[cod g] \\<cdot>\n   (\\<t>[cod g] \\<otimes> cod g) \\<cdot> \\<d>[cod g]) \\<cdot>\n  g =\n  g\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "finally"], ["proof (chain)\npicking this:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n\ngoal (1 subgoal):\n 1. \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n    (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    g", "by blast"], ["proof (state)\nthis:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "moreover"], ["proof (state)\nthis:\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "have \"\\<And>l. \\<lbrakk> \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f; \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g \\<rbrakk> \\<Longrightarrow> l = ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "assume f: \"\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\" and g: \"\\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\""], ["proof (state)\nthis:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have l: \"\\<guillemotleft>l : dom f \\<rightarrow> cod f \\<otimes> cod g\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>l : local.dom\n                         f \\<rightarrow> cod f \\<otimes>\n   cod g\\<guillemotright>", "using f g fg"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n  span f g\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>l : local.dom\n                         f \\<rightarrow> cod f \\<otimes>\n   cod g\\<guillemotright>", "by (metis arr_iff_in_hom dom_comp ide_cod pr_simps(5) seqE)"], ["proof (state)\nthis:\n  \\<guillemotleft>l : local.dom\n                       f \\<rightarrow> cod f \\<otimes>\n cod g\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"?l = (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes> \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n    \\<d>[local.dom f]", "using f g"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n\ngoal (1 subgoal):\n 1. (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n    (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n    \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "also"], ["proof (state)\nthis:\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"... = ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot> (l \\<otimes> l)) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n    \\<d>[local.dom f] =\n    ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     (l \\<otimes> l)) \\<cdot>\n    \\<d>[local.dom f]", "using fg f g interchange"], ["proof (prove)\nusing this:\n  span f g\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n  \\<lbrakk>seq ?h ?g; seq ?h' ?g'\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?h') \\<cdot> (?g \\<otimes> ?g') =\n                    ?h \\<cdot> ?g \\<otimes> ?h' \\<cdot> ?g'\n\ngoal (1 subgoal):\n 1. (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n    \\<d>[local.dom f] =\n    ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     (l \\<otimes> l)) \\<cdot>\n    \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n  \\<d>[local.dom f] =\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   (l \\<otimes> l)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "also"], ["proof (state)\nthis:\n  (\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l \\<otimes>\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l) \\<cdot>\n  \\<d>[local.dom f] =\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   (l \\<otimes> l)) \\<cdot>\n  \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"... = (\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot> (l \\<otimes> l) \\<cdot> \\<d>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     (l \\<otimes> l)) \\<cdot>\n    \\<d>[local.dom f] =\n    (\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n    (l \\<otimes> l) \\<cdot> \\<d>[local.dom f]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     (l \\<otimes> l)) \\<cdot>\n    \\<d>[local.dom f] =\n    (\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n    (l \\<otimes> l) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   (l \\<otimes> l)) \\<cdot>\n  \\<d>[local.dom f] =\n  (\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n  (l \\<otimes> l) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "also"], ["proof (state)\nthis:\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   (l \\<otimes> l)) \\<cdot>\n  \\<d>[local.dom f] =\n  (\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n  (l \\<otimes> l) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"... = ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot> \\<d>[cod f \\<otimes> cod g]) \\<cdot> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n    (l \\<otimes> l) \\<cdot> \\<d>[local.dom f] =\n    ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n    l", "using l \\<delta>.naturality [of l] comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>l : local.dom\n                       f \\<rightarrow> cod f \\<otimes>\n cod g\\<guillemotright>\n  arr l \\<Longrightarrow>\n  \\<d>[cod l] \\<cdot> local.map l =\n  (T \\<circ> \\<Delta>.map) l \\<cdot> \\<d>[local.dom l]\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n     \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n    (l \\<otimes> l) \\<cdot> \\<d>[local.dom f] =\n    ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n    l", "by auto"], ["proof (state)\nthis:\n  (\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n  (l \\<otimes> l) \\<cdot> \\<d>[local.dom f] =\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n  l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "also"], ["proof (state)\nthis:\n  (\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n  (l \\<otimes> l) \\<cdot> \\<d>[local.dom f] =\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n  l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"... = (cod f \\<otimes> cod g) \\<cdot> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n    l =\n    (cod f \\<otimes> cod g) \\<cdot> l", "using f g fg tuple_pr pr0_def pr1_def"], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> (\\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b]) \\<otimes>\n                     \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)) \\<cdot>\n                    \\<d>[?a \\<otimes> ?b] =\n                    ?a \\<otimes> ?b\n  \\<p>\\<^sub>0[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<r>[?a] \\<cdot> (?a \\<otimes> \\<t>[?b])\n  else null\n  \\<p>\\<^sub>1[?a, ?b] \\<equiv>\n  if ide ?a \\<and> ide ?b then \\<l>[?b] \\<cdot> (\\<t>[?a] \\<otimes> ?b)\n  else null\n\ngoal (1 subgoal):\n 1. ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes>\n      \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n     \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n    l =\n    (cod f \\<otimes> cod g) \\<cdot> l", "by auto"], ["proof (state)\nthis:\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n  l =\n  (cod f \\<otimes> cod g) \\<cdot> l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "also"], ["proof (state)\nthis:\n  ((\\<p>\\<^sub>0[cod f, cod g] \\<otimes> \\<p>\\<^sub>1[cod f, cod g]) \\<cdot>\n   \\<d>[cod f \\<otimes> cod g]) \\<cdot>\n  l =\n  (cod f \\<otimes> cod g) \\<cdot> l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "have \"... = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cod f \\<otimes> cod g) \\<cdot> l = l", "using l comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>l : local.dom\n                       f \\<rightarrow> cod f \\<otimes>\n cod g\\<guillemotright>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. (cod f \\<otimes> cod g) \\<cdot> l = l", "by auto"], ["proof (state)\nthis:\n  (cod f \\<otimes> cod g) \\<cdot> l = l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f;\n        \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\\<rbrakk>\n       \\<Longrightarrow> l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "finally"], ["proof (chain)\npicking this:\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] = l", "show \"l = ?l\""], ["proof (prove)\nusing this:\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] = l\n\ngoal (1 subgoal):\n 1. l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "by simp"], ["proof (state)\nthis:\n  l = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> ?l4 = f;\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> ?l4 = g\\<rbrakk>\n  \\<Longrightarrow> ?l4 = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n          \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "ultimately"], ["proof (chain)\npicking this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n  \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> ?l4 = f;\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> ?l4 = g\\<rbrakk>\n  \\<Longrightarrow> ?l4 = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]", "show \"\\<exists>!l. \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and> \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\""], ["proof (prove)\nusing this:\n  \\<p>\\<^sub>0[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  f\n  \\<p>\\<^sub>1[cod f, cod g] \\<cdot>\n  (f \\<otimes> g) \\<cdot> \\<d>[local.dom f] =\n  g\n  \\<lbrakk>\\<p>\\<^sub>0[cod f, cod g] \\<cdot> ?l4 = f;\n   \\<p>\\<^sub>1[cod f, cod g] \\<cdot> ?l4 = g\\<rbrakk>\n  \\<Longrightarrow> ?l4 = (f \\<otimes> g) \\<cdot> \\<d>[local.dom f]\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n       \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g", "by auto"], ["proof (state)\nthis:\n  \\<exists>!l.\n     \\<p>\\<^sub>0[cod f, cod g] \\<cdot> l = f \\<and>\n     \\<p>\\<^sub>1[cod f, cod g] \\<cdot> l = g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span ?f4 ?g4 \\<Longrightarrow>\n  \\<exists>!l.\n     \\<p>\\<^sub>0[cod ?f4, cod ?g4] \\<cdot> l = ?f4 \\<and>\n     \\<p>\\<^sub>1[cod ?f4, cod ?g4] \\<cdot> l = ?g4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extends_to_elementary_cartesian_category:\n    shows \"elementary_cartesian_category C pr1 pr0 \\<I> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr1 pr0 \\<I> \\<tau>", ".."], ["", "lemma is_cartesian_category:\n    shows \"cartesian_category C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "using ECC.is_cartesian_category"], ["proof (prove)\nusing this:\n  cartesian_category (\\<cdot>)\n\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "by simp"], ["", "end"], ["", "(*\n   * TODO: I would like to have coherence theorems for symmetric monoidal and cartesian\n   * monoidal categories here, but I haven't yet figured out a suitably economical way\n   * to extend the existing result.\n   *)"], ["", "end"]]}