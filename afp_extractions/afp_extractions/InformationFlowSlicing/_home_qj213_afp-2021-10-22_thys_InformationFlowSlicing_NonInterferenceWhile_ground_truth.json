{"file_name": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing/NonInterferenceWhile.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing", "problem_names": ["lemmas WCFG_path_induct[consumes 1, case_names empty_path Cons_path]\n  = CFG.path.induct[OF While_CFG_aux]", "lemma lift_valid_node:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge prog) n\"\n  shows \"CFG.valid_node src trg\n  (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n  (Node n)\"", "lemma lifted_CFG_fund_prop:\n  assumes \"labels_LDCFG_nodes prog n c\" and \"\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\"\n  shows \"\\<exists>n' as. CFG.path src trg\n  (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n  n as n' \\<and> transfers (CFG.kinds knd as) s = s' \\<and>\n  preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\"", "lemma final_edge:\n  \"labels_nodes prog n Skip \\<Longrightarrow> prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\"", "lemmas WODNonInterferenceGraph = \n  lift_wod_backward_slice[OF While_CFGExit_wf_aux HighLowDistinct HighLowUNIV]", "lemma WODNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\"", "lemma inner_node_exists:\"\\<exists>n. CFGExit.inner_node sourcenode targetnode \n  (valid_edge prog) (_Entry_) (_Exit_) n\"", "lemmas SCDNonInterferenceGraph = \n  lift_PDG_standard_backward_slice[OF WStandardControlDependence.PDG_scd \n  WhilePostdomination_aux _ HighLowDistinct HighLowUNIV]", "lemma SCDNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\"", "lemmas WCDNonInterferenceGraph = \n  lift_PDG_weak_backward_slice[OF WWeakControlDependence.PDG_wcd \n  WhileStrongPostdomination_aux _ HighLowDistinct HighLowUNIV]", "lemma WCDNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\""], "translations": [["", "lemmas WCFG_path_induct[consumes 1, case_names empty_path Cons_path]\n  = CFG.path.induct[OF While_CFG_aux]"], ["", "lemma lift_valid_node:\n  assumes \"CFG.valid_node sourcenode targetnode (valid_edge prog) n\"\n  shows \"CFG.valid_node src trg\n  (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n  (Node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) n\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog n", "obtain a where \"valid_edge prog a\" and \"n = sourcenode a \\<or> n = targetnode a\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog n\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge prog a;\n         n = sourcenode a \\<or> n = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:While_CFG.valid_node_def)"], ["proof (state)\nthis:\n  valid_edge prog a\n  n = sourcenode a \\<or> n = targetnode a\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "from \\<open>n = sourcenode a \\<or> n = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a \\<or> n = targetnode a", "show ?thesis"], ["proof (prove)\nusing this:\n  n = sourcenode a \\<or> n = targetnode a\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n = sourcenode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. n = targetnode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "assume \"n = sourcenode a\""], ["proof (state)\nthis:\n  n = sourcenode a\n\ngoal (2 subgoals):\n 1. n = sourcenode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. n = targetnode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "proof(cases \"sourcenode a = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "case True"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "have \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind Entry Exit \n        (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_)\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, LDCFG_node.Node (_Entry_))", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, LDCFG_node.Node (_Entry_))\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with While_CFGExit_wf_aux[of prog] \\<open>n = sourcenode a\\<close> True"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = sourcenode a\n  sourcenode a = (_Entry_)\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, LDCFG_node.Node (_Entry_))", "show ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = sourcenode a\n  sourcenode a = (_Entry_)\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, LDCFG_node.Node (_Entry_))\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "by(fastforce simp:CFG.valid_node_def[OF lift_CFG])"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with \\<open>valid_edge prog a\\<close> \\<open>n = sourcenode a \\<or> n = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  n = sourcenode a \\<or> n = targetnode a\n  sourcenode a \\<noteq> (_Entry_)", "have \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind Entry Exit \n        (Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  n = sourcenode a \\<or> n = targetnode a\n  sourcenode a \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_)\n     (LDCFG_node.Node (sourcenode a), kind a,\n      LDCFG_node.Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with While_CFGExit_wf_aux[of prog] \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = sourcenode a\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = sourcenode a\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "by(fastforce simp:CFG.valid_node_def[OF lift_CFG])"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal (1 subgoal):\n 1. n = targetnode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = targetnode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "assume \"n = targetnode a\""], ["proof (state)\nthis:\n  n = targetnode a\n\ngoal (1 subgoal):\n 1. n = targetnode a \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "proof(cases \"targetnode a = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "case True"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode a = (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "have \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind Entry Exit \n        (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_)\n     (LDCFG_node.Node (_Exit_), (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (_Exit_), (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. targetnode a = (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)\n 2. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with While_CFGExit_wf_aux[of prog] \\<open>n = targetnode a\\<close> True"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = targetnode a\n  targetnode a = (_Exit_)\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (_Exit_), (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "show ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = targetnode a\n  targetnode a = (_Exit_)\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (_Exit_), (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "by(fastforce simp:CFG.valid_node_def[OF lift_CFG])"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with \\<open>valid_edge prog a\\<close> \\<open>n = sourcenode a \\<or> n = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  n = sourcenode a \\<or> n = targetnode a\n  targetnode a \\<noteq> (_Exit_)", "have \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind Entry Exit \n        (Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  n = sourcenode a \\<or> n = targetnode a\n  targetnode a \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_)\n     (LDCFG_node.Node (sourcenode a), kind a,\n      LDCFG_node.Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> (_Exit_) \\<Longrightarrow>\n    CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "with While_CFGExit_wf_aux[of prog] \\<open>n = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = targetnode a\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind (valid_edge prog) (_Entry_)\n   (Defs prog) (Uses prog) id (_Exit_)\n  n = targetnode a\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "by(fastforce simp:CFG.valid_node_def[OF lift_CFG])"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lifted_CFG_fund_prop:\n  assumes \"labels_LDCFG_nodes prog n c\" and \"\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\"\n  shows \"\\<exists>n' as. CFG.path src trg\n  (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n  n as n' \\<and> transfers (CFG.kinds knd as) s = s' \\<and>\n  preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "from \\<open>labels_LDCFG_nodes prog n c\\<close>"], ["proof (chain)\npicking this:\n  labels_LDCFG_nodes prog n c", "obtain nx where \"n = Node nx\"\n    and \"labels_nodes prog nx c\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>n = LDCFG_node.Node nx; labels_nodes prog nx c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx c\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "from \\<open>labels_nodes prog nx c\\<close> \\<open>\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>", "obtain n' as where \"prog \\<turnstile> nx -as\\<rightarrow>* n'\" and \"transfers (CFG.kinds kind as) s = s'\"\n    and \"preds (CFG.kinds kind as) s\" and \"labels_nodes prog n' c'\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>While_CFG.path prog nx as n';\n         transfers (While_CFG.kinds as) s = s';\n         preds (While_CFG.kinds as) s; labels_nodes prog n' c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:While_semantics_CFG_wf.fundamental_property)"], ["proof (state)\nthis:\n  While_CFG.path prog nx as n'\n  transfers (While_CFG.kinds as) s = s'\n  preds (While_CFG.kinds as) s\n  labels_nodes prog n' c'\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "from \\<open>labels_nodes prog n' c'\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog n' c'", "have \"labels_LDCFG_nodes prog (Node n') c'\""], ["proof (prove)\nusing this:\n  labels_nodes prog n' c'\n\ngoal (1 subgoal):\n 1. labels_LDCFG_nodes prog (LDCFG_node.Node n') c'", "by simp"], ["proof (state)\nthis:\n  labels_LDCFG_nodes prog (LDCFG_node.Node n') c'\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "from \\<open>prog \\<turnstile> nx -as\\<rightarrow>* n'\\<close> \\<open>transfers (CFG.kinds kind as) s = s'\\<close> \n    \\<open>preds (CFG.kinds kind as) s\\<close> \\<open>n = Node nx\\<close>\n    \\<open>labels_nodes prog nx c\\<close> \\<open>labels_nodes prog n' c'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog nx as n'\n  transfers (While_CFG.kinds as) s = s'\n  preds (While_CFG.kinds as) s\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx c\n  labels_nodes prog n' c'", "have \"\\<exists>es. CFG.path src trg\n    (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n    (Node nx) es (Node n') \\<and> transfers (CFG.kinds knd es) s = s' \\<and>\n    preds (CFG.kinds knd es) s\""], ["proof (prove)\nusing this:\n  While_CFG.path prog nx as n'\n  transfers (While_CFG.kinds as) s = s'\n  preds (While_CFG.kinds as) s\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx c\n  labels_nodes prog n' c'\n\ngoal (1 subgoal):\n 1. \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "proof(induct arbitrary:n s c rule:WCFG_path_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n na s c.\n       \\<lbrakk>While_CFG.valid_node prog n;\n        transfers (While_CFG.kinds []) s = s'; preds (While_CFG.kinds []) s;\n        na = LDCFG_node.Node n; labels_nodes prog n c;\n        labels_nodes prog n c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n) \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s\n 2. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "case (empty_path n nx)"], ["proof (state)\nthis:\n  While_CFG.valid_node prog n\n  transfers (While_CFG.kinds []) s = s'\n  preds (While_CFG.kinds []) s\n  nx = LDCFG_node.Node n\n  labels_nodes prog n c\n  labels_nodes prog n c'\n\ngoal (2 subgoals):\n 1. \\<And>n na s c.\n       \\<lbrakk>While_CFG.valid_node prog n;\n        transfers (While_CFG.kinds []) s = s'; preds (While_CFG.kinds []) s;\n        na = LDCFG_node.Node n; labels_nodes prog n c;\n        labels_nodes prog n c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n) \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s\n 2. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "from \\<open>CFG.valid_node sourcenode targetnode (valid_edge prog) n\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog n", "have valid_node:\"CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n      (Node n)\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog n\n\ngoal (1 subgoal):\n 1. CFG.valid_node src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node n)", "by(rule lift_valid_node)"], ["proof (state)\nthis:\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n\ngoal (2 subgoals):\n 1. \\<And>n na s c.\n       \\<lbrakk>While_CFG.valid_node prog n;\n        transfers (While_CFG.kinds []) s = s'; preds (While_CFG.kinds []) s;\n        na = LDCFG_node.Node n; labels_nodes prog n c;\n        labels_nodes prog n c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n) \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s\n 2. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "have \"CFG.kinds knd \n      ([]::(w_node LDCFG_node \\<times> state edge_kind \\<times> w_node LDCFG_node) list) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG.kinds knd [] = []", "by(simp add:CFG.kinds_def[OF lift_CFG[OF While_CFGExit_wf_aux]])"], ["proof (state)\nthis:\n  CFG.kinds knd [] = []\n\ngoal (2 subgoals):\n 1. \\<And>n na s c.\n       \\<lbrakk>While_CFG.valid_node prog n;\n        transfers (While_CFG.kinds []) s = s'; preds (While_CFG.kinds []) s;\n        na = LDCFG_node.Node n; labels_nodes prog n c;\n        labels_nodes prog n c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n) \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s\n 2. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "with \\<open>transfers (CFG.kinds kind []) s = s'\\<close> \\<open>preds (CFG.kinds kind []) s\\<close>\n      valid_node"], ["proof (chain)\npicking this:\n  transfers (While_CFG.kinds []) s = s'\n  preds (While_CFG.kinds []) s\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n  CFG.kinds knd [] = []", "show ?case"], ["proof (prove)\nusing this:\n  transfers (While_CFG.kinds []) s = s'\n  preds (While_CFG.kinds []) s\n  CFG.valid_node src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n)\n  CFG.kinds knd [] = []\n\ngoal (1 subgoal):\n 1. \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node n) es (LDCFG_node.Node n) \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "by(fastforce intro:CFG.empty_path[OF lift_CFG[OF While_CFGExit_wf_aux]] \n                   simp:While_CFG.kinds_def)"], ["proof (state)\nthis:\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node n) es (LDCFG_node.Node n) \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "case (Cons_path n'' as n' a nx)"], ["proof (state)\nthis:\n  While_CFG.path prog n'' as n'\n  \\<lbrakk>transfers (While_CFG.kinds as) ?s = s';\n   preds (While_CFG.kinds as) ?s; ?n = LDCFG_node.Node n'';\n   labels_nodes prog n'' ?c; labels_nodes prog n' c'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFG.path src trg\n                        (lift_valid_edge (valid_edge prog) sourcenode\n                          targetnode kind (_Entry_) (_Exit_))\n                        (LDCFG_node.Node n'') es (LDCFG_node.Node n') \\<and>\n                       transfers (CFG.kinds knd es) ?s = s' \\<and>\n                       preds (CFG.kinds knd es) ?s\n  valid_edge prog a\n  sourcenode a = nx\n  targetnode a = n''\n  transfers (While_CFG.kinds (a # as)) s = s'\n  preds (While_CFG.kinds (a # as)) s\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx c\n  labels_nodes prog n' c'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "note IH = \\<open>\\<And>n s c. \\<lbrakk>transfers (CFG.kinds kind as) s = s'; \n      preds (CFG.kinds kind as) s; n = LDCFG_node.Node n''; \n      labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n      \\<Longrightarrow> \\<exists>es. CFG.path src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n      (LDCFG_node.Node n'') es (LDCFG_node.Node n') \\<and>\n      transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>transfers (While_CFG.kinds as) ?s = s';\n   preds (While_CFG.kinds as) ?s; ?n = LDCFG_node.Node n'';\n   labels_nodes prog n'' ?c; labels_nodes prog n' c'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFG.path src trg\n                        (lift_valid_edge (valid_edge prog) sourcenode\n                          targetnode kind (_Entry_) (_Exit_))\n                        (LDCFG_node.Node n'') es (LDCFG_node.Node n') \\<and>\n                       transfers (CFG.kinds knd es) ?s = s' \\<and>\n                       preds (CFG.kinds knd es) ?s\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "from \\<open>transfers (CFG.kinds kind (a # as)) s = s'\\<close>"], ["proof (chain)\npicking this:\n  transfers (While_CFG.kinds (a # as)) s = s'", "have \"transfers (CFG.kinds kind as) (transfer (kind a) s) = s'\""], ["proof (prove)\nusing this:\n  transfers (While_CFG.kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. transfers (While_CFG.kinds as) (transfer (kind a) s) = s'", "by(simp add:While_CFG.kinds_def)"], ["proof (state)\nthis:\n  transfers (While_CFG.kinds as) (transfer (kind a) s) = s'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "from \\<open>preds (CFG.kinds kind (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (While_CFG.kinds (a # as)) s", "have \"preds (CFG.kinds kind as) (transfer (kind a) s)\"\n      and \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (While_CFG.kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (While_CFG.kinds as) (transfer (kind a) s) &&& pred (kind a) s", "by(simp_all add:While_CFG.kinds_def)"], ["proof (state)\nthis:\n  preds (While_CFG.kinds as) (transfer (kind a) s)\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n na s c.\n       \\<lbrakk>While_CFG.path prog n'' as n';\n        \\<And>n s c.\n           \\<lbrakk>transfers (While_CFG.kinds as) s = s';\n            preds (While_CFG.kinds as) s; n = LDCFG_node.Node n'';\n            labels_nodes prog n'' c; labels_nodes prog n' c'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>es.\n                                CFG.path src trg\n                                 (lift_valid_edge (valid_edge prog)\n                                   sourcenode targetnode kind (_Entry_)\n                                   (_Exit_))\n                                 (LDCFG_node.Node n'') es\n                                 (LDCFG_node.Node n') \\<and>\n                                transfers (CFG.kinds knd es) s = s' \\<and>\n                                preds (CFG.kinds knd es) s;\n        valid_edge prog a; sourcenode a = n; targetnode a = n'';\n        transfers (While_CFG.kinds (a # as)) s = s';\n        preds (While_CFG.kinds (a # as)) s; na = LDCFG_node.Node n;\n        labels_nodes prog n c; labels_nodes prog n' c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFG.path src trg\n                             (lift_valid_edge (valid_edge prog) sourcenode\n                               targetnode kind (_Entry_) (_Exit_))\n                             (LDCFG_node.Node n) es\n                             (LDCFG_node.Node n') \\<and>\n                            transfers (CFG.kinds knd es) s = s' \\<and>\n                            preds (CFG.kinds knd es) s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "proof(cases \"sourcenode a = (_Entry_)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "case True"], ["proof (state)\nthis:\n  sourcenode a = (_Entry_)\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "with \\<open>sourcenode a = nx\\<close> \\<open>labels_nodes prog nx c\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = nx\n  labels_nodes prog nx c\n  sourcenode a = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = nx\n  labels_nodes prog nx c\n  sourcenode a = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a = (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n 2. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "by simp"], ["proof (state)\nthis:\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "with \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a \\<noteq> (_Entry_)", "have edge:\"lift_valid_edge (valid_edge prog) sourcenode targetnode kind \n        Entry Exit (Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a \\<noteq> (_Entry_)\n\ngoal (1 subgoal):\n 1. lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_)\n     (LDCFG_node.Node (sourcenode a), kind a,\n      LDCFG_node.Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "from \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as n'", "have \"CFG.valid_node sourcenode targetnode (valid_edge prog) n''\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as n'\n\ngoal (1 subgoal):\n 1. While_CFG.valid_node prog n''", "by(rule While_CFG.path_valid_node)"], ["proof (state)\nthis:\n  While_CFG.valid_node prog n''\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "then"], ["proof (chain)\npicking this:\n  While_CFG.valid_node prog n''", "obtain c'' where \"labels_nodes prog n'' c''\""], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog n''\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        labels_nodes prog n'' c'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases rule:While_CFGExit.valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Entry"], ["proof (state)\nthis:\n  n'' = (_Entry_)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>targetnode a = n''\\<close> \\<open>valid_edge prog a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n''\n  valid_edge prog a\n  n'' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  targetnode a = n''\n  valid_edge prog a\n  n'' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Exit"], ["proof (state)\nthis:\n  n'' = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>prog \\<turnstile> n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)", "have \"n' = (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFG.path prog n'' as n'\n  n'' = (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>labels_nodes prog n' c'\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog n' c'\n  n' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  labels_nodes prog n' c'\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     n'' = (_Exit_)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "case inner"], ["proof (state)\nthis:\n  While_CFGExit.inner_node prog n''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  While_CFGExit.inner_node prog n''", "obtain l'' where [simp]:\"n'' = (_ l'' _)\""], ["proof (prove)\nusing this:\n  While_CFGExit.inner_node prog n''\n\ngoal (1 subgoal):\n 1. (\\<And>l''. n'' = (_ l'' _) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n'') auto"], ["proof (state)\nthis:\n  n'' = (_ l'' _)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>valid_edge prog a\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_ l'' _)", "have \"l'' < #:prog\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = n''\n  n'' = (_ l'' _)\n\ngoal (1 subgoal):\n 1. l'' < #:prog", "by(fastforce intro:WCFG_targetlabel_less_num_nodes simp:valid_edge_def)"], ["proof (state)\nthis:\n  l'' < #:prog\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  l'' < #:prog", "obtain c'' where \"labels prog l'' c''\""], ["proof (prove)\nusing this:\n  l'' < #:prog\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        labels prog l'' c'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:less_num_inner_nodes_label)"], ["proof (state)\nthis:\n  labels prog l'' c''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c''. labels_nodes prog n'' c'' \\<Longrightarrow> thesis;\n     While_CFGExit.inner_node prog n''\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that"], ["proof (chain)\npicking this:\n  labels_nodes prog n'' ?c'' \\<Longrightarrow> thesis\n  labels prog l'' c''", "show ?thesis"], ["proof (prove)\nusing this:\n  labels_nodes prog n'' ?c'' \\<Longrightarrow> thesis\n  labels prog l'' c''\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  labels_nodes prog n'' c''\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "from IH[OF \\<open>transfers (CFG.kinds kind as) (transfer (kind a) s) = s'\\<close>\n        \\<open>preds (CFG.kinds kind as) (transfer (kind a) s)\\<close> _ this \n        \\<open>labels_nodes prog n' c'\\<close>]"], ["proof (chain)\npicking this:\n  ?n = LDCFG_node.Node n'' \\<Longrightarrow>\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node n'') es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) (transfer (kind a) s) = s' \\<and>\n     preds (CFG.kinds knd es) (transfer (kind a) s)", "obtain es where \"CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind \n        (_Entry_) (_Exit_)) (LDCFG_node.Node n'') es (LDCFG_node.Node n')\"\n        and \"transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\"\n        and \"preds (CFG.kinds knd es) (transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  ?n = LDCFG_node.Node n'' \\<Longrightarrow>\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node n'') es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) (transfer (kind a) s) = s' \\<and>\n     preds (CFG.kinds knd es) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        \\<lbrakk>CFG.path src trg\n                  (lift_valid_edge (valid_edge prog) sourcenode targetnode\n                    kind (_Entry_) (_Exit_))\n                  (LDCFG_node.Node n'') es (LDCFG_node.Node n');\n         transfers (CFG.kinds knd es) (transfer (kind a) s) = s';\n         preds (CFG.kinds knd es) (transfer (kind a) s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n'') es (LDCFG_node.Node n')\n  transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\n  preds (CFG.kinds knd es) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "with \\<open>targetnode a = n''\\<close> \\<open>sourcenode a = nx\\<close> edge"], ["proof (chain)\npicking this:\n  targetnode a = n''\n  sourcenode a = nx\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n'') es (LDCFG_node.Node n')\n  transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\n  preds (CFG.kinds knd es) (transfer (kind a) s)", "have path:\"CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode \n        kind (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) ((Node (sourcenode a),kind a,Node (targetnode a))#es) \n        (LDCFG_node.Node n')\""], ["proof (prove)\nusing this:\n  targetnode a = n''\n  sourcenode a = nx\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node n'') es (LDCFG_node.Node n')\n  transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\n  preds (CFG.kinds knd es) (transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. CFG.path src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (LDCFG_node.Node nx)\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es)\n     (LDCFG_node.Node n')", "by(fastforce intro:CFG.Cons_path[OF lift_CFG[OF While_CFGExit_wf_aux]])"], ["proof (state)\nthis:\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node nx)\n   ((LDCFG_node.Node (sourcenode a), kind a,\n     LDCFG_node.Node (targetnode a)) #\n    es)\n   (LDCFG_node.Node n')\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "from edge"], ["proof (chain)\npicking this:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))", "have \"knd (Node (sourcenode a),kind a,Node (targetnode a)) = kind a\""], ["proof (prove)\nusing this:\n  lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n   (_Exit_)\n   (LDCFG_node.Node (sourcenode a), kind a, LDCFG_node.Node (targetnode a))\n\ngoal (1 subgoal):\n 1. knd (LDCFG_node.Node (sourcenode a), kind a,\n         LDCFG_node.Node (targetnode a)) =\n    kind a", "by(simp add:knd_def)"], ["proof (state)\nthis:\n  knd (LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) =\n  kind a\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "with \\<open>transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\\<close>\n        \\<open>preds (CFG.kinds knd es) (transfer (kind a) s)\\<close> \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\n  preds (CFG.kinds knd es) (transfer (kind a) s)\n  pred (kind a) s\n  knd (LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) =\n  kind a", "have \"transfers \n        (CFG.kinds knd ((Node (sourcenode a),kind a,Node (targetnode a))#es)) s = s'\"\n        and \"preds \n        (CFG.kinds knd ((Node (sourcenode a),kind a,Node (targetnode a))#es)) s\""], ["proof (prove)\nusing this:\n  transfers (CFG.kinds knd es) (transfer (kind a) s) = s'\n  preds (CFG.kinds knd es) (transfer (kind a) s)\n  pred (kind a) s\n  knd (LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) =\n  kind a\n\ngoal (1 subgoal):\n 1. transfers\n     (CFG.kinds knd\n       ((LDCFG_node.Node (sourcenode a), kind a,\n         LDCFG_node.Node (targetnode a)) #\n        es))\n     s =\n    s' &&&\n    preds\n     (CFG.kinds knd\n       ((LDCFG_node.Node (sourcenode a), kind a,\n         LDCFG_node.Node (targetnode a)) #\n        es))\n     s", "by(auto simp:CFG.kinds_def[OF lift_CFG[OF While_CFGExit_wf_aux]])"], ["proof (state)\nthis:\n  transfers\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s =\n  s'\n  preds\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s\n\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> (_Entry_) \\<Longrightarrow>\n    \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "with path"], ["proof (chain)\npicking this:\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node nx)\n   ((LDCFG_node.Node (sourcenode a), kind a,\n     LDCFG_node.Node (targetnode a)) #\n    es)\n   (LDCFG_node.Node n')\n  transfers\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s =\n  s'\n  preds\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG.path src trg\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   (LDCFG_node.Node nx)\n   ((LDCFG_node.Node (sourcenode a), kind a,\n     LDCFG_node.Node (targetnode a)) #\n    es)\n   (LDCFG_node.Node n')\n  transfers\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s =\n  s'\n  preds\n   (CFG.kinds knd\n     ((LDCFG_node.Node (sourcenode a), kind a,\n       LDCFG_node.Node (targetnode a)) #\n      es))\n   s\n\ngoal (1 subgoal):\n 1. \\<exists>es.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n       transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "by blast"], ["proof (state)\nthis:\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "with \\<open>n = Node nx\\<close> \\<open>labels_LDCFG_nodes prog (Node n') c'\\<close>"], ["proof (chain)\npicking this:\n  n = LDCFG_node.Node nx\n  labels_LDCFG_nodes prog (LDCFG_node.Node n') c'\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s", "show ?thesis"], ["proof (prove)\nusing this:\n  n = LDCFG_node.Node nx\n  labels_LDCFG_nodes prog (LDCFG_node.Node n') c'\n  \\<exists>es.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      (LDCFG_node.Node nx) es (LDCFG_node.Node n') \\<and>\n     transfers (CFG.kinds knd es) s = s' \\<and> preds (CFG.kinds knd es) s\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       CFG.path src trg\n        (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n          (_Entry_) (_Exit_))\n        n as n' \\<and>\n       transfers (CFG.kinds knd as) s = s' \\<and>\n       preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>n' as.\n     CFG.path src trg\n      (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_))\n      n as n' \\<and>\n     transfers (CFG.kinds knd as) s = s' \\<and>\n     preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\n\ngoal:\nNo subgoals!", "qed"], ["", "fun final :: \"cmd \\<Rightarrow> bool\"\n  where \"final Skip = True\"\n  | \"final c = False\""], ["", "lemma final_edge:\n  \"labels_nodes prog n Skip \\<Longrightarrow> prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labels_nodes prog n Skip \\<Longrightarrow>\n    prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "proof(induct prog arbitrary:n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n.\n       labels_nodes Skip n Skip \\<Longrightarrow>\n       Skip \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 5. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "case Skip"], ["proof (state)\nthis:\n  labels_nodes Skip n Skip\n\ngoal (5 subgoals):\n 1. \\<And>n.\n       labels_nodes Skip n Skip \\<Longrightarrow>\n       Skip \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 5. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from \\<open>labels_nodes Skip n Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes Skip n Skip", "have \"n = (_ 0 _)\""], ["proof (prove)\nusing this:\n  labels_nodes Skip n Skip\n\ngoal (1 subgoal):\n 1. n = (_ 0 _)", "by(cases n)(auto elim:labels.cases)"], ["proof (state)\nthis:\n  n = (_ 0 _)\n\ngoal (5 subgoals):\n 1. \\<And>n.\n       labels_nodes Skip n Skip \\<Longrightarrow>\n       Skip \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 5. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "thus ?case"], ["proof (prove)\nusing this:\n  n = (_ 0 _)\n\ngoal (1 subgoal):\n 1. Skip \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(fastforce intro:WCFG_Skip)"], ["proof (state)\nthis:\n  Skip \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "case (LAss V e)"], ["proof (state)\nthis:\n  labels_nodes (V:=e) n Skip\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from \\<open>labels_nodes (V:=e) n Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes (V:=e) n Skip", "have \"n = (_ 1 _)\""], ["proof (prove)\nusing this:\n  labels_nodes (V:=e) n Skip\n\ngoal (1 subgoal):\n 1. n = (_ 1 _)", "by(cases n)(auto elim:labels.cases)"], ["proof (state)\nthis:\n  n = (_ 1 _)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 n.\n       labels_nodes (x1:=x2) n Skip \\<Longrightarrow>\n       x1:=x2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 4. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "thus ?case"], ["proof (prove)\nusing this:\n  n = (_ 1 _)\n\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(fastforce intro:WCFG_LAssSkip)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "case (Seq c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  labels_nodes c\\<^sub>1 ?n Skip \\<Longrightarrow>\n  c\\<^sub>1 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n  labels_nodes c\\<^sub>2 ?n Skip \\<Longrightarrow>\n  c\\<^sub>2 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n  labels_nodes (c\\<^sub>1;; c\\<^sub>2) n Skip\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "note IH2 = \\<open>\\<And>n. labels_nodes c\\<^sub>2 n Skip \\<Longrightarrow> c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\\<close>"], ["proof (state)\nthis:\n  labels_nodes c\\<^sub>2 ?n Skip \\<Longrightarrow>\n  c\\<^sub>2 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from \\<open>labels_nodes (c\\<^sub>1;; c\\<^sub>2) n Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes (c\\<^sub>1;; c\\<^sub>2) n Skip", "obtain l where \"n = (_ l _)\"\n    and \"l \\<ge> #:c\\<^sub>1\" and \"labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 _) Skip\""], ["proof (prove)\nusing this:\n  labels_nodes (c\\<^sub>1;; c\\<^sub>2) n Skip\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n = (_ l _); #:c\\<^sub>1 \\<le> l;\n         labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 _) Skip\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n)(auto elim:labels.cases)"], ["proof (state)\nthis:\n  n = (_ l _)\n  #:c\\<^sub>1 \\<le> l\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 _) Skip\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from IH2[OF \\<open>labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 _) Skip\\<close>]"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<turnstile> (_ l -\n                              #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "."], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>l \\<ge> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  #:c\\<^sub>1 \\<le> l\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"c\\<^sub>1;;c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 _) \\<oplus> #:c\\<^sub>1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  #:c\\<^sub>1 \\<le> l\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> (_ l -\n                              #:c\\<^sub>1 _) \\<oplus> #:c\\<^sub>1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1", "by(fastforce intro:WCFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) \\<oplus> #:c\\<^sub>1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (prog1;; prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> prog1;;\n                         prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 3. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>n = (_ l _)\\<close> \\<open>l \\<ge> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  n = (_ l _)\n  #:c\\<^sub>1 \\<le> l\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) \\<oplus> #:c\\<^sub>1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  n = (_ l _)\n  #:c\\<^sub>1 \\<le> l\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> (_ l -\n                            #:c\\<^sub>1 _) \\<oplus> #:c\\<^sub>1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(simp add:id_def)"], ["proof (state)\nthis:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "case (Cond b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  labels_nodes c\\<^sub>1 ?n Skip \\<Longrightarrow>\n  c\\<^sub>1 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n  labels_nodes c\\<^sub>2 ?n Skip \\<Longrightarrow>\n  c\\<^sub>2 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n  labels_nodes (if (b) c\\<^sub>1 else c\\<^sub>2) n Skip\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "note IH1 = \\<open>\\<And>n. labels_nodes c\\<^sub>1 n Skip \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\\<close>"], ["proof (state)\nthis:\n  labels_nodes c\\<^sub>1 ?n Skip \\<Longrightarrow>\n  c\\<^sub>1 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "note IH2 = \\<open>\\<And>n. labels_nodes c\\<^sub>2 n Skip \\<Longrightarrow> c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\\<close>"], ["proof (state)\nthis:\n  labels_nodes c\\<^sub>2 ?n Skip \\<Longrightarrow>\n  c\\<^sub>2 \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from \\<open>labels_nodes (if (b) c\\<^sub>1 else c\\<^sub>2) n Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes (if (b) c\\<^sub>1 else c\\<^sub>2) n Skip", "obtain l where \"n = (_ l _)\" and disj:\"(l \\<ge> 1 \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip) \\<or>\n    (l \\<ge> #:c\\<^sub>1 + 1 \\<and> labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip)\""], ["proof (prove)\nusing this:\n  labels_nodes (if (b) c\\<^sub>1 else c\\<^sub>2) n Skip\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n = (_ l _);\n         1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<or>\n         #:c\\<^sub>1 + 1 \\<le> l \\<and>\n         labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) (fastforce elim:labels.cases)+"], ["proof (state)\nthis:\n  n = (_ l _)\n  1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<or>\n  #:c\\<^sub>1 + 1 \\<le> l \\<and>\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog1 prog2 n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog1 n Skip \\<Longrightarrow>\n                   prog1 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        \\<And>n.\n           labels_nodes prog2 n Skip \\<Longrightarrow>\n           prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (if (x1) prog1 else prog2) n Skip\\<rbrakk>\n       \\<Longrightarrow> if (x1) prog1\n                         else prog2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from disj"], ["proof (chain)\npicking this:\n  1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<or>\n  #:c\\<^sub>1 + 1 \\<le> l \\<and>\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip", "show ?case"], ["proof (prove)\nusing this:\n  1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<or>\n  #:c\\<^sub>1 + 1 \\<le> l \\<and>\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "assume \"1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\""], ["proof (state)\nthis:\n  1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\n\ngoal (2 subgoals):\n 1. 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "hence \"1 \\<le> l\" and \"labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\""], ["proof (prove)\nusing this:\n  1 \\<le> l \\<and> labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\n\ngoal (1 subgoal):\n 1. 1 \\<le> l &&& labels_nodes c\\<^sub>1 (_ l - 1 _) Skip", "by simp_all"], ["proof (state)\nthis:\n  1 \\<le> l\n  labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\n\ngoal (2 subgoals):\n 1. 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from IH1[OF \\<open>labels_nodes c\\<^sub>1 (_ l - 1 _) Skip\\<close>]"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "."], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (2 subgoals):\n 1. 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> l\n  c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> (_ l - 1 _) \\<oplus> 1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> l\n  c\\<^sub>1 \\<turnstile> (_ l - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> (_ l -\n                                   1 _) \\<oplus> 1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> 1", "by(fastforce intro:WCFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l -\n                                 1 _) \\<oplus> 1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> 1\n\ngoal (2 subgoals):\n 1. 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>1 (_ l - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n 2. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>n = (_ l _)\\<close> \\<open>1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  n = (_ l _)\n  1 \\<le> l\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l -\n                                 1 _) \\<oplus> 1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> 1", "show ?case"], ["proof (prove)\nusing this:\n  n = (_ l _)\n  1 \\<le> l\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l -\n                                 1 _) \\<oplus> 1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(simp add:id_def)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "assume \"#:c\\<^sub>1 + 1 \\<le> l \\<and> labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\""], ["proof (state)\nthis:\n  #:c\\<^sub>1 + 1 \\<le> l \\<and>\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "hence \"#:c\\<^sub>1 + 1 \\<le> l\" and \"labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\""], ["proof (prove)\nusing this:\n  #:c\\<^sub>1 + 1 \\<le> l \\<and>\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l &&&\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip", "by simp_all"], ["proof (state)\nthis:\n  #:c\\<^sub>1 + 1 \\<le> l\n  labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from IH2[OF \\<open>labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip\\<close>]"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                            1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 - 1 _) -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                            1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                              1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "."], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                            1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>#:c\\<^sub>1 + 1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  #:c\\<^sub>1 + 1 \\<le> l\n  c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                            1 _) -\\<Up>id\\<rightarrow> (_Exit_)", "have \"if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 - 1 _) \\<oplus> (#:c\\<^sub>1 + 1)\n      -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> (#:c\\<^sub>1 + 1)\""], ["proof (prove)\nusing this:\n  #:c\\<^sub>1 + 1 \\<le> l\n  c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                            1 _) -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                                   1 _) \\<oplus> #:c\\<^sub>1 +\n           1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1 + 1", "by(fastforce intro:WCFG_CondElse)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                                 1 _) \\<oplus> #:c\\<^sub>1 +\n         1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. #:c\\<^sub>1 + 1 \\<le> l \\<and>\n    labels_nodes c\\<^sub>2 (_ l - #:c\\<^sub>1 - 1 _) Skip \\<Longrightarrow>\n    if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "with \\<open>n = (_ l _)\\<close> \\<open>#:c\\<^sub>1 + 1 \\<le> l\\<close>"], ["proof (chain)\npicking this:\n  n = (_ l _)\n  #:c\\<^sub>1 + 1 \\<le> l\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                                 1 _) \\<oplus> #:c\\<^sub>1 +\n         1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1 + 1", "show ?case"], ["proof (prove)\nusing this:\n  n = (_ l _)\n  #:c\\<^sub>1 + 1 \\<le> l\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> (_ l - #:c\\<^sub>1 -\n                                 1 _) \\<oplus> #:c\\<^sub>1 +\n         1 -\\<Up>id\\<rightarrow> (_Exit_) \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(simp add:id_def)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "case (While b c)"], ["proof (state)\nthis:\n  labels_nodes c ?n Skip \\<Longrightarrow>\n  c \\<turnstile> ?n -\\<Up>id\\<rightarrow> (_Exit_)\n  labels_nodes (while (b) c) n Skip\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "from \\<open>labels_nodes (while (b) c) n Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes (while (b) c) n Skip", "have \"n = (_ 1 _)\""], ["proof (prove)\nusing this:\n  labels_nodes (while (b) c) n Skip\n\ngoal (1 subgoal):\n 1. n = (_ 1 _)", "by(cases n)(auto elim:labels.cases)"], ["proof (state)\nthis:\n  n = (_ 1 _)\n\ngoal (1 subgoal):\n 1. \\<And>x1 prog n.\n       \\<lbrakk>\\<And>n.\n                   labels_nodes prog n Skip \\<Longrightarrow>\n                   prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_);\n        labels_nodes (while (x1) prog) n Skip\\<rbrakk>\n       \\<Longrightarrow> while (x1) prog \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "thus ?case"], ["proof (prove)\nusing this:\n  n = (_ 1 _)\n\ngoal (1 subgoal):\n 1. while (b) c \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)", "by(fastforce intro:WCFG_WhileFalseSkip)"], ["proof (state)\nthis:\n  while (b) c \\<turnstile> n -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Semantic Non-Interference for Weak Order Dependence\\<close>"], ["", "lemmas WODNonInterferenceGraph = \n  lift_wod_backward_slice[OF While_CFGExit_wf_aux HighLowDistinct HighLowUNIV]"], ["", "lemma WODNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "interpret NonInterferenceIntraGraph src trg knd\n     \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_)\"\n     NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n     \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n     \"CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\"\n     NewExit H L \"LDCFG_node.Node (_Entry_)\" \"LDCFG_node.Node (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L))\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_))", "by(rule WODNonInterferenceGraph)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id wod_backward_slice\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "interpret BackwardSlice_wf src trg knd\n    \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n      (_Entry_) (_Exit_)\"\n    NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n    \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n    \"CFG_wf.wod_backward_slice src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\" reds \"labels_LDCFG_nodes prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BackwardSlice_wf src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id wod_backward_slice\n     reds (labels_LDCFG_nodes prog)", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "fix n c s c' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "assume \"labels_LDCFG_nodes prog n c\" and \"\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\""], ["proof (state)\nthis:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "thus \"\\<exists>n' as. CFG.path src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n      n as n' \\<and> transfers (CFG.kinds knd as) s = s' \\<and>\n      preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       local.path n as n' \\<and>\n       transfers (kinds as) s = s' \\<and>\n       preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'", "by(rule lifted_CFG_fund_prop)"], ["proof (state)\nthis:\n  \\<exists>n' as.\n     local.path n as n' \\<and>\n     transfers (kinds as) s = s' \\<and>\n     preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id wod_backward_slice\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id wod_backward_slice\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "fix c n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "assume \"final c\" and \"labels_LDCFG_nodes prog n c\""], ["proof (state)\nthis:\n  final c\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>final c\\<close>"], ["proof (chain)\npicking this:\n  final c", "have [simp]:\"c = Skip\""], ["proof (prove)\nusing this:\n  final c\n\ngoal (1 subgoal):\n 1. c = Skip", "by(cases c) auto"], ["proof (state)\nthis:\n  c = Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_LDCFG_nodes prog n c\\<close>"], ["proof (chain)\npicking this:\n  labels_LDCFG_nodes prog n c", "obtain nx where [simp]:\"n = Node nx\"\n      and \"labels_nodes prog nx Skip\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>n = LDCFG_node.Node nx; labels_nodes prog nx Skip\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip", "have \"prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "by(rule final_edge)"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "obtain a where \"valid_edge prog a\" and \"sourcenode a = nx\"\n      and \"kind a = \\<Up>id\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge prog a; sourcenode a = nx; kind a = \\<Up>id;\n         targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "with \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)", "show \"\\<exists>a. lift_valid_edge (valid_edge prog) sourcenode targetnode\n      kind (_Entry_) (_Exit_) a \\<and>\n      src a = n \\<and> trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_) a \\<and>\n       src a = n \\<and>\n       trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id", "by(rule_tac x=\"(Node nx,\\<Up>id,Node (_Exit_))\" in exI)\n        (auto intro!:lve_edge simp:knd_def valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n      (_Exit_) a \\<and>\n     src a = n \\<and>\n     trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntra src trg knd\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n   (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id wod_backward_slice reds\n   (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n   (LDCFG_node.Node (_Exit_)) final\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Semantic Non-Interference for Standard Control Dependence\\<close>"], ["", "lemma inner_node_exists:\"\\<exists>n. CFGExit.inner_node sourcenode targetnode \n  (valid_edge prog) (_Entry_) (_Exit_) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (While_CFGExit.inner_node prog)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (While_CFGExit.inner_node prog)", "have \"prog \\<turnstile> (_Entry_) -(\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow> (_0_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                     True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)", "by(rule WCFG_Entry)"], ["proof (state)\nthis:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n\ngoal (1 subgoal):\n 1. Ex (While_CFGExit.inner_node prog)", "hence \"CFG.valid_node sourcenode targetnode (valid_edge prog) (_0_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   True)\\<^sub>\\<surd>\\<rightarrow> (_ 0 _)\n\ngoal (1 subgoal):\n 1. While_CFG.valid_node prog (_ 0 _)", "by(auto simp:While_CFG.valid_node_def valid_edge_def)"], ["proof (state)\nthis:\n  While_CFG.valid_node prog (_ 0 _)\n\ngoal (1 subgoal):\n 1. Ex (While_CFGExit.inner_node prog)", "thus ?thesis"], ["proof (prove)\nusing this:\n  While_CFG.valid_node prog (_ 0 _)\n\ngoal (1 subgoal):\n 1. Ex (While_CFGExit.inner_node prog)", "by(auto simp:While_CFGExit.inner_node_def)"], ["proof (state)\nthis:\n  Ex (While_CFGExit.inner_node prog)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas SCDNonInterferenceGraph = \n  lift_PDG_standard_backward_slice[OF WStandardControlDependence.PDG_scd \n  WhilePostdomination_aux _ HighLowDistinct HighLowUNIV]"], ["", "lemma SCDNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "from inner_node_exists"], ["proof (chain)\npicking this:\n  Ex (While_CFGExit.inner_node ?prog)", "obtain n where \"CFGExit.inner_node sourcenode targetnode \n    (valid_edge prog) (_Entry_) (_Exit_) n\""], ["proof (prove)\nusing this:\n  Ex (While_CFGExit.inner_node ?prog)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        While_CFGExit.inner_node prog n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFGExit.inner_node prog n\n\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "then"], ["proof (chain)\npicking this:\n  While_CFGExit.inner_node prog n", "interpret NonInterferenceIntraGraph src trg knd\n     \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_)\"\n     NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n     \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n     \"PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit)\"\n     NewExit H L \"LDCFG_node.Node (_Entry_)\" \"LDCFG_node.Node (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFGExit.inner_node prog n\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_))", "by(fastforce intro:SCDNonInterferenceGraph)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "interpret BackwardSlice_wf src trg knd\n    \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n      (_Entry_) (_Exit_)\"\n    NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n    \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n    \"PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit)\" reds \"labels_LDCFG_nodes prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BackwardSlice_wf src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog)", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "fix n c s c' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "assume \"labels_LDCFG_nodes prog n c\" and \"\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\""], ["proof (state)\nthis:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "thus \"\\<exists>n' as. CFG.path src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n      n as n' \\<and> transfers (CFG.kinds knd as) s = s' \\<and>\n      preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       local.path n as n' \\<and>\n       transfers (kinds as) s = s' \\<and>\n       preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'", "by(rule lifted_CFG_fund_prop)"], ["proof (state)\nthis:\n  \\<exists>n' as.\n     local.path n as n' \\<and>\n     transfers (kinds as) s = s' \\<and>\n     preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (Postdomination.standard_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "fix c n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "assume \"final c\" and \"labels_LDCFG_nodes prog n c\""], ["proof (state)\nthis:\n  final c\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>final c\\<close>"], ["proof (chain)\npicking this:\n  final c", "have [simp]:\"c = Skip\""], ["proof (prove)\nusing this:\n  final c\n\ngoal (1 subgoal):\n 1. c = Skip", "by(cases c) auto"], ["proof (state)\nthis:\n  c = Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_LDCFG_nodes prog n c\\<close>"], ["proof (chain)\npicking this:\n  labels_LDCFG_nodes prog n c", "obtain nx where [simp]:\"n = Node nx\"\n      and \"labels_nodes prog nx Skip\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>n = LDCFG_node.Node nx; labels_nodes prog nx Skip\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip", "have \"prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "by(rule final_edge)"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "obtain a where \"valid_edge prog a\" and \"sourcenode a = nx\"\n      and \"kind a = \\<Up>id\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge prog a; sourcenode a = nx; kind a = \\<Up>id;\n         targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "with \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)", "show \"\\<exists>a. lift_valid_edge (valid_edge prog) sourcenode targetnode\n      kind (_Entry_) (_Exit_) a \\<and>\n      src a = n \\<and> trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_) a \\<and>\n       src a = n \\<and>\n       trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id", "by(rule_tac x=\"(Node nx,\\<Up>id,Node (_Exit_))\" in exI)\n        (auto intro!:lve_edge simp:knd_def valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n      (_Exit_) a \\<and>\n     src a = n \\<and>\n     trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntra src trg knd\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n   (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n   (PDG.PDG_BS src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       NewExit))\n   reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n   (LDCFG_node.Node (_Exit_)) final\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Semantic Non-Interference for Weak Control Dependence\\<close>"], ["", "lemmas WCDNonInterferenceGraph = \n  lift_PDG_weak_backward_slice[OF WWeakControlDependence.PDG_wcd \n  WhileStrongPostdomination_aux _ HighLowDistinct HighLowUNIV]"], ["", "lemma WCDNonInterference:\n  \"NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit))\n     reds (labels_LDCFG_nodes prog)\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_)) final\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "from inner_node_exists"], ["proof (chain)\npicking this:\n  Ex (While_CFGExit.inner_node ?prog)", "obtain n where \"CFGExit.inner_node sourcenode targetnode \n    (valid_edge prog) (_Entry_) (_Exit_) n\""], ["proof (prove)\nusing this:\n  Ex (While_CFGExit.inner_node ?prog)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        While_CFGExit.inner_node prog n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  While_CFGExit.inner_node prog n\n\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "then"], ["proof (chain)\npicking this:\n  While_CFGExit.inner_node prog n", "interpret NonInterferenceIntraGraph src trg knd\n     \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n       (_Entry_) (_Exit_)\"\n     NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n     \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n     \"PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit)\"\n     NewExit H L \"LDCFG_node.Node (_Entry_)\" \"LDCFG_node.Node (_Exit_)\""], ["proof (prove)\nusing this:\n  While_CFGExit.inner_node prog n\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     NewExit H L (LDCFG_node.Node (_Entry_)) (LDCFG_node.Node (_Exit_))", "by(fastforce intro:WCDNonInterferenceGraph)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "interpret BackwardSlice_wf src trg knd\n    \"lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n      (_Entry_) (_Exit_)\"\n    NewEntry \"lift_Def (Defs prog) (_Entry_) (_Exit_) H L\"\n    \"lift_Use (Uses prog) (_Entry_) (_Exit_) H L\" id\n    \"PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_)) NewExit)\" reds \"labels_LDCFG_nodes prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BackwardSlice_wf src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog)", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "fix n c s c' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "assume \"labels_LDCFG_nodes prog n c\" and \"\\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\""], ["proof (state)\nthis:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>n c s c' s'.\n       \\<lbrakk>labels_LDCFG_nodes prog n c;\n        \\<langle>c,s\\<rangle> \\<rightarrow>*\n        \\<langle>c',s'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n' as.\n                            local.path n as n' \\<and>\n                            transfers (kinds as) s = s' \\<and>\n                            preds (kinds as) s \\<and>\n                            labels_LDCFG_nodes prog n' c'", "thus \"\\<exists>n' as. CFG.path src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_) (_Exit_))\n      n as n' \\<and> transfers (CFG.kinds knd as) s = s' \\<and>\n      preds (CFG.kinds knd as) s \\<and> labels_LDCFG_nodes prog n' c'\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n  \\<langle>c,s\\<rangle> \\<rightarrow>* \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>n' as.\n       local.path n as n' \\<and>\n       transfers (kinds as) s = s' \\<and>\n       preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'", "by(rule lifted_CFG_fund_prop)"], ["proof (state)\nthis:\n  \\<exists>n' as.\n     local.path n as n' \\<and>\n     transfers (kinds as) s = s' \\<and>\n     preds (kinds as) s \\<and> labels_LDCFG_nodes prog n' c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntra src trg knd\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n     (PDG.PDG_BS src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n       (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n       (StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n           (_Entry_) (_Exit_))\n         NewExit))\n     reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n     (LDCFG_node.Node (_Exit_)) final", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "fix c n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "assume \"final c\" and \"labels_LDCFG_nodes prog n c\""], ["proof (state)\nthis:\n  final c\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>final c\\<close>"], ["proof (chain)\npicking this:\n  final c", "have [simp]:\"c = Skip\""], ["proof (prove)\nusing this:\n  final c\n\ngoal (1 subgoal):\n 1. c = Skip", "by(cases c) auto"], ["proof (state)\nthis:\n  c = Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_LDCFG_nodes prog n c\\<close>"], ["proof (chain)\npicking this:\n  labels_LDCFG_nodes prog n c", "obtain nx where [simp]:\"n = Node nx\"\n      and \"labels_nodes prog nx Skip\""], ["proof (prove)\nusing this:\n  labels_LDCFG_nodes prog n c\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>n = LDCFG_node.Node nx; labels_nodes prog nx Skip\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = LDCFG_node.Node nx\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "from \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip", "have \"prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n\ngoal (1 subgoal):\n 1. prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "by(rule final_edge)"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)", "obtain a where \"valid_edge prog a\" and \"sourcenode a = nx\"\n      and \"kind a = \\<Up>id\" and \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -\\<Up>id\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge prog a; sourcenode a = nx; kind a = \\<Up>id;\n         targetnode a = (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_edge_def)"], ["proof (state)\nthis:\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>c n.\n       \\<lbrakk>final c; labels_LDCFG_nodes prog n c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            lift_valid_edge (valid_edge prog) sourcenode\n                             targetnode kind (_Entry_) (_Exit_) a \\<and>\n                            src a = n \\<and>\n                            trg a = LDCFG_node.Node (_Exit_) \\<and>\n                            knd a = \\<Up>id", "with \\<open>labels_nodes prog nx Skip\\<close>"], ["proof (chain)\npicking this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)", "show \"\\<exists>a. lift_valid_edge (valid_edge prog) sourcenode targetnode\n      kind (_Entry_) (_Exit_) a \\<and>\n      src a = n \\<and> trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\""], ["proof (prove)\nusing this:\n  labels_nodes prog nx Skip\n  valid_edge prog a\n  sourcenode a = nx\n  kind a = \\<Up>id\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n        (_Entry_) (_Exit_) a \\<and>\n       src a = n \\<and>\n       trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id", "by(rule_tac x=\"(Node nx,\\<Up>id,Node (_Exit_))\" in exI)\n        (auto intro!:lve_edge simp:knd_def valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n      (_Exit_) a \\<and>\n     src a = n \\<and>\n     trg a = LDCFG_node.Node (_Exit_) \\<and> knd a = \\<Up>id\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntra src trg knd\n   (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n     (_Exit_))\n   NewEntry (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n   (lift_Use (Uses prog) (_Entry_) (_Exit_) H L) id\n   (PDG.PDG_BS src trg\n     (lift_valid_edge (valid_edge prog) sourcenode targetnode kind (_Entry_)\n       (_Exit_))\n     (lift_Def (Defs prog) (_Entry_) (_Exit_) H L)\n     (lift_Use (Uses prog) (_Entry_) (_Exit_) H L)\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge (valid_edge prog) sourcenode targetnode kind\n         (_Entry_) (_Exit_))\n       NewExit))\n   reds (labels_LDCFG_nodes prog) NewExit H L (LDCFG_node.Node (_Entry_))\n   (LDCFG_node.Node (_Exit_)) final\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}