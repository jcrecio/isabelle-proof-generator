{"file_name": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing/LiftingIntra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing", "problem_names": ["lemma [simp]:\"\\<not> lift_valid_edge valid_edge src trg knd E X (Node E,et,Node X)\"", "lemma lift_CFG:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\"", "lemma lift_CFG_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFG_wf src trg knd \n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n         (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val\"", "lemma lift_CFGExit:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFGExit src trg knd \n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n         NewEntry NewExit\"", "lemma lift_CFGExit_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFGExit_wf src trg knd \n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n        (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\"", "lemma lift_wod_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (CFG_wf.wod_backward_slice src trg lve lDef lUse)\n         NewExit H L (Node Entry) (Node Exit)\"", "lemma lift_Postdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"Postdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry NewExit\"", "lemma lift_PDG_scd:\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (Postdomination.standard_control_dependence sourcenode targetnode valid_edge Exit)\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"PDG src trg knd \n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\n  (Postdomination.standard_control_dependence src trg \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit)\"", "lemma lift_PDG_standard_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (Postdomination.standard_control_dependence sourcenode targetnode valid_edge Exit)\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit))\n         NewExit H L (Node Entry) (Node Exit)\"", "lemma lift_StrongPostdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"StrongPostdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry NewExit\"", "lemma lift_PDG_wcd:\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (StrongPostdomination.weak_control_dependence sourcenode targetnode \n  valid_edge Exit)\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"PDG src trg knd \n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\n  (StrongPostdomination.weak_control_dependence src trg \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit)\"", "lemma lift_PDG_weak_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (StrongPostdomination.weak_control_dependence sourcenode targetnode \n  valid_edge Exit)\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n         NewExit H L (Node Entry) (Node Exit)\""], "translations": [["", "lemma [simp]:\"\\<not> lift_valid_edge valid_edge src trg knd E X (Node E,et,Node X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lift_valid_edge valid_edge src trg knd E X (Node E, et, Node X)", "by(auto elim:lift_valid_edge.cases)"], ["", "subsubsection \\<open>Lifting @{term Def} and @{term Use} sets\\<close>"], ["", "inductive_set lift_Def_set :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> ('node LDCFG_node \\<times> 'var) set\"\nfor Def::\"('node \\<Rightarrow> 'var set)\" and E::'node and X::'node \n  and H::\"'var set\" and L::\"'var set\"\n\nwhere lift_Def_node: \n  \"V \\<in> Def n \\<Longrightarrow> (Node n,V) \\<in> lift_Def_set Def E X H L\"\n\n  | lift_Def_High:\n  \"V \\<in> H \\<Longrightarrow> (Node E,V) \\<in> lift_Def_set Def E X H L\""], ["", "abbreviation lift_Def :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var set\"\n  where \"lift_Def Def E X H L n \\<equiv> {V. (n,V) \\<in> lift_Def_set Def E X H L}\""], ["", "inductive_set lift_Use_set :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> ('node LDCFG_node \\<times> 'var) set\"\nfor Use::\"'node \\<Rightarrow> 'var set\" and E::'node and X::'node \n  and H::\"'var set\" and L::\"'var set\"\n\nwhere \n  lift_Use_node: \n  \"V \\<in> Use n \\<Longrightarrow> (Node n,V) \\<in> lift_Use_set Use E X H L\"\n\n  | lift_Use_High:\n  \"V \\<in> H \\<Longrightarrow> (Node E,V) \\<in> lift_Use_set Use E X H L\"\n\n  | lift_Use_Low:\n  \"V \\<in> L \\<Longrightarrow> (Node X,V) \\<in> lift_Use_set Use E X H L\""], ["", "abbreviation lift_Use :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var set\"\n  where \"lift_Use Use E X H L n \\<equiv> {V. (n,V) \\<in> lift_Use_set Use E X H L}\""], ["", "subsection \\<open>The lifting lemmas\\<close>"], ["", "subsubsection \\<open>Lifting the basic locales\\<close>"], ["", "abbreviation src :: \"('edge,'node,'state) LDCFG_edge \\<Rightarrow> 'node LDCFG_node\"\n  where \"src a \\<equiv> fst a\""], ["", "abbreviation trg :: \"('edge,'node,'state) LDCFG_edge \\<Rightarrow> 'node LDCFG_node\"\n  where \"trg a \\<equiv> snd(snd a)\""], ["", "definition knd :: \"('edge,'node,'state) LDCFG_edge \\<Rightarrow> 'state edge_kind\"\n  where \"knd a \\<equiv> fst(snd a)\""], ["", "lemma lift_CFG:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                       state_val Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"trg a = NewEntry\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "fix a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a = trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "thus \"a = a'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (1 subgoal):\n 1. a = a'", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "case lve_edge"], ["proof (state)\nthis:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e_ = src a'\n  trg e_ = trg a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e_ = src a'\n  trg e_ = trg a'\n\ngoal (1 subgoal):\n 1. e_ = a'", "by -(erule lift_valid_edge.cases,auto dest:edge_det)"], ["proof (state)\nthis:\n  e_ = a'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "qed(auto elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFG_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFG_wf src trg knd \n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n         (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                       state_val Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "interpret CFG:CFG src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(fastforce intro:lift_CFG wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "show \"lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n          lift_Use Use Entry Exit H L NewEntry = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}", "by(fastforce elim:lift_Use_set.cases lift_Def_set.cases)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n  lift_Use Use Entry Exit H L NewEntry = {}\n\ngoal (4 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a V s"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"V \\<notin> lift_Def Def Entry Exit H L (src a)\" and \"pred (knd a) s\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (4 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"state_val (transfer (knd a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd a) s) V = state_val s V", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V", "case lve_edge"], ["proof (state)\nthis:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  V \\<notin> lift_Def Def Entry Exit H L (src e_)\n  pred (knd e_) s\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  V \\<notin> lift_Def Def Entry Exit H L (src e_)\n  pred (knd e_) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd e_) s) V = state_val s V", "by(fastforce intro:CFG_edge_no_Def_equal dest:lift_Def_node[of _ Def]\n        simp:knd_def)"], ["proof (state)\nthis:\n  state_val (transfer (knd e_) s) V = state_val s V\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e);\n        pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V = state_val s V", "qed(auto simp:knd_def)"], ["proof (state)\nthis:\n  state_val (transfer (knd a) s) V = state_val s V\n\ngoal (3 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s s'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume assms:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\"\n      \"pred (knd a) s\" \"pred (knd a) s'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n\ngoal (3 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "show \"\\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n             state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "assume \"V \\<in> lift_Def Def Entry Exit H L (src a)\""], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L (src a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "with assms"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n  V \\<in> lift_Def Def Entry Exit H L (src a)", "show \"state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n  V \\<in> lift_Def Def Entry Exit H L (src a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  pred (knd e) s\n  pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "proof (cases \"Node (sourcenode a) = Node Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "case True"], ["proof (state)\nthis:\n  Node (sourcenode a) = Node Entry\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "hence \"sourcenode a = Entry\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n\ngoal (1 subgoal):\n 1. sourcenode a = Entry", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Entry\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n            and \"sourcenode a' = Entry\" and \"targetnode a' = Exit\"\n            and \"kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = Entry; targetnode a' = Exit;\n         kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "have \"\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "proof(cases \"targetnode a = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a = Entry\\<close>\n              \\<open>sourcenode a' = Entry\\<close> \\<open>targetnode a' = Exit\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a = Exit", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. a = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  a = a'", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a = Entry\\<close>\n              \\<open>sourcenode a' = Entry\\<close> \\<open>targetnode a' = Exit\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a \\<noteq> Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "from True \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> Entry_empty\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  Node (sourcenode a) = Node Entry\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Def Entry = {} \\<and> Use Entry = {}\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"V \\<in> H\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Def Entry = {} \\<and> Use Entry = {}\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> H", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  V \\<in> H\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "from True \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n            \\<open>sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  Node (sourcenode a) = Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit", "have \"\\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)", "by(fastforce intro:lift_Use_High)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "with \\<open>\\<forall>V\\<in>lift_Use Use Entry Exit H L (src e). \n                            state_val s V = state_val s' V\\<close> \\<open>V \\<in> H\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  V \\<in> H\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)", "have \"state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  V \\<in> H\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. state_val s V = state_val s' V", "by simp"], ["proof (state)\nthis:\n  state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n            \\<open>\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n  state_val s V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n  state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "case False"], ["proof (state)\nthis:\n  Node (sourcenode a) \\<noteq> Node Entry\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "{"], ["proof (state)\nthis:\n  Node (sourcenode a) \\<noteq> Node Entry\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "fix V'"], ["proof (state)\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "assume \"V' \\<in> Use (sourcenode a)\""], ["proof (state)\nthis:\n  V' \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V' \\<in> Use (sourcenode a)", "have \"V' \\<in> lift_Use Use Entry Exit H L (src e)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V' \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. V' \\<in> lift_Use Use Entry Exit H L (src e)", "by(fastforce intro:lift_Use_node)"], ["proof (state)\nthis:\n  V' \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "}"], ["proof (state)\nthis:\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "with \\<open>\\<forall>V\\<in>lift_Use Use Entry Exit H L (src e). \n                            state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)", "have \"\\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "from \\<open>valid_edge a\\<close> this \\<open>pred (knd e) s\\<close> \\<open>pred (knd e) s'\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (knd e) s\n  pred (knd e) s'\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s) V =\n            state_val (transfer (kind a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (knd e) s\n  pred (knd e) s'\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       state_val (transfer (kind a) s) V =\n       state_val (transfer (kind a) s') V", "by -(erule CFG_edge_transfer_uses_only_Use,auto simp:knd_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> False\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Node (sourcenode a) \\<noteq> Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"V \\<in> Def (sourcenode a)\""], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Node (sourcenode a) \\<noteq> Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> Def (sourcenode a)", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  V \\<in> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "with \\<open>\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s) V =\n            state_val (transfer (kind a) s') V\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V \\<in> Def (sourcenode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V \\<in> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "by(simp add:knd_def)"], ["proof (state)\nthis:\n  state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  pred (knd e) s\n  pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> \n          \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     state_val s V = state_val s' V\n  pred (knd e) s\n  pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> \n          \\<open>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_Def_set.cases intro!:Entry_noteq_Exit simp:Exit_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (knd e) s) V = state_val (transfer (knd e) s') V\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           state_val s V = state_val s' V;\n        pred (knd e) s; pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd e) s) V =\n                         state_val (transfer (knd e) s') V", "qed(simp add:knd_def)"], ["proof (state)\nthis:\n  state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n     state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\n\ngoal (2 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s s'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"pred (knd a) s\" \n      and \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"pred (knd a) s'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. pred (knd a) s'", "by(induct rule:lift_valid_edge.induct,\n         auto elim!:CFG_edge_Uses_pred_equal dest:lift_Use_node simp:knd_def)"], ["proof (state)\nthis:\n  pred (knd a) s'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a \\<noteq> trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"\\<exists>Q Q'. knd a = (Q)\\<^sub>\\<surd> \\<and> knd a' = (Q')\\<^sub>\\<surd> \\<and> \n                 (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd a = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e = src a'\n  trg e \\<noteq> trg a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\\<close>\n        \\<open>valid_edge a\\<close> \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>src e = src a'\\<close> \\<open>trg e \\<noteq> trg a'\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src a'\n  trg e \\<noteq> trg a'", "show ?case"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src a'\n  trg e \\<noteq> trg a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ea.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        ea = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case lve_edge"], ["proof (state)\nthis:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e_\n  trg e \\<noteq> trg e_\n\ngoal (4 subgoals):\n 1. \\<And>a ea.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        ea = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e_\n  trg e \\<noteq> trg e_\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd e_ = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(auto dest:deterministic simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd e_ = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (lve_Exit_edge e')"], ["proof (state)\nthis:\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e'\n  trg e \\<noteq> trg e'\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n          \\<open>e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>src e = src e'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src e'", "have \"sourcenode a = Exit\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src e'\n\ngoal (1 subgoal):\n 1. sourcenode a = Exit", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Exit\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd e' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd e' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (2 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "qed auto"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "qed (fastforce elim:lift_valid_edge.cases simp:knd_def)+"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd a = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFGExit:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFGExit src trg knd \n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n         NewEntry NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                       state_val Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret CFG:CFG src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(fastforce intro:lift_CFG wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"src a = NewExit\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from lve_Entry_Exit_edge"], ["proof (chain)\npicking this:\n  ?e =\n  (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e", "show \"\\<exists>a. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a \\<and>\n              src a = NewEntry \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a \\<and>\n     src a = NewEntry \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFGExit_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  shows \"CFGExit_wf src trg knd \n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n        (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                       state_val Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "interpret CFGExit:CFGExit src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" \n    NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(fastforce intro:lift_CFGExit wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "interpret CFG_wf:CFG_wf src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" \n    NewEntry \"lift_Def Def Entry Exit H L\" \"lift_Use Use Entry Exit H L\" state_val"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "by(fastforce intro:lift_CFG_wf wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "show \"lift_Def Def Entry Exit H L NewExit = {} \\<and>\n          lift_Use Use Entry Exit H L NewExit = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "by(fastforce elim:lift_Use_set.cases lift_Def_set.cases)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewExit = {} \\<and>\n  lift_Use Use Entry Exit H L NewExit = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lifting @{term wod_backward_slice}\\<close>"], ["", "lemma lift_wod_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (CFG_wf.wod_backward_slice src trg lve lDef lUse)\n         NewExit H L (Node Entry) (Node Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (CFG_wf.wod_backward_slice src trg lve lDef lUse) NewExit H L\n     (Node Entry) (Node Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (CFG_wf.wod_backward_slice src trg lve lDef lUse) NewExit H L\n     (Node Entry) (Node Exit)", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                       state_val Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (CFG_wf.wod_backward_slice src trg lve lDef lUse) NewExit H L\n     (Node Entry) (Node Exit)", "interpret CFGExit_wf:\n    CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit", "by(fastforce intro:lift_CFGExit_wf wf simp:lve lDef lUse)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     CFGExit_wf.wod_backward_slice NewExit H L (Node Entry) (Node Exit)", "from wf lve"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "have CFG:\"CFG src trg lve NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. CFG src trg lve NewEntry", "by(fastforce intro:lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg lve NewEntry\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     CFGExit_wf.wod_backward_slice NewExit H L (Node Entry) (Node Exit)", "from wf lve lDef lUse"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have CFG_wf:\"CFG_wf src trg knd lve NewEntry\n    lDef lUse state_val\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. CFG_wf src trg knd lve NewEntry lDef lUse state_val", "by(fastforce intro:lift_CFG_wf)"], ["proof (state)\nthis:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     CFGExit_wf.wod_backward_slice NewExit H L (Node Entry) (Node Exit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     CFGExit_wf.wod_backward_slice NewExit H L (Node Entry) (Node Exit)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> CFGExit_wf.wod_backward_slice S \\<Longrightarrow>\n       CFGExit_wf.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 4. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 5. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix n S"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> CFGExit_wf.wod_backward_slice S \\<Longrightarrow>\n       CFGExit_wf.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 4. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 5. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"n \\<in> CFG_wf.wod_backward_slice src trg lve lDef lUse S\""], ["proof (state)\nthis:\n  n \\<in> CFGExit_wf.wod_backward_slice S\n\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> CFGExit_wf.wod_backward_slice S \\<Longrightarrow>\n       CFGExit_wf.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 4. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 5. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  n \\<in> CFGExit_wf.wod_backward_slice S", "show \"CFG.valid_node src trg lve n\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  n \\<in> CFGExit_wf.wod_backward_slice S\n\ngoal (1 subgoal):\n 1. CFGExit_wf.valid_node n", "by -(rule CFG_wf.wod_backward_slice_valid_node)"], ["proof (state)\nthis:\n  CFGExit_wf.valid_node n\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 4. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 4. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "fix n S"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 4. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "assume \"CFG.valid_node src trg lve n\" and \"n \\<in> S\""], ["proof (state)\nthis:\n  CFGExit_wf.valid_node n\n  n \\<in> S\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>CFGExit_wf.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 3. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 4. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  CFGExit_wf.valid_node n\n  n \\<in> S", "show \"n \\<in> CFG_wf.wod_backward_slice src trg lve lDef lUse S\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  CFGExit_wf.valid_node n\n  n \\<in> S\n\ngoal (1 subgoal):\n 1. n \\<in> CFGExit_wf.wod_backward_slice S", "by -(rule CFG_wf.refl)"], ["proof (state)\nthis:\n  n \\<in> CFGExit_wf.wod_backward_slice S\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 3. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 3. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "fix n' S n V"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 3. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "assume \"n' \\<in> CFG_wf.wod_backward_slice src trg lve lDef lUse S\"\n      and \"CFG_wf.data_dependence src trg lve lDef lUse n V n'\""], ["proof (state)\nthis:\n  n' \\<in> CFGExit_wf.wod_backward_slice S\n  CFGExit_wf.data_dependence n V n'\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> CFGExit_wf.wod_backward_slice S;\n        CFGExit_wf.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> CFGExit_wf.wod_backward_slice S\n 2. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 3. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  n' \\<in> CFGExit_wf.wod_backward_slice S\n  CFGExit_wf.data_dependence n V n'", "show \"n \\<in> CFG_wf.wod_backward_slice src trg lve lDef lUse S\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n  n' \\<in> CFGExit_wf.wod_backward_slice S\n  CFGExit_wf.data_dependence n V n'\n\ngoal (1 subgoal):\n 1. n \\<in> CFGExit_wf.wod_backward_slice S", "by -(rule CFG_wf.dd_closed)"], ["proof (state)\nthis:\n  n \\<in> CFGExit_wf.wod_backward_slice S\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 2. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 2. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "fix n S"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 2. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "from CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val", "have \"(\\<exists>m. (CFG.obs src trg lve n\n        (CFG_wf.wod_backward_slice src trg lve lDef lUse S)) = {m}) \\<or>\n      CFG.obs src trg lve n (CFG_wf.wod_backward_slice src trg lve lDef lUse S) = {}\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n    CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}", "by(rule CFG_wf.obs_singleton)"], ["proof (state)\nthis:\n  (\\<exists>m.\n      CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n  CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n 2. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "thus \"finite \n      (CFG.obs src trg lve n (CFG_wf.wod_backward_slice src trg lve lDef lUse S))\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n  CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))", "by fastforce"], ["proof (state)\nthis:\n  finite (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S))\n\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "fix n S"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "from CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val", "have \"(\\<exists>m. (CFG.obs src trg lve n\n        (CFG_wf.wod_backward_slice src trg lve lDef lUse S)) = {m}) \\<or>\n      CFG.obs src trg lve n (CFG_wf.wod_backward_slice src trg lve lDef lUse S) = {}\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n    CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}", "by(rule CFG_wf.obs_singleton)"], ["proof (state)\nthis:\n  (\\<exists>m.\n      CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n  CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}\n\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "thus \"card (CFG.obs src trg lve n\n                        (CFG_wf.wod_backward_slice src trg lve lDef lUse S)) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {m}) \\<or>\n  CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  card (CFGExit_wf.obs n (CFGExit_wf.wod_backward_slice S)) \\<le> 1\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "fix a"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "assume \"lve a\" and \"src a = NewEntry\""], ["proof (state)\nthis:\n  lve a\n  src a = NewEntry\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry", "show \"trg a = NewExit \\<or> trg a = Node Entry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry\n\ngoal (1 subgoal):\n 1. trg a = NewExit \\<or> trg a = Node Entry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit \\<or> trg a = Node Entry\n\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "from lve_Entry_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = NewEntry \\<and> trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = NewEntry \\<and>\n     trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = Node Entry\""], ["proof (state)\nthis:\n  lve a\n  trg a = Node Entry\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry", "show \"src a = NewEntry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry\n\ngoal (1 subgoal):\n 1. src a = NewEntry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = NewExit\""], ["proof (state)\nthis:\n  lve a\n  trg a = NewExit\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit", "show \"src a = NewEntry \\<or> src a = Node Exit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit\n\ngoal (1 subgoal):\n 1. src a = NewEntry \\<or> src a = Node Exit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry \\<or> src a = Node Exit\n\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "from lve_Exit_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = Node Exit \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = Node Exit \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "assume \"lve a\" and \"src a = Node Exit\""], ["proof (state)\nthis:\n  lve a\n  src a = Node Exit\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit", "show \"trg a = NewExit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit\n\ngoal (1 subgoal):\n 1. trg a = NewExit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit\n\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "from lDef"], ["proof (chain)\npicking this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L", "show \"lDef (Node Entry) = H\""], ["proof (prove)\nusing this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n\ngoal (1 subgoal):\n 1. lDef (Node Entry) = H", "by(fastforce elim:lift_Def_set.cases intro:lift_Def_High)"], ["proof (state)\nthis:\n  lDef (Node Entry) = H\n\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Entry) = H\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Entry) = H", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_High)"], ["proof (state)\nthis:\n  lUse (Node Entry) = H\n\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Exit) = L\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Exit) = L", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_Low)"], ["proof (state)\nthis:\n  lUse (Node Exit) = L\n\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "from \\<open>H \\<inter> L = {}\\<close>"], ["proof (chain)\npicking this:\n  H \\<inter> L = {}", "show \"H \\<inter> L = {}\""], ["proof (prove)\nusing this:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<inter> L = {}", "."], ["proof (state)\nthis:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "from \\<open>H \\<union> L = UNIV\\<close>"], ["proof (chain)\npicking this:\n  H \\<union> L = UNIV", "show \"H \\<union> L = UNIV\""], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "."], ["proof (state)\nthis:\n  H \\<union> L = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n   CFGExit_wf.wod_backward_slice NewExit H L (Node Entry) (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lifting \\<open>PDG_BS\\<close> with \\<open>standard_control_dependence\\<close>\\<close>"], ["", "lemma lift_Postdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"Postdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret Postdomination sourcenode targetnode kind valid_edge Entry Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret CFGExit_wf:CFGExit_wf src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_Def Def Entry Exit H L\" \"lift_Use Use Entry Exit H L\" state_val NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "by(fastforce intro:lift_CFGExit_wf wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG:\"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(rule lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "assume \"CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\""], ["proof (state)\nthis:\n  CFGExit_wf.valid_node n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "show \"\\<exists>as. CFG.path src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n      NewEntry as n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "case NewEntry"], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "with NewEntry"], ["proof (chain)\npicking this:\n  n = NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewEntry [] n\""], ["proof (prove)\nusing this:\n  n = NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path NewEntry [] n", "by(fastforce intro:CFG.empty_path[OF CFG] simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path NewEntry [] n\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path NewEntry [] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "case NewExit"], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "with NewExit"], ["proof (chain)\npicking this:\n  n = NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewEntry [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] n\""], ["proof (prove)\nusing this:\n  n = NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path NewEntry\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                     simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n", "case (Node m)"], ["proof (state)\nthis:\n  n = Node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n", "with Entry_Exit_edge \\<open>CFG.valid_node src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  CFGExit_wf.valid_node n\n  n = Node m", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  CFGExit_wf.valid_node n\n  n = Node m\n\ngoal (1 subgoal):\n 1. valid_node m", "by(auto elim:lift_valid_edge.cases \n                simp:CFG.valid_node_def[OF CFG] valid_node_def)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "proof(cases m rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "case Entry"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "with Entry Node"], ["proof (chain)\npicking this:\n  m = Entry\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          NewEntry [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] n\""], ["proof (prove)\nusing this:\n  m = Entry\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                       simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "case Exit"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "from inner"], ["proof (chain)\npicking this:\n  inner_node nx", "obtain ax where \"valid_edge ax\" and \"inner_node (sourcenode ax)\"\n          and \"targetnode ax = Exit\""], ["proof (prove)\nusing this:\n  inner_node nx\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; inner_node (sourcenode ax);\n         targetnode ax = Exit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule inner_node_Exit_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  inner_node (sourcenode ax)\n  targetnode ax = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "hence \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node (sourcenode ax),kind ax,Node Exit)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  inner_node (sourcenode ax)\n  targetnode ax = Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode ax), kind ax, Node Exit)", "by(auto intro:lift_valid_edge.lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax), kind ax, Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "hence path:\"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node (sourcenode ax)) [(Node (sourcenode ax),kind ax,Node Exit)] \n          (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax), kind ax, Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node (sourcenode ax))\n     [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                       simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "have edge:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "from \\<open>inner_node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  inner_node (sourcenode ax)", "have \"valid_node (sourcenode ax)\""], ["proof (prove)\nusing this:\n  inner_node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode ax)", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node (sourcenode ax)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "then"], ["proof (chain)\npicking this:\n  valid_node (sourcenode ax)", "obtain asx where \"Entry -asx\\<rightarrow>* sourcenode ax\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        Entry -asx\\<rightarrow>* sourcenode ax \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path)"], ["proof (state)\nthis:\n  Entry -asx\\<rightarrow>* sourcenode ax\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "from this \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  Entry -asx\\<rightarrow>* sourcenode ax\n  valid_edge ax", "have \"\\<exists>es. CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) es (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  Entry -asx\\<rightarrow>* sourcenode ax\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))", "proof(induct asx arbitrary:ax rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>Entry -[]\\<rightarrow>* sourcenode ax;\n        valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))\n 2. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "case Nil"], ["proof (state)\nthis:\n  Entry -[]\\<rightarrow>* sourcenode ax\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>Entry -[]\\<rightarrow>* sourcenode ax;\n        valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))\n 2. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "from \\<open>Entry -[]\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  Entry -[]\\<rightarrow>* sourcenode ax", "have \"sourcenode ax = Entry\""], ["proof (prove)\nusing this:\n  Entry -[]\\<rightarrow>* sourcenode ax\n\ngoal (1 subgoal):\n 1. sourcenode ax = Entry", "by fastforce"], ["proof (state)\nthis:\n  sourcenode ax = Entry\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>Entry -[]\\<rightarrow>* sourcenode ax;\n        valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))\n 2. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "hence \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) [] (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  sourcenode ax = Entry\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry) [] (Node (sourcenode ax))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode ax = Entry \\<Longrightarrow>\n    CFGExit_wf.path (Node Entry) [] (Node Entry)", "apply(rule CFG.empty_path[OF CFG])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode ax = Entry \\<Longrightarrow>\n    CFGExit_wf.valid_node (Node Entry)", "by(auto intro:lve_Entry_edge simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) [] (Node (sourcenode ax))\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>Entry -[]\\<rightarrow>* sourcenode ax;\n        valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))\n 2. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Entry) [] (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ?ax; valid_edge ?ax\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFGExit_wf.path (Node Entry) es\n                        (Node (sourcenode ?ax))\n  Entry -xs @ [x]\\<rightarrow>* sourcenode ax\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "note IH = \\<open>\\<And>ax. \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk> \\<Longrightarrow>\n            \\<exists>es. CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) es (Node (sourcenode ax))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ?ax; valid_edge ?ax\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFGExit_wf.path (Node Entry) es\n                        (Node (sourcenode ?ax))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "from \\<open>Entry -xs@[x]\\<rightarrow>* sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  Entry -xs @ [x]\\<rightarrow>* sourcenode ax", "have \"Entry -xs\\<rightarrow>* sourcenode x\" and \"valid_edge x\"\n            and \"targetnode x = sourcenode ax\""], ["proof (prove)\nusing this:\n  Entry -xs @ [x]\\<rightarrow>* sourcenode ax\n\ngoal (1 subgoal):\n 1. Entry -xs\\<rightarrow>* sourcenode x &&&\n    valid_edge x &&& targetnode x = sourcenode ax", "by(auto elim:path_split_snoc)"], ["proof (state)\nthis:\n  Entry -xs\\<rightarrow>* sourcenode x\n  valid_edge x\n  targetnode x = sourcenode ax\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "{"], ["proof (state)\nthis:\n  Entry -xs\\<rightarrow>* sourcenode x\n  valid_edge x\n  targetnode x = sourcenode ax\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "assume \"targetnode x = Exit\""], ["proof (state)\nthis:\n  targetnode x = Exit\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "with \\<open>valid_edge ax\\<close> \\<open>targetnode x = sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  targetnode x = sourcenode ax\n  targetnode x = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  targetnode x = sourcenode ax\n  targetnode x = Exit\n\ngoal (1 subgoal):\n 1. False", "by -(rule Exit_source,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "}"], ["proof (state)\nthis:\n  targetnode x = Exit \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "hence \"targetnode x \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode x = Exit \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. targetnode x \\<noteq> Exit", "by clarsimp"], ["proof (state)\nthis:\n  targetnode x \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "with \\<open>valid_edge x\\<close> \\<open>targetnode x = sourcenode ax\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge x\n  sourcenode ax = targetnode x\n  targetnode x \\<noteq> Exit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            (Node (sourcenode x),kind x,Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  valid_edge x\n  sourcenode ax = targetnode x\n  targetnode x \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode x), kind x, Node (sourcenode ax))", "by(fastforce intro:lift_valid_edge.lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "hence path:\"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (sourcenode x)) [(Node (sourcenode x),kind x,Node (sourcenode ax))] \n            (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node (sourcenode x))\n     [(Node (sourcenode x), kind x, Node (sourcenode ax))]\n     (Node (sourcenode ax))", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                         simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node (sourcenode ax))]\n   (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "from IH[OF \\<open>Entry -xs\\<rightarrow>* sourcenode x\\<close> \\<open>valid_edge x\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode x))", "obtain es\n            where \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) es (Node (sourcenode x))\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node Entry) es\n         (Node (sourcenode x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "with path"], ["proof (chain)\npicking this:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node (sourcenode ax))]\n   (Node (sourcenode ax))\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))", "have \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) (es@[(Node (sourcenode x),kind x,Node (sourcenode ax))])\n            (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node (sourcenode ax))]\n   (Node (sourcenode ax))\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry)\n     (es @ [(Node (sourcenode x), kind x, Node (sourcenode ax))])\n     (Node (sourcenode ax))", "by -(rule CFG.path_Append[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode x), kind x, Node (sourcenode ax))])\n   (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>Entry -xs\\<rightarrow>* sourcenode ax;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax));\n        Entry -xs @ [x]\\<rightarrow>* sourcenode ax; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es\n                             (Node (sourcenode ax))", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode x), kind x, Node (sourcenode ax))])\n   (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))", "obtain es where \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) es (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node Entry) es\n         (Node (sourcenode ax)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "with path"], ["proof (chain)\npicking this:\n  CFGExit_wf.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) (es@ [(Node (sourcenode ax),kind ax,Node Exit)]) (Node Exit)\""], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry)\n     (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)", "by -(rule CFG.path_Append[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          NewEntry ((NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)#\n                      (es@ [(Node (sourcenode ax),kind ax,Node Exit)])) (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path NewEntry\n     ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) #\n      es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n     (Node Exit)", "by(fastforce intro:CFG.Cons_path[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path NewEntry\n   ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) #\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "with Node Exit"], ["proof (chain)\npicking this:\n  n = Node m\n  m = Exit\n  CFGExit_wf.path NewEntry\n   ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) #\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  m = Exit\n  CFGExit_wf.path NewEntry\n   ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) #\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "case inner"], ["proof (state)\nthis:\n  inner_node m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "obtain as where \"Entry -as\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        Entry -as\\<rightarrow>* m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path)"], ["proof (state)\nthis:\n  Entry -as\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "with inner"], ["proof (chain)\npicking this:\n  inner_node m\n  Entry -as\\<rightarrow>* m", "have \"\\<exists>es. CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) es (Node m)\""], ["proof (prove)\nusing this:\n  inner_node m\n  Entry -as\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "proof(induct arbitrary:m rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; Entry -[]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)\n 2. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "case Nil"], ["proof (state)\nthis:\n  inner_node m\n  Entry -[]\\<rightarrow>* m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; Entry -[]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)\n 2. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "from \\<open>Entry -[]\\<rightarrow>* m\\<close>"], ["proof (chain)\npicking this:\n  Entry -[]\\<rightarrow>* m", "have \"m = Entry\""], ["proof (prove)\nusing this:\n  Entry -[]\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. m = Entry", "by fastforce"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; Entry -[]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)\n 2. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "with lve_Entry_edge"], ["proof (chain)\npicking this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  m = Entry", "have \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) [] (Node m)\""], ["proof (prove)\nusing this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  m = Entry\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry) [] (Node m)", "by(fastforce intro:CFG.empty_path[OF CFG] simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) [] (Node m)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; Entry -[]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)\n 2. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Entry) [] (Node m)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>inner_node ?m; Entry -xs\\<rightarrow>* ?m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es. CFGExit_wf.path (Node Entry) es (Node ?m)\n  inner_node m\n  Entry -xs @ [x]\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "note IH = \\<open>\\<And>m. \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n            \\<Longrightarrow> \\<exists>es. CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node Entry) es (Node m)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>inner_node ?m; Entry -xs\\<rightarrow>* ?m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es. CFGExit_wf.path (Node Entry) es (Node ?m)\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "from \\<open>Entry -xs@[x]\\<rightarrow>* m\\<close>"], ["proof (chain)\npicking this:\n  Entry -xs @ [x]\\<rightarrow>* m", "have \"Entry -xs\\<rightarrow>* sourcenode x\"\n            and \"valid_edge x\" and \"m = targetnode x\""], ["proof (prove)\nusing this:\n  Entry -xs @ [x]\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. Entry -xs\\<rightarrow>* sourcenode x &&&\n    valid_edge x &&& m = targetnode x", "by(auto elim:path_split_snoc)"], ["proof (state)\nthis:\n  Entry -xs\\<rightarrow>* sourcenode x\n  valid_edge x\n  m = targetnode x\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "with \\<open>inner_node m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  Entry -xs\\<rightarrow>* sourcenode x\n  valid_edge x\n  m = targetnode x", "have edge:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            (Node (sourcenode x),kind x,Node m)\""], ["proof (prove)\nusing this:\n  inner_node m\n  Entry -xs\\<rightarrow>* sourcenode x\n  valid_edge x\n  m = targetnode x\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode x), kind x, Node m)", "by(fastforce intro:lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node m)\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "hence path:\"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (sourcenode x)) [(Node (sourcenode x),kind x,Node m)] (Node m)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node m)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node (sourcenode x))\n     [(Node (sourcenode x), kind x, Node m)] (Node m)", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                         simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node m)] (Node m)\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "from \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x", "have \"valid_node (sourcenode x)\""], ["proof (prove)\nusing this:\n  valid_edge x\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode x)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; Entry -xs\\<rightarrow>* m\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node Entry) es (Node m);\n        inner_node m; Entry -xs @ [x]\\<rightarrow>* m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node Entry) es (Node m)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node (sourcenode x)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "proof(cases \"sourcenode x\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. sourcenode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 3. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "case Entry"], ["proof (state)\nthis:\n  sourcenode x = Entry\n\ngoal (3 subgoals):\n 1. sourcenode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 3. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node m)\n  sourcenode x = Entry", "have \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node Entry) [(Node Entry,kind x,Node m)] (Node m)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode x), kind x, Node m)\n  sourcenode x = Entry\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry) [(Node Entry, kind x, Node m)] (Node m)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.path (Node Entry)\n                       [(Node Entry, kind x, Node m)] (Node m)", "apply(rule CFG.Cons_path[OF CFG])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.path ?n''2 [] (Node m)\n 2. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode kind\n                       Entry Exit (Node Entry, kind x, Node m)\n 3. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> src (Node Entry, kind x, Node m) = Node Entry\n 4. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> trg (Node Entry, kind x, Node m) = ?n''2", "apply(rule CFG.empty_path[OF CFG])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.valid_node (Node m)\n 2. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode kind\n                       Entry Exit (Node Entry, kind x, Node m)\n 3. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> src (Node Entry, kind x, Node m) = Node Entry\n 4. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node (sourcenode x), kind x, Node m);\n     sourcenode x = Entry\\<rbrakk>\n    \\<Longrightarrow> trg (Node Entry, kind x, Node m) = Node m", "by(auto simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) [(Node Entry, kind x, Node m)] (Node m)\n\ngoal (3 subgoals):\n 1. sourcenode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 3. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Entry) [(Node Entry, kind x, Node m)] (Node m)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (2 subgoals):\n 1. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "case Exit"], ["proof (state)\nthis:\n  sourcenode x = Exit\n\ngoal (2 subgoals):\n 1. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "with \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  sourcenode x = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge x\n  sourcenode x = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n 2. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "by simp"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "case inner"], ["proof (state)\nthis:\n  inner_node (sourcenode x)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "from IH[OF this \\<open>Entry -xs\\<rightarrow>* sourcenode x\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode x))", "obtain es \n              where \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node Entry) es (Node (sourcenode x))\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node Entry) es\n         (Node (sourcenode x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "with path"], ["proof (chain)\npicking this:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node m)] (Node m)\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))", "have \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node Entry) (es@[(Node (sourcenode x),kind x,Node m)]) (Node m)\""], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node (sourcenode x))\n   [(Node (sourcenode x), kind x, Node m)] (Node m)\n  CFGExit_wf.path (Node Entry) es (Node (sourcenode x))\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry)\n     (es @ [(Node (sourcenode x), kind x, Node m)]) (Node m)", "by -(rule CFG.path_Append[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode x), kind x, Node m)]) (Node m)\n\ngoal (1 subgoal):\n 1. inner_node (sourcenode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Entry)\n   (es @ [(Node (sourcenode x), kind x, Node m)]) (Node m)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)", "obtain es where path:\"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) es (Node m)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node Entry) es (Node m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "from this path Node"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  CFGExit_wf.path (Node Entry) es (Node m)\n  n = Node m", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          NewEntry ((NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)#es) n\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  CFGExit_wf.path (Node Entry) es (Node m)\n  n = Node m\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path NewEntry\n     ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) # es) n", "by(fastforce intro:CFG.Cons_path[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path NewEntry\n   ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) # es) n\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit_wf.path NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path NewEntry\n   ((NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry) # es) n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path NewEntry as n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "assume \"CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\""], ["proof (state)\nthis:\n  CFGExit_wf.valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       CFGExit_wf.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "show \"\\<exists>as. CFG.path src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n      n as NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewEntry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "case NewEntry"], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewEntry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewEntry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with NewEntry"], ["proof (chain)\npicking this:\n  n = NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        n [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  n = NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path n\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                     simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path n [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewEntry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path n [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "case NewExit"], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with NewExit"], ["proof (chain)\npicking this:\n  n = NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        n [] NewExit\""], ["proof (prove)\nusing this:\n  n = NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path n [] NewExit", "by(fastforce intro:CFG.empty_path[OF CFG] simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path n [] NewExit\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit\n 2. n = NewExit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path n [] NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "case (Node m)"], ["proof (state)\nthis:\n  n = Node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "with Entry_Exit_edge \\<open>CFG.valid_node src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  CFGExit_wf.valid_node n\n  n = Node m", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  CFGExit_wf.valid_node n\n  n = Node m\n\ngoal (1 subgoal):\n 1. valid_node m", "by(auto elim:lift_valid_edge.cases \n                simp:CFG.valid_node_def[OF CFG] valid_node_def)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       \\<exists>as. CFGExit_wf.path n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "proof(cases m rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "case Entry"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "from inner"], ["proof (chain)\npicking this:\n  inner_node nx", "obtain ax where \"valid_edge ax\" and \"inner_node (targetnode ax)\"\n          and \"sourcenode ax = Entry\""], ["proof (prove)\nusing this:\n  inner_node nx\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; inner_node (targetnode ax);\n         sourcenode ax = Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule inner_node_Entry_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  inner_node (targetnode ax)\n  sourcenode ax = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "hence edge:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Entry,kind ax,Node (targetnode ax))\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  inner_node (targetnode ax)\n  sourcenode ax = Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Entry, kind ax, Node (targetnode ax))", "by(auto intro:lift_valid_edge.lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Entry, kind ax, Node (targetnode ax))\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "hence path:\"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] (NewExit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                       simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "from \\<open>inner_node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  inner_node (targetnode ax)", "have \"valid_node (targetnode ax)\""], ["proof (prove)\nusing this:\n  inner_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. valid_node (targetnode ax)", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node (targetnode ax)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "then"], ["proof (chain)\npicking this:\n  valid_node (targetnode ax)", "obtain asx where \"targetnode ax -asx\\<rightarrow>* Exit\""], ["proof (prove)\nusing this:\n  valid_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        targetnode ax -asx\\<rightarrow>* Exit \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  targetnode ax -asx\\<rightarrow>* Exit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "from this \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* Exit\n  valid_edge ax", "have \"\\<exists>es. CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node (targetnode ax)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* Exit\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)", "proof(induct asx arbitrary:ax)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>targetnode ax -[]\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)\n 2. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "case Nil"], ["proof (state)\nthis:\n  targetnode ax -[]\\<rightarrow>* Exit\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>targetnode ax -[]\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)\n 2. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "from \\<open>targetnode ax -[]\\<rightarrow>* Exit\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -[]\\<rightarrow>* Exit", "have \"targetnode ax = Exit\""], ["proof (prove)\nusing this:\n  targetnode ax -[]\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. targetnode ax = Exit", "by fastforce"], ["proof (state)\nthis:\n  targetnode ax = Exit\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>targetnode ax -[]\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)\n 2. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "hence \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (targetnode ax)) [] (Node Exit)\""], ["proof (prove)\nusing this:\n  targetnode ax = Exit\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node (targetnode ax)) [] (Node Exit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode ax = Exit \\<Longrightarrow>\n    CFGExit_wf.path (Node Exit) [] (Node Exit)", "apply(rule CFG.empty_path[OF CFG])"], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode ax = Exit \\<Longrightarrow> CFGExit_wf.valid_node (Node Exit)", "by(auto intro:lve_Exit_edge simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (targetnode ax)) [] (Node Exit)\n\ngoal (2 subgoals):\n 1. \\<And>ax.\n       \\<lbrakk>targetnode ax -[]\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)\n 2. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node (targetnode ax)) [] (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>targetnode ?ax -xs\\<rightarrow>* Exit; valid_edge ?ax\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFGExit_wf.path (Node (targetnode ?ax)) es\n                        (Node Exit)\n  targetnode ax -x # xs\\<rightarrow>* Exit\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "note IH = \\<open>\\<And>ax. \\<lbrakk>targetnode ax -xs\\<rightarrow>* Exit; valid_edge ax\\<rbrakk> \\<Longrightarrow>\n            \\<exists>es. CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (targetnode ax)) es (Node Exit)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>targetnode ?ax -xs\\<rightarrow>* Exit; valid_edge ?ax\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es.\n                       CFGExit_wf.path (Node (targetnode ?ax)) es\n                        (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "from \\<open>targetnode ax -x#xs\\<rightarrow>* Exit\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -x # xs\\<rightarrow>* Exit", "have \"targetnode x -xs\\<rightarrow>* Exit\" and \"valid_edge x\"\n            and \"sourcenode x = targetnode ax\""], ["proof (prove)\nusing this:\n  targetnode ax -x # xs\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. targetnode x -xs\\<rightarrow>* Exit &&&\n    valid_edge x &&& sourcenode x = targetnode ax", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  targetnode x -xs\\<rightarrow>* Exit\n  valid_edge x\n  sourcenode x = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "{"], ["proof (state)\nthis:\n  targetnode x -xs\\<rightarrow>* Exit\n  valid_edge x\n  sourcenode x = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "assume \"sourcenode x = Entry\""], ["proof (state)\nthis:\n  sourcenode x = Entry\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode x = targetnode ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode x = targetnode ax\n  sourcenode x = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode x = targetnode ax\n  sourcenode x = Entry\n\ngoal (1 subgoal):\n 1. False", "by -(rule Entry_target,simp+)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "}"], ["proof (state)\nthis:\n  sourcenode x = Entry \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "hence \"sourcenode x \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  sourcenode x = Entry \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sourcenode x \\<noteq> Entry", "by clarsimp"], ["proof (state)\nthis:\n  sourcenode x \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "with \\<open>valid_edge x\\<close> \\<open>sourcenode x = targetnode ax\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  valid_edge x\n  targetnode ax = sourcenode x\n  sourcenode x \\<noteq> Entry", "have edge:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            (Node (targetnode ax),kind x,Node (targetnode x))\""], ["proof (prove)\nusing this:\n  valid_edge x\n  targetnode ax = sourcenode x\n  sourcenode x \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (targetnode ax), kind x, Node (targetnode x))", "by(fastforce intro:lift_valid_edge.lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (targetnode ax), kind x, Node (targetnode x))\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "from IH[OF \\<open>targetnode x -xs\\<rightarrow>* Exit\\<close> \\<open>valid_edge x\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode x)) es (Node Exit)", "obtain es\n            where \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (targetnode x)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node (targetnode x)) es\n         (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (targetnode ax), kind x, Node (targetnode x))\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)", "have \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node (targetnode ax)) \n            ((Node (targetnode ax),kind x,Node (targetnode x))#es) (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (targetnode ax), kind x, Node (targetnode x))\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node (targetnode ax))\n     ((Node (targetnode ax), kind x, Node (targetnode x)) # es) (Node Exit)", "by(fastforce intro:CFG.Cons_path[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (targetnode ax))\n   ((Node (targetnode ax), kind x, Node (targetnode x)) # es) (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a asx ax.\n       \\<lbrakk>\\<And>ax.\n                   \\<lbrakk>targetnode ax -asx\\<rightarrow>* Exit;\n                    valid_edge ax\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit);\n        targetnode ax -a # asx\\<rightarrow>* Exit; valid_edge ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node (targetnode ax)) es\n                             (Node Exit)", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node (targetnode ax))\n   ((Node (targetnode ax), kind x, Node (targetnode x)) # es) (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)", "obtain es where \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node (targetnode ax)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node (targetnode ax)) es\n         (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Entry, kind ax, Node (targetnode ax))\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) ((Node Entry, kind ax, Node (targetnode ax))#es) (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Entry, kind ax, Node (targetnode ax))\n  CFGExit_wf.path (Node (targetnode ax)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry)\n     ((Node Entry, kind ax, Node (targetnode ax)) # es) (Node Exit)", "by(fastforce intro:CFG.Cons_path[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry)\n   ((Node Entry, kind ax, Node (targetnode ax)) # es) (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with path"], ["proof (chain)\npicking this:\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit_wf.path (Node Entry)\n   ((Node Entry, kind ax, Node (targetnode ax)) # es) (Node Exit)", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) (((Node Entry,kind ax,Node (targetnode ax))#es)@\n                        [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit_wf.path (Node Entry)\n   ((Node Entry, kind ax, Node (targetnode ax)) # es) (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Entry)\n     (((Node Entry, kind ax, Node (targetnode ax)) # es) @\n      [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n     NewExit", "by -(rule CFG.path_Append[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Entry)\n   (((Node Entry, kind ax, Node (targetnode ax)) # es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 3. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with Node Entry"], ["proof (chain)\npicking this:\n  n = Node m\n  m = Entry\n  CFGExit_wf.path (Node Entry)\n   (((Node Entry, kind ax, Node (targetnode ax)) # es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  m = Entry\n  CFGExit_wf.path (Node Entry)\n   (((Node Entry, kind ax, Node (targetnode ax)) # es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "case Exit"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with Exit Node"], ["proof (chain)\npicking this:\n  m = Exit\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          n [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  m = Exit\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path n\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                       simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path n [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit\n 2. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path n [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "case inner"], ["proof (state)\nthis:\n  inner_node m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "obtain as where \"m -as\\<rightarrow>* Exit\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        m -as\\<rightarrow>* Exit \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with inner"], ["proof (chain)\npicking this:\n  inner_node m\n  m -as\\<rightarrow>* Exit", "have \"\\<exists>es. CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node m) es (Node Exit)\""], ["proof (prove)\nusing this:\n  inner_node m\n  m -as\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "proof(induct as arbitrary:m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; m -[]\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)\n 2. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "case Nil"], ["proof (state)\nthis:\n  inner_node m\n  m -[]\\<rightarrow>* Exit\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; m -[]\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)\n 2. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "from \\<open>m -[]\\<rightarrow>* Exit\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* Exit", "have \"m = Exit\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. m = Exit", "by fastforce"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; m -[]\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)\n 2. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "with lve_Exit_edge"], ["proof (chain)\npicking this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  m = Exit", "have \"CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node m) [] (Node Exit)\""], ["proof (prove)\nusing this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  m = Exit\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node m) [] (Node Exit)", "by(fastforce intro:CFG.empty_path[OF CFG] simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node m) [] (Node Exit)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>inner_node m; m -[]\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)\n 2. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "thus ?case"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node m) [] (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>inner_node ?m; ?m -xs\\<rightarrow>* Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es. CFGExit_wf.path (Node ?m) es (Node Exit)\n  inner_node m\n  m -x # xs\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "note IH = \\<open>\\<And>m. \\<lbrakk>inner_node m; m -xs\\<rightarrow>* Exit\\<rbrakk>\n            \\<Longrightarrow> \\<exists>es. CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n            (Node m) es (Node Exit)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>inner_node ?m; ?m -xs\\<rightarrow>* Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es. CFGExit_wf.path (Node ?m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "from \\<open>m -x#xs\\<rightarrow>* Exit\\<close>"], ["proof (chain)\npicking this:\n  m -x # xs\\<rightarrow>* Exit", "have \"targetnode x -xs\\<rightarrow>* Exit\"\n            and \"valid_edge x\" and \"m = sourcenode x\""], ["proof (prove)\nusing this:\n  m -x # xs\\<rightarrow>* Exit\n\ngoal (1 subgoal):\n 1. targetnode x -xs\\<rightarrow>* Exit &&&\n    valid_edge x &&& m = sourcenode x", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  targetnode x -xs\\<rightarrow>* Exit\n  valid_edge x\n  m = sourcenode x\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "with \\<open>inner_node m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  targetnode x -xs\\<rightarrow>* Exit\n  valid_edge x\n  m = sourcenode x", "have edge:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            (Node m,kind x,Node (targetnode x))\""], ["proof (prove)\nusing this:\n  inner_node m\n  targetnode x -xs\\<rightarrow>* Exit\n  valid_edge x\n  m = sourcenode x\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node m, kind x, Node (targetnode x))", "by(fastforce intro:lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node m, kind x, Node (targetnode x))\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "from \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x", "have \"valid_node (targetnode x)\""], ["proof (prove)\nusing this:\n  valid_edge x\n\ngoal (1 subgoal):\n 1. valid_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. \\<And>a as m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>inner_node m; m -as\\<rightarrow>* Exit\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es.\n  CFGExit_wf.path (Node m) es (Node Exit);\n        inner_node m; m -a # as\\<rightarrow>* Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit_wf.path (Node m) es (Node Exit)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "proof(cases \"targetnode x\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 3. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "case Entry"], ["proof (state)\nthis:\n  targetnode x = Entry\n\ngoal (3 subgoals):\n 1. targetnode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 3. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "with \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  targetnode x = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge x\n  targetnode x = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode x = Entry \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 3. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "by simp"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (2 subgoals):\n 1. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "case Exit"], ["proof (state)\nthis:\n  targetnode x = Exit\n\ngoal (2 subgoals):\n 1. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node m, kind x, Node (targetnode x))\n  targetnode x = Exit", "have \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node m) [(Node m,kind x,Node Exit)] (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node m, kind x, Node (targetnode x))\n  targetnode x = Exit\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node m) [(Node m, kind x, Node Exit)] (Node Exit)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.path (Node m) [(Node m, kind x, Node Exit)]\n                       (Node Exit)", "apply(rule CFG.Cons_path[OF CFG])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.path ?n''2 [] (Node Exit)\n 2. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode kind\n                       Entry Exit (Node m, kind x, Node Exit)\n 3. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> src (Node m, kind x, Node Exit) = Node m\n 4. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> trg (Node m, kind x, Node Exit) = ?n''2", "apply(rule CFG.empty_path[OF CFG])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> CFGExit_wf.valid_node (Node Exit)\n 2. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode kind\n                       Entry Exit (Node m, kind x, Node Exit)\n 3. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> src (Node m, kind x, Node Exit) = Node m\n 4. \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit (Node m, kind x, Node (targetnode x));\n     targetnode x = Exit\\<rbrakk>\n    \\<Longrightarrow> trg (Node m, kind x, Node Exit) = Node Exit", "by(auto simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node m) [(Node m, kind x, Node Exit)] (Node Exit)\n\ngoal (2 subgoals):\n 1. targetnode x = Exit \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n 2. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node m) [(Node m, kind x, Node Exit)] (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "case inner"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "from IH[OF this \\<open>targetnode x -xs\\<rightarrow>* Exit\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode x)) es (Node Exit)", "obtain es \n              where \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node (targetnode x)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node (targetnode x)) es\n         (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "with edge"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node m, kind x, Node (targetnode x))\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)", "have \"CFG.path src trg\n              (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n              (Node m) ((Node m,kind x,Node (targetnode x))#es) (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node m, kind x, Node (targetnode x))\n  CFGExit_wf.path (Node (targetnode x)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node m) ((Node m, kind x, Node (targetnode x)) # es)\n     (Node Exit)", "by(fastforce intro:CFG.Cons_path[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node m) ((Node m, kind x, Node (targetnode x)) # es)\n   (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow>\n    \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node m) ((Node m, kind x, Node (targetnode x)) # es)\n   (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "by blast"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)", "obtain es where path:\"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node m) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit_wf.path (Node m) es (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFG.Cons_path[OF CFG] CFG.empty_path[OF CFG]\n                       simp:CFG.valid_node_def[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "with path Node"], ["proof (chain)\npicking this:\n  CFGExit_wf.path (Node m) es (Node Exit)\n  n = Node m\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          n (es@[(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf.path (Node m) es (Node Exit)\n  n = Node m\n  CFGExit_wf.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. CFGExit_wf.path n\n     (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit", "by(fastforce intro:CFG.path_Append[OF CFG])"], ["proof (state)\nthis:\n  CFGExit_wf.path n\n   (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow> \\<exists>as. CFGExit_wf.path n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit_wf.path n\n   (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit_wf.path n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit_wf.path n as NewExit\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_PDG_scd:\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (Postdomination.standard_control_dependence sourcenode targetnode valid_edge Exit)\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"PDG src trg knd \n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\n  (Postdomination.standard_control_dependence src trg \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "interpret PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n    \"Postdomination.standard_control_dependence sourcenode targetnode \n                                                           valid_edge Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n     (Postdomination.standard_control_dependence sourcenode targetnode\n       valid_edge Exit)", "by(rule PDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "have wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                            state_val Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf pd inner"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx", "have pd':\"Postdomination src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_Postdomination)"], ["proof (state)\nthis:\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG:\"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(rule lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG_wf:\"CFG_wf src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n    (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "by(rule lift_CFG_wf)"], ["proof (state)\nthis:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFGExit:\"CFGExit src trg knd \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_CFGExit)"], ["proof (state)\nthis:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFGExit_wf:\"CFGExit_wf src trg knd \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n    (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "by(rule lift_CFGExit_wf)"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (Postdomination.standard_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "proof"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "fix a"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"trg a = NewEntry\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "with CFG"], ["proof (chain)\npicking this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry", "show False"], ["proof (prove)\nusing this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (1 subgoal):\n 1. False", "by(rule CFG.Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "fix a a'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a = trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "with CFG"], ["proof (chain)\npicking this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (1 subgoal):\n 1. a = a'", "by(rule CFG.edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (10 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 8. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        \\<exists>as.\n           CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit)\n            n as n' \\<and>\n           as \\<noteq> []", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 8. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 10. \\<And>n n'.\n        Postdomination.standard_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        \\<exists>as.\n           CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit)\n            n as n' \\<and>\n           as \\<noteq> []", "from CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val", "show \"lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n          lift_Use Use Entry Exit H L NewEntry = {}\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}", "by(rule CFG_wf.Entry_empty)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n  lift_Use Use Entry Exit H L NewEntry = {}\n\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a V s"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"V \\<notin> lift_Def Def Entry Exit H L (src a)\" and \"pred (knd a) s\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s", "show \"state_val (transfer (knd a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd a) s) V = state_val s V", "by(rule CFG_wf.CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (knd a) s) V = state_val s V\n\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a s s'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume assms:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\"\n      \"pred (knd a) s\" \"pred (knd a) s'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'", "show \"\\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n             state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "by(rule CFG_wf.CFG_edge_transfer_uses_only_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n     state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a s s'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"pred (knd a) s\" \n      and \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V", "show \"pred (knd a) s'\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. pred (knd a) s'", "by(rule CFG_wf.CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (knd a) s'\n\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a a'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a \\<noteq> trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'", "show \"\\<exists>Q Q'. knd a = (Q)\\<^sub>\\<surd> \\<and> knd a' = (Q')\\<^sub>\\<surd> \\<and> \n                             (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd a = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(rule CFG_wf.deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd a = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"src a = NewExit\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFGExit"], ["proof (chain)\npicking this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit", "show False"], ["proof (prove)\nusing this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(rule CFGExit.Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 3. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 3. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 4. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "from CFGExit"], ["proof (chain)\npicking this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit", "show \"\\<exists>a. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a \\<and>\n              src a = NewEntry \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule CFGExit.Entry_Exit_edge)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a \\<and>\n     src a = NewEntry \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 3. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 3. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "from CFGExit_wf"], ["proof (chain)\npicking this:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit", "show \"lift_Def Def Entry Exit H L NewExit = {} \\<and>\n          lift_Use Use Entry Exit H L NewExit = {}\""], ["proof (prove)\nusing this:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "by(rule CFGExit_wf.Exit_empty)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewExit = {} \\<and>\n  lift_Use Use Entry Exit H L NewExit = {}\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume scd:\"Postdomination.standard_control_dependence src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n n'\""], ["proof (state)\nthis:\n  Postdomination.standard_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "show \"n' \\<noteq> NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<noteq> NewExit", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "assume \"\\<not> n' \\<noteq> NewExit\""], ["proof (state)\nthis:\n  \\<not> n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "hence \"n' = NewExit\""], ["proof (prove)\nusing this:\n  \\<not> n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. n' = NewExit", "by simp"], ["proof (state)\nthis:\n  n' = NewExit\n\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "with scd pd'"], ["proof (chain)\npicking this:\n  Postdomination.standard_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  n' = NewExit", "show False"], ["proof (prove)\nusing this:\n  Postdomination.standard_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  n' = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:Postdomination.Exit_not_standard_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"Postdomination.standard_control_dependence src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n n'\""], ["proof (state)\nthis:\n  Postdomination.standard_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       Postdomination.standard_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "thus \"\\<exists>as. CFG.path src trg\n               (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n               n as n' \\<and> as \\<noteq> []\""], ["proof (prove)\nusing this:\n  Postdomination.standard_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\n        as n' \\<and>\n       as \\<noteq> []", "by(fastforce simp:Postdomination.standard_control_dependence_def[OF pd'])"], ["proof (state)\nthis:\n  \\<exists>as.\n     CFG.path src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\n      as n' \\<and>\n     as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PDG src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n   (Postdomination.standard_control_dependence src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewExit)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_PDG_standard_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (Postdomination.standard_control_dependence sourcenode targetnode valid_edge Exit)\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit))\n         NewExit H L (Node Entry) (Node Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "interpret PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n    \"Postdomination.standard_control_dependence sourcenode targetnode \n                                                           valid_edge Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n     (Postdomination.standard_control_dependence sourcenode targetnode\n       valid_edge Exit)", "by(rule PDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "have wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                            state_val Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "interpret wf':CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit", "by(fastforce intro:lift_CFGExit_wf wf simp:lve lDef lUse)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from PDG pd inner lve lDef lUse"], ["proof (chain)\npicking this:\n  PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n   (Postdomination.standard_control_dependence sourcenode targetnode\n     valid_edge Exit)\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have PDG':\"PDG src trg knd \n    lve NewEntry lDef lUse state_val NewExit\n    (Postdomination.standard_control_dependence src trg lve NewExit)\""], ["proof (prove)\nusing this:\n  PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n   (Postdomination.standard_control_dependence sourcenode targetnode\n     valid_edge Exit)\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (Postdomination.standard_control_dependence src trg lve NewExit)", "by(fastforce intro:lift_PDG_scd)"], ["proof (state)\nthis:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (Postdomination.standard_control_dependence src trg lve NewExit)\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf pd inner"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx", "have pd':\"Postdomination src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_Postdomination)"], ["proof (state)\nthis:\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "have CFG:\"CFG src trg lve NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. CFG src trg lve NewEntry", "by(fastforce intro:lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg lve NewEntry\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve lDef lUse"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have CFG_wf:\"CFG_wf src trg knd lve NewEntry lDef lUse state_val\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. CFG_wf src trg knd lve NewEntry lDef lUse state_val", "by(fastforce intro:lift_CFG_wf)"], ["proof (state)\nthis:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "have CFGExit:\"CFGExit src trg knd lve NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. CFGExit src trg knd lve NewEntry NewExit", "by(fastforce intro:lift_CFGExit)"], ["proof (state)\nthis:\n  CFGExit src trg knd lve NewEntry NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve lDef lUse"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have CFGExit_wf:\"CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit", "by(fastforce intro:lift_CFGExit_wf)"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (Postdomination.standard_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (Postdomination.standard_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix n S"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (Postdomination.standard_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (Postdomination.standard_control_dependence src trg lve NewExit) S\""], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit)\n           S\n\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (Postdomination.standard_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "with PDG'"], ["proof (chain)\npicking this:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (Postdomination.standard_control_dependence src trg lve NewExit)\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit)\n           S", "show \"CFG.valid_node src trg lve n\""], ["proof (prove)\nusing this:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (Postdomination.standard_control_dependence src trg lve NewExit)\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit)\n           S\n\ngoal (1 subgoal):\n 1. wf'.valid_node n", "by(rule PDG.PDG_BS_valid_node)"], ["proof (state)\nthis:\n  wf'.valid_node n\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "fix n S"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "assume \"CFG.valid_node src trg lve n\" and \"n \\<in> S\""], ["proof (state)\nthis:\n  wf'.valid_node n\n  n \\<in> S\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "thus \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (Postdomination.standard_control_dependence src trg lve NewExit) S\""], ["proof (prove)\nusing this:\n  wf'.valid_node n\n  n \\<in> S\n\ngoal (1 subgoal):\n 1. n \\<in> PDG.PDG_BS src trg lve lDef lUse\n             (Postdomination.standard_control_dependence src trg lve\n               NewExit)\n             S", "by(fastforce intro:PDG.PDG_path_Nil[OF PDG'] simp:PDG.PDG_BS_def[OF PDG'])"], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit)\n           S\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "fix n' S n V"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "assume \"n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (Postdomination.standard_control_dependence src trg lve NewExit) S\"\n      and \"CFG_wf.data_dependence src trg lve lDef lUse n V n'\""], ["proof (state)\nthis:\n  n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S\n  wf'.data_dependence n V n'\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (Postdomination.standard_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (Postdomination.standard_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "thus \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (Postdomination.standard_control_dependence src trg lve NewExit) S\""], ["proof (prove)\nusing this:\n  n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S\n  wf'.data_dependence n V n'\n\ngoal (1 subgoal):\n 1. n \\<in> PDG.PDG_BS src trg lve lDef lUse\n             (Postdomination.standard_control_dependence src trg lve\n               NewExit)\n             S", "by(fastforce intro:PDG.PDG_path_Append[OF PDG'] PDG.PDG_path_ddep[OF PDG']\n                        PDG.PDG_ddep_edge[OF PDG'] simp:PDG.PDG_BS_def[OF PDG']\n                  split:if_split_asm)"], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (Postdomination.standard_control_dependence src trg lve NewExit)\n           S\n\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "fix n S"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "interpret PDGx:PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n      \"Postdomination.standard_control_dependence src trg lve NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (Postdomination.standard_control_dependence src trg lve NewExit)", "by(rule PDG')"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "interpret pdx:Postdomination src trg knd lve NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd lve NewEntry NewExit", "by(fastforce intro:pd' simp:lve)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "have scd:\"StandardControlDependencePDG src trg knd lve NewEntry\n      lDef lUse state_val NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StandardControlDependencePDG src trg knd lve NewEntry lDef lUse\n     state_val NewExit", "by(unfold_locales)"], ["proof (state)\nthis:\n  StandardControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n   NewExit\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "from StandardControlDependencePDG.obs_singleton[OF scd]"], ["proof (chain)\npicking this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n     ?S) =\n  {}", "have \"(\\<exists>m. CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (Postdomination.standard_control_dependence src trg lve NewExit) S) = {m}) \\<or>\n      CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (Postdomination.standard_control_dependence src trg lve NewExit) S) = {}\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n     ?S) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n    wf'.obs n (PDGx.PDG_BS S) = {}", "by(fastforce simp:StandardControlDependencePDG.PDG_BS_s_def[OF scd])"], ["proof (state)\nthis:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "thus \"finite (CFG.obs src trg lve n\n        (PDG.PDG_BS src trg lve lDef lUse\n          (Postdomination.standard_control_dependence src trg lve NewExit) S))\""], ["proof (prove)\nusing this:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (1 subgoal):\n 1. finite (wf'.obs n (PDGx.PDG_BS S))", "by fastforce"], ["proof (state)\nthis:\n  finite (wf'.obs n (PDGx.PDG_BS S))\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "fix n S"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (Postdomination.standard_control_dependence src trg lve NewExit)\n            S))\n       \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "interpret PDGx:PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n      \"Postdomination.standard_control_dependence src trg lve NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (Postdomination.standard_control_dependence src trg lve NewExit)", "by(rule PDG')"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "interpret pdx:Postdomination src trg knd lve NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd lve NewEntry NewExit", "by(fastforce intro:pd' simp:lve)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "have scd:\"StandardControlDependencePDG src trg knd lve NewEntry\n      lDef lUse state_val NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StandardControlDependencePDG src trg knd lve NewEntry lDef lUse\n     state_val NewExit", "by(unfold_locales)"], ["proof (state)\nthis:\n  StandardControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n   NewExit\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "from StandardControlDependencePDG.obs_singleton[OF scd]"], ["proof (chain)\npicking this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n     ?S) =\n  {}", "have \"(\\<exists>m. CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (Postdomination.standard_control_dependence src trg lve NewExit) S) = {m}) \\<or>\n      CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (Postdomination.standard_control_dependence src trg lve NewExit) S) = {}\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (StandardControlDependencePDG.PDG_BS_s src trg lve lDef lUse NewExit\n     ?S) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n    wf'.obs n (PDGx.PDG_BS S) = {}", "by(fastforce simp:StandardControlDependencePDG.PDG_BS_s_def[OF scd])"], ["proof (state)\nthis:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "thus \"card (CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (Postdomination.standard_control_dependence src trg lve NewExit) S)) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (1 subgoal):\n 1. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "fix a"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "assume \"lve a\" and \"src a = NewEntry\""], ["proof (state)\nthis:\n  lve a\n  src a = NewEntry\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry", "show \"trg a = NewExit \\<or> trg a = Node Entry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry\n\ngoal (1 subgoal):\n 1. trg a = NewExit \\<or> trg a = Node Entry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit \\<or> trg a = Node Entry\n\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "from lve_Entry_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = NewEntry \\<and> trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = NewEntry \\<and>\n     trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = Node Entry\""], ["proof (state)\nthis:\n  lve a\n  trg a = Node Entry\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry", "show \"src a = NewEntry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry\n\ngoal (1 subgoal):\n 1. src a = NewEntry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = NewExit\""], ["proof (state)\nthis:\n  lve a\n  trg a = NewExit\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit", "show \"src a = NewEntry \\<or> src a = Node Exit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit\n\ngoal (1 subgoal):\n 1. src a = NewEntry \\<or> src a = Node Exit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry \\<or> src a = Node Exit\n\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "from lve_Exit_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = Node Exit \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = Node Exit \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "assume \"lve a\" and \"src a = Node Exit\""], ["proof (state)\nthis:\n  lve a\n  src a = Node Exit\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit", "show \"trg a = NewExit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit\n\ngoal (1 subgoal):\n 1. trg a = NewExit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit\n\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "from lDef"], ["proof (chain)\npicking this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L", "show \"lDef (Node Entry) = H\""], ["proof (prove)\nusing this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n\ngoal (1 subgoal):\n 1. lDef (Node Entry) = H", "by(fastforce elim:lift_Def_set.cases intro:lift_Def_High)"], ["proof (state)\nthis:\n  lDef (Node Entry) = H\n\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Entry) = H\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Entry) = H", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_High)"], ["proof (state)\nthis:\n  lUse (Node Entry) = H\n\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Exit) = L\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Exit) = L", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_Low)"], ["proof (state)\nthis:\n  lUse (Node Exit) = L\n\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "from \\<open>H \\<inter> L = {}\\<close>"], ["proof (chain)\npicking this:\n  H \\<inter> L = {}", "show \"H \\<inter> L = {}\""], ["proof (prove)\nusing this:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<inter> L = {}", "."], ["proof (state)\nthis:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "from \\<open>H \\<union> L = UNIV\\<close>"], ["proof (chain)\npicking this:\n  H \\<union> L = UNIV", "show \"H \\<union> L = UNIV\""], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "."], ["proof (state)\nthis:\n  H \\<union> L = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n   (PDG.PDG_BS src trg lve lDef lUse\n     (Postdomination.standard_control_dependence src trg lve NewExit))\n   NewExit H L (Node Entry) (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lifting \\<open>PDG_BS\\<close> with \\<open>weak_control_dependence\\<close>\\<close>"], ["", "lemma lift_StrongPostdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                         state_val Exit\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"StrongPostdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit", "by(rule spd)"], ["proof (state)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "have pd:\"Postdomination sourcenode targetnode kind valid_edge Entry Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  Postdomination sourcenode targetnode kind valid_edge Entry Exit\n\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret pd':Postdomination src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n    NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(fastforce intro:wf inner lift_Postdomination pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "interpret CFGExit_wf:CFGExit_wf src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_Def Def Entry Exit H L\" \"lift_Use Use Entry Exit H L\" state_val NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "by(fastforce intro:lift_CFGExit_wf wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG:\"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(rule lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       pd'.valid_node n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       pd'.valid_node n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "assume \"CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\""], ["proof (state)\nthis:\n  pd'.valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       pd'.valid_node n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "show \"finite\n      {n'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n                src a' = n \\<and> trg a' = n'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "proof(cases n)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewEntry \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}\n 3. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "case NewEntry"], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewEntry \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}\n 3. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "hence \"{n'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind \n                     Entry Exit a' \\<and> src a' = n \\<and> trg a' = n'} = {NewExit,Node Entry}\""], ["proof (prove)\nusing this:\n  n = NewEntry\n\ngoal (1 subgoal):\n 1. {n'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = n \\<and> trg a' = n'} =\n    {NewExit, Node Entry}", "by(auto elim:lift_valid_edge.cases intro:lift_valid_edge.intros)"], ["proof (state)\nthis:\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'} =\n  {NewExit, Node Entry}\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewEntry \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}\n 3. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'} =\n  {NewExit, Node Entry}\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "by simp"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = n \\<and> trg a' = n'}\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "case NewExit"], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "hence \"{n'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind \n                     Entry Exit a' \\<and> src a' = n \\<and> trg a' = n'} = {}\""], ["proof (prove)\nusing this:\n  n = NewExit\n\ngoal (1 subgoal):\n 1. {n'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = n \\<and> trg a' = n'} =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'} =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}\n 2. n = NewExit \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'} =\n  {}\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "by simp"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = n \\<and> trg a' = n'}\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "case (Node m)"], ["proof (state)\nthis:\n  n = Node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "with Entry_Exit_edge \\<open>CFG.valid_node src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  pd'.valid_node n\n  n = Node m", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  pd'.valid_node n\n  n = Node m\n\ngoal (1 subgoal):\n 1. valid_node m", "by(auto elim:lift_valid_edge.cases \n                simp:CFG.valid_node_def[OF CFG] valid_node_def)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "hence \"finite {m'. \\<exists>a'. valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. finite\n     {m'.\n      \\<exists>a'.\n         valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}", "by(rule successor_set_finite)"], ["proof (state)\nthis:\n  finite\n   {m'.\n    \\<exists>a'.\n       valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "have \"{m'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind \n                      Entry Exit a' \\<and> src a' = Node m \\<and> trg a' = Node m'} \\<subseteq> \n            {m'. \\<exists>a'. valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'}\n    \\<subseteq> {m'.\n                 \\<exists>a'.\n                    valid_edge a' \\<and>\n                    sourcenode a' = m \\<and> targetnode a' = m'}", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  {m'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = Node m \\<and> trg a' = Node m'}\n  \\<subseteq> {m'.\n               \\<exists>a'.\n                  valid_edge a' \\<and>\n                  sourcenode a' = m \\<and> targetnode a' = m'}\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "with \\<open>finite {m'. \\<exists>a'. valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\\<close>"], ["proof (chain)\npicking this:\n  finite\n   {m'.\n    \\<exists>a'.\n       valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\n  {m'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = Node m \\<and> trg a' = Node m'}\n  \\<subseteq> {m'.\n               \\<exists>a'.\n                  valid_edge a' \\<and>\n                  sourcenode a' = m \\<and> targetnode a' = m'}", "have \"finite {m'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind \n                             Entry Exit a' \\<and> src a' = Node m \\<and> trg a' = Node m'}\""], ["proof (prove)\nusing this:\n  finite\n   {m'.\n    \\<exists>a'.\n       valid_edge a' \\<and> sourcenode a' = m \\<and> targetnode a' = m'}\n  {m'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = Node m \\<and> trg a' = Node m'}\n  \\<subseteq> {m'.\n               \\<exists>a'.\n                  valid_edge a' \\<and>\n                  sourcenode a' = m \\<and> targetnode a' = m'}\n\ngoal (1 subgoal):\n 1. finite\n     {m'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = Node m \\<and> trg a' = Node m'}", "by -(rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {m'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = Node m \\<and> trg a' = Node m'}\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "hence \"finite (Node ` {m'. \\<exists>a'. lift_valid_edge valid_edge sourcenode \n        targetnode kind Entry Exit a' \\<and> src a' = Node m \\<and> trg a' = Node m'})\""], ["proof (prove)\nusing this:\n  finite\n   {m'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = Node m \\<and> trg a' = Node m'}\n\ngoal (1 subgoal):\n 1. finite\n     (Node `\n      {m'.\n       \\<exists>a'.\n          lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n           a' \\<and>\n          src a' = Node m \\<and> trg a' = Node m'})", "by fastforce"], ["proof (state)\nthis:\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'})\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "hence fin:\"finite ((Node ` {m'. \\<exists>a'. lift_valid_edge valid_edge sourcenode \n        targetnode kind Entry Exit a' \\<and> src a' = Node m \\<and> trg a' = Node m'}) \\<union>\n        {NewEntry,NewExit})\""], ["proof (prove)\nusing this:\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'})\n\ngoal (1 subgoal):\n 1. finite\n     (Node `\n      {m'.\n       \\<exists>a'.\n          lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n           a' \\<and>\n          src a' = Node m \\<and> trg a' = Node m'} \\<union>\n      {NewEntry, NewExit})", "by fastforce"], ["proof (state)\nthis:\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'} \\<union>\n    {NewEntry, NewExit})\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "with Node"], ["proof (chain)\npicking this:\n  n = Node m\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'} \\<union>\n    {NewEntry, NewExit})", "have \"{n'. \\<exists>a'. lift_valid_edge valid_edge sourcenode targetnode kind \n        Entry Exit a' \\<and> src a' = n \\<and> trg a' = n'} \\<subseteq>\n        (Node ` {m'. \\<exists>a'. lift_valid_edge valid_edge sourcenode \n        targetnode kind Entry Exit a' \\<and> src a' = Node m \\<and> trg a' = Node m'}) \\<union>\n        {NewEntry,NewExit}\""], ["proof (prove)\nusing this:\n  n = Node m\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'} \\<union>\n    {NewEntry, NewExit})\n\ngoal (1 subgoal):\n 1. {n'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = n \\<and> trg a' = n'}\n    \\<subseteq> Node `\n                {m'.\n                 \\<exists>a'.\n                    lift_valid_edge valid_edge sourcenode targetnode kind\n                     Entry Exit a' \\<and>\n                    src a' = Node m \\<and> trg a' = Node m'} \\<union>\n                {NewEntry, NewExit}", "by auto (case_tac x,auto)"], ["proof (state)\nthis:\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'}\n  \\<subseteq> Node `\n              {m'.\n               \\<exists>a'.\n                  lift_valid_edge valid_edge sourcenode targetnode kind\n                   Entry Exit a' \\<and>\n                  src a' = Node m \\<and> trg a' = Node m'} \\<union>\n              {NewEntry, NewExit}\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       n = Node x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n             a' \\<and>\n            src a' = n \\<and> trg a' = n'}", "with fin"], ["proof (chain)\npicking this:\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'} \\<union>\n    {NewEntry, NewExit})\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'}\n  \\<subseteq> Node `\n              {m'.\n               \\<exists>a'.\n                  lift_valid_edge valid_edge sourcenode targetnode kind\n                   Entry Exit a' \\<and>\n                  src a' = Node m \\<and> trg a' = Node m'} \\<union>\n              {NewEntry, NewExit}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   (Node `\n    {m'.\n     \\<exists>a'.\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a' \\<and>\n        src a' = Node m \\<and> trg a' = Node m'} \\<union>\n    {NewEntry, NewExit})\n  {n'.\n   \\<exists>a'.\n      lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n       a' \\<and>\n      src a' = n \\<and> trg a' = n'}\n  \\<subseteq> Node `\n              {m'.\n               \\<exists>a'.\n                  lift_valid_edge valid_edge sourcenode targetnode kind\n                   Entry Exit a' \\<and>\n                  src a' = Node m \\<and> trg a' = Node m'} \\<union>\n              {NewEntry, NewExit}\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a' \\<and>\n         src a' = n \\<and> trg a' = n'}", "by -(rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = n \\<and> trg a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = n \\<and> trg a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  StrongPostdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_PDG_wcd:\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (StrongPostdomination.weak_control_dependence sourcenode targetnode \n  valid_edge Exit)\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"PDG src trg knd \n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\n  (StrongPostdomination.weak_control_dependence src trg \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "interpret PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n    \"StrongPostdomination.weak_control_dependence sourcenode targetnode \n                                                           valid_edge Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n     (StrongPostdomination.weak_control_dependence sourcenode targetnode\n       valid_edge Exit)", "by(rule PDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "have wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                            state_val Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf spd inner"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx", "have spd':\"StrongPostdomination src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_StrongPostdomination)"], ["proof (state)\nthis:\n  StrongPostdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG:\"CFG src trg\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry", "by(rule lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFG_wf:\"CFG_wf src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n    (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val", "by(rule lift_CFG_wf)"], ["proof (state)\nthis:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFGExit:\"CFGExit src trg knd \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_CFGExit)"], ["proof (state)\nthis:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "from wf"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit", "have CFGExit_wf:\"CFGExit_wf src trg knd \n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n    (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L) state_val NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit", "by(rule lift_CFGExit_wf)"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg\n       (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n       NewExit)", "proof"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "fix a"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"trg a = NewEntry\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (12 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 10. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n     lift_Use Use Entry Exit H L NewExit = {}\nA total of 12 subgoals...", "with CFG"], ["proof (chain)\npicking this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry", "show False"], ["proof (prove)\nusing this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (1 subgoal):\n 1. False", "by(rule CFG.Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "fix a a'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a = trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 9. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        n' \\<noteq> NewExit\nA total of 11 subgoals...", "with CFG"], ["proof (chain)\npicking this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  CFG src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (1 subgoal):\n 1. a = a'", "by(rule CFG.edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (10 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 8. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        \\<exists>as.\n           CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit)\n            n as n' \\<and>\n           as \\<noteq> []", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 8. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 10. \\<And>n n'.\n        StrongPostdomination.weak_control_dependence src trg\n         (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n         NewExit n n' \\<Longrightarrow>\n        \\<exists>as.\n           CFG.path src trg\n            (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n              Exit)\n            n as n' \\<and>\n           as \\<noteq> []", "from CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val", "show \"lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n          lift_Use Use Entry Exit H L NewEntry = {}\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}", "by(rule CFG_wf.Entry_empty)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n  lift_Use Use Entry Exit H L NewEntry = {}\n\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a V s"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"V \\<notin> lift_Def Def Entry Exit H L (src a)\" and \"pred (knd a) s\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (9 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a);\n        pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (knd a) s) V = state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 7. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 9. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s", "show \"state_val (transfer (knd a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  pred (knd a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (knd a) s) V = state_val s V", "by(rule CFG_wf.CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (knd a) s) V = state_val s V\n\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a s s'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume assms:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\"\n      \"pred (knd a) s\" \"pred (knd a) s'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n\ngoal (8 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V;\n        pred (knd a) s; pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            state_val (transfer (knd a) s) V =\n                            state_val (transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 8. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'", "show \"\\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n             state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n  pred (knd a) s\n  pred (knd a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n       state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V", "by(rule CFG_wf.CFG_edge_transfer_uses_only_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n     state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a s s'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"pred (knd a) s\" \n      and \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        pred (knd a) s;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> pred (knd a) s'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 7. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V", "show \"pred (knd a) s'\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  pred (knd a) s\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. pred (knd a) s'", "by(rule CFG_wf.CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (knd a) s'\n\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a a'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a \\<noteq> trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (6 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 4. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 6. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFG_wf"], ["proof (chain)\npicking this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'", "show \"\\<exists>Q Q'. knd a = (Q)\\<^sub>\\<surd> \\<and> knd a' = (Q')\\<^sub>\\<surd> \\<and> \n                             (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\nusing this:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd a = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(rule CFG_wf.deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd a = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix a"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"src a = NewExit\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (5 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 3. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 5. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "with CFGExit"], ["proof (chain)\npicking this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit", "show False"], ["proof (prove)\nusing this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(rule CFGExit.Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 3. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 3. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 4. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "from CFGExit"], ["proof (chain)\npicking this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit", "show \"\\<exists>a. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a \\<and>\n              src a = NewEntry \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule CFGExit.Entry_Exit_edge)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a \\<and>\n     src a = NewEntry \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 3. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 3. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "from CFGExit_wf"], ["proof (chain)\npicking this:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit", "show \"lift_Def Def Entry Exit H L NewExit = {} \\<and>\n          lift_Use Use Entry Exit H L NewExit = {}\""], ["proof (prove)\nusing this:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "by(rule CFGExit_wf.Exit_empty)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewExit = {} \\<and>\n  lift_Use Use Entry Exit H L NewExit = {}\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume wcd:\"StrongPostdomination.weak_control_dependence src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n n'\""], ["proof (state)\nthis:\n  StrongPostdomination.weak_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       n' \\<noteq> NewExit\n 2. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "show \"n' \\<noteq> NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<noteq> NewExit", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "assume \"\\<not> n' \\<noteq> NewExit\""], ["proof (state)\nthis:\n  \\<not> n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "hence \"n' = NewExit\""], ["proof (prove)\nusing this:\n  \\<not> n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. n' = NewExit", "by simp"], ["proof (state)\nthis:\n  n' = NewExit\n\ngoal (1 subgoal):\n 1. \\<not> n' \\<noteq> NewExit \\<Longrightarrow> False", "with wcd spd'"], ["proof (chain)\npicking this:\n  StrongPostdomination.weak_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n  StrongPostdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  n' = NewExit", "show False"], ["proof (prove)\nusing this:\n  StrongPostdomination.weak_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n  StrongPostdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n  n' = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro:StrongPostdomination.Exit_not_weak_control_dependent)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n' \\<noteq> NewExit\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "assume \"StrongPostdomination.weak_control_dependence src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n n'\""], ["proof (state)\nthis:\n  StrongPostdomination.weak_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       StrongPostdomination.weak_control_dependence src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewExit n n' \\<Longrightarrow>\n       \\<exists>as.\n          CFG.path src trg\n           (lift_valid_edge valid_edge sourcenode targetnode kind Entry\n             Exit)\n           n as n' \\<and>\n          as \\<noteq> []", "thus \"\\<exists>as. CFG.path src trg\n               (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n               n as n' \\<and> as \\<noteq> []\""], ["proof (prove)\nusing this:\n  StrongPostdomination.weak_control_dependence src trg\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewExit n n'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\n        as n' \\<and>\n       as \\<noteq> []", "by(fastforce simp:StrongPostdomination.weak_control_dependence_def[OF spd'])"], ["proof (state)\nthis:\n  \\<exists>as.\n     CFG.path src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\n      as n' \\<and>\n     as \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PDG src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   state_val NewExit\n   (StrongPostdomination.weak_control_dependence src trg\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewExit)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_PDG_weak_backward_slice:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and Def and Use and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  assumes PDG:\"PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit \n  (StrongPostdomination.weak_control_dependence sourcenode targetnode \n  valid_edge Exit)\"\n  and spd:\"StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val \n         (PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n         NewExit H L (Node Entry) (Node Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "interpret PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n    \"StrongPostdomination.weak_control_dependence sourcenode targetnode \n                                                           valid_edge Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n     (StrongPostdomination.weak_control_dependence sourcenode targetnode\n       valid_edge Exit)", "by(rule PDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "have wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use\n                            state_val Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n     Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "interpret wf':CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit", "by(fastforce intro:lift_CFGExit_wf wf simp:lve lDef lUse)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from PDG spd inner lve lDef lUse"], ["proof (chain)\npicking this:\n  PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n   (StrongPostdomination.weak_control_dependence sourcenode targetnode\n     valid_edge Exit)\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have PDG':\"PDG src trg knd \n    lve NewEntry lDef lUse state_val NewExit\n    (StrongPostdomination.weak_control_dependence src trg lve NewExit)\""], ["proof (prove)\nusing this:\n  PDG sourcenode targetnode kind valid_edge Entry Def Use state_val Exit\n   (StrongPostdomination.weak_control_dependence sourcenode targetnode\n     valid_edge Exit)\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg lve NewExit)", "by(fastforce intro:lift_PDG_wcd)"], ["proof (state)\nthis:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (StrongPostdomination.weak_control_dependence src trg lve NewExit)\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf spd inner"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx", "have spd':\"StrongPostdomination src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) \n    NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  StrongPostdomination sourcenode targetnode kind valid_edge Entry Exit\n  inner_node nx\n\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry NewExit", "by(rule lift_StrongPostdomination)"], ["proof (state)\nthis:\n  StrongPostdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "have CFG:\"CFG src trg lve NewEntry\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. CFG src trg lve NewEntry", "by(fastforce intro:lift_CFG)"], ["proof (state)\nthis:\n  CFG src trg lve NewEntry\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve lDef lUse"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have CFG_wf:\"CFG_wf src trg knd lve NewEntry lDef lUse state_val\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. CFG_wf src trg knd lve NewEntry lDef lUse state_val", "by(fastforce intro:lift_CFG_wf)"], ["proof (state)\nthis:\n  CFG_wf src trg knd lve NewEntry lDef lUse state_val\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "have CFGExit:\"CFGExit src trg knd lve NewEntry NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. CFGExit src trg knd lve NewEntry NewExit", "by(fastforce intro:lift_CFGExit)"], ["proof (state)\nthis:\n  CFGExit src trg knd lve NewEntry NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "from wf lve lDef lUse"], ["proof (chain)\npicking this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "have CFGExit_wf:\"CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit\""], ["proof (prove)\nusing this:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry Def Use state_val\n   Exit\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit", "by(fastforce intro:lift_CFGExit_wf)"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd lve NewEntry lDef lUse state_val NewExit\n\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n     (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n     NewExit H L (Node Entry) (Node Exit)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (StrongPostdomination.weak_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix n S"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (StrongPostdomination.weak_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (StrongPostdomination.weak_control_dependence src trg lve NewExit) S\""], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve\n             NewExit)\n           S\n\ngoal (16 subgoals):\n 1. \\<And>n S.\n       n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                (StrongPostdomination.weak_control_dependence src trg lve\n                  NewExit)\n                S \\<Longrightarrow>\n       wf'.valid_node n\n 2. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 4. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 5. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 9. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 10. \\<exists>a.\n        lve a \\<and>\n        src a = Node Exit \\<and>\n        trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\nA total of 16 subgoals...", "with PDG'"], ["proof (chain)\npicking this:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (StrongPostdomination.weak_control_dependence src trg lve NewExit)\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve\n             NewExit)\n           S", "show \"CFG.valid_node src trg lve n\""], ["proof (prove)\nusing this:\n  PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n   (StrongPostdomination.weak_control_dependence src trg lve NewExit)\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve\n             NewExit)\n           S\n\ngoal (1 subgoal):\n 1. wf'.valid_node n", "by(rule PDG.PDG_BS_valid_node)"], ["proof (state)\nthis:\n  wf'.valid_node n\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "fix n S"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "assume \"CFG.valid_node src trg lve n\" and \"n \\<in> S\""], ["proof (state)\nthis:\n  wf'.valid_node n\n  n \\<in> S\n\ngoal (15 subgoals):\n 1. \\<And>n S.\n       \\<lbrakk>wf'.valid_node n; n \\<in> S\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 3. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 4. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 8. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 9. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 10. \\<And>a.\n        \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n        \\<Longrightarrow> trg a = NewExit\nA total of 15 subgoals...", "thus \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (StrongPostdomination.weak_control_dependence src trg lve NewExit) S\""], ["proof (prove)\nusing this:\n  wf'.valid_node n\n  n \\<in> S\n\ngoal (1 subgoal):\n 1. n \\<in> PDG.PDG_BS src trg lve lDef lUse\n             (StrongPostdomination.weak_control_dependence src trg lve\n               NewExit)\n             S", "by(fastforce intro:PDG.PDG_path_Nil[OF PDG'] simp:PDG.PDG_BS_def[OF PDG'])"], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve\n             NewExit)\n           S\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "fix n' S n V"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "assume \"n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (StrongPostdomination.weak_control_dependence src trg lve NewExit) S\"\n      and \"CFG_wf.data_dependence src trg lve lDef lUse n V n'\""], ["proof (state)\nthis:\n  n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S\n  wf'.data_dependence n V n'\n\ngoal (14 subgoals):\n 1. \\<And>n' S n V.\n       \\<lbrakk>n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n                          (StrongPostdomination.weak_control_dependence src\n                            trg lve NewExit)\n                          S;\n        wf'.data_dependence n V n'\\<rbrakk>\n       \\<Longrightarrow> n \\<in> PDG.PDG_BS src trg lve lDef lUse\n                                  (StrongPostdomination.weak_control_dependence\n                                    src trg lve NewExit)\n                                  S\n 2. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 3. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 7. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 8. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 9. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 10. lDef (Node Entry) = H\nA total of 14 subgoals...", "thus \"n \\<in> PDG.PDG_BS src trg lve lDef lUse\n      (StrongPostdomination.weak_control_dependence src trg lve NewExit) S\""], ["proof (prove)\nusing this:\n  n' \\<in> PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S\n  wf'.data_dependence n V n'\n\ngoal (1 subgoal):\n 1. n \\<in> PDG.PDG_BS src trg lve lDef lUse\n             (StrongPostdomination.weak_control_dependence src trg lve\n               NewExit)\n             S", "by(fastforce intro:PDG.PDG_path_Append[OF PDG'] PDG.PDG_path_ddep[OF PDG']\n                        PDG.PDG_ddep_edge[OF PDG'] simp:PDG.PDG_BS_def[OF PDG']\n                  split:if_split_asm)"], ["proof (state)\nthis:\n  n \\<in> PDG.PDG_BS src trg lve lDef lUse\n           (StrongPostdomination.weak_control_dependence src trg lve\n             NewExit)\n           S\n\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "fix n S"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S.\n       finite\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n 2. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "interpret PDGx:PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n      \"StrongPostdomination.weak_control_dependence src trg lve NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg lve NewExit)", "by(rule PDG')"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "interpret spdx:StrongPostdomination src trg knd lve NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd lve NewEntry NewExit", "by(fastforce intro:spd' simp:lve)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "have wcd:\"WeakControlDependencePDG src trg knd lve NewEntry\n      lDef lUse state_val NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WeakControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n     NewExit", "by(unfold_locales)"], ["proof (state)\nthis:\n  WeakControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n   NewExit\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "from WeakControlDependencePDG.obs_singleton[OF wcd]"], ["proof (chain)\npicking this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit ?S) =\n  {}", "have \"(\\<exists>m. CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit) S) = {m}) \\<or>\n      CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (StrongPostdomination.weak_control_dependence src trg lve NewExit) S) = {}\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit ?S) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n    wf'.obs n (PDGx.PDG_BS S) = {}", "by(fastforce simp:WeakControlDependencePDG.PDG_BS_w_def[OF wcd])"], ["proof (state)\nthis:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (13 subgoals):\n 1. \\<And>n S. finite (wf'.obs n (PDGx.PDG_BS S))\n 2. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 6. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 7. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 8. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 9. lDef (Node Entry) = H\n 10. lUse (Node Entry) = H\nA total of 13 subgoals...", "thus \"finite (CFG.obs src trg lve n\n        (PDG.PDG_BS src trg lve lDef lUse\n          (StrongPostdomination.weak_control_dependence src trg lve NewExit) S))\""], ["proof (prove)\nusing this:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (1 subgoal):\n 1. finite (wf'.obs n (PDGx.PDG_BS S))", "by fastforce"], ["proof (state)\nthis:\n  finite (wf'.obs n (PDGx.PDG_BS S))\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "fix n S"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S.\n       card\n        (wf'.obs n\n          (PDG.PDG_BS src trg lve lDef lUse\n            (StrongPostdomination.weak_control_dependence src trg lve\n              NewExit)\n            S))\n       \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "interpret PDGx:PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n      \"StrongPostdomination.weak_control_dependence src trg lve NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PDG src trg knd lve NewEntry lDef lUse state_val NewExit\n     (StrongPostdomination.weak_control_dependence src trg lve NewExit)", "by(rule PDG')"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "interpret spdx:StrongPostdomination src trg knd lve NewEntry NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination src trg knd lve NewEntry NewExit", "by(fastforce intro:spd' simp:lve)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "have wcd:\"WeakControlDependencePDG src trg knd lve NewEntry\n      lDef lUse state_val NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WeakControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n     NewExit", "by(unfold_locales)"], ["proof (state)\nthis:\n  WeakControlDependencePDG src trg knd lve NewEntry lDef lUse state_val\n   NewExit\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "from WeakControlDependencePDG.obs_singleton[OF wcd]"], ["proof (chain)\npicking this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit ?S) =\n  {}", "have \"(\\<exists>m. CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n       (StrongPostdomination.weak_control_dependence src trg lve NewExit) S) = {m}) \\<or>\n      CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (StrongPostdomination.weak_control_dependence src trg lve NewExit) S) = {}\""], ["proof (prove)\nusing this:\n  (\\<exists>m.\n      wf'.obs ?n\n       (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit\n         ?S) =\n      {m}) \\<or>\n  wf'.obs ?n\n   (WeakControlDependencePDG.PDG_BS_w src trg lve lDef lUse NewExit ?S) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n    wf'.obs n (PDGx.PDG_BS S) = {}", "by(fastforce simp:WeakControlDependencePDG.PDG_BS_w_def[OF wcd])"], ["proof (state)\nthis:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (12 subgoals):\n 1. \\<And>n S. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 5. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 6. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 7. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 8. lDef (Node Entry) = H\n 9. lUse (Node Entry) = H\n 10. lUse (Node Exit) = L\nA total of 12 subgoals...", "thus \"card (CFG.obs src trg lve n\n      (PDG.PDG_BS src trg lve lDef lUse\n        (StrongPostdomination.weak_control_dependence src trg lve NewExit) S)) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<exists>m. wf'.obs n (PDGx.PDG_BS S) = {m}) \\<or>\n  wf'.obs n (PDGx.PDG_BS S) = {}\n\ngoal (1 subgoal):\n 1. card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  card (wf'.obs n (PDGx.PDG_BS S)) \\<le> 1\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "fix a"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "assume \"lve a\" and \"src a = NewEntry\""], ["proof (state)\nthis:\n  lve a\n  src a = NewEntry\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry", "show \"trg a = NewExit \\<or> trg a = Node Entry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = NewEntry\n\ngoal (1 subgoal):\n 1. trg a = NewExit \\<or> trg a = Node Entry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit \\<or> trg a = Node Entry\n\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "from lve_Entry_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = NewEntry \\<and> trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node ?E) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = NewEntry \\<and>\n     trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = Node Entry\""], ["proof (state)\nthis:\n  lve a\n  trg a = Node Entry\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry", "show \"src a = NewEntry\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = Node Entry\n\ngoal (1 subgoal):\n 1. src a = NewEntry", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = NewExit\""], ["proof (state)\nthis:\n  lve a\n  trg a = NewExit\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit", "show \"src a = NewEntry \\<or> src a = Node Exit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  trg a = NewExit\n\ngoal (1 subgoal):\n 1. src a = NewEntry \\<or> src a = Node Exit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  src a = NewEntry \\<or> src a = Node Exit\n\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "from lve_Exit_edge lve"], ["proof (chain)\npicking this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit", "show \"\\<exists>a. lve a \\<and> src a = Node Exit \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  ?e =\n  (Node ?X, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit) \\<Longrightarrow>\n  lift_valid_edge ?valid_edge ?src ?trg ?knd ?E ?X ?e\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:knd_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = Node Exit \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "assume \"lve a\" and \"src a = Node Exit\""], ["proof (state)\nthis:\n  lve a\n  src a = Node Exit\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "with lve"], ["proof (chain)\npicking this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit", "show \"trg a = NewExit\""], ["proof (prove)\nusing this:\n  lve \\<equiv>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n  lve a\n  src a = Node Exit\n\ngoal (1 subgoal):\n 1. trg a = NewExit", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  trg a = NewExit\n\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "from lDef"], ["proof (chain)\npicking this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L", "show \"lDef (Node Entry) = H\""], ["proof (prove)\nusing this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n\ngoal (1 subgoal):\n 1. lDef (Node Entry) = H", "by(fastforce elim:lift_Def_set.cases intro:lift_Def_High)"], ["proof (state)\nthis:\n  lDef (Node Entry) = H\n\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Entry) = H\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Entry) = H", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_High)"], ["proof (state)\nthis:\n  lUse (Node Entry) = H\n\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Exit) = L\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Exit) = L", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_Low)"], ["proof (state)\nthis:\n  lUse (Node Exit) = L\n\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "from \\<open>H \\<inter> L = {}\\<close>"], ["proof (chain)\npicking this:\n  H \\<inter> L = {}", "show \"H \\<inter> L = {}\""], ["proof (prove)\nusing this:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<inter> L = {}", "."], ["proof (state)\nthis:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "from \\<open>H \\<union> L = UNIV\\<close>"], ["proof (chain)\npicking this:\n  H \\<union> L = UNIV", "show \"H \\<union> L = UNIV\""], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "."], ["proof (state)\nthis:\n  H \\<union> L = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceIntraGraph src trg knd lve NewEntry lDef lUse state_val\n   (PDG.PDG_BS src trg lve lDef lUse\n     (StrongPostdomination.weak_control_dependence src trg lve NewExit))\n   NewExit H L (Node Entry) (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}