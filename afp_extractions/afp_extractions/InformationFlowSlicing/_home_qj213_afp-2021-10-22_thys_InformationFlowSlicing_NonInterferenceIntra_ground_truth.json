{"file_name": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing/NonInterferenceIntra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing", "problem_names": ["lemma Low_neq_Exit: assumes \"L \\<noteq> {}\" shows \"(_Low_) \\<noteq> (_Exit_)\"", "lemma Entry_path_High_path:\n  assumes \"(_Entry_) -as\\<rightarrow>* n\" and \"inner_node n\"\n  obtains a' as' where \"as = a'#as'\" and \"(_High_) -as'\\<rightarrow>* n\" \n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma Exit_path_Low_path:\n  assumes \"n -as\\<rightarrow>* (_Exit_)\" and \"inner_node n\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* (_Low_)\"\n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma not_Low_High: \"V \\<notin> L \\<Longrightarrow> V \\<in> H\"", "lemma not_High_Low: \"V \\<notin> H \\<Longrightarrow> V \\<in> L\"", "lemma relevant_vars_Entry:\n  assumes \"V \\<in> rv S (_Entry_)\" and \"(_High_) \\<notin> backward_slice S\"\n  shows \"V \\<in> L\"", "lemma lowEquivalence_relevant_nodes_Entry:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\"\n  shows \"\\<forall>V \\<in> rv S (_Entry_). state_val s V = state_val s' V\"", "lemma rv_Low_Use_Low:\n  assumes \"(_Low_) \\<in> S\"\n  shows \"\\<lbrakk>n -as\\<rightarrow>* (_Low_); n -as'\\<rightarrow>* (_Low_);\n    \\<forall>V \\<in> rv S n. state_val s V = state_val s' V;\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V \\<in> Use (_Low_). state_val (transfers (slice_kinds S as) s) V =\n                       state_val (transfers (slice_kinds S as') s') V\"", "lemma nonInterference_path_to_Low:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>* (_Low_)\" and \"preds (kinds as) s\"\n  and \"(_Entry_) -as'\\<rightarrow>* (_Low_)\" and \"preds (kinds as') s'\"\n  shows \"transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\"", "theorem nonInterference_path:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>* (_Exit_)\" and \"preds (kinds as) s\"\n  and \"(_Entry_) -as'\\<rightarrow>* (_Exit_)\" and \"preds (kinds as') s'\"\n  shows \"transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\"", "theorem nonInterference:\n  assumes \"s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"valid_edge a\" and \"sourcenode a = (_High_)\" and \"targetnode a = n\" \n  and \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\" and \"n \\<triangleq> c\" and \"final c'\"\n  and \"\\<langle>c,s\\<^sub>1\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1'\\<rangle>\" and \"\\<langle>c,s\\<^sub>2\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2'\\<rangle>\"\n  shows \"s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'\""], "translations": [["", "lemma Low_neq_Exit: assumes \"L \\<noteq> {}\" shows \"(_Low_) \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Low_) \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "assume \"(_Low_) = (_Exit_)\""], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "have \"Use (_Exit_) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Use (_Exit_) = {}", "by fastforce"], ["proof (state)\nthis:\n  Use (_Exit_) = {}\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "with UseLow \\<open>L \\<noteq> {}\\<close> \\<open>(_Low_) = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n  Use (_Exit_) = {}", "show False"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n  Use (_Exit_) = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Entry_path_High_path:\n  assumes \"(_Entry_) -as\\<rightarrow>* n\" and \"inner_node n\"\n  obtains a' as' where \"as = a'#as'\" and \"(_High_) -as'\\<rightarrow>* n\" \n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; (_High_) -as'\\<rightarrow>* n;\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>(_Entry_) -as\\<rightarrow>* n\\<close> \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n\n  inner_node n", "show \"\\<exists>a' as'. as = a'#as' \\<and> (_High_) -as'\\<rightarrow>* n \\<and> kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n\n  inner_node n\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof(induct n'\\<equiv>\"(_Entry_)\" as n rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case (Cons_path n'' as n' a)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a' as'.\n                       as = a' # as' \\<and>\n                       (_High_) -as'\\<rightarrow>* n' \\<and>\n                       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  inner_node n'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n'' -as\\<rightarrow>* n'\\<close> \\<open>inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  inner_node n'", "have \"n'' \\<noteq> (_Exit_)\""], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  inner_node n'\n\ngoal (1 subgoal):\n 1. n'' \\<noteq> (_Exit_)", "by(fastforce simp:inner_node_def)"], ["proof (state)\nthis:\n  n'' \\<noteq> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>targetnode a = n''\\<close> \\<open>sourcenode a = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = n''\n  sourcenode a = (_Entry_)\n  n'' \\<noteq> (_Exit_)", "have \"n'' = (_High_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = n''\n  sourcenode a = (_Entry_)\n  n'' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. n'' = (_High_)", "by -(drule Entry_edge_Exit_or_High,auto)"], ["proof (state)\nthis:\n  n'' = (_High_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from High_target_Entry_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\" and \"sourcenode a' = (_Entry_)\"\n      and \"targetnode a' = (_High_)\" and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Entry_);\n         targetnode a' = (_High_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_Entry_)\\<close> \\<open>targetnode a = n''\\<close>\n      \\<open>n'' = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' = (_High_)\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' = (_High_)\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a = a'", "by(auto dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n'' -as\\<rightarrow>* n'\\<close> \\<open>n'' = (_High_)\\<close> \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'", "show ?case"], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       a # as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n' \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     a # as = a' # as' \\<and>\n     (_High_) -as'\\<rightarrow>* n' \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "qed fastforce"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     as = a' # as' \\<and>\n     (_High_) -as'\\<rightarrow>* n \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_path_Low_path:\n  assumes \"n -as\\<rightarrow>* (_Exit_)\" and \"inner_node n\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* (_Low_)\"\n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a']; n -as'\\<rightarrow>* (_Low_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* (_Exit_)", "show \"\\<exists>as' a'. as = as'@[a'] \\<and> n -as'\\<rightarrow>* (_Low_) \\<and> kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof(induct as rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. n -[]\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n    \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* (_Exit_)\n\ngoal (2 subgoals):\n 1. n -[]\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n    \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n -[]\\<rightarrow>* (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  inner_node n\n  n -[]\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     [] = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case (snoc a' as')"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n  \\<exists>as'a a'.\n     as' = as'a @ [a'] \\<and>\n     n -as'a\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  n -as' @ [a']\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n -as'@[a']\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as' @ [a']\\<rightarrow>* (_Exit_)", "have \"n -as'\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' = (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as' @ [a']\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' = (_Exit_)", "by(auto elim:path_split_snoc)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "{"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "assume \"sourcenode a' = (_Entry_)\""], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Entry_)", "have \"n = (_Entry_)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. n = (_Entry_)", "by(blast intro!:path_Entry_target)"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:inner_node_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "}"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a'\\<close> \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False", "have \"sourcenode a' = (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Low_)", "by(blast dest!:Exit_edge_Entry_or_Low)"], ["proof (state)\nthis:\n  sourcenode a' = (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain ax where \"valid_edge ax\" and \"sourcenode ax = (_Low_)\"\n      and \"targetnode ax = (_Exit_)\" and \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = (_Low_);\n         targetnode ax = (_Exit_);\n         kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a'\\<close> \\<open>targetnode a' = (_Exit_)\\<close> \\<open>sourcenode a' = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Low_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"a' = ax\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Low_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a' = ax", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = ax\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a' = ax", "show ?case"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a' = ax\n\ngoal (1 subgoal):\n 1. \\<exists>as'a a'a.\n       as' @ [a'] = as'a @ [a'a] \\<and>\n       n -as'a\\<rightarrow>* (_Low_) \\<and>\n       kind a'a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'a a'a.\n     as' @ [a'] = as'a @ [a'a] \\<and>\n     n -as'a\\<rightarrow>* (_Low_) \\<and>\n     kind a'a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     as = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_Low_High: \"V \\<notin> L \\<Longrightarrow> V \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<notin> L \\<Longrightarrow> V \\<in> H", "using HighLowUNIV"], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. V \\<notin> L \\<Longrightarrow> V \\<in> H", "by fastforce"], ["", "lemma not_High_Low: \"V \\<notin> H \\<Longrightarrow> V \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<notin> H \\<Longrightarrow> V \\<in> L", "using HighLowUNIV"], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. V \\<notin> H \\<Longrightarrow> V \\<in> L", "by fastforce"], ["", "subsection \\<open>Low Equivalence\\<close>"], ["", "text \\<open>\nIn classical noninterference, an external observer can only see public values,\nin our case the \\<open>L\\<close>-variables. If two states agree in the values of all \n\\<open>L\\<close>-variables, these states are indistinguishable for him. \n\\emph{Low equivalence} groups those states in an equivalence class using \nthe relation \\<open>\\<approx>\\<^sub>L\\<close>:\n\\<close>"], ["", "definition lowEquivalence :: \"'state \\<Rightarrow> 'state \\<Rightarrow> bool\" (infixl \"\\<approx>\\<^sub>L\" 50)\n  where \"s \\<approx>\\<^sub>L s' \\<equiv> \\<forall>V \\<in> L. state_val s V = state_val s' V\""], ["", "text \\<open>The following lemmas connect low equivalent states with\nrelevant variables as necessary in the correctness proof for slicing.\\<close>"], ["", "lemma relevant_vars_Entry:\n  assumes \"V \\<in> rv S (_Entry_)\" and \"(_High_) \\<notin> backward_slice S\"\n  shows \"V \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<in> L", "from \\<open>V \\<in> rv S (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (_Entry_)", "obtain as n' where \"(_Entry_) -as\\<rightarrow>* n'\"\n    and \"n' \\<in> backward_slice S\" and \"V \\<in> Use n'\"\n    and \"\\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (_Entry_)\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>(_Entry_) -as\\<rightarrow>* n'; n' \\<in> backward_slice S;\n         V \\<in> Use n';\n         \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  V \\<in> Use n'\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. V \\<in> L", "from \\<open>(_Entry_) -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n'", "have \"valid_node n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_node n'", "by(rule path_valid_node)"], ["proof (state)\nthis:\n  valid_node n'\n\ngoal (1 subgoal):\n 1. V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node n'\n\ngoal (1 subgoal):\n 1. V \\<in> L", "proof(cases n' rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node n' \\<Longrightarrow> V \\<in> L", "case Entry"], ["proof (state)\nthis:\n  n' = (_Entry_)\n\ngoal (3 subgoals):\n 1. n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node n' \\<Longrightarrow> V \\<in> L", "with \\<open>V \\<in> Use n'\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use n'\n  n' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> Use n'\n  n' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:Entry_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node n' \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node n' \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node n' \\<Longrightarrow> V \\<in> L", "case Exit"], ["proof (state)\nthis:\n  n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node n' \\<Longrightarrow> V \\<in> L", "with \\<open>V \\<in> Use n'\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use n'\n  n' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> Use n'\n  n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:Exit_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node n' \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. inner_node n' \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node n' \\<Longrightarrow> V \\<in> L", "case inner"], ["proof (state)\nthis:\n  inner_node n'\n\ngoal (1 subgoal):\n 1. inner_node n' \\<Longrightarrow> V \\<in> L", "with \\<open>(_Entry_) -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n'\n  inner_node n'", "obtain a' as' where \"as = a'#as'\"\n      and \"(_High_) -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n'\n  inner_node n'\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; (_High_) -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule Entry_path_High_path)"], ["proof (state)\nthis:\n  as = a' # as'\n  (_High_) -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. inner_node n' \\<Longrightarrow> V \\<in> L", "from \\<open>(_Entry_) -as\\<rightarrow>* n'\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n'\n  as = a' # as'", "have \"sourcenode a' = (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Entry_)", "by(fastforce elim:path.cases)"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. inner_node n' \\<Longrightarrow> V \\<in> L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> L", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>(_High_) -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -as'\\<rightarrow>* n'\n  as' = []", "have \"n' = (_High_)\""], ["proof (prove)\nusing this:\n  (_High_) -as'\\<rightarrow>* n'\n  as' = []\n\ngoal (1 subgoal):\n 1. n' = (_High_)", "by fastforce"], ["proof (state)\nthis:\n  n' = (_High_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>n' \\<in> backward_slice S\\<close> \\<open>(_High_) \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> backward_slice S\n  (_High_) \\<notin> backward_slice S\n  n' = (_High_)", "have False"], ["proof (prove)\nusing this:\n  n' \\<in> backward_slice S\n  (_High_) \\<notin> backward_slice S\n  n' = (_High_)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>(_High_) -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -as'\\<rightarrow>* n'\n  as' \\<noteq> []", "have \"hd (sourcenodes as') = (_High_)\""], ["proof (prove)\nusing this:\n  (_High_) -as'\\<rightarrow>* n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') = (_High_)", "by(rule path_sourcenode)"], ["proof (state)\nthis:\n  hd (sourcenodes as') = (_High_)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "from False"], ["proof (chain)\npicking this:\n  as' \\<noteq> []", "have \"hd (sourcenodes as') \\<in> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') \\<in> set (sourcenodes as')", "by(fastforce intro:hd_in_set simp:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as') \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  hd (sourcenodes as') \\<in> set (sourcenodes as')", "have \"hd (sourcenodes as') \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  hd (sourcenodes as') \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as') \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>hd (sourcenodes as') = (_High_)\\<close> \\<open>\\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\\<close>"], ["proof (chain)\npicking this:\n  hd (sourcenodes as') = (_High_)\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\n  hd (sourcenodes as') \\<in> set (sourcenodes as)", "have \"V \\<notin> Def (_High_)\""], ["proof (prove)\nusing this:\n  hd (sourcenodes as') = (_High_)\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\n  hd (sourcenodes as') \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (_High_)", "by fastforce"], ["proof (state)\nthis:\n  V \\<notin> Def (_High_)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "hence \"V \\<notin> H\""], ["proof (prove)\nusing this:\n  V \\<notin> Def (_High_)\n\ngoal (1 subgoal):\n 1. V \\<notin> H", "by(simp add:DefHigh)"], ["proof (state)\nthis:\n  V \\<notin> H\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  V \\<notin> H\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by(rule not_High_Low)"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowEquivalence_relevant_nodes_Entry:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\"\n  shows \"\\<forall>V \\<in> rv S (_Entry_). state_val s V = state_val s' V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (_Entry_). state_val s V = state_val s' V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (_Entry_) \\<Longrightarrow>\n       state_val s V = state_val s' V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (_Entry_) \\<Longrightarrow>\n       state_val s V = state_val s' V", "assume \"V \\<in> rv S (_Entry_)\""], ["proof (state)\nthis:\n  V \\<in> rv S (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (_Entry_) \\<Longrightarrow>\n       state_val s V = state_val s' V", "with \\<open>(_High_) \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  (_High_) \\<notin> backward_slice S\n  V \\<in> rv S (_Entry_)", "have \"V \\<in> L\""], ["proof (prove)\nusing this:\n  (_High_) \\<notin> backward_slice S\n  V \\<in> rv S (_Entry_)\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by -(rule relevant_vars_Entry)"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (_Entry_) \\<Longrightarrow>\n       state_val s V = state_val s' V", "with \\<open>s \\<approx>\\<^sub>L s'\\<close>"], ["proof (chain)\npicking this:\n  s \\<approx>\\<^sub>L s'\n  V \\<in> L", "show \"state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  s \\<approx>\\<^sub>L s'\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. state_val s V = state_val s' V", "by(simp add:lowEquivalence_def)"], ["proof (state)\nthis:\n  state_val s V = state_val s' V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_Low_Use_Low:\n  assumes \"(_Low_) \\<in> S\"\n  shows \"\\<lbrakk>n -as\\<rightarrow>* (_Low_); n -as'\\<rightarrow>* (_Low_);\n    \\<forall>V \\<in> rv S n. state_val s V = state_val s' V;\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V \\<in> Use (_Low_). state_val (transfers (slice_kinds S as) s) V =\n                       state_val (transfers (slice_kinds S as') s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* (_Low_); n -as'\\<rightarrow>* (_Low_);\n     \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n     preds (slice_kinds S as) s; preds (slice_kinds S as') s'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                         state_val (transfers (slice_kinds S as) s) V =\n                         state_val (transfers (slice_kinds S as') s') V", "proof(induct n as n\\<equiv>\"(_Low_)\" arbitrary:as' s s' rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case empty_path"], ["proof (state)\nthis:\n  valid_node (_Low_)\n  (_Low_) -as'\\<rightarrow>* (_Low_)\n  \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V\n  preds (slice_kinds S []) s\n  preds (slice_kinds S as') s'\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  valid_node (_Low_)\n  (_Low_) -as'\\<rightarrow>* (_Low_)\n  \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V\n  preds (slice_kinds S []) s\n  preds (slice_kinds S as') s'\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "fix V"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "assume \"V \\<in> Use (_Low_)\""], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_node (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_node (_Low_)", "have \"(_Low_) -[]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_node (_Low_)\n\ngoal (1 subgoal):\n 1. (_Low_) -[]\\<rightarrow>* (_Low_)", "by(fastforce intro:path.empty_path)"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>* (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>* (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_node (_Low_)\\<close> \\<open>(_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node (_Low_)\n  (_Low_) \\<in> S", "have \"(_Low_) \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  valid_node (_Low_)\n  (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. (_Low_) \\<in> backward_slice S", "by(fastforce intro:refl)"], ["proof (state)\nthis:\n  (_Low_) \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "ultimately"], ["proof (chain)\npicking this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>* (_Low_)\n  (_Low_) \\<in> backward_slice S", "have \"V \\<in> rv S (_Low_)\""], ["proof (prove)\nusing this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>* (_Low_)\n  (_Low_) \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (_Low_)", "by(fastforce intro:rvI simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "hence \"\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (_Low_)\""], ["proof (prove)\nusing this:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (_Low_)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (_Low_)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>as' s s'.\n       \\<lbrakk>valid_node (_Low_); (_Low_) -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>(_Low_) -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  (_Low_) -as'\\<rightarrow>* (_Low_)", "have \"as' = []\""], ["proof (prove)\nusing this:\n  (_Low_) -as'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. as' = []", "proof(induct n\\<equiv>\"(_Low_)\" as' n'\\<equiv>\"(_Low_)\" rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Low_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case (Cons_path n'' as a)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* (_Low_)\n  n'' = (_Low_) \\<Longrightarrow> as = []\n  valid_edge a\n  sourcenode a = (_Low_)\n  targetnode a = n''\n\ngoal (2 subgoals):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Low_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Low_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with \\<open>targetnode a = n''\\<close> \\<open>n'' -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n''\n  n'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = n''\n  n'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(rule path_Exit_source,fastforce)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Low_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = (_Low_); targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = []", "by simp"], ["proof (state)\nthis:\n  a # as = []\n\ngoal (1 subgoal):\n 1. valid_node (_Low_) \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  as' = []\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (_Low_)\\<close> \n      \\<open>\\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (_Low_)\n  \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V\n  as' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (_Low_)\n  \\<forall>V\\<in>rv S (_Low_). state_val s V = state_val s' V\n  as' = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case (Cons_path n'' as a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* (_Low_)\n  \\<lbrakk>n'' -?as'\\<rightarrow>* (_Low_);\n   \\<forall>V\\<in>rv S n''. state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n -as'\\<rightarrow>* (_Low_)\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note IH = \\<open>\\<And>as' s s'. \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n    \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n   preds (slice_kinds S as) s; preds (slice_kinds S as') s'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_). state_val (transfers (slice_kinds S as) s) V =\n                     state_val (transfers (slice_kinds S as') s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' -?as'\\<rightarrow>* (_Low_);\n   \\<forall>V\\<in>rv S n''. state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* (_Low_);\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V;\n            preds (slice_kinds S as) s;\n            preds (slice_kinds S as') s'\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* (_Low_);\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s;\n        preds (slice_kinds S as') s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>n -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* (_Low_)\n  as' = []", "have \"n = (_Low_)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* (_Low_)\n  as' = []\n\ngoal (1 subgoal):\n 1. n = (_Low_)", "by fastforce"], ["proof (state)\nthis:\n  n = (_Low_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  n = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  n = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain ax where \"valid_edge ax\"\n        and \"sourcenode ax = (_Low_)\" and \"targetnode ax = (_Exit_)\"\n        and \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = (_Low_);\n         targetnode ax = (_Exit_);\n         kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>n = (_Low_)\\<close> \\<open>targetnode a = (_Exit_)\\<close>\n        \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = (_Low_)\\<close> \\<open>targetnode ax = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  n = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)", "have \"a = ax\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  n = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n\ngoal (1 subgoal):\n 1. a = ax", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = ax\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = ax", "have \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = ax\n\ngoal (1 subgoal):\n 1. kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>targetnode a = (_Exit_)\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  targetnode a = n''\n  n'' -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  targetnode a = n''\n  n'' -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(rule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>n -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx", "have \"n = sourcenode ax\" and \"valid_edge ax\" \n        and \"targetnode ax -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. n = sourcenode ax &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode ax\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"targetnode ax = n''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  targetnode ax = n''\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>targetnode ax -asx\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  targetnode ax = n''", "have \"n'' -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  targetnode ax = n''\n\ngoal (1 subgoal):\n 1. n'' -asx\\<rightarrow>* (_Low_)", "by simp"], ["proof (state)\nthis:\n  n'' -asx\\<rightarrow>* (_Low_)\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge ax\\<close> \\<open>valid_edge a\\<close> \\<open>n = sourcenode ax\\<close> \\<open>sourcenode a = n\\<close>\n          True \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  valid_edge a\n  n = sourcenode ax\n  sourcenode a = n\n  targetnode ax = n''\n  targetnode a = n''", "have \"ax = a\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  valid_edge a\n  n = sourcenode ax\n  sourcenode a = n\n  targetnode ax = n''\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. ax = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  ax = a\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have preds1:\"preds (slice_kinds S as) (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> Cons \\<open>ax = a\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  ax = a", "have preds2:\"preds (slice_kinds S asx) \n          (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  ax = a\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>\n          \\<open>preds (slice_kinds S (a#as)) s\\<close> \\<open>preds (slice_kinds S as') s'\\<close>\n          \\<open>ax = a\\<close> Cons \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  ax = a\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V", "have \"\\<forall>V\\<in>rv S n''. state_val (transfer (slice_kind S a) s) V =\n                                 state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  ax = a\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n''.\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by -(rule rv_edge_slice_kinds,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n''.\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from IH[OF \\<open>n'' -asx\\<rightarrow>* (_Low_)\\<close> this preds1 preds2] \n          Cons \\<open>ax = a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n  ax = a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n  ax = a\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = n\\<close> \\<open>n = sourcenode ax\\<close>\n          \\<open>targetnode a = n''\\<close> \\<open>preds (slice_kinds S (a#as)) s\\<close>\n          \\<open>preds (slice_kinds S as') s'\\<close> Cons\n          \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  n = sourcenode ax\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  targetnode ax \\<noteq> n''", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  n = sourcenode ax\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. False", "by -(rule rv_branching_edges_slice_kinds_False,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Correctness Proofs\\<close>"], ["", "text \\<open>\nIn the following, we present two correctness proofs that slicing guarantees\nIFC noninterference. In both theorems, \n\\<open>(_High_) \\<notin> backward_slice S\\<close>, where \\<open>(_Low_) \\<in> S\\<close>,\nmakes sure that no high variable (which are all defined in \\<open>(_High_)\\<close>) \ncan influence a low variable (which are all used in \\<open>(_Low_)\\<close>).\n\nFirst, a theorem regarding \n\\<open>(_Entry_) -as\\<rightarrow>* (_Exit_)\\<close> paths in the control flow graph (CFG),\nwhich agree to a complete program execution:\\<close>"], ["", "lemma nonInterference_path_to_Low:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>* (_Low_)\" and \"preds (kinds as) s\"\n  and \"(_Entry_) -as'\\<rightarrow>* (_Low_)\" and \"preds (kinds as') s'\"\n  shows \"transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>(_Entry_) -as\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds as) s\\<close> \\<open>(_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* (_Low_)\n  preds (kinds as) s\n  (_Low_) \\<in> S", "obtain asx where \"preds (slice_kinds S asx) s\"\n    and \"\\<forall>V \\<in> Use (_Low_). state_val(transfers (slice_kinds S asx) s) V = \n                           state_val(transfers (kinds as) s) V\"\n    and \"slice_edges S as = slice_edges S asx\"\n    and \"(_Entry_) -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* (_Low_)\n  preds (kinds as) s\n  (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>preds (slice_kinds S asx) s;\n         \\<forall>V\\<in>Use (_Low_).\n            state_val (transfers (slice_kinds S asx) s) V =\n            state_val (transfers (kinds as) s) V;\n         slice_edges S as = slice_edges S asx;\n         (_Entry_) -asx\\<rightarrow>* (_Low_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule fundamental_property_of_static_slicing)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) s\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (kinds as) s) V\n  slice_edges S as = slice_edges S asx\n  (_Entry_) -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>(_Entry_) -as'\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds as') s'\\<close> \\<open>(_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>* (_Low_)\n  preds (kinds as') s'\n  (_Low_) \\<in> S", "obtain asx' where \"preds (slice_kinds S asx') s'\"\n    and \"\\<forall>V \\<in> Use (_Low_). state_val (transfers (slice_kinds S asx') s') V = \n                           state_val (transfers (kinds as') s') V\"\n    and \"slice_edges S as' = slice_edges S asx'\"\n    and \"(_Entry_) -asx'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>* (_Low_)\n  preds (kinds as') s'\n  (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>preds (slice_kinds S asx') s';\n         \\<forall>V\\<in>Use (_Low_).\n            state_val (transfers (slice_kinds S asx') s') V =\n            state_val (transfers (kinds as') s') V;\n         slice_edges S as' = slice_edges S asx';\n         (_Entry_) -asx'\\<rightarrow>* (_Low_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule fundamental_property_of_static_slicing)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx') s'\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') s') V =\n     state_val (transfers (kinds as') s') V\n  slice_edges S as' = slice_edges S asx'\n  (_Entry_) -asx'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>s \\<approx>\\<^sub>L s'\\<close> \\<open>(_High_) \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  s \\<approx>\\<^sub>L s'\n  (_High_) \\<notin> backward_slice S", "have \"\\<forall>V \\<in> rv S (_Entry_). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  s \\<approx>\\<^sub>L s'\n  (_High_) \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (_Entry_). state_val s V = state_val s' V", "by(rule lowEquivalence_relevant_nodes_Entry)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (_Entry_). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>(_Entry_) -asx\\<rightarrow>* (_Low_)\\<close> \\<open>(_Entry_) -asx'\\<rightarrow>* (_Low_)\\<close> \\<open>(_Low_) \\<in> S\\<close>\n    \\<open>preds (slice_kinds S asx) s\\<close> \\<open>preds (slice_kinds S asx') s'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx\\<rightarrow>* (_Low_)\n  (_Entry_) -asx'\\<rightarrow>* (_Low_)\n  (_Low_) \\<in> S\n  preds (slice_kinds S asx) s\n  preds (slice_kinds S asx') s'\n  \\<forall>V\\<in>rv S (_Entry_). state_val s V = state_val s' V", "have \"\\<forall>V \\<in> Use (_Low_). state_val (transfers (slice_kinds S asx) s) V =\n                          state_val (transfers (slice_kinds S asx') s') V\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx\\<rightarrow>* (_Low_)\n  (_Entry_) -asx'\\<rightarrow>* (_Low_)\n  (_Low_) \\<in> S\n  preds (slice_kinds S asx) s\n  preds (slice_kinds S asx') s'\n  \\<forall>V\\<in>rv S (_Entry_). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S asx) s) V =\n       state_val (transfers (slice_kinds S asx') s') V", "by -(rule rv_Low_Use_Low,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (slice_kinds S asx') s') V\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>\\<forall>V \\<in> Use (_Low_). state_val(transfers (slice_kinds S asx) s) V = \n                          state_val(transfers (kinds as) s) V\\<close>\n    \\<open>\\<forall>V \\<in> Use (_Low_). state_val (transfers (slice_kinds S asx') s') V = \n                       state_val (transfers (kinds as') s') V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (kinds as) s) V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') s') V =\n     state_val (transfers (kinds as') s') V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (slice_kinds S asx') s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (kinds as) s) V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') s') V =\n     state_val (transfers (kinds as') s') V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) s) V =\n     state_val (transfers (slice_kinds S asx') s') V\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "by(auto simp:lowEquivalence_def UseLow)"], ["proof (state)\nthis:\n  transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem nonInterference_path:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>* (_Exit_)\" and \"preds (kinds as) s\"\n  and \"(_Entry_) -as'\\<rightarrow>* (_Exit_)\" and \"preds (kinds as') s'\"\n  shows \"transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>(_Entry_) -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* (_Exit_)", "obtain x xs where \"as = x#xs\"\n    and \"(_Entry_) = sourcenode x\" and \"valid_edge x\" \n    and \"targetnode x -xs\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x; valid_edge x;\n         targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"as = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>* (_Exit_); as = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>* (_Exit_); as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(simp,drule empty_path_nodes,drule Entry_noteq_Exit,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>* (_Exit_); as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule path_split_Cons)"], ["proof (state)\nthis:\n  as = x # xs\n  (_Entry_) = sourcenode x\n  valid_edge x\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x", "have \"valid_node (targetnode x)\""], ["proof (prove)\nusing this:\n  valid_edge x\n\ngoal (1 subgoal):\n 1. valid_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "hence \"inner_node (targetnode x)\""], ["proof (prove)\nusing this:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "proof(cases rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "case Entry"], ["proof (state)\nthis:\n  targetnode x = (_Entry_)\n\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  targetnode x = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge x\n  targetnode x = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "case Exit"], ["proof (state)\nthis:\n  targetnode x = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>targetnode x -xs\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  targetnode x = (_Exit_)", "have \"xs = []\""], ["proof (prove)\nusing this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  targetnode x = (_Exit_)\n\ngoal (1 subgoal):\n 1. xs = []", "by -(rule path_Exit_source,simp)"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain z where \"valid_edge z\"\n      and \"sourcenode z = (_Entry_)\" and \"targetnode z = (_Exit_)\"\n      and \"kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>valid_edge z; sourcenode z = (_Entry_);\n         targetnode z = (_Exit_);\n         kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge z\n  sourcenode z = (_Entry_)\n  targetnode z = (_Exit_)\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "from \\<open>valid_edge x\\<close> \\<open>valid_edge z\\<close> \\<open>(_Entry_) = sourcenode x\\<close> \n      \\<open>sourcenode z = (_Entry_)\\<close> Exit \\<open>targetnode z = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  valid_edge z\n  (_Entry_) = sourcenode x\n  sourcenode z = (_Entry_)\n  targetnode x = (_Exit_)\n  targetnode z = (_Exit_)", "have \"x = z\""], ["proof (prove)\nusing this:\n  valid_edge x\n  valid_edge z\n  (_Entry_) = sourcenode x\n  sourcenode z = (_Entry_)\n  targetnode x = (_Exit_)\n  targetnode z = (_Exit_)\n\ngoal (1 subgoal):\n 1. x = z", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  x = z\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>preds (kinds as) s\\<close> \\<open>as = x#xs\\<close> \\<open>xs = []\\<close> \\<open>kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as) s\n  as = x # xs\n  xs = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  x = z", "have False"], ["proof (prove)\nusing this:\n  preds (kinds as) s\n  as = x # xs\n  xs = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  x = z\n\ngoal (1 subgoal):\n 1. False", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "qed simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>targetnode x -xs\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  inner_node (targetnode x)", "obtain x' xs' where \"xs = xs'@[x']\"\n    and \"targetnode x -xs'\\<rightarrow>* (_Low_)\" and \"kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. (\\<And>xs' x'.\n        \\<lbrakk>xs = xs' @ [x']; targetnode x -xs'\\<rightarrow>* (_Low_);\n         kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Exit_path_Low_path)"], ["proof (state)\nthis:\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>(_Entry_) = sourcenode x\\<close> \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) = sourcenode x\n  valid_edge x\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Entry_) -x#xs'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode x\n  valid_edge x\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Entry_) -x # xs'\\<rightarrow>* (_Low_)", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>as = x#xs\\<close> \\<open>xs = xs'@[x']\\<close>"], ["proof (chain)\npicking this:\n  as = x # xs\n  xs = xs' @ [x']", "have \"as = (x#xs')@[x']\""], ["proof (prove)\nusing this:\n  as = x # xs\n  xs = xs' @ [x']\n\ngoal (1 subgoal):\n 1. as = (x # xs') @ [x']", "by simp"], ["proof (state)\nthis:\n  as = (x # xs') @ [x']\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>preds (kinds as) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as) s\n  as = (x # xs') @ [x']", "have \"preds (kinds (x#xs')) s\""], ["proof (prove)\nusing this:\n  preds (kinds as) s\n  as = (x # xs') @ [x']\n\ngoal (1 subgoal):\n 1. preds (kinds (x # xs')) s", "by(simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (x # xs')) s\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>(_Entry_) -as'\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>* (_Exit_)", "obtain y ys where \"as' = y#ys\"\n    and \"(_Entry_) = sourcenode y\" and \"valid_edge y\" \n    and \"targetnode y -ys\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y; valid_edge y;\n         targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"as' = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>* (_Exit_); as' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>* (_Exit_); as' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(simp,drule empty_path_nodes,drule Entry_noteq_Exit,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>* (_Exit_); as' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(erule path_split_Cons)"], ["proof (state)\nthis:\n  as' = y # ys\n  (_Entry_) = sourcenode y\n  valid_edge y\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y", "have \"valid_node (targetnode y)\""], ["proof (prove)\nusing this:\n  valid_edge y\n\ngoal (1 subgoal):\n 1. valid_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode y)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "hence \"inner_node (targetnode y)\""], ["proof (prove)\nusing this:\n  valid_node (targetnode y)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "proof(cases rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "case Entry"], ["proof (state)\nthis:\n  targetnode y = (_Entry_)\n\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y\n  targetnode y = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge y\n  targetnode y = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "case Exit"], ["proof (state)\nthis:\n  targetnode y = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>targetnode y -ys\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  targetnode y = (_Exit_)", "have \"ys = []\""], ["proof (prove)\nusing this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  targetnode y = (_Exit_)\n\ngoal (1 subgoal):\n 1. ys = []", "by -(rule path_Exit_source,simp)"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain z where \"valid_edge z\"\n      and \"sourcenode z = (_Entry_)\" and \"targetnode z = (_Exit_)\"\n      and \"kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>valid_edge z; sourcenode z = (_Entry_);\n         targetnode z = (_Exit_);\n         kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge z\n  sourcenode z = (_Entry_)\n  targetnode z = (_Exit_)\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "from \\<open>valid_edge y\\<close> \\<open>valid_edge z\\<close> \\<open>(_Entry_) = sourcenode y\\<close> \n      \\<open>sourcenode z = (_Entry_)\\<close> Exit \\<open>targetnode z = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y\n  valid_edge z\n  (_Entry_) = sourcenode y\n  sourcenode z = (_Entry_)\n  targetnode y = (_Exit_)\n  targetnode z = (_Exit_)", "have \"y = z\""], ["proof (prove)\nusing this:\n  valid_edge y\n  valid_edge z\n  (_Entry_) = sourcenode y\n  sourcenode z = (_Entry_)\n  targetnode y = (_Exit_)\n  targetnode z = (_Exit_)\n\ngoal (1 subgoal):\n 1. y = z", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  y = z\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>preds (kinds as') s'\\<close> \\<open>as' = y#ys\\<close> \\<open>ys = []\\<close> \\<open>kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as') s'\n  as' = y # ys\n  ys = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  y = z", "have False"], ["proof (prove)\nusing this:\n  preds (kinds as') s'\n  as' = y # ys\n  ys = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  y = z\n\ngoal (1 subgoal):\n 1. False", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "qed simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>targetnode y -ys\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  inner_node (targetnode y)", "obtain y' ys' where \"ys = ys'@[y']\"\n    and \"targetnode y -ys'\\<rightarrow>* (_Low_)\" and \"kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. (\\<And>ys' y'.\n        \\<lbrakk>ys = ys' @ [y']; targetnode y -ys'\\<rightarrow>* (_Low_);\n         kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Exit_path_Low_path)"], ["proof (state)\nthis:\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>(_Entry_) = sourcenode y\\<close> \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) = sourcenode y\n  valid_edge y\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Entry_) -y#ys'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode y\n  valid_edge y\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Entry_) -y # ys'\\<rightarrow>* (_Low_)", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>as' = y#ys\\<close> \\<open>ys = ys'@[y']\\<close>"], ["proof (chain)\npicking this:\n  as' = y # ys\n  ys = ys' @ [y']", "have \"as' = (y#ys')@[y']\""], ["proof (prove)\nusing this:\n  as' = y # ys\n  ys = ys' @ [y']\n\ngoal (1 subgoal):\n 1. as' = (y # ys') @ [y']", "by simp"], ["proof (state)\nthis:\n  as' = (y # ys') @ [y']\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>preds (kinds as') s'\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as') s'\n  as' = (y # ys') @ [y']", "have \"preds (kinds (y#ys')) s'\""], ["proof (prove)\nusing this:\n  preds (kinds as') s'\n  as' = (y # ys') @ [y']\n\ngoal (1 subgoal):\n 1. preds (kinds (y # ys')) s'", "by(simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (y # ys')) s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "from \\<open>s \\<approx>\\<^sub>L s'\\<close> \\<open>(_High_) \\<notin> backward_slice S\\<close> \\<open>(_Low_) \\<in> S\\<close>\n    \\<open>(_Entry_) -x#xs'\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds (x#xs')) s\\<close>\n    \\<open>(_Entry_) -y#ys'\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds (y#ys')) s'\\<close>"], ["proof (chain)\npicking this:\n  s \\<approx>\\<^sub>L s'\n  (_High_) \\<notin> backward_slice S\n  (_Low_) \\<in> S\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n  preds (kinds (x # xs')) s\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n  preds (kinds (y # ys')) s'", "have \"transfers (kinds (x#xs')) s \\<approx>\\<^sub>L transfers (kinds (y#ys')) s'\""], ["proof (prove)\nusing this:\n  s \\<approx>\\<^sub>L s'\n  (_High_) \\<notin> backward_slice S\n  (_Low_) \\<in> S\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n  preds (kinds (x # xs')) s\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n  preds (kinds (y # ys')) s'\n\ngoal (1 subgoal):\n 1. transfers (kinds (x # xs')) s \\<approx>\\<^sub>L\n    transfers (kinds (y # ys')) s'", "by(rule nonInterference_path_to_Low)"], ["proof (state)\nthis:\n  transfers (kinds (x # xs')) s \\<approx>\\<^sub>L\n  transfers (kinds (y # ys')) s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "with \\<open>as = x#xs\\<close> \\<open>xs = xs'@[x']\\<close> \\<open>kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>\n    \\<open>as' = y#ys\\<close> \\<open>ys = ys'@[y']\\<close> \\<open>kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  as = x # xs\n  xs = xs' @ [x']\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  as' = y # ys\n  ys = ys' @ [y']\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  transfers (kinds (x # xs')) s \\<approx>\\<^sub>L\n  transfers (kinds (y # ys')) s'", "show ?thesis"], ["proof (prove)\nusing this:\n  as = x # xs\n  xs = xs' @ [x']\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  as' = y # ys\n  ys = ys' @ [y']\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  transfers (kinds (x # xs')) s \\<approx>\\<^sub>L\n  transfers (kinds (y # ys')) s'\n\ngoal (1 subgoal):\n 1. transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'", "by(simp add:kinds_def transfers_split)"], ["proof (state)\nthis:\n  transfers (kinds as) s \\<approx>\\<^sub>L transfers (kinds as') s'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>The second theorem assumes that we have a operational semantics,\nwhose evaluations are written \\<open>\\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\\<close> and which conforms \nto the CFG. The correctness theorem then states that if no high variable\ninfluenced a low variable and the initial states were low equivalent, the\nreulting states are again low equivalent:\\<close>"], ["", "locale NonInterferenceIntra = \n  NonInterferenceIntraGraph sourcenode targetnode kind valid_edge Entry \n    Def Use state_val backward_slice Exit H L High Low +\n  BackwardSlice_wf sourcenode targetnode kind valid_edge Entry Def Use state_val \n    backward_slice sem identifies\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> 'state edge_kind\" and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\") and Def :: \"'node \\<Rightarrow> 'var set\"\n  and Use :: \"'node \\<Rightarrow> 'var set\" and state_val :: \"'state \\<Rightarrow> 'var \\<Rightarrow> 'val\"\n  and backward_slice :: \"'node set \\<Rightarrow> 'node set\"\n  and sem :: \"'com \\<Rightarrow> 'state \\<Rightarrow> 'com \\<Rightarrow> 'state \\<Rightarrow> bool\" \n    (\"((1\\<langle>_,/_\\<rangle>) \\<Rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [0,0,0,0] 81)\n  and identifies :: \"'node \\<Rightarrow> 'com \\<Rightarrow> bool\" (\"_ \\<triangleq> _\" [51, 0] 80)\n  and Exit :: \"'node\" (\"'('_Exit'_')\")\n  and H :: \"'var set\" and L :: \"'var set\" \n  and High :: \"'node\"  (\"'('_High'_')\") and Low :: \"'node\"   (\"'('_Low'_')\") +\n  fixes final :: \"'com \\<Rightarrow> bool\"\n  assumes final_edge_Low: \"\\<lbrakk>final c; n \\<triangleq> c\\<rbrakk> \n  \\<Longrightarrow> \\<exists>a. valid_edge a \\<and> sourcenode a = n \\<and> targetnode a = (_Low_) \\<and> kind a = \\<Up>id\"\nbegin"], ["", "text\\<open>The following theorem needs the explicit edge from \\<open>(_High_)\\<close>\n  to \\<open>n\\<close>. An approach using a \\<open>init\\<close> predicate for initial statements,\n  being reachable from \\<open>(_High_)\\<close> via a \\<open>(\\<lambda>s. True)\\<^sub>\\<surd>\\<close> edge,\n  does not work as the same statement could be identified by several nodes, some\n  initial, some not. E.g., in the program \\texttt{while (True) Skip;;Skip}\n  two nodes identify this inital statement: the initial node and the node\n  within the loop (because of loop unrolling).\\<close>"], ["", "theorem nonInterference:\n  assumes \"s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\" and \"(_High_) \\<notin> backward_slice S\" and \"(_Low_) \\<in> S\"\n  and \"valid_edge a\" and \"sourcenode a = (_High_)\" and \"targetnode a = n\" \n  and \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\" and \"n \\<triangleq> c\" and \"final c'\"\n  and \"\\<langle>c,s\\<^sub>1\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1'\\<rangle>\" and \"\\<langle>c,s\\<^sub>2\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2'\\<rangle>\"\n  shows \"s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from High_target_Entry_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain ax where \"valid_edge ax\"\n    and \"sourcenode ax = (_Entry_)\" and \"targetnode ax = (_High_)\"\n    and \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = (_Entry_);\n         targetnode ax = (_High_);\n         kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>n \\<triangleq> c\\<close> \\<open>\\<langle>c,s\\<^sub>1\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<^sub>1\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>1'\\<rangle>", "obtain n\\<^sub>1 as\\<^sub>1 where \"n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1\" and \"transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1'\"\n    and \"preds (kinds as\\<^sub>1) s\\<^sub>1\" and \"n\\<^sub>1 \\<triangleq> c'\""], ["proof (prove)\nusing this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<^sub>1\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>1'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 n\\<^sub>1.\n        \\<lbrakk>n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1;\n         transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1';\n         preds (kinds as\\<^sub>1) s\\<^sub>1;\n         n\\<^sub>1 \\<triangleq> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n  transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1'\n  preds (kinds as\\<^sub>1) s\\<^sub>1\n  n\\<^sub>1 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_High_)\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n", "have \"(_High_) -a#as\\<^sub>1\\<rightarrow>* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. (_High_) -a # as\\<^sub>1\\<rightarrow>* n\\<^sub>1", "by(rule Cons_path)"], ["proof (state)\nthis:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>final c'\\<close> \\<open>n\\<^sub>1 \\<triangleq> c'\\<close>"], ["proof (chain)\npicking this:\n  final c'\n  n\\<^sub>1 \\<triangleq> c'", "obtain a\\<^sub>1 where \"valid_edge a\\<^sub>1\" and \"sourcenode a\\<^sub>1 = n\\<^sub>1\" \n    and \"targetnode a\\<^sub>1 = (_Low_)\" and \"kind a\\<^sub>1 = \\<Up>id\""], ["proof (prove)\nusing this:\n  final c'\n  n\\<^sub>1 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. (\\<And>a\\<^sub>1.\n        \\<lbrakk>valid_edge a\\<^sub>1; sourcenode a\\<^sub>1 = n\\<^sub>1;\n         targetnode a\\<^sub>1 = (_Low_); kind a\\<^sub>1 = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:final_edge_Low)"], ["proof (state)\nthis:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "hence \"n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)", "by(fastforce intro:path_edge)"], ["proof (state)\nthis:\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "with \\<open>(_High_) -a#as\\<^sub>1\\<rightarrow>* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)", "have \"(_High_) -(a#as\\<^sub>1)@[a\\<^sub>1]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>* n\\<^sub>1\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "by(rule path_Append)"], ["proof (state)\nthis:\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = (_Entry_)\\<close> \\<open>targetnode ax = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "have \"(_Entry_) -ax#((a#as\\<^sub>1)@[a\\<^sub>1])\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>preds (kinds as\\<^sub>1) s\\<^sub>1\\<close>\n    \\<open>kind a\\<^sub>1 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>1) s\\<^sub>1\n  kind a\\<^sub>1 = \\<Up>id", "have \"preds (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) s\\<^sub>1\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>1) s\\<^sub>1\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])) s\\<^sub>1", "by (simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])) s\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>n \\<triangleq> c\\<close> \\<open>\\<langle>c,s\\<^sub>2\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<^sub>2\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>2'\\<rangle>", "obtain n\\<^sub>2 as\\<^sub>2 where \"n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2\" and \"transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2'\"\n    and \"preds (kinds as\\<^sub>2) s\\<^sub>2\" and \"n\\<^sub>2 \\<triangleq> c'\""], ["proof (prove)\nusing this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<^sub>2\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>2 n\\<^sub>2.\n        \\<lbrakk>n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2;\n         transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2';\n         preds (kinds as\\<^sub>2) s\\<^sub>2;\n         n\\<^sub>2 \\<triangleq> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n  transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2'\n  preds (kinds as\\<^sub>2) s\\<^sub>2\n  n\\<^sub>2 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_High_)\\<close> \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n", "have \"(_High_) -a#as\\<^sub>2\\<rightarrow>* n\\<^sub>2\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. (_High_) -a # as\\<^sub>2\\<rightarrow>* n\\<^sub>2", "by(rule Cons_path)"], ["proof (state)\nthis:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>final c'\\<close> \\<open>n\\<^sub>2 \\<triangleq> c'\\<close>"], ["proof (chain)\npicking this:\n  final c'\n  n\\<^sub>2 \\<triangleq> c'", "obtain a\\<^sub>2 where \"valid_edge a\\<^sub>2\" and \"sourcenode a\\<^sub>2 = n\\<^sub>2\" \n    and \"targetnode a\\<^sub>2 = (_Low_)\" and \"kind a\\<^sub>2 = \\<Up>id\""], ["proof (prove)\nusing this:\n  final c'\n  n\\<^sub>2 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. (\\<And>a\\<^sub>2.\n        \\<lbrakk>valid_edge a\\<^sub>2; sourcenode a\\<^sub>2 = n\\<^sub>2;\n         targetnode a\\<^sub>2 = (_Low_); kind a\\<^sub>2 = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:final_edge_Low)"], ["proof (state)\nthis:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "hence \"n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)", "by(fastforce intro:path_edge)"], ["proof (state)\nthis:\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "with \\<open>(_High_) -a#as\\<^sub>2\\<rightarrow>* n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)", "have \"(_High_) -(a#as\\<^sub>2)@[a\\<^sub>2]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>* n\\<^sub>2\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "by(rule path_Append)"], ["proof (state)\nthis:\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = (_Entry_)\\<close> \\<open>targetnode ax = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "have \"(_Entry_) -ax#((a#as\\<^sub>2)@[a\\<^sub>2])\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>preds (kinds as\\<^sub>2) s\\<^sub>2\\<close>\n    \\<open>kind a\\<^sub>2 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>2) s\\<^sub>2\n  kind a\\<^sub>2 = \\<Up>id", "have \"preds (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>2) s\\<^sub>2\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2", "by (simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "from \\<open>s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\\<close> \\<open>(_High_) \\<notin> backward_slice S\\<close> \\<open>(_Low_) \\<in> S\\<close>\n    \\<open>(_Entry_) -ax#((a#as\\<^sub>1)@[a\\<^sub>1])\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) s\\<^sub>1\\<close>\n    \\<open>(_Entry_) -ax#((a#as\\<^sub>2)@[a\\<^sub>2])\\<rightarrow>* (_Low_)\\<close> \\<open>preds (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\n  (_High_) \\<notin> backward_slice S\n  (_Low_) \\<in> S\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])) s\\<^sub>1\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2", "have \"transfers (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) s\\<^sub>1 \\<approx>\\<^sub>L \n        transfers (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\n  (_High_) \\<notin> backward_slice S\n  (_Low_) \\<in> S\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])) s\\<^sub>1\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n     s\\<^sub>1 \\<approx>\\<^sub>L\n    transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2", "by(rule nonInterference_path_to_Low)"], ["proof (state)\nthis:\n  transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   s\\<^sub>1 \\<approx>\\<^sub>L\n  transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "with \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a\\<^sub>1 = \\<Up>id\\<close> \\<open>kind a\\<^sub>2 = \\<Up>id\\<close>\n    \\<open>transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a\\<^sub>1 = \\<Up>id\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1'\n  transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2'\n  transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   s\\<^sub>1 \\<approx>\\<^sub>L\n  transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a\\<^sub>1 = \\<Up>id\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (kinds as\\<^sub>1) s\\<^sub>1 = s\\<^sub>1'\n  transfers (kinds as\\<^sub>2) s\\<^sub>2 = s\\<^sub>2'\n  transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   s\\<^sub>1 \\<approx>\\<^sub>L\n  transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'", "by(simp add:kinds_def transfers_split)"], ["proof (state)\nthis:\n  s\\<^sub>1' \\<approx>\\<^sub>L s\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}