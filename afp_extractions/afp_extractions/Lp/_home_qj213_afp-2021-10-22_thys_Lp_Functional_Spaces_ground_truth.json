{"file_name": "/home/qj213/afp-2021-10-22/thys/Lp/Functional_Spaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Lp", "problem_names": ["lemma plus_apply [simp, code]: \"(f + g) x = f x + g x\"", "lemmas uminus_fun_def = fun_Compl_def", "lemmas minus_fun_def = fun_diff_def", "lemma zero_fun [simp, code]:\n  \"0 x = 0\"", "lemma fun_sum_apply:\n  fixes u::\"'i \\<Rightarrow> 'a \\<Rightarrow> ('b::comm_monoid_add)\"\n  shows \"(sum u I) x = sum (\\<lambda>i. u i x) I\"", "lemma scaleR_apply [simp, code]: \"(c *\\<^sub>R f) x = c *\\<^sub>R (f x)\"", "lemmas divideR_apply = scaleR_apply", "lemma [measurable]:\n  \"0 \\<in> borel_measurable M\"", "lemma borel_measurable_const_scaleR' [measurable (raw)]:\n  \"(f::('a \\<Rightarrow> 'b::real_normed_vector)) \\<in> borel_measurable M \\<Longrightarrow> c *\\<^sub>R f \\<in> borel_measurable M\"", "lemma borel_measurable_add'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  assumes g: \"g \\<in> borel_measurable M\"\n  shows \"f + g \\<in> borel_measurable M\"", "lemma borel_measurable_uminus'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  shows \"-f \\<in> borel_measurable M\"", "lemma borel_measurable_diff'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  assumes g: \"g \\<in> borel_measurable M\"\n  shows \"f - g \\<in> borel_measurable M\"", "lemma borel_measurable_sum'[measurable (raw)]:\n  fixes f::\"'i \\<Rightarrow> 'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> f i \\<in> borel_measurable M\"\n  shows \"(\\<Sum>i\\<in>I. f i) \\<in> borel_measurable M\"", "lemma zero_applied_to [simp]:\n  \"(0::('a \\<Rightarrow> ('b::real_vector))) x = 0\"", "lemma eNorm_triangular_ineq:\n  \"eNorm N (x + y) \\<le> defect N * eNorm N x + defect N * eNorm N y\"", "lemma defect_ge_1:\n  \"defect N \\<ge> 1\"", "lemma eNorm_cmult:\n  \"eNorm N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * eNorm N x\"", "lemma eNorm_zero [simp]:\n  \"eNorm N 0 = 0\"", "lemma eNorm_uminus [simp]:\n  \"eNorm N (-x) = eNorm N x\"", "lemma eNorm_sum:\n  \"eNorm N (\\<Sum>i\\<in>{..<n}. u i) \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (u i))\"", "lemma quasinorm_of:\n  fixes N::\"('a::real_vector) \\<Rightarrow> ennreal\" and C::real\n  assumes \"quasinorm_on UNIV C N\"\n  shows \"eNorm (quasinorm_of (C,N)) x = N x\"\n        \"defect (quasinorm_of (C,N)) = C\"", "lemma quasinorm_onI:\n  fixes N::\"('a::real_vector) \\<Rightarrow> ennreal\" and C::real and F::\"'a set\"\n  assumes \"\\<And>x y. x \\<in> F \\<Longrightarrow> y \\<in> F \\<Longrightarrow> x + y \\<in> F\"\n          \"\\<And>x y. x \\<in> F \\<Longrightarrow> y \\<in> F \\<Longrightarrow> N (x + y) \\<le> C * N x + C * N y\"\n          \"\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> c *\\<^sub>R x \\<in> F\"\n          \"\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> N (c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * N x\"\n          \"0 \\<in> F\" \"N(0) = 0\" \"C \\<ge> 1\"\n  shows \"quasinorm_on F C N\"", "lemma extend_quasinorm:\n  assumes \"quasinorm_on F C N\"\n  shows \"quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)\"", "lemma spaceN_iff:\n  \"x \\<in> space\\<^sub>N N \\<longleftrightarrow> eNorm N x < \\<infinity>\"", "lemma spaceN_cmult [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"c *\\<^sub>R x \\<in> space\\<^sub>N N\"", "lemma spaceN_add [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\" \"y \\<in> space\\<^sub>N N\"\n  shows \"x + y \\<in> space\\<^sub>N N\"", "lemma spaceN_diff [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\" \"y \\<in> space\\<^sub>N N\"\n  shows \"x - y \\<in> space\\<^sub>N N\"", "lemma spaceN_contains_zero [simp]:\n  \"0 \\<in> space\\<^sub>N N\"", "lemma spaceN_sum [simp]:\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> x i \\<in> space\\<^sub>N N\"\n  shows \"(\\<Sum>i\\<in>I. x i) \\<in> space\\<^sub>N N\"", "lemma zero_spaceN_iff:\n  \"x \\<in> zero_space\\<^sub>N N \\<longleftrightarrow> eNorm N x = 0\"", "lemma zero_spaceN_cmult:\n  assumes \"x \\<in> zero_space\\<^sub>N N\"\n  shows \"c *\\<^sub>R x \\<in> zero_space\\<^sub>N N\"", "lemma zero_spaceN_add:\n  assumes \"x \\<in> zero_space\\<^sub>N N\" \"y \\<in> zero_space\\<^sub>N N\"\n  shows \"x + y \\<in> zero_space\\<^sub>N N\"", "lemma zero_spaceN_diff:\n  assumes \"x \\<in> zero_space\\<^sub>N N\" \"y \\<in> zero_space\\<^sub>N N\"\n  shows \"x - y \\<in> zero_space\\<^sub>N N\"", "lemma zero_spaceN_subset_spaceN:\n  \"zero_space\\<^sub>N N \\<subseteq> space\\<^sub>N N\"", "lemma Norm_nonneg [simp]:\n  \"Norm N x \\<ge> 0\"", "lemma Norm_zero [simp]:\n  \"Norm N 0 = 0\"", "lemma Norm_uminus [simp]:\n  \"Norm N (-x) = Norm N x\"", "lemma eNorm_Norm:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"eNorm N x = ennreal (Norm N x)\"", "lemma eNorm_Norm':\n  assumes \"x \\<notin> space\\<^sub>N N\"\n  shows \"Norm N x = 0\"", "lemma Norm_cmult:\n  \"Norm N (c *\\<^sub>R x) = abs c * Norm N x\"", "lemma Norm_triangular_ineq:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\"", "lemma Norm_triangular_ineq_diff:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"Norm N (x - y) \\<le> defect N * Norm N x + defect N * Norm N y\"", "lemma zero_spaceN_iff':\n  \"x \\<in> zero_space\\<^sub>N N \\<longleftrightarrow> (x \\<in> space\\<^sub>N N \\<and> Norm N x = 0)\"", "lemma Norm_sum:\n  assumes \"\\<And>i. i < n \\<Longrightarrow> u i \\<in> space\\<^sub>N N\"\n  shows \"Norm N (\\<Sum>i\\<in>{..<n}. u i) \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * Norm N (u i))\"", "lemma N_of_norm:\n  \"eNorm N_of_norm f = ennreal (norm f)\"\n  \"Norm N_of_norm f = norm f\"\n  \"defect (N_of_norm) = 1\"", "lemma N_of_norm_space [simp]:\n  \"space\\<^sub>N N_of_norm = UNIV\"", "lemma N_of_norm_zero_space [simp]:\n  \"zero_space\\<^sub>N N_of_norm = {0}\"", "lemma bcontfun\\<^sub>N:\n  fixes f::\"('a::topological_space \\<Rightarrow> 'b::real_normed_vector)\"\n  shows \"eNorm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else (\\<infinity>::ennreal))\"\n        \"Norm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else 0)\"\n        \"defect (bcontfun\\<^sub>N::(('a \\<Rightarrow> 'b) quasinorm)) = 1\"", "lemma bcontfun\\<^sub>N_space:\n  \"space\\<^sub>N bcontfun\\<^sub>N = bcontfun\"", "lemma bcontfun\\<^sub>N_zero_space:\n  \"zero_space\\<^sub>N bcontfun\\<^sub>N = {0}\"", "lemma bcontfun\\<^sub>ND:\n  assumes \"f \\<in> space\\<^sub>N bcontfun\\<^sub>N\"\n  shows \"continuous_on UNIV f\"\n        \"\\<And>x. norm(f x) \\<le> Norm bcontfun\\<^sub>N f\"", "lemma bcontfun\\<^sub>NI:\n  assumes \"continuous_on UNIV f\"\n          \"\\<And>x. norm(f x) \\<le> C\"\n  shows \"f \\<in> space\\<^sub>N bcontfun\\<^sub>N\"\n        \"Norm bcontfun\\<^sub>N f \\<le> C\"", "lemma quasinorm_subsetD:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"\\<exists>C\\<ge>(0::real). \\<forall>f. eNorm N2 f \\<le> C * eNorm N1 f\"", "lemma quasinorm_subsetI:\n  assumes \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> eNorm N2 f \\<le> ennreal C * eNorm N1 f\"\n  shows \"N1 \\<subseteq>\\<^sub>N N2\"", "lemma quasinorm_subsetI':\n  assumes \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> f \\<in> space\\<^sub>N N2\"\n          \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> Norm N2 f \\<le> C * Norm N1 f\"\n  shows \"N1 \\<subseteq>\\<^sub>N N2\"", "lemma quasinorm_subset_space:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"space\\<^sub>N N1 \\<subseteq> space\\<^sub>N N2\"", "lemma quasinorm_subset_Norm_eNorm:\n  assumes \"f \\<in> space\\<^sub>N N1 \\<Longrightarrow> Norm N2 f \\<le> C * Norm N1 f\"\n          \"N1 \\<subseteq>\\<^sub>N N2\"\n          \"C > 0\"\n  shows \"eNorm N2 f \\<le> ennreal C * eNorm N1 f\"", "lemma quasinorm_subset_zero_space:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"zero_space\\<^sub>N N1 \\<subseteq> zero_space\\<^sub>N N2\"", "lemma quasinorm_equivalent_sym [sym]:\n  assumes \"N1 =\\<^sub>N N2\"\n  shows \"N2 =\\<^sub>N N1\"", "lemma quasinorm_equivalent_trans [trans]:\n  assumes \"N1 =\\<^sub>N N2\" \"N2 =\\<^sub>N N3\"\n  shows \"N1 =\\<^sub>N N3\"", "lemma quasinorm_intersection:\n  \"eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\"\n  \"defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)\"", "lemma quasinorm_intersection_commute:\n  \"N1 \\<inter>\\<^sub>N N2 = N2 \\<inter>\\<^sub>N N1\"", "lemma quasinorm_intersection_space:\n  \"space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) = space\\<^sub>N N1 \\<inter> space\\<^sub>N N2\"", "lemma quasinorm_intersection_zero_space:\n  \"zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) = zero_space\\<^sub>N N1 \\<inter> zero_space\\<^sub>N N2\"", "lemma quasinorm_intersection_subset:\n  \"N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N1\" \"N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N2\"", "lemma quasinorm_intersection_minimum:\n  assumes \"N \\<subseteq>\\<^sub>N N1\" \"N \\<subseteq>\\<^sub>N N2\"\n  shows \"N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2\"", "lemma quasinorm_intersection_assoc:\n  \"(N1 \\<inter>\\<^sub>N N2) \\<inter>\\<^sub>N N3 =\\<^sub>N N1 \\<inter>\\<^sub>N (N2 \\<inter>\\<^sub>N N3)\"", "lemma quasinorm_sum:\n  \"eNorm (N1 +\\<^sub>N N2) f = Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\"\n  \"defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)\"", "lemma quasinorm_sum_limit:\n  \"\\<exists>f1 f2. (\\<forall>n. f = f1 n + f2 n) \\<and> (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n)) \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\"", "lemma quasinorm_sum_space:\n  \"space\\<^sub>N (N1 +\\<^sub>N N2) = {f + g|f g. f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2}\"", "lemma quasinorm_sum_zerospace:\n  \"{f + g |f g. f \\<in> zero_space\\<^sub>N N1 \\<and> g \\<in> zero_space\\<^sub>N N2} \\<subseteq> zero_space\\<^sub>N (N1 +\\<^sub>N N2)\"", "lemma quasinorm_sum_subset:\n  \"N1 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2\" \"N2 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2\"", "lemma quasinorm_sum_maximum:\n  assumes \"N1 \\<subseteq>\\<^sub>N N\" \"N2 \\<subseteq>\\<^sub>N N\"\n  shows \"N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N\"", "lemma quasinorm_sum_assoc:\n  \"(N1 +\\<^sub>N N2) +\\<^sub>N N3 =\\<^sub>N N1 +\\<^sub>N (N2 +\\<^sub>N N3)\"", "lemma istopology_topology\\<^sub>N:\n  \"istopology (\\<lambda>U. \\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U)\"", "lemma openin_topology\\<^sub>N:\n  \"openin (topology\\<^sub>N N) U \\<longleftrightarrow> (\\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U)\"", "lemma openin_topology\\<^sub>N_I:\n  assumes \"\\<And>x. x \\<in> U \\<Longrightarrow> \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U\"\n  shows \"openin (topology\\<^sub>N N) U\"", "lemma openin_topology\\<^sub>N_D:\n  assumes \"openin (topology\\<^sub>N N) U\"\n          \"x \\<in> U\"\n  shows \"\\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U\"", "lemma cauchy_ine\\<^sub>N_I:\n  assumes \"\\<And>e. e > 0 \\<Longrightarrow> (\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e)\"\n  shows \"cauchy_ine\\<^sub>N N u\"", "lemma cauchy_in\\<^sub>N_I:\n  assumes \"\\<And>e. e > 0 \\<Longrightarrow> (\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e)\"\n  shows \"cauchy_in\\<^sub>N N u\"", "lemma cauchy_ine_in:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\"\n  shows \"cauchy_ine\\<^sub>N N u \\<longleftrightarrow> cauchy_in\\<^sub>N N u\"", "lemma tendsto_ine_in:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\" \"x \\<in> space\\<^sub>N N\"\n  shows \"tendsto_ine\\<^sub>N N u x \\<longleftrightarrow> tendsto_in\\<^sub>N N u x\"", "lemma complete\\<^sub>N_I:\n  assumes \"\\<And>u. cauchy_in\\<^sub>N N u \\<Longrightarrow> (\\<forall>n. u n \\<in> space\\<^sub>N N) \\<Longrightarrow> (\\<exists>x\\<in> space\\<^sub>N N. tendsto_in\\<^sub>N N u x)\"\n  shows \"complete\\<^sub>N N\"", "lemma cauchy_tendsto_in_subseq:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\"\n          \"cauchy_in\\<^sub>N N u\"\n          \"strict_mono r\"\n          \"tendsto_in\\<^sub>N N (u o r) x\"\n  shows \"tendsto_in\\<^sub>N N u x\"", "lemma complete_N_of_norm:\n  \"complete\\<^sub>N (N_of_norm::'a::banach quasinorm)\"", "lemma complete_bcontfunN:\n  \"complete\\<^sub>N (bcontfun\\<^sub>N::('a::metric_space \\<Rightarrow> 'b::banach) quasinorm)\""], "translations": [["", "lemma plus_apply [simp, code]: \"(f + g) x = f x + g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f + g) x = f x + g x", "by (simp add: plus_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, plus_class)", ".."], ["", "end"], ["", "text \\<open>\\verb+minus_fun+ is already defined, in \\verb+Lattices.thy+, but under the strange name\n\\verb+fun_Compl_def+. We restate the definition so that \\verb+unfolding minus_fun_def+ works.\nSame thing for \\verb+minus_fun_def+. A better solution would be to have a coherent naming scheme\nin \\verb+Lattices.thy+.\\<close>"], ["", "lemmas uminus_fun_def = fun_Compl_def"], ["", "lemmas minus_fun_def = fun_diff_def"], ["", "instantiation \"fun\" :: (type, zero) zero\nbegin"], ["", "definition zero_fun_def: \"0 = (\\<lambda>x. 0)\""], ["", "lemma zero_fun [simp, code]:\n  \"0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 x = (0::'b)", "by (simp add: zero_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, zero_class)", ".."], ["", "end"], ["", "instance \"fun\"::(type, semigroup_add) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, semigroup_add_class)", "by (standard, rule ext, auto simp add: add.assoc)"], ["", "instance \"fun\"::(type, ab_semigroup_add) ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, ab_semigroup_add_class)", "by (standard, rule ext, auto simp add: add_ac)"], ["", "instance \"fun\"::(type, monoid_add) monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, monoid_add_class)", "by (standard, rule ext, auto)"], ["", "instance \"fun\"::(type, comm_monoid_add) comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, comm_monoid_add_class)", "by (standard, rule ext, auto)"], ["", "lemma fun_sum_apply:\n  fixes u::\"'i \\<Rightarrow> 'a \\<Rightarrow> ('b::comm_monoid_add)\"\n  shows \"(sum u I) x = sum (\\<lambda>i. u i x) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum u I x = (\\<Sum>i\\<in>I. u i x)", "by (induction I rule: infinite_finite_induct, auto)"], ["", "instance \"fun\"::(type, cancel_semigroup_add) cancel_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cancel_semigroup_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix a b c::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"a + b = a + c\""], ["proof (state)\nthis:\n  a + b = a + c\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "then"], ["proof (chain)\npicking this:\n  a + b = a + c", "have \"a x + b x = a x + c x\" for x"], ["proof (prove)\nusing this:\n  a + b = a + c\n\ngoal (1 subgoal):\n 1. a x + b x = a x + c x", "by (metis plus_fun_def)"], ["proof (state)\nthis:\n  a ?x + b ?x = a ?x + c ?x\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b = a + c \\<Longrightarrow> b = c\n 2. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "then"], ["proof (chain)\npicking this:\n  a ?x + b ?x = a ?x + c ?x", "show \"b = c\""], ["proof (prove)\nusing this:\n  a ?x + b ?x = a ?x + c ?x\n\ngoal (1 subgoal):\n 1. b = c", "by (intro ext, auto)"], ["proof (state)\nthis:\n  b = c\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "fix b a c::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "assume \"b + a = c + a\""], ["proof (state)\nthis:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "then"], ["proof (chain)\npicking this:\n  b + a = c + a", "have \"b x + a x = c x + a x\" for x"], ["proof (prove)\nusing this:\n  b + a = c + a\n\ngoal (1 subgoal):\n 1. b x + a x = c x + a x", "by (metis plus_fun_def)"], ["proof (state)\nthis:\n  b ?x + a ?x = c ?x + a ?x\n\ngoal (1 subgoal):\n 1. \\<And>b a c. b + a = c + a \\<Longrightarrow> b = c", "then"], ["proof (chain)\npicking this:\n  b ?x + a ?x = c ?x + a ?x", "show \"b = c\""], ["proof (prove)\nusing this:\n  b ?x + a ?x = c ?x + a ?x\n\ngoal (1 subgoal):\n 1. b = c", "by (intro ext, auto)"], ["proof (state)\nthis:\n  b = c\n\ngoal:\nNo subgoals!", "qed"], ["", "instance \"fun\"::(type, cancel_ab_semigroup_add) cancel_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cancel_ab_semigroup_add_class)", "by (standard, rule ext, auto, rule ext, auto simp add: diff_diff_add)"], ["", "instance \"fun\"::(type, cancel_comm_monoid_add) cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cancel_comm_monoid_add_class)", "by standard"], ["", "instance \"fun\"::(type, group_add) group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, group_add_class)", "by (standard, auto)"], ["", "instance \"fun\"::(type, ab_group_add) ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, ab_group_add_class)", "by (standard, auto)"], ["", "instantiation \"fun\" :: (type, real_vector) real_vector\nbegin"], ["", "definition scaleR_fun::\"real \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  where \"scaleR_fun = (\\<lambda>c f. (\\<lambda>x. c *\\<^sub>R f x))\""], ["", "lemma scaleR_apply [simp, code]: \"(c *\\<^sub>R f) x = c *\\<^sub>R (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c *\\<^sub>R f) x = c *\\<^sub>R f x", "by (simp add: scaleR_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, real_vector_class)", "by (standard, auto simp add: scaleR_add_right scaleR_add_left)"], ["", "end"], ["", "lemmas divideR_apply = scaleR_apply"], ["", "lemma [measurable]:\n  \"0 \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> borel_measurable M", "unfolding zero_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) \\<in> borel_measurable M", "by auto"], ["", "lemma borel_measurable_const_scaleR' [measurable (raw)]:\n  \"(f::('a \\<Rightarrow> 'b::real_normed_vector)) \\<in> borel_measurable M \\<Longrightarrow> c *\\<^sub>R f \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable M \\<Longrightarrow>\n    c *\\<^sub>R f \\<in> borel_measurable M", "unfolding scaleR_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable M \\<Longrightarrow>\n    (\\<lambda>x. c *\\<^sub>R f x) \\<in> borel_measurable M", "using borel_measurable_add"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> borel_measurable ?M;\n   ?g \\<in> borel_measurable ?M\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. ?f x + ?g x) \\<in> borel_measurable ?M\n\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable M \\<Longrightarrow>\n    (\\<lambda>x. c *\\<^sub>R f x) \\<in> borel_measurable M", "by auto"], ["", "lemma borel_measurable_add'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  assumes g: \"g \\<in> borel_measurable M\"\n  shows \"f + g \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f + g \\<in> borel_measurable M", "unfolding plus_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x + g x) \\<in> borel_measurable M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> borel_measurable M\n  g \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x + g x) \\<in> borel_measurable M", "by auto"], ["", "lemma borel_measurable_uminus'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  shows \"-f \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - f \\<in> borel_measurable M", "unfolding fun_Compl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. - f x) \\<in> borel_measurable M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. - f x) \\<in> borel_measurable M", "by auto"], ["", "lemma borel_measurable_diff'[measurable (raw)]:\n  fixes f g :: \"'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes f: \"f \\<in> borel_measurable M\"\n  assumes g: \"g \\<in> borel_measurable M\"\n  shows \"f - g \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f - g \\<in> borel_measurable M", "unfolding fun_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x - g x) \\<in> borel_measurable M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> borel_measurable M\n  g \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x - g x) \\<in> borel_measurable M", "by auto"], ["", "lemma borel_measurable_sum'[measurable (raw)]:\n  fixes f::\"'i \\<Rightarrow> 'a \\<Rightarrow> 'b::{second_countable_topology, real_normed_vector}\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> f i \\<in> borel_measurable M\"\n  shows \"(\\<Sum>i\\<in>I. f i) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f I \\<in> borel_measurable M", "using borel_measurable_sum[of I f, OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> I \\<Longrightarrow> i \\<in> I) \\<Longrightarrow>\n  (\\<lambda>x. \\<Sum>i\\<in>I. f i x) \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. sum f I \\<in> borel_measurable M", "unfolding fun_sum_apply[symmetric]"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> I \\<Longrightarrow> i \\<in> I) \\<Longrightarrow>\n  sum f I \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. sum f I \\<in> borel_measurable M", "by simp"], ["", "lemma zero_applied_to [simp]:\n  \"(0::('a \\<Rightarrow> ('b::real_vector))) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 x = (0::'b)", "unfolding zero_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) = (0::'b)", "by simp"], ["", "section \\<open>Quasinorms on function spaces\\<close>"], ["", "text \\<open>A central feature of modern analysis is the use of various functional\nspaces, and of results of functional analysis on them. Think for instance of\n$L^p$ spaces, of Sobolev or Besov spaces, or variations around them. Here are\nseveral relevant facts about this point of view:\n\\begin{itemize}\n\\item These spaces typically depend on one or several parameters.\nThis makes it difficult to play with type classes in a system without dependent\ntypes.\n\\item The $L^p$ spaces are not spaces of functions (their elements are\nequivalence classes of functions, where two functions are identified if they\ncoincide almost everywhere). However, in usual analysis proofs, one takes a\ndefinite representative and works with it, never going to the equivalence class\npoint of view (which only becomes relevant when one wants to use the fact that\none has a Banach space at our disposal, to apply functional analytic tools).\n\\item It is important to describe how the spaces are related to each other,\nwith respect to inclusions or compact inclusions. For instance, one of the most\nimportant theorems in analysis is Sobolev embedding theorem, describing when\none Sobolev space is included in another one. One also needs to be able to\ntake intersections or sums of Banach spaces, for instance to develop\ninterpolation theory.\n\\item Some other spaces play an important role in analysis, for instance the\nweak $L^1$ space. This space only has a quasi-norm (i.e., its norm satisfies the\ntriangular inequality up to a fixed multiplicative constant). A general enough setting\nshould also encompass this kind of space. (One could argue that one should also consider more\ngeneral topologies such as Frechet spaces, to deal with Gevrey or analytic functions.\nThis is true, but considering quasi-norms already gives a wealth of applications).\n\\end{itemize}\n\nGiven these points, it seems that the most effective way of formalizing this\nkind of question in Isabelle/HOL is to think of such a functional space not as\nan abstract space or type, but as a subset of the space of all functions or of\nall distributions. Functions that do not belong to the functional space\nunder consideration will then have infinite norm. Then inclusions, intersections,\nand so on, become trivial to implement. Since the same object contains both the information\nabout the norm and the space where the norm is finite, it conforms to the customary habit in\nmathematics of identifying the two of them, talking for instance about the $L^p$ space and the\n$L^p$ norm.\n\nAll in all, this approach seems quite promising for ``real life analysis''.\n\\<close>"], ["", "subsection \\<open>Definition of quasinorms\\<close>"], ["", "typedef (overloaded) ('a::real_vector) quasinorm = \"{(C::real, N::('a \\<Rightarrow> ennreal)). (C \\<ge> 1)\n      \\<and> (\\<forall> x c. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N(x)) \\<and> (\\<forall> x y. N(x+y) \\<le> C * N x + C * N y)}\"\nmorphisms Rep_quasinorm quasinorm_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {(x, N).\n                1 \\<le> ennreal x \\<and>\n                (\\<forall>x c.\n                    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n                (\\<forall>xa y.\n                    N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {(x, N).\n              1 \\<le> ennreal x \\<and>\n              (\\<forall>x c.\n                  N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n              (\\<forall>xa y.\n                  N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}", "show \"(1,(\\<lambda>x. 0)) \\<in> {(C::real, N::('a \\<Rightarrow> ennreal)). (C \\<ge> 1)\n      \\<and> (\\<forall> x c. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and> (\\<forall> x y. N (x+y) \\<le> C * N x + C * N y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, \\<lambda>x. 0)\n    \\<in> {(x, N).\n           1 \\<le> ennreal x \\<and>\n           (\\<forall>x c.\n               N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n           (\\<forall>xa y.\n               N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}", "by auto"], ["proof (state)\nthis:\n  (1, \\<lambda>x. 0)\n  \\<in> {(x, N).\n         1 \\<le> ennreal x \\<and>\n         (\\<forall>x c.\n             N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n         (\\<forall>xa y.\n             N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition eNorm::\"'a quasinorm \\<Rightarrow> ('a::real_vector) \\<Rightarrow> ennreal\"\n  where \"eNorm N x = (snd (Rep_quasinorm N)) x\""], ["", "definition defect::\"('a::real_vector) quasinorm \\<Rightarrow> real\"\n  where \"defect N = fst (Rep_quasinorm N)\""], ["", "lemma eNorm_triangular_ineq:\n  \"eNorm N (x + y) \\<le> defect N * eNorm N x + defect N * eNorm N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (x + y)\n    \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y", "unfolding eNorm_def defect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_quasinorm N) (x + y)\n    \\<le> ennreal (fst (Rep_quasinorm N)) * snd (Rep_quasinorm N) x +\n          ennreal (fst (Rep_quasinorm N)) * snd (Rep_quasinorm N) y", "using Rep_quasinorm[of N]"], ["proof (prove)\nusing this:\n  Rep_quasinorm N\n  \\<in> {(x, N).\n         1 \\<le> ennreal x \\<and>\n         (\\<forall>x c.\n             N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n         (\\<forall>xa y.\n             N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}\n\ngoal (1 subgoal):\n 1. snd (Rep_quasinorm N) (x + y)\n    \\<le> ennreal (fst (Rep_quasinorm N)) * snd (Rep_quasinorm N) x +\n          ennreal (fst (Rep_quasinorm N)) * snd (Rep_quasinorm N) y", "by auto"], ["", "lemma defect_ge_1:\n  \"defect N \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> defect N", "unfolding defect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> fst (Rep_quasinorm N)", "using Rep_quasinorm[of N]"], ["proof (prove)\nusing this:\n  Rep_quasinorm N\n  \\<in> {(x, N).\n         1 \\<le> ennreal x \\<and>\n         (\\<forall>x c.\n             N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n         (\\<forall>xa y.\n             N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}\n\ngoal (1 subgoal):\n 1. 1 \\<le> fst (Rep_quasinorm N)", "by auto"], ["", "lemma eNorm_cmult:\n  \"eNorm N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * eNorm N x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * eNorm N x", "unfolding eNorm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_quasinorm N) (c *\\<^sub>R x) =\n    ennreal \\<bar>c\\<bar> * snd (Rep_quasinorm N) x", "using Rep_quasinorm[of N]"], ["proof (prove)\nusing this:\n  Rep_quasinorm N\n  \\<in> {(x, N).\n         1 \\<le> ennreal x \\<and>\n         (\\<forall>x c.\n             N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n         (\\<forall>xa y.\n             N (xa + y) \\<le> ennreal x * N xa + ennreal x * N y)}\n\ngoal (1 subgoal):\n 1. snd (Rep_quasinorm N) (c *\\<^sub>R x) =\n    ennreal \\<bar>c\\<bar> * snd (Rep_quasinorm N) x", "by auto"], ["", "lemma eNorm_zero [simp]:\n  \"eNorm N 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (0::'a) = 0", "by (metis eNorm_cmult abs_zero ennreal_0 mult_zero_left real_vector.scale_zero_left)"], ["", "lemma eNorm_uminus [simp]:\n  \"eNorm N (-x) = eNorm N x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (- x) = eNorm N x", "using eNorm_cmult[of N \"-1\" x]"], ["proof (prove)\nusing this:\n  eNorm N (- 1 *\\<^sub>R x) = ennreal \\<bar>- 1\\<bar> * eNorm N x\n\ngoal (1 subgoal):\n 1. eNorm N (- x) = eNorm N x", "by auto"], ["", "lemma eNorm_sum:\n  \"eNorm N (\\<Sum>i\\<in>{..<n}. u i) \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (u i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "proof (cases \"n=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "by simp"], ["proof (state)\nthis:\n  eNorm N (sum u {..<n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain m where \"n = Suc m\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "have \"\\<And>v. eNorm N (\\<Sum>i\\<in>{..n}. v i) \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (v i)) + (defect N)^n * eNorm N (v n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       eNorm N (sum v {..n})\n       \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ n) * eNorm N (v n)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       eNorm N (sum v {..0})\n       \\<le> (\\<Sum>i<0. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ 0) * eNorm N (v 0)\n 2. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v.\n       eNorm N (sum v {..0})\n       \\<le> (\\<Sum>i<0. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ 0) * eNorm N (v 0)\n 2. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (sum v {..0})\n    \\<le> (\\<Sum>i<0. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n          ennreal (defect N ^ 0) * eNorm N (v 0)", "by simp"], ["proof (state)\nthis:\n  eNorm N (sum v {..0})\n  \\<le> (\\<Sum>i<0. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ 0) * eNorm N (v 0)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  eNorm N (sum ?v {..n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ n) * eNorm N (?v n)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have *: \"(defect N)^(Suc n) = (defect N)^n * ennreal(defect N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N ^ Suc n) = ennreal (defect N ^ n) * ennreal (defect N)", "by (metis defect_ge_1 ennreal_le_iff ennreal_neg ennreal_power less_le not_less not_one_le_zero semiring_normalization_rules(28))"], ["proof (state)\nthis:\n  ennreal (defect N ^ Suc n) = ennreal (defect N ^ n) * ennreal (defect N)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "fix v::\"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "define w where \"w = (\\<lambda>i. if i = n then v n + v (Suc n) else v i)\""], ["proof (state)\nthis:\n  w = (\\<lambda>i. if i = n then v n + v (Suc n) else v i)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"(\\<Sum>i\\<in>{..Suc n}. v i) = (\\<Sum>i\\<in>{..<n}. v i) + v n + v (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v {..Suc n} = sum v {..<n} + v n + v (Suc n)", "using lessThan_Suc_atMost sum.lessThan_Suc"], ["proof (prove)\nusing this:\n  {..<Suc ?k} = {..?k}\n  sum ?g {..<Suc ?n} = sum ?g {..<?n} + ?g ?n\n\ngoal (1 subgoal):\n 1. sum v {..Suc n} = sum v {..<n} + v n + v (Suc n)", "by auto"], ["proof (state)\nthis:\n  sum v {..Suc n} = sum v {..<n} + v n + v (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  sum v {..Suc n} = sum v {..<n} + v n + v (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... = (\\<Sum>i\\<in>{..<n}. w i) + w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v {..<n} + v n + v (Suc n) = sum w {..<n} + w n", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum v {..<n} + v n + v (Suc n) =\n    (\\<Sum>i<n. if i = n then v n + v (Suc n) else v i) +\n    (if n = n then v n + v (Suc n) else v n)", "by auto"], ["proof (state)\nthis:\n  sum v {..<n} + v n + v (Suc n) = sum w {..<n} + w n\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "finally"], ["proof (chain)\npicking this:\n  sum v {..Suc n} = sum w {..<n} + w n", "have \"(\\<Sum>i\\<in>{..Suc n}. v i) = (\\<Sum>i\\<in>{..n}. w i)\""], ["proof (prove)\nusing this:\n  sum v {..Suc n} = sum w {..<n} + w n\n\ngoal (1 subgoal):\n 1. sum v {..Suc n} = sum w {..n}", "by (metis lessThan_Suc_atMost sum.lessThan_Suc)"], ["proof (state)\nthis:\n  sum v {..Suc n} = sum w {..n}\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "then"], ["proof (chain)\npicking this:\n  sum v {..Suc n} = sum w {..n}", "have \"eNorm N (\\<Sum>i\\<in>{..Suc n}. v i) = eNorm N (\\<Sum>i\\<in>{..n}. w i)\""], ["proof (prove)\nusing this:\n  sum v {..Suc n} = sum w {..n}\n\ngoal (1 subgoal):\n 1. eNorm N (sum v {..Suc n}) = eNorm N (sum w {..n})", "by simp"], ["proof (state)\nthis:\n  eNorm N (sum v {..Suc n}) = eNorm N (sum w {..n})\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  eNorm N (sum v {..Suc n}) = eNorm N (sum w {..n})\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (w i)) + (defect N)^n * eNorm N (w n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (sum w {..n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n          ennreal (defect N ^ n) * eNorm N (w n)", "using Suc.IH"], ["proof (prove)\nusing this:\n  eNorm N (sum ?v {..n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ n) * eNorm N (?v n)\n\ngoal (1 subgoal):\n 1. eNorm N (sum w {..n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n          ennreal (defect N ^ n) * eNorm N (w n)", "by auto"], ["proof (state)\nthis:\n  eNorm N (sum w {..n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n        ennreal (defect N ^ n) * eNorm N (w n)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  eNorm N (sum w {..n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n        ennreal (defect N ^ n) * eNorm N (w n)\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... = (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (v i)) + (defect N)^n * eNorm N (v n + v (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n    ennreal (defect N ^ n) * eNorm N (w n) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ennreal (defect N ^ Suc i) *\n        eNorm N (if i = n then v n + v (Suc n) else v i)) +\n    ennreal (defect N ^ n) *\n    eNorm N (if n = n then v n + v (Suc n) else v n) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n  ennreal (defect N ^ n) * eNorm N (w n) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (w i)) +\n  ennreal (defect N ^ n) * eNorm N (w n) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (v i)) +\n          (defect N)^n * (defect N * eNorm N (v n) + defect N * eNorm N (v (Suc n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n          ennreal (defect N ^ n) *\n          (ennreal (defect N) * eNorm N (v n) +\n           ennreal (defect N) * eNorm N (v (Suc n)))", "by (rule add_mono, simp, rule mult_left_mono, auto simp add: eNorm_triangular_ineq)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ n) *\n        (ennreal (defect N) * eNorm N (v n) +\n         ennreal (defect N) * eNorm N (v (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) * eNorm N (v n + v (Suc n))\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ n) *\n        (ennreal (defect N) * eNorm N (v n) +\n         ennreal (defect N) * eNorm N (v (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... = (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (v i))\n        + (defect N)^(Suc n) * eNorm N (v n) + (defect N)^(Suc n) * eNorm N (v (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) *\n    (ennreal (defect N) * eNorm N (v n) +\n     ennreal (defect N) * eNorm N (v (Suc n))) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ Suc n) * eNorm N (v n) +\n    ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) *\n    (ennreal (defect N) * eNorm N (v n) +\n     ennreal (defect N) * eNorm N (v (Suc n))) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ n) * ennreal (defect N) * eNorm N (v n) +\n    ennreal (defect N ^ n) * ennreal (defect N) * eNorm N (v (Suc n))", "by (simp add: distrib_left semiring_normalization_rules(18))"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) *\n  (ennreal (defect N) * eNorm N (v n) +\n   ennreal (defect N) * eNorm N (v (Suc n))) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ Suc n) * eNorm N (v n) +\n  ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ n) *\n  (ennreal (defect N) * eNorm N (v n) +\n   ennreal (defect N) * eNorm N (v (Suc n))) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ Suc n) * eNorm N (v n) +\n  ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "have \"... = (\\<Sum>i\\<in>{..<Suc n}. (defect N)^(Suc i) * eNorm N (v i)) + (defect N)^(Suc n) * eNorm N (v (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ Suc n) * eNorm N (v n) +\n    ennreal (defect N ^ Suc n) * eNorm N (v (Suc n)) =\n    (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n    ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ Suc n) * eNorm N (v n) +\n  ennreal (defect N ^ Suc n) * eNorm N (v (Suc n)) =\n  (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n  ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (\\<And>v.\n           eNorm N (sum v {..n})\n           \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n                 ennreal (defect N ^ n) * eNorm N (v n)) \\<Longrightarrow>\n       eNorm N (sum v {..Suc n})\n       \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n             ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "finally"], ["proof (chain)\npicking this:\n  eNorm N (sum v {..Suc n})\n  \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "show \"eNorm N (\\<Sum>i\\<in>{..Suc n}. v i)\n            \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) + ennreal (defect N ^ Suc n) * eNorm N (v (Suc n)) \""], ["proof (prove)\nusing this:\n  eNorm N (sum v {..Suc n})\n  \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))\n\ngoal (1 subgoal):\n 1. eNorm N (sum v {..Suc n})\n    \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n          ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))", "by simp"], ["proof (state)\nthis:\n  eNorm N (sum v {..Suc n})\n  \\<le> (\\<Sum>i<Suc n. ennreal (defect N ^ Suc i) * eNorm N (v i)) +\n        ennreal (defect N ^ Suc n) * eNorm N (v (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eNorm N (sum ?v {..?n1})\n  \\<le> (\\<Sum>i<?n1. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ ?n1) * eNorm N (?v ?n1)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "then"], ["proof (chain)\npicking this:\n  eNorm N (sum ?v {..?n1})\n  \\<le> (\\<Sum>i<?n1. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ ?n1) * eNorm N (?v ?n1)", "have \"eNorm N (\\<Sum>i\\<in>{..<Suc m}. u i)\n      \\<le> (\\<Sum>i\\<in>{..<m}. (defect N)^(Suc i) * eNorm N (u i)) + (defect N)^m * eNorm N (u m)\""], ["proof (prove)\nusing this:\n  eNorm N (sum ?v {..?n1})\n  \\<le> (\\<Sum>i<?n1. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ ?n1) * eNorm N (?v ?n1)\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<Suc m})\n    \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n          ennreal (defect N ^ m) * eNorm N (u m)", "using lessThan_Suc_atMost"], ["proof (prove)\nusing this:\n  eNorm N (sum ?v {..?n1})\n  \\<le> (\\<Sum>i<?n1. ennreal (defect N ^ Suc i) * eNorm N (?v i)) +\n        ennreal (defect N ^ ?n1) * eNorm N (?v ?n1)\n  {..<Suc ?k} = {..?k}\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<Suc m})\n    \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n          ennreal (defect N ^ m) * eNorm N (u m)", "by auto"], ["proof (state)\nthis:\n  eNorm N (sum u {..<Suc m})\n  \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n        ennreal (defect N ^ m) * eNorm N (u m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "also"], ["proof (state)\nthis:\n  eNorm N (sum u {..<Suc m})\n  \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n        ennreal (defect N ^ m) * eNorm N (u m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "have \"... \\<le> (\\<Sum>i\\<in>{..<m}. (defect N)^(Suc i) * eNorm N (u i)) + (defect N)^(Suc m) * eNorm N (u m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n    ennreal (defect N ^ m) * eNorm N (u m)\n    \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n          ennreal (defect N ^ Suc m) * eNorm N (u m)", "apply (rule add_mono, auto intro!: mult_right_mono ennreal_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. defect N ^ m \\<le> defect N * defect N ^ m", "using defect_ge_1"], ["proof (prove)\nusing this:\n  1 \\<le> defect ?N\n\ngoal (1 subgoal):\n 1. defect N ^ m \\<le> defect N * defect N ^ m", "by (metis atMost_iff le_less lessThan_Suc_atMost lessThan_iff power_Suc power_increasing)"], ["proof (state)\nthis:\n  (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n  ennreal (defect N ^ m) * eNorm N (u m)\n  \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n        ennreal (defect N ^ Suc m) * eNorm N (u m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n  ennreal (defect N ^ m) * eNorm N (u m)\n  \\<le> (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n        ennreal (defect N ^ Suc m) * eNorm N (u m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "have \"... = (\\<Sum>i\\<in>{..<Suc m}. (defect N)^(Suc i) * eNorm N (u i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n    ennreal (defect N ^ Suc m) * eNorm N (u m) =\n    (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<m. ennreal (defect N ^ Suc i) * eNorm N (u i)) +\n  ennreal (defect N ^ Suc m) * eNorm N (u m) =\n  (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "finally"], ["proof (chain)\npicking this:\n  eNorm N (sum u {..<Suc m})\n  \\<le> (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))", "show \"eNorm N (\\<Sum>i\\<in>{..<n}. u i) \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\""], ["proof (prove)\nusing this:\n  eNorm N (sum u {..<Suc m})\n  \\<le> (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "unfolding \\<open>n = Suc m\\<close>"], ["proof (prove)\nusing this:\n  eNorm N (sum u {..<Suc m})\n  \\<le> (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<Suc m})\n    \\<le> (\\<Sum>i<Suc m. ennreal (defect N ^ Suc i) * eNorm N (u i))", "by auto"], ["proof (state)\nthis:\n  eNorm N (sum u {..<n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Quasinorms are often defined by taking a meaningful formula on a vector subspace,\nand then extending by infinity elsewhere. Let us show that this results in a quasinorm on the\nwhole space.\\<close>"], ["", "definition quasinorm_on::\"('a set) \\<Rightarrow> real \\<Rightarrow> (('a::real_vector) \\<Rightarrow> ennreal) \\<Rightarrow> bool\"\n  where \"quasinorm_on F C N = (\n    (\\<forall>x y. (x \\<in> F \\<and> y \\<in> F) \\<longrightarrow> (x + y \\<in> F) \\<and> N (x+y) \\<le> C * N x + C * N y)\n    \\<and> (\\<forall>c x. x \\<in> F \\<longrightarrow> c *\\<^sub>R x \\<in> F \\<and> N(c *\\<^sub>R x) = \\<bar>c\\<bar> * N x)\n    \\<and> C \\<ge> 1 \\<and> 0 \\<in> F)\""], ["", "lemma quasinorm_of:\n  fixes N::\"('a::real_vector) \\<Rightarrow> ennreal\" and C::real\n  assumes \"quasinorm_on UNIV C N\"\n  shows \"eNorm (quasinorm_of (C,N)) x = N x\"\n        \"defect (quasinorm_of (C,N)) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm (quasinorm_of (C, N)) x = N x &&& defect (quasinorm_of (C, N)) = C", "using assms"], ["proof (prove)\nusing this:\n  quasinorm_on UNIV C N\n\ngoal (1 subgoal):\n 1. eNorm (quasinorm_of (C, N)) x = N x &&& defect (quasinorm_of (C, N)) = C", "unfolding eNorm_def defect_def quasinorm_on_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y.\n      x \\<in> UNIV \\<and> y \\<in> UNIV \\<longrightarrow>\n      x + y \\<in> UNIV \\<and>\n      N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n  (\\<forall>c x.\n      x \\<in> UNIV \\<longrightarrow>\n      c *\\<^sub>R x \\<in> UNIV \\<and>\n      N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n  1 \\<le> C \\<and> (0::'a) \\<in> UNIV\n\ngoal (1 subgoal):\n 1. snd (Rep_quasinorm (quasinorm_of (C, N))) x = N x &&&\n    fst (Rep_quasinorm (quasinorm_of (C, N))) = C", "by (auto simp add: quasinorm_of_inverse)"], ["", "lemma quasinorm_onI:\n  fixes N::\"('a::real_vector) \\<Rightarrow> ennreal\" and C::real and F::\"'a set\"\n  assumes \"\\<And>x y. x \\<in> F \\<Longrightarrow> y \\<in> F \\<Longrightarrow> x + y \\<in> F\"\n          \"\\<And>x y. x \\<in> F \\<Longrightarrow> y \\<in> F \\<Longrightarrow> N (x + y) \\<le> C * N x + C * N y\"\n          \"\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> c *\\<^sub>R x \\<in> F\"\n          \"\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> N (c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * N x\"\n          \"0 \\<in> F\" \"N(0) = 0\" \"C \\<ge> 1\"\n  shows \"quasinorm_on F C N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on F C N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quasinorm_on F C N", "have \"N(c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x\" if \"x \\<in> F\" for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "using \\<open>N 0 = 0\\<close>"], ["proof (prove)\nusing this:\n  c = 0\n  N (0::'a) = 0\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "by auto"], ["proof (state)\nthis:\n  N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "have \"N((1/c) *\\<^sub>R (c *\\<^sub>R x)) \\<le> ennreal (abs (1/c)) * N (c *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N ((1 / c) *\\<^sub>R c *\\<^sub>R x)\n    \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)", "apply (rule \\<open>\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> N(c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * N x\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 / c \\<noteq> 0\n 2. c *\\<^sub>R x \\<in> F", "using False assms that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  \\<lbrakk>?x \\<in> F; ?y \\<in> F\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> F\n  \\<lbrakk>?x \\<in> F; ?y \\<in> F\\<rbrakk>\n  \\<Longrightarrow> N (?x + ?y) \\<le> ennreal C * N ?x + ennreal C * N ?y\n  \\<lbrakk>?c \\<noteq> 0; ?x \\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?c *\\<^sub>R ?x \\<in> F\n  \\<lbrakk>?c \\<noteq> 0; ?x \\<in> F\\<rbrakk>\n  \\<Longrightarrow> N (?c *\\<^sub>R ?x) \\<le> ennreal \\<bar>?c\\<bar> * N ?x\n  (0::'a) \\<in> F\n  N (0::'a) = 0\n  1 \\<le> C\n  x \\<in> F\n\ngoal (2 subgoals):\n 1. 1 / c \\<noteq> 0\n 2. c *\\<^sub>R x \\<in> F", "by auto"], ["proof (state)\nthis:\n  N ((1 / c) *\\<^sub>R c *\\<^sub>R x)\n  \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "then"], ["proof (chain)\npicking this:\n  N ((1 / c) *\\<^sub>R c *\\<^sub>R x)\n  \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)", "have \"N x \\<le> ennreal (abs (1/c)) * N (c *\\<^sub>R x)\""], ["proof (prove)\nusing this:\n  N ((1 / c) *\\<^sub>R c *\\<^sub>R x)\n  \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. N x \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)", "using False"], ["proof (prove)\nusing this:\n  N ((1 / c) *\\<^sub>R c *\\<^sub>R x)\n  \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. N x \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)", "by auto"], ["proof (state)\nthis:\n  N x \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "then"], ["proof (chain)\npicking this:\n  N x \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)", "have \"ennreal \\<bar>c\\<bar> * N x \\<le> ennreal \\<bar>c\\<bar> * ennreal (abs (1/c)) * N (c *\\<^sub>R x)\""], ["proof (prove)\nusing this:\n  N x \\<le> ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. ennreal \\<bar>c\\<bar> * N x\n    \\<le> ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> *\n          N (c *\\<^sub>R x)", "by (simp add: mult.assoc mult_left_mono)"], ["proof (state)\nthis:\n  ennreal \\<bar>c\\<bar> * N x\n  \\<le> ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> *\n        N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "also"], ["proof (state)\nthis:\n  ennreal \\<bar>c\\<bar> * N x\n  \\<le> ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> *\n        N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "have \"... = N (c *\\<^sub>R x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x) =\n    N (c *\\<^sub>R x)", "using ennreal_mult' abs_mult False"], ["proof (prove)\nusing this:\n  0 \\<le> ?a \\<Longrightarrow> ennreal (?a * ?b) = ennreal ?a * ennreal ?b\n  \\<bar>?a * ?b\\<bar> = \\<bar>?a\\<bar> * \\<bar>?b\\<bar>\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x) =\n    N (c *\\<^sub>R x)", "by (metis abs_ge_zero abs_one comm_monoid_mult_class.mult_1 ennreal_1 eq_divide_eq_1 field_class.field_divide_inverse)"], ["proof (state)\nthis:\n  ennreal \\<bar>c\\<bar> * ennreal \\<bar>1 / c\\<bar> * N (c *\\<^sub>R x) =\n  N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "finally"], ["proof (chain)\npicking this:\n  ennreal \\<bar>c\\<bar> * N x \\<le> N (c *\\<^sub>R x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal \\<bar>c\\<bar> * N x \\<le> N (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "using \\<open>\\<And>c x. c \\<noteq> 0 \\<Longrightarrow> x \\<in> F \\<Longrightarrow> N(c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * N x\\<close>[OF False \\<open>x \\<in> F\\<close>]"], ["proof (prove)\nusing this:\n  ennreal \\<bar>c\\<bar> * N x \\<le> N (c *\\<^sub>R x)\n  N (c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * N x\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x", "by auto"], ["proof (state)\nthis:\n  N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> F \\<Longrightarrow>\n  N (?c *\\<^sub>R ?x) = ennreal \\<bar>?c\\<bar> * N ?x\n\ngoal (1 subgoal):\n 1. quasinorm_on F C N", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> F \\<Longrightarrow>\n  N (?c *\\<^sub>R ?x) = ennreal \\<bar>?c\\<bar> * N ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> F \\<Longrightarrow>\n  N (?c *\\<^sub>R ?x) = ennreal \\<bar>?c\\<bar> * N ?x\n\ngoal (1 subgoal):\n 1. quasinorm_on F C N", "unfolding quasinorm_on_def"], ["proof (prove)\nusing this:\n  ?x \\<in> F \\<Longrightarrow>\n  N (?c *\\<^sub>R ?x) = ennreal \\<bar>?c\\<bar> * N ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n        x + y \\<in> F \\<and>\n        N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n    (\\<forall>c x.\n        x \\<in> F \\<longrightarrow>\n        c *\\<^sub>R x \\<in> F \\<and>\n        N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n    1 \\<le> C \\<and> (0::'a) \\<in> F", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> F \\<Longrightarrow>\n  N (?c *\\<^sub>R ?x) = ennreal \\<bar>?c\\<bar> * N ?x\n  \\<lbrakk>?x \\<in> F; ?y \\<in> F\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> F\n  \\<lbrakk>?x \\<in> F; ?y \\<in> F\\<rbrakk>\n  \\<Longrightarrow> N (?x + ?y) \\<le> ennreal C * N ?x + ennreal C * N ?y\n  \\<lbrakk>?c \\<noteq> 0; ?x \\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?c *\\<^sub>R ?x \\<in> F\n  \\<lbrakk>?c \\<noteq> 0; ?x \\<in> F\\<rbrakk>\n  \\<Longrightarrow> N (?c *\\<^sub>R ?x) \\<le> ennreal \\<bar>?c\\<bar> * N ?x\n  (0::'a) \\<in> F\n  N (0::'a) = 0\n  1 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n        x + y \\<in> F \\<and>\n        N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n    (\\<forall>c x.\n        x \\<in> F \\<longrightarrow>\n        c *\\<^sub>R x \\<in> F \\<and>\n        N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n    1 \\<le> C \\<and> (0::'a) \\<in> F", "by (auto, metis real_vector.scale_zero_left)"], ["proof (state)\nthis:\n  quasinorm_on F C N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_quasinorm:\n  assumes \"quasinorm_on F C N\"\n  shows \"quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)", "have *: \"(if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) + ennreal C * (if y \\<in> F then N y else \\<infinity>)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "proof (cases \"x \\<in> F \\<and> y \\<in> F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> F \\<and> y \\<in> F \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)\n 2. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  x \\<in> F \\<and> y \\<in> F\n\ngoal (2 subgoals):\n 1. x \\<in> F \\<and> y \\<in> F \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)\n 2. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> F \\<and> y \\<in> F", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> F \\<and> y \\<in> F\n\ngoal (1 subgoal):\n 1. (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> F \\<and> y \\<in> F\n  quasinorm_on F C N\n\ngoal (1 subgoal):\n 1. (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "unfolding quasinorm_on_def"], ["proof (prove)\nusing this:\n  x \\<in> F \\<and> y \\<in> F\n  (\\<forall>x y.\n      x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n      x + y \\<in> F \\<and>\n      N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n  (\\<forall>c x.\n      x \\<in> F \\<longrightarrow>\n      c *\\<^sub>R x \\<in> F \\<and>\n      N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n  1 \\<le> C \\<and> (0::'a) \\<in> F\n\ngoal (1 subgoal):\n 1. (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  (if x + y \\<in> F then N (x + y) else \\<infinity>)\n  \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n        ennreal C * (if y \\<in> F then N y else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  \\<not> (x \\<in> F \\<and> y \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  \\<not> (x \\<in> F \\<and> y \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "have \"C \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> C", "using assms"], ["proof (prove)\nusing this:\n  quasinorm_on F C N\n\ngoal (1 subgoal):\n 1. 1 \\<le> C", "unfolding quasinorm_on_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y.\n      x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n      x + y \\<in> F \\<and>\n      N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n  (\\<forall>c x.\n      x \\<in> F \\<longrightarrow>\n      c *\\<^sub>R x \\<in> F \\<and>\n      N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n  1 \\<le> C \\<and> (0::'a) \\<in> F\n\ngoal (1 subgoal):\n 1. 1 \\<le> C", "by auto"], ["proof (state)\nthis:\n  1 \\<le> C\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (x \\<in> F \\<and> y \\<in> F)\n  1 \\<le> C", "have *: \"ennreal C * (if x \\<in> F then N x else \\<infinity>) + ennreal C * (if y \\<in> F then N y else \\<infinity>) = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> F \\<and> y \\<in> F)\n  1 \\<le> C\n\ngoal (1 subgoal):\n 1. ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n    ennreal C * (if y \\<in> F then N y else \\<infinity>) =\n    \\<infinity>", "using ennreal_mult_eq_top_iff"], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> F \\<and> y \\<in> F)\n  1 \\<le> C\n  (?a * ?b = \\<top>) =\n  (?a = \\<top> \\<and> ?b \\<noteq> 0 \\<or> ?b = \\<top> \\<and> ?a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n    ennreal C * (if y \\<in> F then N y else \\<infinity>) =\n    \\<infinity>", "by auto"], ["proof (state)\nthis:\n  ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n  ennreal C * (if y \\<in> F then N y else \\<infinity>) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> F \\<and> y \\<in> F) \\<Longrightarrow>\n    (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x + y \\<in> F then N (x + y) else \\<infinity>)\n    \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n          ennreal C * (if y \\<in> F then N y else \\<infinity>)", "by (simp add: *)"], ["proof (state)\nthis:\n  (if x + y \\<in> F then N (x + y) else \\<infinity>)\n  \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n        ennreal C * (if y \\<in> F then N y else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if ?x + ?y \\<in> F then N (?x + ?y) else \\<infinity>)\n  \\<le> ennreal C * (if ?x \\<in> F then N ?x else \\<infinity>) +\n        ennreal C * (if ?y \\<in> F then N ?y else \\<infinity>)\n\ngoal (1 subgoal):\n 1. quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)", "apply (rule quasinorm_onI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if x + y \\<in> F then N (x + y) else \\<infinity>)\n                         \\<le> ennreal C *\n                               (if x \\<in> F then N x else \\<infinity>) +\n                               ennreal C *\n                               (if y \\<in> F then N y else \\<infinity>)\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if c *\\<^sub>R x \\<in> F then N (c *\\<^sub>R x)\n                          else \\<infinity>)\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               (if x \\<in> F then N x else \\<infinity>)\n 5. (0::'a) \\<in> UNIV\n 6. (if (0::'a) \\<in> F then N (0::'a) else \\<infinity>) = 0\n 7. 1 \\<le> C", "using assms *"], ["proof (prove)\nusing this:\n  quasinorm_on F C N\n  (if ?x + ?y \\<in> F then N (?x + ?y) else \\<infinity>)\n  \\<le> ennreal C * (if ?x \\<in> F then N ?x else \\<infinity>) +\n        ennreal C * (if ?y \\<in> F then N ?y else \\<infinity>)\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if x + y \\<in> F then N (x + y) else \\<infinity>)\n                         \\<le> ennreal C *\n                               (if x \\<in> F then N x else \\<infinity>) +\n                               ennreal C *\n                               (if y \\<in> F then N y else \\<infinity>)\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if c *\\<^sub>R x \\<in> F then N (c *\\<^sub>R x)\n                          else \\<infinity>)\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               (if x \\<in> F then N x else \\<infinity>)\n 5. (0::'a) \\<in> UNIV\n 6. (if (0::'a) \\<in> F then N (0::'a) else \\<infinity>) = 0\n 7. 1 \\<le> C", "unfolding quasinorm_on_def"], ["proof (prove)\nusing this:\n  (\\<forall>x y.\n      x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n      x + y \\<in> F \\<and>\n      N (x + y) \\<le> ennreal C * N x + ennreal C * N y) \\<and>\n  (\\<forall>c x.\n      x \\<in> F \\<longrightarrow>\n      c *\\<^sub>R x \\<in> F \\<and>\n      N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * N x) \\<and>\n  1 \\<le> C \\<and> (0::'a) \\<in> F\n  (if ?x + ?y \\<in> F then N (?x + ?y) else \\<infinity>)\n  \\<le> ennreal C * (if ?x \\<in> F then N ?x else \\<infinity>) +\n        ennreal C * (if ?y \\<in> F then N ?y else \\<infinity>)\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if x + y \\<in> F then N (x + y) else \\<infinity>)\n                         \\<le> ennreal C *\n                               (if x \\<in> F then N x else \\<infinity>) +\n                               ennreal C *\n                               (if y \\<in> F then N y else \\<infinity>)\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (if c *\\<^sub>R x \\<in> F then N (c *\\<^sub>R x)\n                          else \\<infinity>)\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               (if x \\<in> F then N x else \\<infinity>)\n 5. (0::'a) \\<in> UNIV\n 6. (if (0::'a) \\<in> F then N (0::'a) else \\<infinity>) = 0\n 7. 1 \\<le> C", "apply (auto simp add: ennreal_top_mult mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                (if x + y \\<in> F then N (x + y) else \\<infinity>)\n                \\<le> ennreal C * (if x \\<in> F then N x else \\<infinity>) +\n                      ennreal C * (if y \\<in> F then N y else \\<infinity>);\n     \\<forall>x y.\n        x \\<in> F \\<and> y \\<in> F \\<longrightarrow>\n        x + y \\<in> F \\<and>\n        N (x + y) \\<le> ennreal C * N x + ennreal C * N y;\n     \\<forall>c x.\n        x \\<in> F \\<longrightarrow>\n        c *\\<^sub>R x \\<in> F \\<and>\n        N (c *\\<^sub>R x) = N x * ennreal \\<bar>c\\<bar>;\n     1 \\<le> C; (0::'a) \\<in> F\\<rbrakk>\n    \\<Longrightarrow> N (0::'a) = 0", "by (metis abs_zero ennreal_0 mult_zero_right real_vector.scale_zero_right)"], ["proof (state)\nthis:\n  quasinorm_on UNIV C (\\<lambda>x. if x \\<in> F then N x else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The space and the zero space of a quasinorm\\<close>"], ["", "text \\<open>The space of a quasinorm is the vector subspace where it is meaningful, i.e., finite.\\<close>"], ["", "definition space\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> 'a set\"\n  where \"space\\<^sub>N N = {f. eNorm N f < \\<infinity>}\""], ["", "lemma spaceN_iff:\n  \"x \\<in> space\\<^sub>N N \\<longleftrightarrow> eNorm N x < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> space\\<^sub>N N) = (eNorm N x < \\<infinity>)", "unfolding space\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {f. eNorm N f < \\<infinity>}) = (eNorm N x < \\<infinity>)", "by simp"], ["", "lemma spaceN_cmult [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"c *\\<^sub>R x \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R x \\<in> space\\<^sub>N N", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. c *\\<^sub>R x \\<in> space\\<^sub>N N", "unfolding spaceN_iff"], ["proof (prove)\nusing this:\n  eNorm N x < \\<infinity>\n\ngoal (1 subgoal):\n 1. eNorm N (c *\\<^sub>R x) < \\<infinity>", "using eNorm_cmult[of N c x]"], ["proof (prove)\nusing this:\n  eNorm N x < \\<infinity>\n  eNorm N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * eNorm N x\n\ngoal (1 subgoal):\n 1. eNorm N (c *\\<^sub>R x) < \\<infinity>", "by (simp add: ennreal_mult_less_top)"], ["", "lemma spaceN_add [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\" \"y \\<in> space\\<^sub>N N\"\n  shows \"x + y \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "have \"eNorm N x < \\<infinity>\" \"eNorm N y < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N x < \\<infinity> &&& eNorm N y < \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space\\<^sub>N N\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. eNorm N x < \\<infinity> &&& eNorm N y < \\<infinity>", "unfolding space\\<^sub>N_def"], ["proof (prove)\nusing this:\n  x \\<in> {f. eNorm N f < \\<infinity>}\n  y \\<in> {f. eNorm N f < \\<infinity>}\n\ngoal (1 subgoal):\n 1. eNorm N x < \\<infinity> &&& eNorm N y < \\<infinity>", "by auto"], ["proof (state)\nthis:\n  eNorm N x < \\<infinity>\n  eNorm N y < \\<infinity>\n\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  eNorm N x < \\<infinity>\n  eNorm N y < \\<infinity>", "have \"defect N * eNorm N x + defect N * eNorm N y < \\<infinity>\""], ["proof (prove)\nusing this:\n  eNorm N x < \\<infinity>\n  eNorm N y < \\<infinity>\n\ngoal (1 subgoal):\n 1. ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n    < \\<infinity>", "by (simp add: ennreal_mult_less_top)"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  < \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "unfolding space\\<^sub>N_def"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. x + y \\<in> {f. eNorm N f < \\<infinity>}", "using eNorm_triangular_ineq[of N x y] le_less_trans"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  < \\<infinity>\n  eNorm N (x + y)\n  \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. x + y \\<in> {f. eNorm N f < \\<infinity>}", "by blast"], ["proof (state)\nthis:\n  x + y \\<in> space\\<^sub>N N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spaceN_diff [simp]:\n  assumes \"x \\<in> space\\<^sub>N N\" \"y \\<in> space\\<^sub>N N\"\n  shows \"x - y \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y \\<in> space\\<^sub>N N", "using spaceN_add[OF assms(1) spaceN_cmult[OF assms(2), of \"-1\"]]"], ["proof (prove)\nusing this:\n  x + - 1 *\\<^sub>R y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. x - y \\<in> space\\<^sub>N N", "by auto"], ["", "lemma spaceN_contains_zero [simp]:\n  \"0 \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> space\\<^sub>N N", "unfolding space\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> {f. eNorm N f < \\<infinity>}", "by auto"], ["", "lemma spaceN_sum [simp]:\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> x i \\<in> space\\<^sub>N N\"\n  shows \"(\\<Sum>i\\<in>I. x i) \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum x I \\<in> space\\<^sub>N N", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> x ?i \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. sum x I \\<in> space\\<^sub>N N", "by (induction I rule: infinite_finite_induct, auto)"], ["", "text \\<open>The zero space of a quasinorm is the vector subspace of vectors with zero norm. If one wants\nto get a true metric space, one should quotient the space by the zero space.\\<close>"], ["", "definition zero_space\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> 'a set\"\n  where \"zero_space\\<^sub>N N = {f. eNorm N f = 0}\""], ["", "lemma zero_spaceN_iff:\n  \"x \\<in> zero_space\\<^sub>N N \\<longleftrightarrow> eNorm N x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> zero_space\\<^sub>N N) = (eNorm N x = 0)", "unfolding zero_space\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {f. eNorm N f = 0}) = (eNorm N x = 0)", "by simp"], ["", "lemma zero_spaceN_cmult:\n  assumes \"x \\<in> zero_space\\<^sub>N N\"\n  shows \"c *\\<^sub>R x \\<in> zero_space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R x \\<in> zero_space\\<^sub>N N", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> zero_space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. c *\\<^sub>R x \\<in> zero_space\\<^sub>N N", "unfolding zero_spaceN_iff"], ["proof (prove)\nusing this:\n  eNorm N x = 0\n\ngoal (1 subgoal):\n 1. eNorm N (c *\\<^sub>R x) = 0", "using eNorm_cmult[of N c x]"], ["proof (prove)\nusing this:\n  eNorm N x = 0\n  eNorm N (c *\\<^sub>R x) = ennreal \\<bar>c\\<bar> * eNorm N x\n\ngoal (1 subgoal):\n 1. eNorm N (c *\\<^sub>R x) = 0", "by simp"], ["", "lemma zero_spaceN_add:\n  assumes \"x \\<in> zero_space\\<^sub>N N\" \"y \\<in> zero_space\\<^sub>N N\"\n  shows \"x + y \\<in> zero_space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> zero_space\\<^sub>N N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> zero_space\\<^sub>N N", "have \"eNorm N x = 0\" \"eNorm N y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N x = 0 &&& eNorm N y = 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> zero_space\\<^sub>N N\n  y \\<in> zero_space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. eNorm N x = 0 &&& eNorm N y = 0", "unfolding zero_space\\<^sub>N_def"], ["proof (prove)\nusing this:\n  x \\<in> {f. eNorm N f = 0}\n  y \\<in> {f. eNorm N f = 0}\n\ngoal (1 subgoal):\n 1. eNorm N x = 0 &&& eNorm N y = 0", "by auto"], ["proof (state)\nthis:\n  eNorm N x = 0\n  eNorm N y = 0\n\ngoal (1 subgoal):\n 1. x + y \\<in> zero_space\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  eNorm N x = 0\n  eNorm N y = 0", "have \"defect N * eNorm N x + defect N * eNorm N y = 0\""], ["proof (prove)\nusing this:\n  eNorm N x = 0\n  eNorm N y = 0\n\ngoal (1 subgoal):\n 1. ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0", "by auto"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0\n\ngoal (1 subgoal):\n 1. x + y \\<in> zero_space\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0\n\ngoal (1 subgoal):\n 1. x + y \\<in> zero_space\\<^sub>N N", "unfolding zero_spaceN_iff"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0\n\ngoal (1 subgoal):\n 1. eNorm N (x + y) = 0", "using eNorm_triangular_ineq[of N x y]"], ["proof (prove)\nusing this:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y = 0\n  eNorm N (x + y)\n  \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n\ngoal (1 subgoal):\n 1. eNorm N (x + y) = 0", "by auto"], ["proof (state)\nthis:\n  x + y \\<in> zero_space\\<^sub>N N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_spaceN_diff:\n  assumes \"x \\<in> zero_space\\<^sub>N N\" \"y \\<in> zero_space\\<^sub>N N\"\n  shows \"x - y \\<in> zero_space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y \\<in> zero_space\\<^sub>N N", "using zero_spaceN_add[OF assms(1) zero_spaceN_cmult[OF assms(2), of \"-1\"]]"], ["proof (prove)\nusing this:\n  x + - 1 *\\<^sub>R y \\<in> zero_space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. x - y \\<in> zero_space\\<^sub>N N", "by auto"], ["", "lemma zero_spaceN_subset_spaceN:\n  \"zero_space\\<^sub>N N \\<subseteq> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N N \\<subseteq> space\\<^sub>N N", "by (simp add: spaceN_iff zero_spaceN_iff subset_eq)"], ["", "text \\<open>On the space, the norms are finite. Hence, it is much more convenient to work there with\na real valued version of the norm. We use Norm with a capital N to distinguish it from norms\nin a (type class) banach space.\\<close>"], ["", "definition Norm::\"'a quasinorm \\<Rightarrow> ('a::real_vector) \\<Rightarrow> real\"\n  where \"Norm N x = enn2real (eNorm N x)\""], ["", "lemma Norm_nonneg [simp]:\n  \"Norm N x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Norm N x", "unfolding Norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> enn2real (eNorm N x)", "by auto"], ["", "lemma Norm_zero [simp]:\n  \"Norm N 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (0::'a) = 0", "unfolding Norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (eNorm N (0::'a)) = 0", "by auto"], ["", "lemma Norm_uminus [simp]:\n  \"Norm N (-x) = Norm N x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (- x) = Norm N x", "unfolding Norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (eNorm N (- x)) = enn2real (eNorm N x)", "by auto"], ["", "lemma eNorm_Norm:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"eNorm N x = ennreal (Norm N x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N x = ennreal (Norm N x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. eNorm N x = ennreal (Norm N x)", "unfolding Norm_def"], ["proof (prove)\nusing this:\n  x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. eNorm N x = ennreal (enn2real (eNorm N x))", "by (simp add: spaceN_iff)"], ["", "lemma eNorm_Norm':\n  assumes \"x \\<notin> space\\<^sub>N N\"\n  shows \"Norm N x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N x = 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. Norm N x = 0", "unfolding Norm_def"], ["proof (prove)\nusing this:\n  x \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. enn2real (eNorm N x) = 0", "apply (auto simp add: spaceN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eNorm N x < \\<top> \\<Longrightarrow> enn2real (eNorm N x) = 0", "using top.not_eq_extremum"], ["proof (prove)\nusing this:\n  (?a \\<noteq> \\<top>) = (?a < \\<top>)\n\ngoal (1 subgoal):\n 1. \\<not> eNorm N x < \\<top> \\<Longrightarrow> enn2real (eNorm N x) = 0", "by fastforce"], ["", "lemma Norm_cmult:\n  \"Norm N (c *\\<^sub>R x) = abs c * Norm N x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (c *\\<^sub>R x) = \\<bar>c\\<bar> * Norm N x", "unfolding Norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (eNorm N (c *\\<^sub>R x)) =\n    \\<bar>c\\<bar> * enn2real (eNorm N x)", "unfolding eNorm_cmult"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (ennreal \\<bar>c\\<bar> * eNorm N x) =\n    \\<bar>c\\<bar> * enn2real (eNorm N x)", "by (simp add: enn2real_mult)"], ["", "lemma Norm_triangular_ineq:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "proof (cases \"y \\<in> space\\<^sub>N N\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "case True"], ["proof (state)\nthis:\n  y \\<in> space\\<^sub>N N\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have *: \"defect N * Norm N x + defect N * Norm N y \\<ge> 1 * 0 + 1 * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 * 0 \\<le> defect N * Norm N x\n 2. 1 * 0 \\<le> defect N * Norm N y", "by (rule mult_mono'[OF defect_ge_1 Norm_nonneg], simp, simp)+"], ["proof (state)\nthis:\n  1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"ennreal (Norm N (x + y)) = eNorm N (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (Norm N (x + y)) = eNorm N (x + y)", "using eNorm_Norm[OF spaceN_add[OF assms True]]"], ["proof (prove)\nusing this:\n  eNorm N (x + y) = ennreal (Norm N (x + y))\n\ngoal (1 subgoal):\n 1. ennreal (Norm N (x + y)) = eNorm N (x + y)", "by auto"], ["proof (state)\nthis:\n  ennreal (Norm N (x + y)) = eNorm N (x + y)\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "also"], ["proof (state)\nthis:\n  ennreal (Norm N (x + y)) = eNorm N (x + y)\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"... \\<le> defect N * eNorm N x + defect N * eNorm N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (x + y)\n    \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y", "using eNorm_triangular_ineq[of N x y]"], ["proof (prove)\nusing this:\n  eNorm N (x + y)\n  \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n\ngoal (1 subgoal):\n 1. eNorm N (x + y)\n    \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y", "by auto"], ["proof (state)\nthis:\n  eNorm N (x + y)\n  \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "also"], ["proof (state)\nthis:\n  eNorm N (x + y)\n  \\<le> ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"... = defect N * ennreal(Norm N x) + defect N * ennreal(Norm N y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y =\n    ennreal (defect N) * ennreal (Norm N x) +\n    ennreal (defect N) * ennreal (Norm N y)", "using eNorm_Norm assms True"], ["proof (prove)\nusing this:\n  ?x \\<in> space\\<^sub>N ?N \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n  x \\<in> space\\<^sub>N N\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y =\n    ennreal (defect N) * ennreal (Norm N x) +\n    ennreal (defect N) * ennreal (Norm N y)", "by metis"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y =\n  ennreal (defect N) * ennreal (Norm N x) +\n  ennreal (defect N) * ennreal (Norm N y)\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "also"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N x + ennreal (defect N) * eNorm N y =\n  ennreal (defect N) * ennreal (Norm N x) +\n  ennreal (defect N) * ennreal (Norm N y)\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"... = ennreal(defect N * Norm N x + defect N * Norm N y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * ennreal (Norm N x) +\n    ennreal (defect N) * ennreal (Norm N y) =\n    ennreal (defect N * Norm N x + defect N * Norm N y)", "using ennreal_mult ennreal_plus Norm_nonneg defect_ge_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ennreal (?a * ?b) = ennreal ?a * ennreal ?b\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ennreal (?a + ?b) = ennreal ?a + ennreal ?b\n  0 \\<le> Norm ?N ?x\n  1 \\<le> defect ?N\n\ngoal (1 subgoal):\n 1. ennreal (defect N) * ennreal (Norm N x) +\n    ennreal (defect N) * ennreal (Norm N y) =\n    ennreal (defect N * Norm N x + defect N * Norm N y)", "by (metis (no_types, hide_lams) ennreal_eq_0_iff less_le ennreal_ge_1 ennreal_mult' le_less_linear not_one_le_zero semiring_normalization_rules(34))"], ["proof (state)\nthis:\n  ennreal (defect N) * ennreal (Norm N x) +\n  ennreal (defect N) * ennreal (Norm N y) =\n  ennreal (defect N * Norm N x + defect N * Norm N y)\n\ngoal (2 subgoals):\n 1. y \\<in> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n 2. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "finally"], ["proof (chain)\npicking this:\n  ennreal (Norm N (x + y))\n  \\<le> ennreal (defect N * Norm N x + defect N * Norm N y)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (Norm N (x + y))\n  \\<le> ennreal (defect N * Norm N x + defect N * Norm N y)\n\ngoal (1 subgoal):\n 1. Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "apply (subst ennreal_le_iff[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ennreal (Norm N (x + y))\n    \\<le> ennreal\n           (defect N * Norm N x + defect N * Norm N y) \\<Longrightarrow>\n    0 \\<le> defect N * Norm N x + defect N * Norm N y\n 2. ennreal (Norm N (x + y))\n    \\<le> ennreal\n           (defect N * Norm N x + defect N * Norm N y) \\<Longrightarrow>\n    ennreal (Norm N (x + y))\n    \\<le> ennreal (defect N * Norm N x + defect N * Norm N y)", "using *"], ["proof (prove)\nusing this:\n  1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal (2 subgoals):\n 1. ennreal (Norm N (x + y))\n    \\<le> ennreal\n           (defect N * Norm N x + defect N * Norm N y) \\<Longrightarrow>\n    0 \\<le> defect N * Norm N x + defect N * Norm N y\n 2. ennreal (Norm N (x + y))\n    \\<le> ennreal\n           (defect N * Norm N x + defect N * Norm N y) \\<Longrightarrow>\n    ennreal (Norm N (x + y))\n    \\<le> ennreal (defect N * Norm N x + defect N * Norm N y)", "by auto"], ["proof (state)\nthis:\n  Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "case False"], ["proof (state)\nthis:\n  y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"x + y \\<notin> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<notin> space\\<^sub>N N", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x + y \\<notin> space\\<^sub>N N \\<Longrightarrow> False", "assume \"\\<not> (x + y \\<notin> space\\<^sub>N N)\""], ["proof (state)\nthis:\n  \\<not> x + y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<not> x + y \\<notin> space\\<^sub>N N \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> x + y \\<notin> space\\<^sub>N N", "have \"x + y \\<in> space\\<^sub>N N\""], ["proof (prove)\nusing this:\n  \\<not> x + y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. x + y \\<in> space\\<^sub>N N", "by simp"], ["proof (state)\nthis:\n  x + y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<not> x + y \\<notin> space\\<^sub>N N \\<Longrightarrow> False", "have \"y \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> space\\<^sub>N N", "using spaceN_diff[OF \\<open>x + y \\<in> space\\<^sub>N N\\<close> assms]"], ["proof (prove)\nusing this:\n  x + y - x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. y \\<in> space\\<^sub>N N", "by auto"], ["proof (state)\nthis:\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<not> x + y \\<notin> space\\<^sub>N N \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> space\\<^sub>N N", "show False"], ["proof (prove)\nusing this:\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  y \\<in> space\\<^sub>N N\n  y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x + y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "then"], ["proof (chain)\npicking this:\n  x + y \\<notin> space\\<^sub>N N", "have \"Norm N (x+y) = 0\""], ["proof (prove)\nusing this:\n  x + y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. Norm N (x + y) = 0", "unfolding Norm_def"], ["proof (prove)\nusing this:\n  x + y \\<notin> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. enn2real (eNorm N (x + y)) = 0", "using spaceN_iff top.not_eq_extremum"], ["proof (prove)\nusing this:\n  x + y \\<notin> space\\<^sub>N N\n  (?x \\<in> space\\<^sub>N ?N) = (eNorm ?N ?x < \\<infinity>)\n  (?a \\<noteq> \\<top>) = (?a < \\<top>)\n\ngoal (1 subgoal):\n 1. enn2real (eNorm N (x + y)) = 0", "by force"], ["proof (state)\nthis:\n  Norm N (x + y) = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "moreover"], ["proof (state)\nthis:\n  Norm N (x + y) = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "have \"defect N * Norm N x + defect N * Norm N y \\<ge> 1 * 0 + 1 * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 * 0 \\<le> defect N * Norm N x\n 2. 1 * 0 \\<le> defect N * Norm N y", "by (rule mult_mono'[OF defect_ge_1 Norm_nonneg], simp, simp)+"], ["proof (state)\nthis:\n  1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal (1 subgoal):\n 1. y \\<notin> space\\<^sub>N N \\<Longrightarrow>\n    Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "ultimately"], ["proof (chain)\npicking this:\n  Norm N (x + y) = 0\n  1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y", "show ?thesis"], ["proof (prove)\nusing this:\n  Norm N (x + y) = 0\n  1 * 0 + 1 * 0 \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal (1 subgoal):\n 1. Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y", "by simp"], ["proof (state)\nthis:\n  Norm N (x + y) \\<le> defect N * Norm N x + defect N * Norm N y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Norm_triangular_ineq_diff:\n  assumes \"x \\<in> space\\<^sub>N N\"\n  shows \"Norm N (x - y) \\<le> defect N * Norm N x + defect N * Norm N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (x - y) \\<le> defect N * Norm N x + defect N * Norm N y", "using Norm_triangular_ineq[OF assms, of \"-y\"]"], ["proof (prove)\nusing this:\n  Norm N (x + - y) \\<le> defect N * Norm N x + defect N * Norm N (- y)\n\ngoal (1 subgoal):\n 1. Norm N (x - y) \\<le> defect N * Norm N x + defect N * Norm N y", "by auto"], ["", "lemma zero_spaceN_iff':\n  \"x \\<in> zero_space\\<^sub>N N \\<longleftrightarrow> (x \\<in> space\\<^sub>N N \\<and> Norm N x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> zero_space\\<^sub>N N) =\n    (x \\<in> space\\<^sub>N N \\<and> Norm N x = 0)", "using eNorm_Norm"], ["proof (prove)\nusing this:\n  ?x \\<in> space\\<^sub>N ?N \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n\ngoal (1 subgoal):\n 1. (x \\<in> zero_space\\<^sub>N N) =\n    (x \\<in> space\\<^sub>N N \\<and> Norm N x = 0)", "unfolding space\\<^sub>N_def zero_space\\<^sub>N_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {f. eNorm ?N f < \\<infinity>} \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n\ngoal (1 subgoal):\n 1. (x \\<in> {f. eNorm N f = 0}) =\n    (x \\<in> {f. eNorm N f < \\<infinity>} \\<and> Norm N x = 0)", "by (auto simp add: Norm_def, fastforce)"], ["", "lemma Norm_sum:\n  assumes \"\\<And>i. i < n \\<Longrightarrow> u i \\<in> space\\<^sub>N N\"\n  shows \"Norm N (\\<Sum>i\\<in>{..<n}. u i) \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * Norm N (u i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have *: \"0 \\<le> defect N * defect N ^ i * Norm N (u i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> defect N * defect N ^ i * Norm N (u i)", "by (meson Norm_nonneg defect_ge_1 dual_order.trans linear mult_nonneg_nonneg not_one_le_zero zero_le_power)"], ["proof (state)\nthis:\n  0 \\<le> defect N * defect N ^ ?i * Norm N (u ?i)\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have \"ennreal (Norm N (\\<Sum>i\\<in>{..<n}. u i)) = eNorm N (\\<Sum>i\\<in>{..<n}. u i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (Norm N (sum u {..<n})) = eNorm N (sum u {..<n})", "apply (rule eNorm_Norm[symmetric], rule spaceN_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> u i \\<in> space\\<^sub>N N", "using assms"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> u ?i \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> u i \\<in> space\\<^sub>N N", "by auto"], ["proof (state)\nthis:\n  ennreal (Norm N (sum u {..<n})) = eNorm N (sum u {..<n})\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "also"], ["proof (state)\nthis:\n  ennreal (Norm N (sum u {..<n})) = eNorm N (sum u {..<n})\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have \"... \\<le> (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * eNorm N (u i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "using eNorm_sum"], ["proof (prove)\nusing this:\n  eNorm ?N (sum ?u {..<?n})\n  \\<le> (\\<Sum>i<?n. ennreal (defect ?N ^ Suc i) * eNorm ?N (?u i))\n\ngoal (1 subgoal):\n 1. eNorm N (sum u {..<n})\n    \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))", "by simp"], ["proof (state)\nthis:\n  eNorm N (sum u {..<n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "also"], ["proof (state)\nthis:\n  eNorm N (sum u {..<n})\n  \\<le> (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have \"... = (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * ennreal (Norm N (u i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i)) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i)))", "using eNorm_Norm[OF assms]"], ["proof (prove)\nusing this:\n  ?i1 < n \\<Longrightarrow> eNorm N (u ?i1) = ennreal (Norm N (u ?i1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i)) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i)) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i)))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * eNorm N (u i)) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i)))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have \"... = (\\<Sum>i\\<in>{..<n}. ennreal((defect N)^(Suc i) * Norm N (u i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i))) =\n    (\\<Sum>i<n. ennreal (defect N ^ Suc i * Norm N (u i)))", "by (subst ennreal_mult'', auto)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i))) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i * Norm N (u i)))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i) * ennreal (Norm N (u i))) =\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i * Norm N (u i)))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have \"... = ennreal (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * Norm N (u i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. ennreal (defect N ^ Suc i * Norm N (u i))) =\n    ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "by (auto intro!: sum_ennreal simp add: *)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. ennreal (defect N ^ Suc i * Norm N (u i))) =\n  ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "finally"], ["proof (chain)\npicking this:\n  ennreal (Norm N (sum u {..<n}))\n  \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "have **: \"ennreal (Norm N (\\<Sum>i\\<in>{..<n}. u i)) \\<le> ennreal (\\<Sum>i\\<in>{..<n}. (defect N)^(Suc i) * Norm N (u i))\""], ["proof (prove)\nusing this:\n  ennreal (Norm N (sum u {..<n}))\n  \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))\n\ngoal (1 subgoal):\n 1. ennreal (Norm N (sum u {..<n}))\n    \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "by simp"], ["proof (state)\nthis:\n  ennreal (Norm N (sum u {..<n}))\n  \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))\n\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "apply (subst ennreal_le_iff[symmetric], rule sum_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       0 \\<le> defect N ^ Suc x * Norm N (u x)\n 2. ennreal (Norm N (sum u {..<n}))\n    \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "using * **"], ["proof (prove)\nusing this:\n  0 \\<le> defect N * defect N ^ ?i * Norm N (u ?i)\n  ennreal (Norm N (sum u {..<n}))\n  \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       0 \\<le> defect N ^ Suc x * Norm N (u x)\n 2. ennreal (Norm N (sum u {..<n}))\n    \\<le> ennreal (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))", "by auto"], ["proof (state)\nthis:\n  Norm N (sum u {..<n}) \\<le> (\\<Sum>i<n. defect N ^ Suc i * Norm N (u i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>An example: the ambient norm in a normed vector space\\<close>"], ["", "definition N_of_norm::\"'a::real_normed_vector quasinorm\"\n  where \"N_of_norm = quasinorm_of (1, \\<lambda>f. norm f)\""], ["", "lemma N_of_norm:\n  \"eNorm N_of_norm f = ennreal (norm f)\"\n  \"Norm N_of_norm f = norm f\"\n  \"defect (N_of_norm) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N_of_norm f = ennreal (norm f) &&&\n    Norm N_of_norm f = norm f &&& defect N_of_norm = 1", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. eNorm N_of_norm f = ennreal (norm f)\n 2. Norm N_of_norm f = norm f\n 3. defect N_of_norm = 1", "have *: \"quasinorm_on UNIV 1 (\\<lambda>f. norm f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV 1 (\\<lambda>x. ennreal (norm x))", "by (rule quasinorm_onI, auto simp add: ennreal_mult', metis ennreal_leI ennreal_plus norm_imp_pos_and_ge norm_triangle_ineq)"], ["proof (state)\nthis:\n  quasinorm_on UNIV 1 (\\<lambda>x. ennreal (norm x))\n\ngoal (3 subgoals):\n 1. eNorm N_of_norm f = ennreal (norm f)\n 2. Norm N_of_norm f = norm f\n 3. defect N_of_norm = 1", "show \"eNorm N_of_norm f = ennreal (norm f)\"\n       \"defect (N_of_norm) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N_of_norm f = ennreal (norm f) &&& defect N_of_norm = 1", "unfolding N_of_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm\n     (quasinorm_of\n       (case (1, norm) of\n        (x, y) \\<Rightarrow> (x, \\<lambda>x. ennreal (y x))))\n     f =\n    ennreal (norm f) &&&\n    defect\n     (quasinorm_of\n       (case (1, norm) of\n        (x, y) \\<Rightarrow> (x, \\<lambda>x. ennreal (y x)))) =\n    1", "using quasinorm_of[OF *]"], ["proof (prove)\nusing this:\n  eNorm (quasinorm_of (1, \\<lambda>x. ennreal (norm x))) ?x =\n  ennreal (norm ?x)\n  defect (quasinorm_of (1, \\<lambda>x. ennreal (norm x))) = 1\n\ngoal (1 subgoal):\n 1. eNorm\n     (quasinorm_of\n       (case (1, norm) of\n        (x, y) \\<Rightarrow> (x, \\<lambda>x. ennreal (y x))))\n     f =\n    ennreal (norm f) &&&\n    defect\n     (quasinorm_of\n       (case (1, norm) of\n        (x, y) \\<Rightarrow> (x, \\<lambda>x. ennreal (y x)))) =\n    1", "by auto"], ["proof (state)\nthis:\n  eNorm N_of_norm f = ennreal (norm f)\n  defect N_of_norm = 1\n\ngoal (1 subgoal):\n 1. Norm N_of_norm f = norm f", "then"], ["proof (chain)\npicking this:\n  eNorm N_of_norm f = ennreal (norm f)\n  defect N_of_norm = 1", "show \"Norm N_of_norm f = norm f\""], ["proof (prove)\nusing this:\n  eNorm N_of_norm f = ennreal (norm f)\n  defect N_of_norm = 1\n\ngoal (1 subgoal):\n 1. Norm N_of_norm f = norm f", "unfolding Norm_def"], ["proof (prove)\nusing this:\n  eNorm N_of_norm f = ennreal (norm f)\n  defect N_of_norm = 1\n\ngoal (1 subgoal):\n 1. enn2real (eNorm N_of_norm f) = norm f", "by auto"], ["proof (state)\nthis:\n  Norm N_of_norm f = norm f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_of_norm_space [simp]:\n  \"space\\<^sub>N N_of_norm = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space\\<^sub>N N_of_norm = UNIV", "unfolding space\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. eNorm N_of_norm f < \\<infinity>} = UNIV", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. eNorm N_of_norm x < \\<top>", "unfolding N_of_norm(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. ennreal (norm x) < \\<top>", "by auto"], ["", "lemma N_of_norm_zero_space [simp]:\n  \"zero_space\\<^sub>N N_of_norm = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N N_of_norm = {0::'a}", "unfolding zero_space\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. eNorm N_of_norm f = 0} = {0::'a}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. eNorm N_of_norm x = 0 \\<Longrightarrow> x = (0::'a)", "unfolding N_of_norm(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. ennreal (norm x) = 0 \\<Longrightarrow> x = (0::'a)", "by auto"], ["", "subsection \\<open>An example: the space of bounded continuous functions from a topological space to a normed\nreal vector space\\<close>"], ["", "text \\<open>The Banach space of bounded continuous functions is defined in\n\\verb+Bounded_Continuous_Function.thy+, as a type \\verb+bcontfun+. We import very quickly the\nresults proved in this file to the current framework.\\<close>"], ["", "definition bcontfun\\<^sub>N::\"('a::topological_space \\<Rightarrow> 'b::real_normed_vector) quasinorm\"\n  where \"bcontfun\\<^sub>N = quasinorm_of (1, \\<lambda>f. if f \\<in> bcontfun then norm(Bcontfun f) else (\\<infinity>::ennreal))\""], ["", "lemma bcontfun\\<^sub>N:\n  fixes f::\"('a::topological_space \\<Rightarrow> 'b::real_normed_vector)\"\n  shows \"eNorm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else (\\<infinity>::ennreal))\"\n        \"Norm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else 0)\"\n        \"defect (bcontfun\\<^sub>N::(('a \\<Rightarrow> 'b) quasinorm)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n     else \\<infinity>) &&&\n    Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0) &&&\n    defect bcontfun\\<^sub>N = 1", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n 2. Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)\n 3. defect bcontfun\\<^sub>N = 1", "have *: \"quasinorm_on bcontfun 1 (\\<lambda>(f::('a \\<Rightarrow> 'b)). norm(Bcontfun f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on bcontfun 1 (\\<lambda>x. ennreal (norm (Bcontfun x)))", "proof (rule quasinorm_onI, auto)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> bcontfun\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (x + y)))\n                         \\<le> ennreal (norm (Bcontfun x)) +\n                               ennreal (norm (Bcontfun y))\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 5. 0 \\<in> bcontfun\n 6. Bcontfun 0 = 0", "fix f g::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> bcontfun\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (x + y)))\n                         \\<le> ennreal (norm (Bcontfun x)) +\n                               ennreal (norm (Bcontfun y))\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 5. 0 \\<in> bcontfun\n 6. Bcontfun 0 = 0", "assume H: \"f \\<in> bcontfun\" \"g \\<in> bcontfun\""], ["proof (state)\nthis:\n  f \\<in> bcontfun\n  g \\<in> bcontfun\n\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> bcontfun\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (x + y)))\n                         \\<le> ennreal (norm (Bcontfun x)) +\n                               ennreal (norm (Bcontfun y))\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 5. 0 \\<in> bcontfun\n 6. Bcontfun 0 = 0", "then"], ["proof (chain)\npicking this:\n  f \\<in> bcontfun\n  g \\<in> bcontfun", "show \"f + g \\<in> bcontfun\""], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n  g \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. f + g \\<in> bcontfun", "unfolding plus_fun_def"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n  g \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x + g x) \\<in> bcontfun", "by (simp add: plus_cont)"], ["proof (state)\nthis:\n  f + g \\<in> bcontfun\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (x + y)))\n                         \\<le> ennreal (norm (Bcontfun x)) +\n                               ennreal (norm (Bcontfun y))\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 4. 0 \\<in> bcontfun\n 5. Bcontfun 0 = 0", "have *: \"Bcontfun(f + g) = Bcontfun f + Bcontfun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bcontfun (f + g) = Bcontfun f + Bcontfun g", "using H"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n  g \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. Bcontfun (f + g) = Bcontfun f + Bcontfun g", "by (auto simp: eq_onp_def plus_fun_def bcontfun_def intro!: plus_bcontfun.abs_eq[symmetric])"], ["proof (state)\nthis:\n  Bcontfun (f + g) = Bcontfun f + Bcontfun g\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> bcontfun; y \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (x + y)))\n                         \\<le> ennreal (norm (Bcontfun x)) +\n                               ennreal (norm (Bcontfun y))\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 4. 0 \\<in> bcontfun\n 5. Bcontfun 0 = 0", "show \"ennreal (norm (Bcontfun (f + g))) \\<le> ennreal (norm (Bcontfun f)) + ennreal (norm (Bcontfun g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (norm (Bcontfun (f + g)))\n    \\<le> ennreal (norm (Bcontfun f)) + ennreal (norm (Bcontfun g))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (norm (Bcontfun f + Bcontfun g))\n    \\<le> ennreal (norm (Bcontfun f)) + ennreal (norm (Bcontfun g))", "using ennreal_leI[OF norm_triangle_ineq]"], ["proof (prove)\nusing this:\n  ennreal (norm (?x1 + ?y1)) \\<le> ennreal (norm ?x1 + norm ?y1)\n\ngoal (1 subgoal):\n 1. ennreal (norm (Bcontfun f + Bcontfun g))\n    \\<le> ennreal (norm (Bcontfun f)) + ennreal (norm (Bcontfun g))", "by auto"], ["proof (state)\nthis:\n  ennreal (norm (Bcontfun (f + g)))\n  \\<le> ennreal (norm (Bcontfun f)) + ennreal (norm (Bcontfun g))\n\ngoal (4 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 3. 0 \\<in> bcontfun\n 4. Bcontfun 0 = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 3. 0 \\<in> bcontfun\n 4. Bcontfun 0 = 0", "fix c::real and f::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 3. 0 \\<in> bcontfun\n 4. Bcontfun 0 = 0", "assume H: \"f \\<in> bcontfun\""], ["proof (state)\nthis:\n  f \\<in> bcontfun\n\ngoal (4 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> bcontfun\n 2. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 3. 0 \\<in> bcontfun\n 4. Bcontfun 0 = 0", "then"], ["proof (chain)\npicking this:\n  f \\<in> bcontfun", "show \"c *\\<^sub>R f \\<in> bcontfun\""], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. c *\\<^sub>R f \\<in> bcontfun", "unfolding scaleR_fun_def"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. c *\\<^sub>R f x) \\<in> bcontfun", "by (simp add: scaleR_cont)"], ["proof (state)\nthis:\n  c *\\<^sub>R f \\<in> bcontfun\n\ngoal (3 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 2. 0 \\<in> bcontfun\n 3. Bcontfun 0 = 0", "have *: \"Bcontfun(c *\\<^sub>R f) = c *\\<^sub>R Bcontfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bcontfun (c *\\<^sub>R f) = c *\\<^sub>R Bcontfun f", "using H"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. Bcontfun (c *\\<^sub>R f) = c *\\<^sub>R Bcontfun f", "by (auto simp: eq_onp_def scaleR_fun_def bcontfun_def intro!: scaleR_bcontfun.abs_eq[symmetric])"], ["proof (state)\nthis:\n  Bcontfun (c *\\<^sub>R f) = c *\\<^sub>R Bcontfun f\n\ngoal (3 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> bcontfun\\<rbrakk>\n       \\<Longrightarrow> ennreal (norm (Bcontfun (c *\\<^sub>R x)))\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               ennreal (norm (Bcontfun x))\n 2. 0 \\<in> bcontfun\n 3. Bcontfun 0 = 0", "show \"ennreal (norm (Bcontfun (c *\\<^sub>R f))) \\<le> ennreal \\<bar>c\\<bar> * ennreal (norm (Bcontfun f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (norm (Bcontfun (c *\\<^sub>R f)))\n    \\<le> ennreal \\<bar>c\\<bar> * ennreal (norm (Bcontfun f))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (norm (c *\\<^sub>R Bcontfun f))\n    \\<le> ennreal \\<bar>c\\<bar> * ennreal (norm (Bcontfun f))", "by (simp add: ennreal_mult'')"], ["proof (state)\nthis:\n  ennreal (norm (Bcontfun (c *\\<^sub>R f)))\n  \\<le> ennreal \\<bar>c\\<bar> * ennreal (norm (Bcontfun f))\n\ngoal (2 subgoals):\n 1. 0 \\<in> bcontfun\n 2. Bcontfun 0 = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> bcontfun\n 2. Bcontfun 0 = 0", "show \"(0::'a\\<Rightarrow>'b) \\<in> bcontfun\" \"Bcontfun 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> bcontfun &&& Bcontfun 0 = 0", "unfolding zero_fun_def zero_bcontfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) \\<in> bcontfun &&&\n    Bcontfun (\\<lambda>x. 0::'d) = Bcontfun (\\<lambda>_. 0::'d)", "by (auto simp add: const_bcontfun)"], ["proof (state)\nthis:\n  0 \\<in> bcontfun\n  Bcontfun 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quasinorm_on bcontfun 1 (\\<lambda>x. ennreal (norm (Bcontfun x)))\n\ngoal (3 subgoals):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n 2. Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)\n 3. defect bcontfun\\<^sub>N = 1", "have **: \"quasinorm_on UNIV 1 (\\<lambda>(f::'a\\<Rightarrow>'b). if f \\<in> bcontfun then norm(Bcontfun f) else (\\<infinity>::ennreal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV 1\n     (\\<lambda>f.\n         if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n         else \\<infinity>)", "by (rule extend_quasinorm[OF *])"], ["proof (state)\nthis:\n  quasinorm_on UNIV 1\n   (\\<lambda>f.\n       if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n       else \\<infinity>)\n\ngoal (3 subgoals):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n 2. Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)\n 3. defect bcontfun\\<^sub>N = 1", "show \"eNorm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else (\\<infinity>::ennreal))\"\n       \"defect (bcontfun\\<^sub>N::('a \\<Rightarrow> 'b) quasinorm) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n     else \\<infinity>) &&&\n    defect bcontfun\\<^sub>N = 1", "using quasinorm_of[OF **]"], ["proof (prove)\nusing this:\n  eNorm\n   (quasinorm_of\n     (1, \\<lambda>f.\n            if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n            else \\<infinity>))\n   ?x =\n  (if ?x \\<in> bcontfun then ennreal (norm (Bcontfun ?x)) else \\<infinity>)\n  defect\n   (quasinorm_of\n     (1, \\<lambda>f.\n            if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n            else \\<infinity>)) =\n  1\n\ngoal (1 subgoal):\n 1. eNorm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n     else \\<infinity>) &&&\n    defect bcontfun\\<^sub>N = 1", "unfolding bcontfun\\<^sub>N_def"], ["proof (prove)\nusing this:\n  eNorm\n   (quasinorm_of\n     (1, \\<lambda>f.\n            if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n            else \\<infinity>))\n   ?x =\n  (if ?x \\<in> bcontfun then ennreal (norm (Bcontfun ?x)) else \\<infinity>)\n  defect\n   (quasinorm_of\n     (1, \\<lambda>f.\n            if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n            else \\<infinity>)) =\n  1\n\ngoal (1 subgoal):\n 1. eNorm\n     (quasinorm_of\n       (1, \\<lambda>f.\n              if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n              else \\<infinity>))\n     f =\n    (if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n     else \\<infinity>) &&&\n    defect\n     (quasinorm_of\n       (1, \\<lambda>f.\n              if f \\<in> bcontfun then ennreal (norm (Bcontfun f))\n              else \\<infinity>)) =\n    1", "by auto"], ["proof (state)\nthis:\n  eNorm bcontfun\\<^sub>N f =\n  (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n  defect bcontfun\\<^sub>N = 1\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)", "then"], ["proof (chain)\npicking this:\n  eNorm bcontfun\\<^sub>N f =\n  (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n  defect bcontfun\\<^sub>N = 1", "show \"Norm bcontfun\\<^sub>N f = (if f \\<in> bcontfun then norm(Bcontfun f) else 0)\""], ["proof (prove)\nusing this:\n  eNorm bcontfun\\<^sub>N f =\n  (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n  defect bcontfun\\<^sub>N = 1\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N f =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)", "unfolding Norm_def"], ["proof (prove)\nusing this:\n  eNorm bcontfun\\<^sub>N f =\n  (if f \\<in> bcontfun then ennreal (norm (Bcontfun f)) else \\<infinity>)\n  defect bcontfun\\<^sub>N = 1\n\ngoal (1 subgoal):\n 1. enn2real (eNorm bcontfun\\<^sub>N f) =\n    (if f \\<in> bcontfun then norm (Bcontfun f) else 0)", "by auto"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N f =\n  (if f \\<in> bcontfun then norm (Bcontfun f) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bcontfun\\<^sub>N_space:\n  \"space\\<^sub>N bcontfun\\<^sub>N = bcontfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space\\<^sub>N bcontfun\\<^sub>N = bcontfun", "using bcontfun\\<^sub>N(1)"], ["proof (prove)\nusing this:\n  eNorm bcontfun\\<^sub>N ?f =\n  (if ?f \\<in> bcontfun then ennreal (norm (Bcontfun ?f)) else \\<infinity>)\n\ngoal (1 subgoal):\n 1. space\\<^sub>N bcontfun\\<^sub>N = bcontfun", "by (metis (no_types, lifting) Collect_cong bcontfun_def enn2real_top ennreal_0\n  ennreal_enn2real ennreal_less_top ennreal_zero_neq_top infinity_ennreal_def mem_Collect_eq space\\<^sub>N_def)"], ["", "lemma bcontfun\\<^sub>N_zero_space:\n  \"zero_space\\<^sub>N bcontfun\\<^sub>N = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N bcontfun\\<^sub>N = {0}", "apply (auto simp add: zero_spaceN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. eNorm bcontfun\\<^sub>N x = 0 \\<Longrightarrow> x = 0", "by (metis Bcontfun_inject bcontfun\\<^sub>N(1) eNorm_zero ennreal_eq_zero_iff ennreal_zero_neq_top infinity_ennreal_def norm_eq_zero norm_imp_pos_and_ge)"], ["", "lemma bcontfun\\<^sub>ND:\n  assumes \"f \\<in> space\\<^sub>N bcontfun\\<^sub>N\"\n  shows \"continuous_on UNIV f\"\n        \"\\<And>x. norm(f x) \\<le> Norm bcontfun\\<^sub>N f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV f &&&\n    (\\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous_on UNIV f\n 2. \\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f", "have \"f \\<in> bcontfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "unfolding bcontfun\\<^sub>N_space"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "by simp"], ["proof (state)\nthis:\n  f \\<in> bcontfun\n\ngoal (2 subgoals):\n 1. continuous_on UNIV f\n 2. \\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f", "then"], ["proof (chain)\npicking this:\n  f \\<in> bcontfun", "show \"continuous_on UNIV f\""], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. continuous_on UNIV f", "unfolding bcontfun_def"], ["proof (prove)\nusing this:\n  f \\<in> {f. continuous_on UNIV f \\<and> bounded (range f)}\n\ngoal (1 subgoal):\n 1. continuous_on UNIV f", "by auto"], ["proof (state)\nthis:\n  continuous_on UNIV f\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f", "show \"\\<And>x. norm(f x) \\<le> Norm bcontfun\\<^sub>N f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f", "using norm_bounded bcontfun\\<^sub>N(2) \\<open>f \\<in> bcontfun\\<close>"], ["proof (prove)\nusing this:\n  norm (apply_bcontfun ?f ?x) \\<le> norm ?f\n  Norm bcontfun\\<^sub>N ?f =\n  (if ?f \\<in> bcontfun then norm (Bcontfun ?f) else 0)\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> Norm bcontfun\\<^sub>N f", "by (metis Bcontfun_inverse)"], ["proof (state)\nthis:\n  norm (f ?x) \\<le> Norm bcontfun\\<^sub>N f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bcontfun\\<^sub>NI:\n  assumes \"continuous_on UNIV f\"\n          \"\\<And>x. norm(f x) \\<le> C\"\n  shows \"f \\<in> space\\<^sub>N bcontfun\\<^sub>N\"\n        \"Norm bcontfun\\<^sub>N f \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N bcontfun\\<^sub>N &&&\n    Norm bcontfun\\<^sub>N f \\<le> C", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N bcontfun\\<^sub>N\n 2. Norm bcontfun\\<^sub>N f \\<le> C", "have \"f \\<in> bcontfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "using assms bcontfun_normI"], ["proof (prove)\nusing this:\n  continuous_on UNIV f\n  norm (f ?x) \\<le> C\n  \\<lbrakk>continuous_on UNIV ?f; \\<And>x. norm (?f x) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "by blast"], ["proof (state)\nthis:\n  f \\<in> bcontfun\n\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N bcontfun\\<^sub>N\n 2. Norm bcontfun\\<^sub>N f \\<le> C", "then"], ["proof (chain)\npicking this:\n  f \\<in> bcontfun", "show \"f \\<in> space\\<^sub>N bcontfun\\<^sub>N\""], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N bcontfun\\<^sub>N", "unfolding bcontfun\\<^sub>N_space"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. f \\<in> bcontfun", "by simp"], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N f \\<le> C", "show \"Norm bcontfun\\<^sub>N f \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N f \\<le> C", "unfolding bcontfun\\<^sub>N(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if f \\<in> bcontfun then norm (Bcontfun f) else 0) \\<le> C", "using \\<open>f \\<in> bcontfun\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. (if f \\<in> bcontfun then norm (Bcontfun f) else 0) \\<le> C", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> bcontfun \\<Longrightarrow> norm (Bcontfun f) \\<le> C", "using assms(2)"], ["proof (prove)\nusing this:\n  norm (f ?x) \\<le> C\n\ngoal (1 subgoal):\n 1. f \\<in> bcontfun \\<Longrightarrow> norm (Bcontfun f) \\<le> C", "by (metis apply_bcontfun_cases apply_bcontfun_inverse norm_bound)"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N f \\<le> C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Continuous inclusions between functional spaces\\<close>"], ["", "text \\<open>Continuous inclusions between functional spaces are now defined\\<close>"], ["", "instantiation quasinorm:: (real_vector) preorder\nbegin"], ["", "definition less_eq_quasinorm::\"'a quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> bool\"\n  where \"less_eq_quasinorm N1 N2 = (\\<exists>C\\<ge>(0::real). \\<forall>f. eNorm N2 f \\<le> C * eNorm N1 f)\""], ["", "definition less_quasinorm::\"'a quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> bool\"\n  where \"less_quasinorm N1 N2 = (less_eq N1 N2 \\<and> (\\<not> less_eq N2 N1))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a quasinorm, preorder_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a quasinorm, preorder_class)", "have E: \"N \\<le> N\" for N::\"'a quasinorm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> N", "unfolding less_eq_quasinorm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N f \\<le> ennreal C * eNorm N f", "by (rule exI[of _ 1], auto)"], ["proof (state)\nthis:\n  ?N \\<le> ?N\n\ngoal (1 subgoal):\n 1. OFCLASS('a quasinorm, preorder_class)", "have T: \"N1 \\<le> N3\" if \"N1 \\<le> N2\" \"N2 \\<le> N3\" for N1 N2 N3::\"'a quasinorm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "obtain C C' where *: \"\\<And>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f\"\n                         \"\\<And>f. eNorm N3 f \\<le> ennreal C' * eNorm N2 f\"\n                         \"C \\<ge> 0\" \"C' \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C C'.\n        \\<lbrakk>\\<And>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f;\n         \\<And>f. eNorm N3 f \\<le> ennreal C' * eNorm N2 f; 0 \\<le> C;\n         0 \\<le> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>N1 \\<le> N2\\<close> \\<open>N2 \\<le> N3\\<close>"], ["proof (prove)\nusing this:\n  N1 \\<le> N2\n  N2 \\<le> N3\n\ngoal (1 subgoal):\n 1. (\\<And>C C'.\n        \\<lbrakk>\\<And>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f;\n         \\<And>f. eNorm N3 f \\<le> ennreal C' * eNorm N2 f; 0 \\<le> C;\n         0 \\<le> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N3 f \\<le> ennreal C * eNorm N2 f\n\ngoal (1 subgoal):\n 1. (\\<And>C C'.\n        \\<lbrakk>\\<And>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f;\n         \\<And>f. eNorm N3 f \\<le> ennreal C' * eNorm N2 f; 0 \\<le> C;\n         0 \\<le> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  eNorm N2 ?f \\<le> ennreal C * eNorm N1 ?f\n  eNorm N3 ?f \\<le> ennreal C' * eNorm N2 ?f\n  0 \\<le> C\n  0 \\<le> C'\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "{"], ["proof (state)\nthis:\n  eNorm N2 ?f \\<le> ennreal C * eNorm N1 ?f\n  eNorm N3 ?f \\<le> ennreal C' * eNorm N2 ?f\n  0 \\<le> C\n  0 \\<le> C'\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "have \"eNorm N3 f \\<le> ennreal C' * ennreal C * eNorm N1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N3 f \\<le> ennreal C' * ennreal C * eNorm N1 f", "by (metis *(1)[of f] *(2)[of f] mult.commute mult.left_commute mult_left_mono order_trans zero_le)"], ["proof (state)\nthis:\n  eNorm N3 f \\<le> ennreal C' * ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "also"], ["proof (state)\nthis:\n  eNorm N3 f \\<le> ennreal C' * ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "have \"... = ennreal(C' * C) * eNorm N1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal C' * ennreal C * eNorm N1 f = ennreal (C' * C) * eNorm N1 f", "using \\<open>C \\<ge> 0\\<close> \\<open>C' \\<ge> 0\\<close> ennreal_mult"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  0 \\<le> C'\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ennreal (?a * ?b) = ennreal ?a * ennreal ?b\n\ngoal (1 subgoal):\n 1. ennreal C' * ennreal C * eNorm N1 f = ennreal (C' * C) * eNorm N1 f", "by auto"], ["proof (state)\nthis:\n  ennreal C' * ennreal C * eNorm N1 f = ennreal (C' * C) * eNorm N1 f\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "finally"], ["proof (chain)\npicking this:\n  eNorm N3 f \\<le> ennreal (C' * C) * eNorm N1 f", "have \"eNorm N3 f \\<le> ennreal(C' * C) * eNorm N1 f\""], ["proof (prove)\nusing this:\n  eNorm N3 f \\<le> ennreal (C' * C) * eNorm N1 f\n\ngoal (1 subgoal):\n 1. eNorm N3 f \\<le> ennreal (C' * C) * eNorm N1 f", "by simp"], ["proof (state)\nthis:\n  eNorm N3 f \\<le> ennreal (C' * C) * eNorm N1 f\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "}"], ["proof (state)\nthis:\n  eNorm N3 ?f2 \\<le> ennreal (C' * C) * eNorm N1 ?f2\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "then"], ["proof (chain)\npicking this:\n  eNorm N3 ?f2 \\<le> ennreal (C' * C) * eNorm N1 ?f2", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N3 ?f2 \\<le> ennreal (C' * C) * eNorm N1 ?f2\n\ngoal (1 subgoal):\n 1. N1 \\<le> N3", "unfolding less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  eNorm N3 ?f2 \\<le> ennreal (C' * C) * eNorm N1 ?f2\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N3 f \\<le> ennreal C * eNorm N1 f", "using \\<open>C \\<ge> 0\\<close> \\<open>C' \\<ge> 0\\<close> zero_le_mult_iff"], ["proof (prove)\nusing this:\n  eNorm N3 ?f2 \\<le> ennreal (C' * C) * eNorm N1 ?f2\n  0 \\<le> C\n  0 \\<le> C'\n  ((0::?'a) \\<le> ?a * ?b) =\n  ((0::?'a) \\<le> ?a \\<and> (0::?'a) \\<le> ?b \\<or>\n   ?a \\<le> (0::?'a) \\<and> ?b \\<le> (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N3 f \\<le> ennreal C * eNorm N1 f", "by auto"], ["proof (state)\nthis:\n  N1 \\<le> N3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?N1.0 \\<le> ?N2.0; ?N2.0 \\<le> ?N3.0\\<rbrakk>\n  \\<Longrightarrow> ?N1.0 \\<le> ?N3.0\n\ngoal (1 subgoal):\n 1. OFCLASS('a quasinorm, preorder_class)", "show \"OFCLASS('a quasinorm, preorder_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a quasinorm, preorder_class)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "unfolding less_quasinorm_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (x \\<le> y \\<and> \\<not> y \\<le> x) =\n       (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "using E"], ["proof (prove)\nusing this:\n  ?N \\<le> ?N\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "using T"], ["proof (prove)\nusing this:\n  \\<lbrakk>?N1.0 \\<le> ?N2.0; ?N2.0 \\<le> ?N3.0\\<rbrakk>\n  \\<Longrightarrow> ?N1.0 \\<le> ?N3.0\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  OFCLASS('a quasinorm, preorder_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "abbreviation quasinorm_subset :: \"('a::real_vector) quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> bool\"\n  where \"quasinorm_subset \\<equiv> less\""], ["", "abbreviation quasinorm_subset_eq :: \"('a::real_vector) quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> bool\"\n  where \"quasinorm_subset_eq \\<equiv> less_eq\""], ["", "notation\n  quasinorm_subset (\"'(\\<subset>\\<^sub>N')\") and\n  quasinorm_subset (\"(_/ \\<subset>\\<^sub>N _)\" [51, 51] 50) and\n  quasinorm_subset_eq (\"'(\\<subseteq>\\<^sub>N')\") and\n  quasinorm_subset_eq (\"(_/ \\<subseteq>\\<^sub>N _)\" [51, 51] 50)"], ["", "lemma quasinorm_subsetD:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"\\<exists>C\\<ge>(0::real). \\<forall>f. eNorm N2 f \\<le> C * eNorm N1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "using assms"], ["proof (prove)\nusing this:\n  N1 \\<subseteq>\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "unfolding less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "by auto"], ["", "lemma quasinorm_subsetI:\n  assumes \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> eNorm N2 f \\<le> ennreal C * eNorm N1 f\"\n  shows \"N1 \\<subseteq>\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N2", "have \"eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "proof (cases \"f \\<in> space\\<^sub>N N1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f\n 2. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "case True"], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N1\n\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f\n 2. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<in> space\\<^sub>N N1", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "using assms[OF \\<open>f \\<in> space\\<^sub>N N1\\<close>]"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "by (metis (no_types, hide_lams) dual_order.trans ennreal_leI max.cobounded2 max.commute\n      mult.commute ordered_comm_semiring_class.comm_mult_left_mono zero_le)"], ["proof (state)\nthis:\n  eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f\n\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "case False"], ["proof (state)\nthis:\n  f \\<notin> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<notin> space\\<^sub>N N1", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<notin> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "using spaceN_iff"], ["proof (prove)\nusing this:\n  f \\<notin> space\\<^sub>N N1\n  (?x \\<in> space\\<^sub>N ?N) = (eNorm ?N ?x < \\<infinity>)\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f", "by (metis ennreal_ge_1 ennreal_mult_less_top infinity_ennreal_def max.cobounded1\n      max.commute not_le not_one_le_zero top.not_eq_extremum)"], ["proof (state)\nthis:\n  eNorm N2 f \\<le> ennreal (max C 1) * eNorm N1 f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eNorm N2 ?f \\<le> ennreal (max C 1) * eNorm N1 ?f\n\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N2", "then"], ["proof (chain)\npicking this:\n  eNorm N2 ?f \\<le> ennreal (max C 1) * eNorm N1 ?f", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N2 ?f \\<le> ennreal (max C 1) * eNorm N1 ?f\n\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N2", "unfolding less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  eNorm N2 ?f \\<le> ennreal (max C 1) * eNorm N1 ?f\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "by (metis ennreal_max_0' max.cobounded2)"], ["proof (state)\nthis:\n  N1 \\<subseteq>\\<^sub>N N2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_subsetI':\n  assumes \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> f \\<in> space\\<^sub>N N2\"\n          \"\\<And>f. f \\<in> space\\<^sub>N N1 \\<Longrightarrow> Norm N2 f \\<le> C * Norm N1 f\"\n  shows \"N1 \\<subseteq>\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N2", "proof (rule quasinorm_subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "assume \"f \\<in> space\\<^sub>N N1\""], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<in> space\\<^sub>N N1", "have \"f \\<in> space\\<^sub>N N2\""], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N N2", "using assms(1)"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n  ?f \\<in> space\\<^sub>N N1 \\<Longrightarrow> ?f \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N N2", "by simp"], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<in> space\\<^sub>N N2", "have \"eNorm N2 f = ennreal(Norm N2 f)\""], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. eNorm N2 f = ennreal (Norm N2 f)", "using eNorm_Norm"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N2\n  ?x \\<in> space\\<^sub>N ?N \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n\ngoal (1 subgoal):\n 1. eNorm N2 f = ennreal (Norm N2 f)", "by auto"], ["proof (state)\nthis:\n  eNorm N2 f = ennreal (Norm N2 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "also"], ["proof (state)\nthis:\n  eNorm N2 f = ennreal (Norm N2 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "have \"... \\<le> ennreal(C * Norm N1 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (Norm N2 f) \\<le> ennreal (C * Norm N1 f)", "using assms(2)[OF \\<open>f \\<in> space\\<^sub>N N1\\<close>] ennreal_leI"], ["proof (prove)\nusing this:\n  Norm N2 f \\<le> C * Norm N1 f\n  ?x \\<le> ?y \\<Longrightarrow> ennreal ?x \\<le> ennreal ?y\n\ngoal (1 subgoal):\n 1. ennreal (Norm N2 f) \\<le> ennreal (C * Norm N1 f)", "by blast"], ["proof (state)\nthis:\n  ennreal (Norm N2 f) \\<le> ennreal (C * Norm N1 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "also"], ["proof (state)\nthis:\n  ennreal (Norm N2 f) \\<le> ennreal (C * Norm N1 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "have \"... = ennreal C * ennreal(Norm N1 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (C * Norm N1 f) = ennreal C * ennreal (Norm N1 f)", "using ennreal_mult''"], ["proof (prove)\nusing this:\n  0 \\<le> ?b \\<Longrightarrow> ennreal (?a * ?b) = ennreal ?a * ennreal ?b\n\ngoal (1 subgoal):\n 1. ennreal (C * Norm N1 f) = ennreal C * ennreal (Norm N1 f)", "by auto"], ["proof (state)\nthis:\n  ennreal (C * Norm N1 f) = ennreal C * ennreal (Norm N1 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "also"], ["proof (state)\nthis:\n  ennreal (C * Norm N1 f) = ennreal C * ennreal (Norm N1 f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "have \"... = ennreal C * eNorm N1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal C * ennreal (Norm N1 f) = ennreal C * eNorm N1 f", "using eNorm_Norm[OF \\<open>f \\<in> space\\<^sub>N N1\\<close>]"], ["proof (prove)\nusing this:\n  eNorm N1 f = ennreal (Norm N1 f)\n\ngoal (1 subgoal):\n 1. ennreal C * ennreal (Norm N1 f) = ennreal C * eNorm N1 f", "by auto"], ["proof (state)\nthis:\n  ennreal C * ennreal (Norm N1 f) = ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n       eNorm N2 f \\<le> ennreal ?C * eNorm N1 f", "finally"], ["proof (chain)\npicking this:\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f", "show \"eNorm N2 f \\<le> ennreal C * eNorm N1 f\""], ["proof (prove)\nusing this:\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "by simp"], ["proof (state)\nthis:\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_subset_space:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"space\\<^sub>N N1 \\<subseteq> space\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space\\<^sub>N N1 \\<subseteq> space\\<^sub>N N2", "using assms"], ["proof (prove)\nusing this:\n  N1 \\<subseteq>\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. space\\<^sub>N N1 \\<subseteq> space\\<^sub>N N2", "unfolding space\\<^sub>N_def less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. {f. eNorm N1 f < \\<infinity>} \\<subseteq> {f. eNorm N2 f < \\<infinity>}", "by (auto, metis ennreal_mult_eq_top_iff ennreal_neq_top less_le top.extremum_strict top.not_eq_extremum)"], ["", "lemma quasinorm_subset_Norm_eNorm:\n  assumes \"f \\<in> space\\<^sub>N N1 \\<Longrightarrow> Norm N2 f \\<le> C * Norm N1 f\"\n          \"N1 \\<subseteq>\\<^sub>N N2\"\n          \"C > 0\"\n  shows \"eNorm N2 f \\<le> ennreal C * eNorm N1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "proof (cases \"f \\<in> space\\<^sub>N N1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f\n 2. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "case True"], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N1\n\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f\n 2. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<in> space\\<^sub>N N1", "have \"f \\<in> space\\<^sub>N N2\""], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N N2", "using quasinorm_subset_space[OF \\<open>N1 \\<subseteq>\\<^sub>N N2\\<close>]"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N1\n  space\\<^sub>N N1 \\<subseteq> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. f \\<in> space\\<^sub>N N2", "by auto"], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N2\n\ngoal (2 subgoals):\n 1. f \\<in> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f\n 2. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<in> space\\<^sub>N N2", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "using eNorm_Norm[OF True] eNorm_Norm assms(1)[OF True]"], ["proof (prove)\nusing this:\n  f \\<in> space\\<^sub>N N2\n  eNorm N1 f = ennreal (Norm N1 f)\n  ?x \\<in> space\\<^sub>N ?N \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n  Norm N2 f \\<le> C * Norm N1 f\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "by (metis Norm_nonneg ennreal_leI ennreal_mult'')"], ["proof (state)\nthis:\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "case False"], ["proof (state)\nthis:\n  f \\<notin> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. f \\<notin> space\\<^sub>N N1 \\<Longrightarrow>\n    eNorm N2 f \\<le> ennreal C * eNorm N1 f", "then"], ["proof (chain)\npicking this:\n  f \\<notin> space\\<^sub>N N1", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<notin> space\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "using \\<open>C > 0\\<close>"], ["proof (prove)\nusing this:\n  f \\<notin> space\\<^sub>N N1\n  0 < C\n\ngoal (1 subgoal):\n 1. eNorm N2 f \\<le> ennreal C * eNorm N1 f", "by (metis ennreal_eq_zero_iff ennreal_mult_eq_top_iff infinity_ennreal_def less_imp_le neq_top_trans not_le spaceN_iff)"], ["proof (state)\nthis:\n  eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_subset_zero_space:\n  assumes \"N1 \\<subseteq>\\<^sub>N N2\"\n  shows \"zero_space\\<^sub>N N1 \\<subseteq> zero_space\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N N1 \\<subseteq> zero_space\\<^sub>N N2", "using assms"], ["proof (prove)\nusing this:\n  N1 \\<subseteq>\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N N1 \\<subseteq> zero_space\\<^sub>N N2", "unfolding zero_space\\<^sub>N_def less_eq_quasinorm_def"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N1 f\n\ngoal (1 subgoal):\n 1. {f. eNorm N1 f = 0} \\<subseteq> {f. eNorm N2 f = 0}", "by (auto, metis le_zero_eq mult_zero_right)"], ["", "text \\<open>We would like to define the equivalence relation associated to the above order, i.e., the\nequivalence between norms. This is not equality, so we do not have a true order, but nevertheless\nthis is handy, and not standard in a preorder in Isabelle. The file Library/Preorder.thy defines\nsuch an equivalence relation, but including it breaks some proofs so we go the naive way.\\<close>"], ["", "definition quasinorm_equivalent::\"('a::real_vector) quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> bool\" (infix \"=\\<^sub>N\" 60)\n  where \"quasinorm_equivalent N1 N2 = ((N1 \\<subseteq>\\<^sub>N N2) \\<and> (N2 \\<subseteq>\\<^sub>N N1))\""], ["", "lemma quasinorm_equivalent_sym [sym]:\n  assumes \"N1 =\\<^sub>N N2\"\n  shows \"N2 =\\<^sub>N N1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N2 =\\<^sub>N N1", "using assms"], ["proof (prove)\nusing this:\n  N1 =\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. N2 =\\<^sub>N N1", "unfolding quasinorm_equivalent_def"], ["proof (prove)\nusing this:\n  N1 \\<subseteq>\\<^sub>N N2 \\<and> N2 \\<subseteq>\\<^sub>N N1\n\ngoal (1 subgoal):\n 1. N2 \\<subseteq>\\<^sub>N N1 \\<and> N1 \\<subseteq>\\<^sub>N N2", "by auto"], ["", "lemma quasinorm_equivalent_trans [trans]:\n  assumes \"N1 =\\<^sub>N N2\" \"N2 =\\<^sub>N N3\"\n  shows \"N1 =\\<^sub>N N3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 =\\<^sub>N N3", "using assms order_trans"], ["proof (prove)\nusing this:\n  N1 =\\<^sub>N N2\n  N2 =\\<^sub>N N3\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. N1 =\\<^sub>N N3", "unfolding quasinorm_equivalent_def"], ["proof (prove)\nusing this:\n  N1 \\<subseteq>\\<^sub>N N2 \\<and> N2 \\<subseteq>\\<^sub>N N1\n  N2 \\<subseteq>\\<^sub>N N3 \\<and> N3 \\<subseteq>\\<^sub>N N2\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N3 \\<and> N3 \\<subseteq>\\<^sub>N N1", "by blast"], ["", "subsection \\<open>The intersection and the sum of two functional spaces\\<close>"], ["", "text \\<open>In this paragraph, we define the intersection and the sum of two functional spaces.\nIn terms of the order introduced above, this corresponds to the minimum and the maximum.\nMore important, these are the first two examples of interpolation spaces between two\nfunctional spaces, and they are central as all the other ones are built using them.\\<close>"], ["", "definition quasinorm_intersection::\"('a::real_vector) quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> 'a quasinorm\" (infix \"\\<inter>\\<^sub>N\" 70)\n  where \"quasinorm_intersection N1 N2 = quasinorm_of (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f)\""], ["", "lemma quasinorm_intersection:\n  \"eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\"\n  \"defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f &&&\n    defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\n 2. defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)", "have T: \"eNorm N1 (x + y) + eNorm N2 (x + y) \\<le>\n    ennreal (max (defect N1) (defect N2)) * (eNorm N1 x + eNorm N2 x) + ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "have \"eNorm N1 (x + y) \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x + ennreal (max (defect N1) (defect N2)) * eNorm N1 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n          ennreal (max (defect N1) (defect N2)) * eNorm N1 y", "using eNorm_triangular_ineq[of N1 x y]"], ["proof (prove)\nusing this:\n  eNorm N1 (x + y)\n  \\<le> ennreal (defect N1) * eNorm N1 x + ennreal (defect N1) * eNorm N1 y\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n          ennreal (max (defect N1) (defect N2)) * eNorm N1 y", "by (metis (no_types) max_def distrib_left ennreal_leI mult_right_mono order_trans zero_le)"], ["proof (state)\nthis:\n  eNorm N1 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 y\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "moreover"], ["proof (state)\nthis:\n  eNorm N1 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 y\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "have \"eNorm N2 (x + y) \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x + ennreal (max (defect N1) (defect N2)) * eNorm N2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x +\n          ennreal (max (defect N1) (defect N2)) * eNorm N2 y", "using eNorm_triangular_ineq[of N2 x y]"], ["proof (prove)\nusing this:\n  eNorm N2 (x + y)\n  \\<le> ennreal (defect N2) * eNorm N2 x + ennreal (defect N2) * eNorm N2 y\n\ngoal (1 subgoal):\n 1. eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x +\n          ennreal (max (defect N1) (defect N2)) * eNorm N2 y", "by (metis (no_types) max_def max.commute distrib_left ennreal_leI mult_right_mono order_trans zero_le)"], ["proof (state)\nthis:\n  eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N2 y\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "ultimately"], ["proof (chain)\npicking this:\n  eNorm N1 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 y\n  eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N2 y", "have \"eNorm N1 (x + y) + eNorm N2 (x + y) \\<le> ennreal (max (defect N1) (defect N2)) * (eNorm N1 x + eNorm N1 y + (eNorm N2 x + eNorm N2 y))\""], ["proof (prove)\nusing this:\n  eNorm N1 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 y\n  eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N2 x +\n        ennreal (max (defect N1) (defect N2)) * eNorm N2 y\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N1 y + (eNorm N2 x + eNorm N2 y))", "by (simp add: add_mono_thms_linordered_semiring(1) distrib_left)"], ["proof (state)\nthis:\n  eNorm N1 (x + y) + eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        (eNorm N1 x + eNorm N1 y + (eNorm N2 x + eNorm N2 y))\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "then"], ["proof (chain)\npicking this:\n  eNorm N1 (x + y) + eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        (eNorm N1 x + eNorm N1 y + (eNorm N2 x + eNorm N2 y))", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N1 (x + y) + eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        (eNorm N1 x + eNorm N1 y + (eNorm N2 x + eNorm N2 y))\n\ngoal (1 subgoal):\n 1. eNorm N1 (x + y) + eNorm N2 (x + y)\n    \\<le> ennreal (max (defect N1) (defect N2)) *\n          (eNorm N1 x + eNorm N2 x) +\n          ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)", "by (simp add: ab_semigroup_add_class.add_ac(1) add.left_commute distrib_left)"], ["proof (state)\nthis:\n  eNorm N1 (x + y) + eNorm N2 (x + y)\n  \\<le> ennreal (max (defect N1) (defect N2)) * (eNorm N1 x + eNorm N2 x) +\n        ennreal (max (defect N1) (defect N2)) * (eNorm N1 y + eNorm N2 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eNorm N1 (?x + ?y) + eNorm N2 (?x + ?y)\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        (eNorm N1 ?x + eNorm N2 ?x) +\n        ennreal (max (defect N1) (defect N2)) * (eNorm N1 ?y + eNorm N2 ?y)\n\ngoal (2 subgoals):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\n 2. defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)", "have H: \"eNorm N1 (c *\\<^sub>R x) + eNorm N2 (c *\\<^sub>R x) \\<le> ennreal \\<bar>c\\<bar> * (eNorm N1 x + eNorm N2 x)\" for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (c *\\<^sub>R x) + eNorm N2 (c *\\<^sub>R x)\n    \\<le> ennreal \\<bar>c\\<bar> * (eNorm N1 x + eNorm N2 x)", "by (simp add: eNorm_cmult[of N1 c x] eNorm_cmult[of N2 c x] distrib_left)"], ["proof (state)\nthis:\n  eNorm N1 (?c *\\<^sub>R ?x) + eNorm N2 (?c *\\<^sub>R ?x)\n  \\<le> ennreal \\<bar>?c\\<bar> * (eNorm N1 ?x + eNorm N2 ?x)\n\ngoal (2 subgoals):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\n 2. defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)", "have *: \"quasinorm_on UNIV (max (defect N1) (defect N2)) (\\<lambda>f. eNorm N1 f + eNorm N2 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV (max (defect N1) (defect N2))\n     (\\<lambda>f. eNorm N1 f + eNorm N2 f)", "apply (rule quasinorm_onI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 (x + y) + eNorm N2 (x + y)\n                         \\<le> ennreal (max (defect N1) (defect N2)) *\n                               (eNorm N1 x + eNorm N2 x) +\n                               ennreal (max (defect N1) (defect N2)) *\n                               (eNorm N1 y + eNorm N2 y)\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 (c *\\<^sub>R x) + eNorm N2 (c *\\<^sub>R x)\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               (eNorm N1 x + eNorm N2 x)\n 5. (0::'a) \\<in> UNIV\n 6. eNorm N1 (0::'a) + eNorm N2 (0::'a) = 0\n 7. 1 \\<le> max (defect N1) (defect N2)", "using T H defect_ge_1[of N1] defect_ge_1[of N2]"], ["proof (prove)\nusing this:\n  eNorm N1 (?x + ?y) + eNorm N2 (?x + ?y)\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        (eNorm N1 ?x + eNorm N2 ?x) +\n        ennreal (max (defect N1) (defect N2)) * (eNorm N1 ?y + eNorm N2 ?y)\n  eNorm N1 (?c *\\<^sub>R ?x) + eNorm N2 (?c *\\<^sub>R ?x)\n  \\<le> ennreal \\<bar>?c\\<bar> * (eNorm N1 ?x + eNorm N2 ?x)\n  1 \\<le> defect N1\n  1 \\<le> defect N2\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 (x + y) + eNorm N2 (x + y)\n                         \\<le> ennreal (max (defect N1) (defect N2)) *\n                               (eNorm N1 x + eNorm N2 x) +\n                               ennreal (max (defect N1) (defect N2)) *\n                               (eNorm N1 y + eNorm N2 y)\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 (c *\\<^sub>R x) + eNorm N2 (c *\\<^sub>R x)\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               (eNorm N1 x + eNorm N2 x)\n 5. (0::'a) \\<in> UNIV\n 6. eNorm N1 (0::'a) + eNorm N2 (0::'a) = 0\n 7. 1 \\<le> max (defect N1) (defect N2)", "by auto"], ["proof (state)\nthis:\n  quasinorm_on UNIV (max (defect N1) (defect N2))\n   (\\<lambda>f. eNorm N1 f + eNorm N2 f)\n\ngoal (2 subgoals):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\n 2. defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)", "show \"defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)\"\n       \"eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2) &&&\n    eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f", "unfolding quasinorm_intersection_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. defect\n     (quasinorm_of\n       (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f)) =\n    max (defect N1) (defect N2) &&&\n    eNorm\n     (quasinorm_of\n       (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f))\n     f =\n    eNorm N1 f + eNorm N2 f", "using quasinorm_of[OF *]"], ["proof (prove)\nusing this:\n  eNorm\n   (quasinorm_of\n     (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f))\n   ?x =\n  eNorm N1 ?x + eNorm N2 ?x\n  defect\n   (quasinorm_of\n     (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f)) =\n  max (defect N1) (defect N2)\n\ngoal (1 subgoal):\n 1. defect\n     (quasinorm_of\n       (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f)) =\n    max (defect N1) (defect N2) &&&\n    eNorm\n     (quasinorm_of\n       (max (defect N1) (defect N2), \\<lambda>f. eNorm N1 f + eNorm N2 f))\n     f =\n    eNorm N1 f + eNorm N2 f", "by auto"], ["proof (state)\nthis:\n  defect (N1 \\<inter>\\<^sub>N N2) = max (defect N1) (defect N2)\n  eNorm (N1 \\<inter>\\<^sub>N N2) f = eNorm N1 f + eNorm N2 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_intersection_commute:\n  \"N1 \\<inter>\\<^sub>N N2 = N2 \\<inter>\\<^sub>N N1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<inter>\\<^sub>N N2 = N2 \\<inter>\\<^sub>N N1", "unfolding quasinorm_intersection_def max.commute[of \"defect N1\"] add.commute[of \"eNorm N1 _\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_of\n     (max (defect N2) (defect N1), \\<lambda>f. eNorm N2 f + eNorm N1 f) =\n    quasinorm_of\n     (max (defect N2) (defect N1), \\<lambda>f. eNorm N2 f + eNorm N1 f)", "by simp"], ["", "lemma quasinorm_intersection_space:\n  \"space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) = space\\<^sub>N N1 \\<inter> space\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) =\n    space\\<^sub>N N1 \\<inter> space\\<^sub>N N2", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) \\<Longrightarrow>\n       x \\<in> space\\<^sub>N N1\n 2. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) \\<Longrightarrow>\n       x \\<in> space\\<^sub>N N2\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> space\\<^sub>N N1; x \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> space\\<^sub>N (N1 \\<inter>\\<^sub>N N2)", "unfolding quasinorm_intersection(1) spaceN_iff"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       eNorm N1 x + eNorm N2 x < \\<infinity> \\<Longrightarrow>\n       eNorm N1 x < \\<infinity>\n 2. \\<And>x.\n       eNorm N1 x + eNorm N2 x < \\<infinity> \\<Longrightarrow>\n       eNorm N2 x < \\<infinity>\n 3. \\<And>x.\n       \\<lbrakk>eNorm N1 x < \\<infinity>; eNorm N2 x < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 x + eNorm N2 x < \\<infinity>", "by auto"], ["", "lemma quasinorm_intersection_zero_space:\n  \"zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) = zero_space\\<^sub>N N1 \\<inter> zero_space\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) =\n    zero_space\\<^sub>N N1 \\<inter> zero_space\\<^sub>N N2", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) \\<Longrightarrow>\n       x \\<in> zero_space\\<^sub>N N1\n 2. \\<And>x.\n       x \\<in> zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2) \\<Longrightarrow>\n       x \\<in> zero_space\\<^sub>N N2\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> zero_space\\<^sub>N N1;\n        x \\<in> zero_space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> x \\<in> zero_space\\<^sub>N (N1 \\<inter>\\<^sub>N N2)", "unfolding quasinorm_intersection(1) zero_spaceN_iff"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. eNorm N1 x + eNorm N2 x = 0 \\<Longrightarrow> eNorm N1 x = 0\n 2. \\<And>x. eNorm N1 x + eNorm N2 x = 0 \\<Longrightarrow> eNorm N2 x = 0\n 3. \\<And>x.\n       \\<lbrakk>eNorm N1 x = 0; eNorm N2 x = 0\\<rbrakk>\n       \\<Longrightarrow> eNorm N1 x + eNorm N2 x = 0", "by (auto simp add: add_eq_0_iff_both_eq_0)"], ["", "lemma quasinorm_intersection_subset:\n  \"N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N1\" \"N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N1 &&&\n    N1 \\<inter>\\<^sub>N N2 \\<subseteq>\\<^sub>N N2", "by (rule quasinorm_subsetI[of _ _ 1], auto simp add: quasinorm_intersection(1))+"], ["", "lemma quasinorm_intersection_minimum:\n  assumes \"N \\<subseteq>\\<^sub>N N1\" \"N \\<subseteq>\\<^sub>N N2\"\n  shows \"N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2", "obtain C1 C2::real where *: \"\\<And>f. eNorm N1 f \\<le> C1 * eNorm N f\"\n                              \"\\<And>f. eNorm N2 f \\<le> C2 * eNorm N f\"\n                              \"C1 \\<ge> 0\" \"C2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C1 C2.\n        \\<lbrakk>\\<And>f. eNorm N1 f \\<le> ennreal C1 * eNorm N f;\n         \\<And>f. eNorm N2 f \\<le> ennreal C2 * eNorm N f; 0 \\<le> C1;\n         0 \\<le> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasinorm_subsetD[OF assms(1)] quasinorm_subsetD[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N1 f \\<le> ennreal C * eNorm N f\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N2 f \\<le> ennreal C * eNorm N f\n\ngoal (1 subgoal):\n 1. (\\<And>C1 C2.\n        \\<lbrakk>\\<And>f. eNorm N1 f \\<le> ennreal C1 * eNorm N f;\n         \\<And>f. eNorm N2 f \\<le> ennreal C2 * eNorm N f; 0 \\<le> C1;\n         0 \\<le> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eNorm N1 ?f \\<le> ennreal C1 * eNorm N ?f\n  eNorm N2 ?f \\<le> ennreal C2 * eNorm N ?f\n  0 \\<le> C1\n  0 \\<le> C2\n\ngoal (1 subgoal):\n 1. N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2", "have **: \"eNorm (N1 \\<inter>\\<^sub>N N2) f \\<le> (C1 + C2) * eNorm N f\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm (N1 \\<inter>\\<^sub>N N2) f \\<le> ennreal (C1 + C2) * eNorm N f", "unfolding quasinorm_intersection(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 f + eNorm N2 f \\<le> ennreal (C1 + C2) * eNorm N f", "using add_mono[OF *(1) *(2)]"], ["proof (prove)\nusing this:\n  eNorm N1 ?f2 + eNorm N2 ?f1\n  \\<le> ennreal C1 * eNorm N ?f2 + ennreal C2 * eNorm N ?f1\n\ngoal (1 subgoal):\n 1. eNorm N1 f + eNorm N2 f \\<le> ennreal (C1 + C2) * eNorm N f", "by (simp add: distrib_right *)"], ["proof (state)\nthis:\n  eNorm (N1 \\<inter>\\<^sub>N N2) ?f \\<le> ennreal (C1 + C2) * eNorm N ?f\n\ngoal (1 subgoal):\n 1. N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2", "apply (rule quasinorm_subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N \\<Longrightarrow>\n       eNorm (N1 \\<inter>\\<^sub>N N2) f \\<le> ennreal ?C * eNorm N f", "using **"], ["proof (prove)\nusing this:\n  eNorm (N1 \\<inter>\\<^sub>N N2) ?f \\<le> ennreal (C1 + C2) * eNorm N ?f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> space\\<^sub>N N \\<Longrightarrow>\n       eNorm (N1 \\<inter>\\<^sub>N N2) f \\<le> ennreal ?C * eNorm N f", "by auto"], ["proof (state)\nthis:\n  N \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N N2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_intersection_assoc:\n  \"(N1 \\<inter>\\<^sub>N N2) \\<inter>\\<^sub>N N3 =\\<^sub>N N1 \\<inter>\\<^sub>N (N2 \\<inter>\\<^sub>N N3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N1 \\<inter>\\<^sub>N N2) \\<inter>\\<^sub>N N3 =\\<^sub>N\n    N1 \\<inter>\\<^sub>N (N2 \\<inter>\\<^sub>N N3)", "unfolding quasinorm_equivalent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (N1 \\<inter>\\<^sub>N N2) \\<inter>\\<^sub>N N3\n    \\<subseteq>\\<^sub>N N1 \\<inter>\\<^sub>N (N2 \\<inter>\\<^sub>N N3) \\<and>\n    N1 \\<inter>\\<^sub>N (N2 \\<inter>\\<^sub>N N3)\n    \\<subseteq>\\<^sub>N (N1 \\<inter>\\<^sub>N N2) \\<inter>\\<^sub>N N3", "by (meson order_trans quasinorm_intersection_minimum quasinorm_intersection_subset)"], ["", "definition quasinorm_sum::\"('a::real_vector) quasinorm \\<Rightarrow> 'a quasinorm \\<Rightarrow> 'a quasinorm\" (infix \"+\\<^sub>N\" 70)\n  where \"quasinorm_sum N1 N2 = quasinorm_of (max (defect N1) (defect N2), \\<lambda>f. Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2})\""], ["", "lemma quasinorm_sum:\n  \"eNorm (N1 +\\<^sub>N N2) f = Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\"\n  \"defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2} &&&\n    defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "define N where \"N = (\\<lambda>f. Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2})\""], ["proof (state)\nthis:\n  N =\n  (\\<lambda>f. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "have T: \"N (f+g) \\<le>\n    ennreal (max (defect N1) (defect N2)) * N f + ennreal (max (defect N1) (defect N2)) * N g\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"\\<exists>u. (\\<forall>n. u n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}) \\<and> u \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       (\\<forall>n.\n           u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n       u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n         f2. f = f1 + f2}", "by (rule Inf_as_limit, auto, rule exI[of _ \"f\"], rule exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}", "obtain uf where uf: \"\\<And>n. uf n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\"\n                             \"uf \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. (\\<And>uf.\n        \\<lbrakk>\\<And>n.\n                    uf n\n                    \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2};\n         uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 +\n            eNorm N2 f2 |\n            f1 f2. f = f1 + f2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n  uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2}\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"\\<exists>f1 f2. \\<forall>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       \\<forall>n.\n          uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "apply (rule SMT.choices(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "using uf(1)"], ["proof (prove)\nusing this:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "by blast"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "then"], ["proof (chain)\npicking this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "obtain f1 f2 where F: \"\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n)\" \"\\<And>n. f = f1 n + f2 n\""], ["proof (prove)\nusing this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n);\n         \\<And>n. f = f1 n + f2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n  f = f1 ?n + f2 ?n\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"\\<exists>u. (\\<forall>n. u n \\<in> {eNorm N1 g1 + eNorm N2 g2| g1 g2. g = g1 + g2}) \\<and> u \\<longlonglongrightarrow> Inf {eNorm N1 g1 + eNorm N2 g2| g1 g2. g = g1 + g2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       (\\<forall>n.\n           u n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}) \\<and>\n       u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 + eNorm N2 g2 |g1\n         g2. g = g1 + g2}", "by (rule Inf_as_limit, auto, rule exI[of _ \"g\"], rule exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 + eNorm N2 g2 |g1\n       g2. g = g1 + g2}\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 + eNorm N2 g2 |g1\n       g2. g = g1 + g2}", "obtain ug where ug: \"\\<And>n. ug n \\<in> {eNorm N1 g1 + eNorm N2 g2| g1 g2. g = g1 + g2}\"\n                             \"ug \\<longlonglongrightarrow> Inf {eNorm N1 g1 + eNorm N2 g2| g1 g2. g = g1 + g2}\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 + eNorm N2 g2 |g1\n       g2. g = g1 + g2}\n\ngoal (1 subgoal):\n 1. (\\<And>ug.\n        \\<lbrakk>\\<And>n.\n                    ug n\n                    \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2};\n         ug \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 +\n            eNorm N2 g2 |\n            g1 g2. g = g1 + g2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ug ?n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}\n  ug \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 g1 + eNorm N2 g2 |g1 g2.\n     g = g1 + g2}\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"\\<exists>g1 g2. \\<forall>n. ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n) \\<and> g = g1 n + g2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g1 g2.\n       \\<forall>n.\n          ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n) \\<and> g = g1 n + g2 n", "apply (rule SMT.choices(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. ug n = eNorm N1 y + eNorm N2 ya \\<and> g = y + ya", "using ug(1)"], ["proof (prove)\nusing this:\n  ug ?n \\<in> {eNorm N1 g1 + eNorm N2 g2 |g1 g2. g = g1 + g2}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. ug n = eNorm N1 y + eNorm N2 ya \\<and> g = y + ya", "by blast"], ["proof (state)\nthis:\n  \\<exists>g1 g2.\n     \\<forall>n.\n        ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n) \\<and> g = g1 n + g2 n\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "then"], ["proof (chain)\npicking this:\n  \\<exists>g1 g2.\n     \\<forall>n.\n        ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n) \\<and> g = g1 n + g2 n", "obtain g1 g2 where G: \"\\<And>n. ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n)\" \"\\<And>n. g = g1 n + g2 n\""], ["proof (prove)\nusing this:\n  \\<exists>g1 g2.\n     \\<forall>n.\n        ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n) \\<and> g = g1 n + g2 n\n\ngoal (1 subgoal):\n 1. (\\<And>g1 g2.\n        \\<lbrakk>\\<And>n. ug n = eNorm N1 (g1 n) + eNorm N2 (g2 n);\n         \\<And>n. g = g1 n + g2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ug ?n = eNorm N1 (g1 ?n) + eNorm N2 (g2 ?n)\n  g = g1 ?n + g2 ?n\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "define h1 where \"h1 = (\\<lambda>n. f1 n + g1 n)\""], ["proof (state)\nthis:\n  h1 = (\\<lambda>n. f1 n + g1 n)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "define h2 where \"h2 = (\\<lambda>n. f2 n + g2 n)\""], ["proof (state)\nthis:\n  h2 = (\\<lambda>n. f2 n + g2 n)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have *: \"f + g = h1 n + h2 n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f + g = h1 n + h2 n", "unfolding h1_def h2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f + g = f1 n + g1 n + (f2 n + g2 n)", "using F(2) G(2)"], ["proof (prove)\nusing this:\n  f = f1 ?n + f2 ?n\n  g = g1 ?n + g2 ?n\n\ngoal (1 subgoal):\n 1. f + g = f1 n + g1 n + (f2 n + g2 n)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  f + g = h1 ?n + h2 ?n\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"N (f+g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "have \"N (f+g) \\<le> eNorm N1 (h1 n) + eNorm N2 (h2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (f + g) \\<le> eNorm N1 (h1 n) + eNorm N2 (h2 n)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2}\n    \\<le> eNorm N1 (h1 n) + eNorm N2 (h2 n)", "apply (rule Inf_lower, auto, rule exI[of _ \"h1 n\"], rule exI[of _ \"h2 n\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (h1 n) + eNorm N2 (h2 n) =\n    eNorm N1 (h1 n) + eNorm N2 (h2 n) \\<and>\n    f + g = h1 n + h2 n", "using *"], ["proof (prove)\nusing this:\n  f + g = h1 ?n + h2 ?n\n\ngoal (1 subgoal):\n 1. eNorm N1 (h1 n) + eNorm N2 (h2 n) =\n    eNorm N1 (h1 n) + eNorm N2 (h2 n) \\<and>\n    f + g = h1 n + h2 n", "by auto"], ["proof (state)\nthis:\n  N (f + g) \\<le> eNorm N1 (h1 n) + eNorm N2 (h2 n)\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "also"], ["proof (state)\nthis:\n  N (f + g) \\<le> eNorm N1 (h1 n) + eNorm N2 (h2 n)\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "have \"... \\<le> ennreal (defect N1) * eNorm N1 (f1 n) + ennreal (defect N1) * eNorm N1 (g1 n)\n                      + (ennreal (defect N2) * eNorm N2 (f2 n) + ennreal (defect N2) * eNorm N2 (g2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (h1 n) + eNorm N2 (h2 n)\n    \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n          ennreal (defect N1) * eNorm N1 (g1 n) +\n          (ennreal (defect N2) * eNorm N2 (f2 n) +\n           ennreal (defect N2) * eNorm N2 (g2 n))", "unfolding h1_def h2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (f1 n + g1 n) + eNorm N2 (f2 n + g2 n)\n    \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n          ennreal (defect N1) * eNorm N1 (g1 n) +\n          (ennreal (defect N2) * eNorm N2 (f2 n) +\n           ennreal (defect N2) * eNorm N2 (g2 n))", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. eNorm N1 (f1 n + g1 n)\n    \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n          ennreal (defect N1) * eNorm N1 (g1 n)\n 2. eNorm N2 (f2 n + g2 n)\n    \\<le> ennreal (defect N2) * eNorm N2 (f2 n) +\n          ennreal (defect N2) * eNorm N2 (g2 n)", "using eNorm_triangular_ineq"], ["proof (prove)\nusing this:\n  eNorm ?N (?x + ?y)\n  \\<le> ennreal (defect ?N) * eNorm ?N ?x +\n        ennreal (defect ?N) * eNorm ?N ?y\n\ngoal (2 subgoals):\n 1. eNorm N1 (f1 n + g1 n)\n    \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n          ennreal (defect N1) * eNorm N1 (g1 n)\n 2. eNorm N2 (f2 n + g2 n)\n    \\<le> ennreal (defect N2) * eNorm N2 (f2 n) +\n          ennreal (defect N2) * eNorm N2 (g2 n)", "by auto"], ["proof (state)\nthis:\n  eNorm N1 (h1 n) + eNorm N2 (h2 n)\n  \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n        ennreal (defect N1) * eNorm N1 (g1 n) +\n        (ennreal (defect N2) * eNorm N2 (f2 n) +\n         ennreal (defect N2) * eNorm N2 (g2 n))\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "also"], ["proof (state)\nthis:\n  eNorm N1 (h1 n) + eNorm N2 (h2 n)\n  \\<le> ennreal (defect N1) * eNorm N1 (f1 n) +\n        ennreal (defect N1) * eNorm N1 (g1 n) +\n        (ennreal (defect N2) * eNorm N2 (f2 n) +\n         ennreal (defect N2) * eNorm N2 (g2 n))\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "have \"... \\<le> (ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) + ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n))\n                      + (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) + ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N1) * eNorm N1 (f1 n) +\n    ennreal (defect N1) * eNorm N1 (g1 n) +\n    (ennreal (defect N2) * eNorm N2 (f2 n) +\n     ennreal (defect N2) * eNorm N2 (g2 n))\n    \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n          ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n          (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n           ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n))", "by (auto intro!: add_mono mult_mono ennreal_leI)"], ["proof (state)\nthis:\n  ennreal (defect N1) * eNorm N1 (f1 n) +\n  ennreal (defect N1) * eNorm N1 (g1 n) +\n  (ennreal (defect N2) * eNorm N2 (f2 n) +\n   ennreal (defect N2) * eNorm N2 (g2 n))\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n        (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n         ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n))\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "also"], ["proof (state)\nthis:\n  ennreal (defect N1) * eNorm N1 (f1 n) +\n  ennreal (defect N1) * eNorm N1 (g1 n) +\n  (ennreal (defect N2) * eNorm N2 (f2 n) +\n   ennreal (defect N2) * eNorm N2 (g2 n))\n  \\<le> ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n        ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n        (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n         ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n))\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "have \"... = ennreal (max (defect N1) (defect N2)) * (uf n + ug n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n    ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n    (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n     ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n)) =\n    ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "unfolding F(1) G(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n    ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n    (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n     ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n)) =\n    ennreal (max (defect N1) (defect N2)) *\n    (eNorm N1 (f1 n) + eNorm N2 (f2 n) +\n     (eNorm N1 (g1 n) + eNorm N2 (g2 n)))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ennreal (max (defect N1) (defect N2)) * eNorm N1 (f1 n) +\n  ennreal (max (defect N1) (defect N2)) * eNorm N1 (g1 n) +\n  (ennreal (max (defect N1) (defect N2)) * eNorm N2 (f2 n) +\n   ennreal (max (defect N1) (defect N2)) * eNorm N2 (g2 n)) =\n  ennreal (max (defect N1) (defect N2)) * (uf n + ug n)\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "finally"], ["proof (chain)\npicking this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "show ?thesis"], ["proof (prove)\nusing this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)", "by simp"], ["proof (state)\nthis:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf n + ug n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf ?n + ug ?n)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "moreover"], ["proof (state)\nthis:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf ?n + ug ?n)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "have \"... \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) * (N f + N g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n    \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                              (N f + N g)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n    \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                              (\\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2} +\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     g = f1 + f2})", "by (auto intro!: tendsto_intros simp add: uf(2) ug(2))"], ["proof (state)\nthis:\n  (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n  \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                            (N f + N g)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "ultimately"], ["proof (chain)\npicking this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf ?n + ug ?n)\n  (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n  \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                            (N f + N g)", "have \"N (f+g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)\""], ["proof (prove)\nusing this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf ?n + ug ?n)\n  (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n  \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                            (N f + N g)\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (uf ?n + ug ?n)\n  (\\<lambda>n. ennreal (max (defect N1) (defect N2)) * (uf n + ug n))\n  \\<longlonglongrightarrow> ennreal (max (defect N1) (defect N2)) *\n                            (N f + N g)\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)", "by blast"], ["proof (state)\nthis:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "then"], ["proof (chain)\npicking this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)", "show ?thesis"], ["proof (prove)\nusing this:\n  N (f + g) \\<le> ennreal (max (defect N1) (defect N2)) * (N f + N g)\n\ngoal (1 subgoal):\n 1. N (f + g)\n    \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n          ennreal (max (defect N1) (defect N2)) * N g", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  N (f + g)\n  \\<le> ennreal (max (defect N1) (defect N2)) * N f +\n        ennreal (max (defect N1) (defect N2)) * N g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N (?f + ?g)\n  \\<le> ennreal (max (defect N1) (defect N2)) * N ?f +\n        ennreal (max (defect N1) (defect N2)) * N ?g\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "have H: \"N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f\" for c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "have \"\\<exists>u. (\\<forall>n. u n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}) \\<and> u \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       (\\<forall>n.\n           u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n       u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n         f2. f = f1 + f2}", "by (rule Inf_as_limit, auto, rule exI[of _ \"f\"], rule exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}", "obtain uf where uf: \"\\<And>n. uf n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\"\n                             \"uf \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. (\\<And>uf.\n        \\<lbrakk>\\<And>n.\n                    uf n\n                    \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2};\n         uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 +\n            eNorm N2 f2 |\n            f1 f2. f = f1 + f2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n  uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2}\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "have \"\\<exists>f1 f2. \\<forall>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       \\<forall>n.\n          uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "apply (rule SMT.choices(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "using uf(1)"], ["proof (prove)\nusing this:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "by blast"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "then"], ["proof (chain)\npicking this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "obtain f1 f2 where F: \"\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n)\" \"\\<And>n. f = f1 n + f2 n\""], ["proof (prove)\nusing this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n);\n         \\<And>n. f = f1 n + f2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n  f = f1 ?n + f2 ?n\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "have \"N (c *\\<^sub>R f) \\<le> \\<bar>c\\<bar> * uf n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "have \"N (c *\\<^sub>R f) \\<le> eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f)\n    \\<le> eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. c *\\<^sub>R f = f1 + f2}\n    \\<le> eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n)", "apply (rule Inf_lower, auto, rule exI[of _ \"c *\\<^sub>R f1 n\"], rule exI[of _ \"c *\\<^sub>R f2 n\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) =\n    eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) \\<and>\n    c *\\<^sub>R f = c *\\<^sub>R f1 n + c *\\<^sub>R f2 n", "using F(2)[of n] scaleR_add_right"], ["proof (prove)\nusing this:\n  f = f1 n + f2 n\n  ?a *\\<^sub>R (?x + ?y) = ?a *\\<^sub>R ?x + ?a *\\<^sub>R ?y\n\ngoal (1 subgoal):\n 1. eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) =\n    eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) \\<and>\n    c *\\<^sub>R f = c *\\<^sub>R f1 n + c *\\<^sub>R f2 n", "by auto"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f)\n  \\<le> eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n)\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "also"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f)\n  \\<le> eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n)\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "have \"... = \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) =\n    ennreal \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "by (auto simp add: algebra_simps eNorm_cmult)"], ["proof (state)\nthis:\n  eNorm N1 (c *\\<^sub>R f1 n) + eNorm N2 (c *\\<^sub>R f2 n) =\n  ennreal \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "finally"], ["proof (chain)\npicking this:\n  N (c *\\<^sub>R f)\n  \\<le> ennreal \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "show ?thesis"], ["proof (prove)\nusing this:\n  N (c *\\<^sub>R f)\n  \\<le> ennreal \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "using F(1)"], ["proof (prove)\nusing this:\n  N (c *\\<^sub>R f)\n  \\<le> ennreal \\<bar>c\\<bar> * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n", "by simp"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf ?n\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "moreover"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf ?n\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "have \"... \\<longlonglongrightarrow> \\<bar>c\\<bar> * N f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n    \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> * N f", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n    \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> *\n                              \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n    f = f1 + f2}", "by (auto intro!: tendsto_intros simp add: uf(2))"], ["proof (state)\nthis:\n  (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n  \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> * N f\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "ultimately"], ["proof (chain)\npicking this:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf ?n\n  (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n  \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> * N f", "show ?thesis"], ["proof (prove)\nusing this:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf ?n\n  (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n  \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> * N f\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * uf ?n\n  (\\<lambda>n. ennreal \\<bar>c\\<bar> * uf n)\n  \\<longlonglongrightarrow> ennreal \\<bar>c\\<bar> * N f\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f", "by blast"], ["proof (state)\nthis:\n  N (c *\\<^sub>R f) \\<le> ennreal \\<bar>c\\<bar> * N f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N (?c *\\<^sub>R ?f) \\<le> ennreal \\<bar>?c\\<bar> * N ?f\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "have \"Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. 0 = f1 + f2} \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} \\<le> 0", "by (rule Inf_lower, auto, rule exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} \\<le> 0\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} \\<le> 0", "have Z: \"Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. 0 = f1 + f2} = 0\""], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0", "by auto"], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "have *: \"quasinorm_on UNIV (max (defect N1) (defect N2)) (\\<lambda>f. Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasinorm_on UNIV (max (defect N1) (defect N2))\n     (\\<lambda>f.\n         \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})", "apply (rule quasinorm_onI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     x + y = f1 + f2}\n                         \\<le> ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2} +\n                               ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     y = f1 + f2}\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     c *\\<^sub>R x = f1 + f2}\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2}\n 5. (0::'a) \\<in> UNIV\n 6. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n 7. 1 \\<le> max (defect N1) (defect N2)", "using T H Z defect_ge_1[of N1] defect_ge_1[of N2]"], ["proof (prove)\nusing this:\n  N (?f + ?g)\n  \\<le> ennreal (max (defect N1) (defect N2)) * N ?f +\n        ennreal (max (defect N1) (defect N2)) * N ?g\n  N (?c *\\<^sub>R ?f) \\<le> ennreal \\<bar>?c\\<bar> * N ?f\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n  1 \\<le> defect N1\n  1 \\<le> defect N2\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     x + y = f1 + f2}\n                         \\<le> ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2} +\n                               ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     y = f1 + f2}\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     c *\\<^sub>R x = f1 + f2}\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2}\n 5. (0::'a) \\<in> UNIV\n 6. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n 7. 1 \\<le> max (defect N1) (defect N2)", "unfolding N_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?f + ?g = f1 + f2}\n  \\<le> ennreal (max (defect N1) (defect N2)) *\n        \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?f = f1 + f2} +\n        ennreal (max (defect N1) (defect N2)) *\n        \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?g = f1 + f2}\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?c *\\<^sub>R ?f = f1 + f2}\n  \\<le> ennreal \\<bar>?c\\<bar> *\n        \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?f = f1 + f2}\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n  1 \\<le> defect N1\n  1 \\<le> defect N2\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> UNIV\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     x + y = f1 + f2}\n                         \\<le> ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2} +\n                               ennreal (max (defect N1) (defect N2)) *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     y = f1 + f2}\n 3. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> UNIV\n 4. \\<And>c x.\n       \\<lbrakk>c \\<noteq> 0; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n                                     c *\\<^sub>R x = f1 + f2}\n                         \\<le> ennreal \\<bar>c\\<bar> *\n                               \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     x = f1 + f2}\n 5. (0::'a) \\<in> UNIV\n 6. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. (0::'a) = f1 + f2} = 0\n 7. 1 \\<le> max (defect N1) (defect N2)", "by auto"], ["proof (state)\nthis:\n  quasinorm_on UNIV (max (defect N1) (defect N2))\n   (\\<lambda>f. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})\n\ngoal (2 subgoals):\n 1. eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n 2. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)", "show \"defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)\"\n       \"eNorm (N1 +\\<^sub>N N2) f = Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2) &&&\n    eNorm (N1 +\\<^sub>N N2) f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}", "unfolding quasinorm_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. defect\n     (quasinorm_of\n       (max (defect N1) (defect N2),\n        \\<lambda>f.\n           \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})) =\n    max (defect N1) (defect N2) &&&\n    eNorm\n     (quasinorm_of\n       (max (defect N1) (defect N2),\n        \\<lambda>f.\n           \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}))\n     f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}", "using quasinorm_of[OF *]"], ["proof (prove)\nusing this:\n  eNorm\n   (quasinorm_of\n     (max (defect N1) (defect N2),\n      \\<lambda>f.\n         \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}))\n   ?x =\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. ?x = f1 + f2}\n  defect\n   (quasinorm_of\n     (max (defect N1) (defect N2),\n      \\<lambda>f.\n         \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})) =\n  max (defect N1) (defect N2)\n\ngoal (1 subgoal):\n 1. defect\n     (quasinorm_of\n       (max (defect N1) (defect N2),\n        \\<lambda>f.\n           \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2})) =\n    max (defect N1) (defect N2) &&&\n    eNorm\n     (quasinorm_of\n       (max (defect N1) (defect N2),\n        \\<lambda>f.\n           \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}))\n     f =\n    \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}", "by auto"], ["proof (state)\nthis:\n  defect (N1 +\\<^sub>N N2) = max (defect N1) (defect N2)\n  eNorm (N1 +\\<^sub>N N2) f =\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_sum_limit:\n  \"\\<exists>f1 f2. (\\<forall>n. f = f1 n + f2 n) \\<and> (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n)) \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "have \"\\<exists>u. (\\<forall>n. u n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}) \\<and> u \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       (\\<forall>n.\n           u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n       u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n         f2. f = f1 + f2}", "by (rule Inf_as_limit, auto, rule exI[of _ \"f\"], rule exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}", "obtain uf where uf: \"\\<And>n. uf n \\<in> {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\"\n                           \"uf \\<longlonglongrightarrow> Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f = f1 + f2}\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     (\\<forall>n.\n         u n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}) \\<and>\n     u \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1\n       f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. (\\<And>uf.\n        \\<lbrakk>\\<And>n.\n                    uf n\n                    \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2};\n         uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 +\n            eNorm N2 f2 |\n            f1 f2. f = f1 + f2}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n  uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2}\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "have \"\\<exists>f1 f2. \\<forall>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       \\<forall>n.\n          uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "apply (rule SMT.choices(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "using uf(1)"], ["proof (prove)\nusing this:\n  uf ?n \\<in> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f = f1 + f2}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>y ya. uf n = eNorm N1 y + eNorm N2 ya \\<and> f = y + ya", "by blast"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "then"], ["proof (chain)\npicking this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n", "obtain f1 f2 where F: \"\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n)\" \"\\<And>n. f = f1 n + f2 n\""], ["proof (prove)\nusing this:\n  \\<exists>f1 f2.\n     \\<forall>n.\n        uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n) \\<and> f = f1 n + f2 n\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>\\<And>n. uf n = eNorm N1 (f1 n) + eNorm N2 (f2 n);\n         \\<And>n. f = f1 n + f2 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n  f = f1 ?n + f2 ?n\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "have \"(\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n)) \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n    \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "using F(1) uf(2)"], ["proof (prove)\nusing this:\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n  uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n    \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "unfolding quasinorm_sum(1)"], ["proof (prove)\nusing this:\n  uf ?n = eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n)\n  uf \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n     f = f1 + f2}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n    \\<longlonglongrightarrow> \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2.\n    f = f1 + f2}", "by presburger"], ["proof (state)\nthis:\n  (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "using F(2)"], ["proof (prove)\nusing this:\n  (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\n  f = f1 ?n + f2 ?n\n\ngoal (1 subgoal):\n 1. \\<exists>f1 f2.\n       (\\<forall>n. f = f1 n + f2 n) \\<and>\n       (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n       \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f", "by auto"], ["proof (state)\nthis:\n  \\<exists>f1 f2.\n     (\\<forall>n. f = f1 n + f2 n) \\<and>\n     (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n     \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_sum_space:\n  \"space\\<^sub>N (N1 +\\<^sub>N N2) = {f + g|f g. f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space\\<^sub>N (N1 +\\<^sub>N N2) =\n    {f + g |f g. f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2}", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2) \\<Longrightarrow>\n       \\<exists>f g.\n          x = f + g \\<and>\n          f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2) \\<Longrightarrow>\n       \\<exists>f g.\n          x = f + g \\<and>\n          f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "assume \"x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)\""], ["proof (state)\nthis:\n  x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2) \\<Longrightarrow>\n       \\<exists>f g.\n          x = f + g \\<and>\n          f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "then"], ["proof (chain)\npicking this:\n  x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "have \"Inf {eNorm N1 f + eNorm N2 g| f g. x = f + g} < \\<infinity>\""], ["proof (prove)\nusing this:\n  x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f + eNorm N2 g |f g. x = f + g} < \\<infinity>", "unfolding quasinorm_sum(1) spaceN_iff"], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. x = f1 + f2} < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f + eNorm N2 g |f g. x = f + g} < \\<infinity>", "."], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 f + eNorm N2 g |f g. x = f + g} < \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2) \\<Longrightarrow>\n       \\<exists>f g.\n          x = f + g \\<and>\n          f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> {eNorm N1 f + eNorm N2 g |f g. x = f + g} < \\<infinity>", "have \"\\<exists>z \\<in> {eNorm N1 f + eNorm N2 g| f g. x = f + g}. z < \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f + eNorm N2 g |f g. x = f + g} < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>{eNorm N1 f + eNorm N2 g |f g. x = f + g}.\n       z < \\<infinity>", "by (simp add: Inf_less_iff)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>{eNorm N1 f + eNorm N2 g |f g. x = f + g}. z < \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space\\<^sub>N (N1 +\\<^sub>N N2) \\<Longrightarrow>\n       \\<exists>f g.\n          x = f + g \\<and>\n          f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>{eNorm N1 f + eNorm N2 g |f g. x = f + g}. z < \\<infinity>", "show \"\\<exists>f g. x = f + g \\<and> f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>{eNorm N1 f + eNorm N2 g |f g. x = f + g}. z < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       x = f + g \\<and>\n       f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2", "using spaceN_iff"], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>{eNorm N1 f + eNorm N2 g |f g. x = f + g}. z < \\<infinity>\n  (?x \\<in> space\\<^sub>N ?N) = (eNorm ?N ?x < \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<exists>f g.\n       x = f + g \\<and>\n       f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2", "by force"], ["proof (state)\nthis:\n  \\<exists>f g.\n     x = f + g \\<and>\n     f \\<in> space\\<^sub>N N1 \\<and> g \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "assume H: \"f \\<in> space\\<^sub>N N1\" \"g \\<in> space\\<^sub>N N2\""], ["proof (state)\nthis:\n  f \\<in> space\\<^sub>N N1\n  g \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "have \"Inf {eNorm N1 u + eNorm N2 v| u v. f + g = u + v} \\<le> eNorm N1 f + eNorm N2 g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v}\n    \\<le> eNorm N1 f + eNorm N2 g", "by (rule Inf_lower, auto)"], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v}\n  \\<le> eNorm N1 f + eNorm N2 g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "also"], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v}\n  \\<le> eNorm N1 f + eNorm N2 g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "have \"... < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N1 f + eNorm N2 g < \\<infinity>", "using spaceN_iff H"], ["proof (prove)\nusing this:\n  (?x \\<in> space\\<^sub>N ?N) = (eNorm ?N ?x < \\<infinity>)\n  f \\<in> space\\<^sub>N N1\n  g \\<in> space\\<^sub>N N2\n\ngoal (1 subgoal):\n 1. eNorm N1 f + eNorm N2 g < \\<infinity>", "by auto"], ["proof (state)\nthis:\n  eNorm N1 f + eNorm N2 g < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> space\\<^sub>N N1; g \\<in> space\\<^sub>N N2\\<rbrakk>\n       \\<Longrightarrow> f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v} < \\<infinity>", "show \"f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)\""], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v} < \\<infinity>\n\ngoal (1 subgoal):\n 1. f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)", "unfolding spaceN_iff quasinorm_sum(1)"], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 u + eNorm N2 v |u v. f + g = u + v} < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2}\n    < \\<infinity>", "."], ["proof (state)\nthis:\n  f + g \\<in> space\\<^sub>N (N1 +\\<^sub>N N2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_sum_zerospace:\n  \"{f + g |f g. f \\<in> zero_space\\<^sub>N N1 \\<and> g \\<in> zero_space\\<^sub>N N2} \\<subseteq> zero_space\\<^sub>N (N1 +\\<^sub>N N2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f + g |f g.\n     f \\<in> zero_space\\<^sub>N N1 \\<and> g \\<in> zero_space\\<^sub>N N2}\n    \\<subseteq> zero_space\\<^sub>N (N1 +\\<^sub>N N2)", "proof (auto, unfold zero_spaceN_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>eNorm N1 f = 0; eNorm N2 g = 0\\<rbrakk>\n       \\<Longrightarrow> eNorm (N1 +\\<^sub>N N2) (f + g) = 0", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>eNorm N1 f = 0; eNorm N2 g = 0\\<rbrakk>\n       \\<Longrightarrow> eNorm (N1 +\\<^sub>N N2) (f + g) = 0", "assume H: \"eNorm N1 f = 0\" \"eNorm N2 g = 0\""], ["proof (state)\nthis:\n  eNorm N1 f = 0\n  eNorm N2 g = 0\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>eNorm N1 f = 0; eNorm N2 g = 0\\<rbrakk>\n       \\<Longrightarrow> eNorm (N1 +\\<^sub>N N2) (f + g) = 0", "have \"Inf {eNorm N1 f1 + eNorm N2 f2| f1 f2. f + g = f1 + f2} \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} \\<le> 0", "by (rule Inf_lower, auto, rule exI[of _ f], auto simp add: H)"], ["proof (state)\nthis:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>eNorm N1 f = 0; eNorm N2 g = 0\\<rbrakk>\n       \\<Longrightarrow> eNorm (N1 +\\<^sub>N N2) (f + g) = 0", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} \\<le> 0", "show \"eNorm (N1 +\\<^sub>N N2) (f + g) = 0\""], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} \\<le> 0\n\ngoal (1 subgoal):\n 1. eNorm (N1 +\\<^sub>N N2) (f + g) = 0", "unfolding quasinorm_sum(1)"], ["proof (prove)\nusing this:\n  \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {eNorm N1 f1 + eNorm N2 f2 |f1 f2. f + g = f1 + f2} = 0", "by auto"], ["proof (state)\nthis:\n  eNorm (N1 +\\<^sub>N N2) (f + g) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_sum_subset:\n  \"N1 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2\" \"N2 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2 &&&\n    N2 \\<subseteq>\\<^sub>N N1 +\\<^sub>N N2", "by (rule quasinorm_subsetI[of _ _ 1], auto simp add: quasinorm_sum(1), rule Inf_lower, auto,\n  metis add.commute add.left_neutral eNorm_zero)+"], ["", "lemma quasinorm_sum_maximum:\n  assumes \"N1 \\<subseteq>\\<^sub>N N\" \"N2 \\<subseteq>\\<^sub>N N\"\n  shows \"N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "obtain C1 C2::real where *: \"\\<And>f. eNorm N f \\<le> C1 * eNorm N1 f\"\n                              \"\\<And>f. eNorm N f \\<le> C2 * eNorm N2 f\"\n                              \"C1 \\<ge> 0\" \"C2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C1 C2.\n        \\<lbrakk>\\<And>f. eNorm N f \\<le> ennreal C1 * eNorm N1 f;\n         \\<And>f. eNorm N f \\<le> ennreal C2 * eNorm N2 f; 0 \\<le> C1;\n         0 \\<le> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasinorm_subsetD[OF assms(1)] quasinorm_subsetD[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N f \\<le> ennreal C * eNorm N1 f\n  \\<exists>C\\<ge>0. \\<forall>f. eNorm N f \\<le> ennreal C * eNorm N2 f\n\ngoal (1 subgoal):\n 1. (\\<And>C1 C2.\n        \\<lbrakk>\\<And>f. eNorm N f \\<le> ennreal C1 * eNorm N1 f;\n         \\<And>f. eNorm N f \\<le> ennreal C2 * eNorm N2 f; 0 \\<le> C1;\n         0 \\<le> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eNorm N ?f \\<le> ennreal C1 * eNorm N1 ?f\n  eNorm N ?f \\<le> ennreal C2 * eNorm N2 ?f\n  0 \\<le> C1\n  0 \\<le> C2\n\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "have **: \"eNorm N f \\<le> (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "obtain f1 f2 where F: \"\\<And>n. f = f1 n + f2 n\"\n                          \"(\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n)) \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>\\<And>n. f = f1 n + f2 n;\n         (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n         \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasinorm_sum_limit"], ["proof (prove)\nusing this:\n  \\<exists>f1 f2.\n     (\\<forall>n. ?f = f1 n + f2 n) \\<and>\n     (\\<lambda>n. eNorm ?N1.0 (f1 n) + eNorm ?N2.0 (f2 n))\n     \\<longlonglongrightarrow> eNorm (?N1.0 +\\<^sub>N ?N2.0) ?f\n\ngoal (1 subgoal):\n 1. (\\<And>f1 f2.\n        \\<lbrakk>\\<And>n. f = f1 n + f2 n;\n         (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n         \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f = f1 ?n + f2 ?n\n  (\\<lambda>n. eNorm N1 (f1 n) + eNorm N2 (f2 n))\n  \\<longlonglongrightarrow> eNorm (N1 +\\<^sub>N N2) f\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "have \"eNorm N f \\<le> ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "have \"eNorm N f \\<le> ennreal(defect N) * eNorm N (f1 n) + ennreal(defect N) * eNorm N (f2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N) * eNorm N (f1 n) +\n          ennreal (defect N) * eNorm N (f2 n)", "unfolding \\<open>f = f1 n + f2 n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (f1 n + f2 n)\n    \\<le> ennreal (defect N) * eNorm N (f1 n) +\n          ennreal (defect N) * eNorm N (f2 n)", "using eNorm_triangular_ineq"], ["proof (prove)\nusing this:\n  eNorm ?N (?x + ?y)\n  \\<le> ennreal (defect ?N) * eNorm ?N ?x +\n        ennreal (defect ?N) * eNorm ?N ?y\n\ngoal (1 subgoal):\n 1. eNorm N (f1 n + f2 n)\n    \\<le> ennreal (defect N) * eNorm N (f1 n) +\n          ennreal (defect N) * eNorm N (f2 n)", "by auto"], ["proof (state)\nthis:\n  eNorm N f\n  \\<le> ennreal (defect N) * eNorm N (f1 n) +\n        ennreal (defect N) * eNorm N (f2 n)\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "also"], ["proof (state)\nthis:\n  eNorm N f\n  \\<le> ennreal (defect N) * eNorm N (f1 n) +\n        ennreal (defect N) * eNorm N (f2 n)\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "have \"... \\<le> ennreal(defect N) * (C1 * eNorm N1 (f1 n)) + ennreal(defect N) * (C2 * eNorm N2 (f2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * eNorm N (f1 n) +\n    ennreal (defect N) * eNorm N (f2 n)\n    \\<le> ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n          ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ennreal (defect N) * eNorm N (f1 n)\n    \\<le> ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n))\n 2. ennreal (defect N) * eNorm N (f2 n)\n    \\<le> ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))", "by (rule mult_mono, simp, simp add: *, simp, simp)+"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N (f1 n) + ennreal (defect N) * eNorm N (f2 n)\n  \\<le> ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n        ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "also"], ["proof (state)\nthis:\n  ennreal (defect N) * eNorm N (f1 n) + ennreal (defect N) * eNorm N (f2 n)\n  \\<le> ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n        ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "have \"... \\<le> ennreal(defect N) * (max C1 C2 * eNorm N1 (f1 n)) + ennreal(defect N) * (max C1 C2 * eNorm N2 (f2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n    ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))\n    \\<le> ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n          ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n))", "by (auto intro!:add_mono mult_mono ennreal_leI)"], ["proof (state)\nthis:\n  ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n  ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))\n  \\<le> ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n        ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "also"], ["proof (state)\nthis:\n  ennreal (defect N) * (ennreal C1 * eNorm N1 (f1 n)) +\n  ennreal (defect N) * (ennreal C2 * eNorm N2 (f2 n))\n  \\<le> ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n        ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "have \"... = ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n    ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n)) =\n    ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "apply (subst ennreal_mult')"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> defect N\n 2. ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n    ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n)) =\n    ennreal (defect N) * ennreal (max C1 C2) *\n    (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "using defect_ge_1 order_trans zero_le_one"], ["proof (prove)\nusing this:\n  1 \\<le> defect ?N\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  (0::?'a) \\<le> (1::?'a)\n\ngoal (2 subgoals):\n 1. 0 \\<le> defect N\n 2. ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n    ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n)) =\n    ennreal (defect N) * ennreal (max C1 C2) *\n    (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n    ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n)) =\n    ennreal (defect N) * ennreal (max C1 C2) *\n    (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ennreal (defect N) * (ennreal (max C1 C2) * eNorm N1 (f1 n)) +\n  ennreal (defect N) * (ennreal (max C1 C2) * eNorm N2 (f2 n)) =\n  ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "finally"], ["proof (chain)\npicking this:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) *\n          (eNorm N1 (f1 n) + eNorm N2 (f2 n))", "by simp"], ["proof (state)\nthis:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "moreover"], ["proof (state)\nthis:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n))\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "have \"... \\<longlonglongrightarrow> (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 n) + eNorm N2 (f2 n)))\n    \\<longlonglongrightarrow> ennreal (defect N * max C1 C2) *\n                              eNorm (N1 +\\<^sub>N N2) f", "by (auto intro!:tendsto_intros F(2))"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n)))\n  \\<longlonglongrightarrow> ennreal (defect N * max C1 C2) *\n                            eNorm (N1 +\\<^sub>N N2) f\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "ultimately"], ["proof (chain)\npicking this:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n))\n  (\\<lambda>n.\n      ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n)))\n  \\<longlonglongrightarrow> ennreal (defect N * max C1 C2) *\n                            eNorm (N1 +\\<^sub>N N2) f", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n))\n  (\\<lambda>n.\n      ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n)))\n  \\<longlonglongrightarrow> ennreal (defect N * max C1 C2) *\n                            eNorm (N1 +\\<^sub>N N2) f\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  eNorm N f\n  \\<le> ennreal (defect N * max C1 C2) *\n        (eNorm N1 (f1 ?n) + eNorm N2 (f2 ?n))\n  (\\<lambda>n.\n      ennreal (defect N * max C1 C2) * (eNorm N1 (f1 n) + eNorm N2 (f2 n)))\n  \\<longlonglongrightarrow> ennreal (defect N * max C1 C2) *\n                            eNorm (N1 +\\<^sub>N N2) f\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. eNorm N f\n    \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f", "by blast"], ["proof (state)\nthis:\n  eNorm N f \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eNorm N ?f\n  \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) ?f\n\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  eNorm N ?f\n  \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) ?f", "show ?thesis"], ["proof (prove)\nusing this:\n  eNorm N ?f\n  \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) ?f\n\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "using quasinorm_subsetI"], ["proof (prove)\nusing this:\n  eNorm N ?f\n  \\<le> ennreal (defect N * max C1 C2) * eNorm (N1 +\\<^sub>N N2) ?f\n  (\\<And>f.\n      f \\<in> space\\<^sub>N ?N1.0 \\<Longrightarrow>\n      eNorm ?N2.0 f \\<le> ennreal ?C * eNorm ?N1.0 f) \\<Longrightarrow>\n  ?N1.0 \\<subseteq>\\<^sub>N ?N2.0\n\ngoal (1 subgoal):\n 1. N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N", "by force"], ["proof (state)\nthis:\n  N1 +\\<^sub>N N2 \\<subseteq>\\<^sub>N N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasinorm_sum_assoc:\n  \"(N1 +\\<^sub>N N2) +\\<^sub>N N3 =\\<^sub>N N1 +\\<^sub>N (N2 +\\<^sub>N N3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N1 +\\<^sub>N N2) +\\<^sub>N N3 =\\<^sub>N N1 +\\<^sub>N (N2 +\\<^sub>N N3)", "unfolding quasinorm_equivalent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (N1 +\\<^sub>N N2) +\\<^sub>N N3\n    \\<subseteq>\\<^sub>N N1 +\\<^sub>N (N2 +\\<^sub>N N3) \\<and>\n    N1 +\\<^sub>N (N2 +\\<^sub>N N3)\n    \\<subseteq>\\<^sub>N (N1 +\\<^sub>N N2) +\\<^sub>N N3", "by (meson order_trans quasinorm_sum_maximum quasinorm_sum_subset)"], ["", "subsection \\<open>Topology\\<close>"], ["", "definition topology\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> 'a topology\"\n  where \"topology\\<^sub>N N = topology (\\<lambda>U. \\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U)\""], ["", "lemma istopology_topology\\<^sub>N:\n  \"istopology (\\<lambda>U. \\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. istopology\n     (\\<lambda>U.\n         \\<forall>x\\<in>U.\n            \\<exists>e>0.\n               \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U)", "unfolding istopology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>S T.\n        (\\<forall>x\\<in>S.\n            \\<exists>e>0.\n               \\<forall>y.\n                  eNorm N (y - x) < e \\<longrightarrow>\n                  y \\<in> S) \\<longrightarrow>\n        (\\<forall>x\\<in>T.\n            \\<exists>e>0.\n               \\<forall>y.\n                  eNorm N (y - x) < e \\<longrightarrow>\n                  y \\<in> T) \\<longrightarrow>\n        (\\<forall>x\\<in>S \\<inter> T.\n            \\<exists>e>0.\n               \\<forall>y.\n                  eNorm N (y - x) < e \\<longrightarrow>\n                  y \\<in> S \\<inter> T)) \\<and>\n    (\\<forall>\\<K>.\n        (\\<forall>K\\<in>\\<K>.\n            \\<forall>x\\<in>K.\n               \\<exists>e>0.\n                  \\<forall>y.\n                     eNorm N (y - x) < e \\<longrightarrow>\n                     y \\<in> K) \\<longrightarrow>\n        (\\<forall>x\\<in>\\<Union> \\<K>.\n            \\<exists>e>0.\n               \\<forall>y.\n                  eNorm N (y - x) < e \\<longrightarrow>\n                  y \\<in> \\<Union> \\<K>))", "by (auto, metis dual_order.strict_trans less_linear, meson)"], ["", "lemma openin_topology\\<^sub>N:\n  \"openin (topology\\<^sub>N N) U \\<longleftrightarrow> (\\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (topology\\<^sub>N N) U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U)", "unfolding topology\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin\n     (topology\n       (\\<lambda>U.\n           \\<forall>x\\<in>U.\n              \\<exists>e>0.\n                 \\<forall>y.\n                    eNorm N (y - x) < e \\<longrightarrow> y \\<in> U))\n     U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U)", "using istopology_topology\\<^sub>N[of N]"], ["proof (prove)\nusing this:\n  istopology\n   (\\<lambda>U.\n       \\<forall>x\\<in>U.\n          \\<exists>e>0.\n             \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U)\n\ngoal (1 subgoal):\n 1. openin\n     (topology\n       (\\<lambda>U.\n           \\<forall>x\\<in>U.\n              \\<exists>e>0.\n                 \\<forall>y.\n                    eNorm N (y - x) < e \\<longrightarrow> y \\<in> U))\n     U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U)", "by (simp add: topology_inverse')"], ["", "lemma openin_topology\\<^sub>N_I:\n  assumes \"\\<And>x. x \\<in> U \\<Longrightarrow> \\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U\"\n  shows \"openin (topology\\<^sub>N N) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (topology\\<^sub>N N) U", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> U \\<Longrightarrow>\n  \\<exists>e>0. \\<forall>y. eNorm N (y - ?x) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. openin (topology\\<^sub>N N) U", "unfolding openin_topology\\<^sub>N"], ["proof (prove)\nusing this:\n  ?x \\<in> U \\<Longrightarrow>\n  \\<exists>e>0. \\<forall>y. eNorm N (y - ?x) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U.\n       \\<exists>e>0.\n          \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U", "by auto"], ["", "lemma openin_topology\\<^sub>N_D:\n  assumes \"openin (topology\\<^sub>N N) U\"\n          \"x \\<in> U\"\n  shows \"\\<exists>e>0. \\<forall>y. eNorm N (y-x) < e \\<longrightarrow> y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U", "using assms"], ["proof (prove)\nusing this:\n  openin (topology\\<^sub>N N) U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U", "unfolding openin_topology\\<^sub>N"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U.\n     \\<exists>e>0.\n        \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>y. eNorm N (y - x) < e \\<longrightarrow> y \\<in> U", "by auto"], ["", "text \\<open>One should then use this topology to define limits and so on. This is not something\nspecific to quasinorms, but to all topologies defined in this way, not using type classes.\nHowever, there is no such body of material (yet?) in Isabelle-HOL, where topology is\nessentially done with type classes. So, we do not go any further for now.\n\nOne exception is the notion of completeness, as it is so important in functional analysis.\nWe give a naive definition, which will be sufficient for the proof of completeness\nof several spaces. Usually, the most convenient criterion to prove completeness of\na normed vector space is in terms of converging series. This criterion\nis the only nontrivial thing we prove here. We will apply it to prove the\ncompleteness of $L^p$ spaces.\\<close>"], ["", "definition cauchy_ine\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"cauchy_ine\\<^sub>N N u = (\\<forall>e>0. \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e)\""], ["", "definition tendsto_ine\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a => bool\"\n  where \"tendsto_ine\\<^sub>N N u x = (\\<lambda>n. eNorm N (u n - x)) \\<longlonglongrightarrow> 0\""], ["", "definition complete\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> bool\"\n  where \"complete\\<^sub>N N = (\\<forall>u. cauchy_ine\\<^sub>N N u \\<longrightarrow> (\\<exists>x. tendsto_ine\\<^sub>N N u x))\""], ["", "text \\<open>The above definitions are in terms of eNorms, but usually the nice definitions\nonly make sense on the space of the norm, and are expressed in terms of Norms. We formulate\nthe same definitions with norms, they will be more convenient for the proofs.\\<close>"], ["", "definition cauchy_in\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"cauchy_in\\<^sub>N N u = (\\<forall>e>0. \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e)\""], ["", "definition tendsto_in\\<^sub>N::\"('a::real_vector) quasinorm \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> 'a => bool\"\n  where \"tendsto_in\\<^sub>N N u x = (\\<lambda>n. Norm N (u n - x)) \\<longlonglongrightarrow> 0\""], ["", "lemma cauchy_ine\\<^sub>N_I:\n  assumes \"\\<And>e. e > 0 \\<Longrightarrow> (\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e)\"\n  shows \"cauchy_ine\\<^sub>N N u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u", "using assms"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ?e\n\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u", "unfolding cauchy_ine\\<^sub>N_def"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ?e\n\ngoal (1 subgoal):\n 1. \\<forall>e>0.\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "by auto"], ["", "lemma cauchy_in\\<^sub>N_I:\n  assumes \"\\<And>e. e > 0 \\<Longrightarrow> (\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e)\"\n  shows \"cauchy_in\\<^sub>N N u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_in\\<^sub>N N u", "using assms"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < ?e\n\ngoal (1 subgoal):\n 1. cauchy_in\\<^sub>N N u", "unfolding cauchy_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < ?e\n\ngoal (1 subgoal):\n 1. \\<forall>e>0.\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "by auto"], ["", "lemma cauchy_ine_in:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\"\n  shows \"cauchy_ine\\<^sub>N N u \\<longleftrightarrow> cauchy_in\\<^sub>N N u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u = cauchy_in\\<^sub>N N u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cauchy_ine\\<^sub>N N u \\<Longrightarrow> cauchy_in\\<^sub>N N u\n 2. cauchy_in\\<^sub>N N u \\<Longrightarrow> cauchy_ine\\<^sub>N N u", "assume \"cauchy_in\\<^sub>N N u\""], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N N u\n\ngoal (2 subgoals):\n 1. cauchy_ine\\<^sub>N N u \\<Longrightarrow> cauchy_in\\<^sub>N N u\n 2. cauchy_in\\<^sub>N N u \\<Longrightarrow> cauchy_ine\\<^sub>N N u", "show \"cauchy_ine\\<^sub>N N u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u", "proof (rule cauchy_ine\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "fix e::ennreal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "assume \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "define e2 where \"e2 = min e 1\""], ["proof (state)\nthis:\n  e2 = min e 1\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  e2 = min e 1", "obtain r where \"e2 = ennreal r\" \"r > 0\""], ["proof (prove)\nusing this:\n  e2 = min e 1\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>e2 = ennreal r; 0 < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding e2_def"], ["proof (prove)\nusing this:\n  min e 1 = min e 1\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>min e 1 = ennreal r; 0 < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  min e 1 = min e 1\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>min e 1 = ennreal r; 0 < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ennreal_eq_1 ennreal_less_zero_iff le_ennreal_iff le_numeral_extra(1) min_def zero_less_one)"], ["proof (state)\nthis:\n  e2 = ennreal r\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  e2 = ennreal r\n  0 < r", "obtain M where *: \"\\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < r\""], ["proof (prove)\nusing this:\n  e2 = ennreal r\n  0 < r\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M. Norm N (u n - u m) < r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_in\\<^sub>N N u\\<close> \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  e2 = ennreal r\n  0 < r\n  cauchy_in\\<^sub>N N u\n  0 < r\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M. Norm N (u n - u m) < r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  e2 = ennreal r\n  0 < r\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n  0 < r\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M. Norm N (u n - u m) < r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < r\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < r", "have \"\\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < r\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < r\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal r", "by (auto simp add: assms eNorm_Norm \\<open>0 < r\\<close> ennreal_lessI)"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal r\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal r", "have \"\\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal r\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "unfolding \\<open>e2 = ennreal r\\<close>[symmetric] e2_def"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < min e 1\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "show \"\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cauchy_ine\\<^sub>N N u\n\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u \\<Longrightarrow> cauchy_in\\<^sub>N N u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u \\<Longrightarrow> cauchy_in\\<^sub>N N u", "assume \"cauchy_ine\\<^sub>N N u\""], ["proof (state)\nthis:\n  cauchy_ine\\<^sub>N N u\n\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N u \\<Longrightarrow> cauchy_in\\<^sub>N N u", "show \"cauchy_in\\<^sub>N N u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_in\\<^sub>N N u", "proof (rule cauchy_in\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "fix e::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "assume \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  0 < e", "obtain M where *: \"\\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M.\n              eNorm N (u n - u m) < ennreal e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_ine\\<^sub>N N u\\<close> \\<open>e > 0\\<close> ennreal_less_zero_iff"], ["proof (prove)\nusing this:\n  0 < e\n  cauchy_ine\\<^sub>N N u\n  0 < e\n  (0 < ennreal ?x) = (0 < ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M.\n              eNorm N (u n - u m) < ennreal e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_ine\\<^sub>N_def"], ["proof (prove)\nusing this:\n  0 < e\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n  0 < e\n  (0 < ennreal ?x) = (0 < ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M.\n              eNorm N (u n - u m) < ennreal e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal e", "have \"\\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < ennreal e\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "by (auto, metis Norm_def \\<open>0 < e\\<close> eNorm_Norm eNorm_Norm' enn2real_nonneg ennreal_less_iff)"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "show \"\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N N u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_ine_in:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\" \"x \\<in> space\\<^sub>N N\"\n  shows \"tendsto_ine\\<^sub>N N u x \\<longleftrightarrow> tendsto_in\\<^sub>N N u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N u x = tendsto_in\\<^sub>N N u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N u x = tendsto_in\\<^sub>N N u x", "have *: \"eNorm N (u n - x) = Norm N (u n - x)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (u n - x) = ennreal (Norm N (u n - x))", "using assms eNorm_Norm spaceN_diff"], ["proof (prove)\nusing this:\n  u ?n \\<in> space\\<^sub>N N\n  x \\<in> space\\<^sub>N N\n  ?x \\<in> space\\<^sub>N ?N \\<Longrightarrow>\n  eNorm ?N ?x = ennreal (Norm ?N ?x)\n  \\<lbrakk>?x \\<in> space\\<^sub>N ?N; ?y \\<in> space\\<^sub>N ?N\\<rbrakk>\n  \\<Longrightarrow> ?x - ?y \\<in> space\\<^sub>N ?N\n\ngoal (1 subgoal):\n 1. eNorm N (u n - x) = ennreal (Norm N (u n - x))", "by blast"], ["proof (state)\nthis:\n  eNorm N (u ?n - x) = ennreal (Norm N (u ?n - x))\n\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N u x = tendsto_in\\<^sub>N N u x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N u x = tendsto_in\\<^sub>N N u x", "unfolding tendsto_in\\<^sub>N_def tendsto_ine\\<^sub>N_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (Norm N (u n - x))) \\<longlonglongrightarrow> 0 =\n    (\\<lambda>n. Norm N (u n - x)) \\<longlonglongrightarrow> 0", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ennreal (Norm N (u n - x)))\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    (\\<lambda>n. Norm N (u n - x)) \\<longlonglongrightarrow> 0\n 2. (\\<lambda>n. Norm N (u n - x))\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    (\\<lambda>n. ennreal (Norm N (u n - x))) \\<longlonglongrightarrow> 0", "apply (metis (full_types) Norm_nonneg ennreal_0 eventually_sequentiallyI order_refl tendsto_ennreal_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (u n - x))\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    (\\<lambda>n. ennreal (Norm N (u n - x))) \\<longlonglongrightarrow> 0", "using tendsto_ennrealI"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?x) ?F \\<Longrightarrow>\n  ((\\<lambda>x. ennreal (?f x)) \\<longlongrightarrow> ennreal ?x) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (u n - x))\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    (\\<lambda>n. ennreal (Norm N (u n - x))) \\<longlonglongrightarrow> 0", "by fastforce"], ["proof (state)\nthis:\n  tendsto_ine\\<^sub>N N u x = tendsto_in\\<^sub>N N u x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete\\<^sub>N_I:\n  assumes \"\\<And>u. cauchy_in\\<^sub>N N u \\<Longrightarrow> (\\<forall>n. u n \\<in> space\\<^sub>N N) \\<Longrightarrow> (\\<exists>x\\<in> space\\<^sub>N N. tendsto_in\\<^sub>N N u x)\"\n  shows \"complete\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete\\<^sub>N N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complete\\<^sub>N N", "have \"\\<exists>x. tendsto_ine\\<^sub>N N u x\" if \"cauchy_ine\\<^sub>N N u\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "obtain M::nat where *: \"\\<And>n m. n \\<ge> M \\<Longrightarrow> m \\<ge> M \\<Longrightarrow> eNorm N (u n - u m) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>n m.\n            \\<lbrakk>M \\<le> n; M \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_ine\\<^sub>N N u\\<close> ennreal_zero_less_one"], ["proof (prove)\nusing this:\n  cauchy_ine\\<^sub>N N u\n  0 < 1\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>n m.\n            \\<lbrakk>M \\<le> n; M \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_ine\\<^sub>N_def"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n  0 < 1\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>n m.\n            \\<lbrakk>M \\<le> n; M \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (u ?n - u ?m) < 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "define v where \"v = (\\<lambda>n. u (n+M) - u M)\""], ["proof (state)\nthis:\n  v = (\\<lambda>n. u (n + M) - u M)\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "have \"eNorm N (v n) < 1\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (v n) < 1", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (u (n + M) - u M) < 1", "using *"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (u ?n - u ?m) < 1\n\ngoal (1 subgoal):\n 1. eNorm N (u (n + M) - u M) < 1", "by auto"], ["proof (state)\nthis:\n  eNorm N (v ?n) < 1\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  eNorm N (v ?n) < 1", "have \"v n \\<in> space\\<^sub>N N\" for n"], ["proof (prove)\nusing this:\n  eNorm N (v ?n) < 1\n\ngoal (1 subgoal):\n 1. v n \\<in> space\\<^sub>N N", "using spaceN_iff[of _ N]"], ["proof (prove)\nusing this:\n  eNorm N (v ?n) < 1\n  (?x \\<in> space\\<^sub>N N) = (eNorm N ?x < \\<infinity>)\n\ngoal (1 subgoal):\n 1. v n \\<in> space\\<^sub>N N", "by (metis dual_order.strict_trans ennreal_1 ennreal_less_top infinity_ennreal_def)"], ["proof (state)\nthis:\n  v ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "have \"cauchy_ine\\<^sub>N N v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_ine\\<^sub>N N v", "proof (rule cauchy_ine\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "fix e::ennreal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "assume \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "then"], ["proof (chain)\npicking this:\n  0 < e", "obtain P::nat where *: \"\\<And>n m. n \\<ge> P \\<Longrightarrow> m \\<ge> P \\<Longrightarrow> eNorm N (u n - u m) < e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>n m.\n            \\<lbrakk>P \\<le> n; P \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_ine\\<^sub>N N u\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  cauchy_ine\\<^sub>N N u\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>n m.\n            \\<lbrakk>P \\<le> n; P \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_ine\\<^sub>N_def"], ["proof (prove)\nusing this:\n  0 < e\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>n m.\n            \\<lbrakk>P \\<le> n; P \\<le> m\\<rbrakk>\n            \\<Longrightarrow> eNorm N (u n - u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<le> ?n; P \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (u ?n - u ?m) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "have \"eNorm N (v n - v m) < e\" if \"n \\<ge> P\" \"m \\<ge> P\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (v n - v m) < e", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eNorm N (u (n + M) - u M - (u (m + M) - u M)) < e", "by (auto, rule *, insert that, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<le> ?n; P \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (v ?n - v ?m) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P \\<le> ?n; P \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (v ?n - v ?m) < e", "show \"\\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<le> ?n; P \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> eNorm N (v ?n - v ?m) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. eNorm N (v n - v m) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cauchy_ine\\<^sub>N N v\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  cauchy_ine\\<^sub>N N v", "have \"cauchy_in\\<^sub>N N v\""], ["proof (prove)\nusing this:\n  cauchy_ine\\<^sub>N N v\n\ngoal (1 subgoal):\n 1. cauchy_in\\<^sub>N N v", "using cauchy_ine_in[OF \\<open>\\<And>n. v n \\<in> space\\<^sub>N N\\<close>]"], ["proof (prove)\nusing this:\n  cauchy_ine\\<^sub>N N v\n  cauchy_ine\\<^sub>N N (\\<lambda>n. v (?n1 n)) =\n  cauchy_in\\<^sub>N N (\\<lambda>n. v (?n1 n))\n\ngoal (1 subgoal):\n 1. cauchy_in\\<^sub>N N v", "by auto"], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N N v\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  cauchy_in\\<^sub>N N v", "obtain y where \"tendsto_in\\<^sub>N N v y\" \"y \\<in> space\\<^sub>N N\""], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N v\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>tendsto_in\\<^sub>N N v y; y \\<in> space\\<^sub>N N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms \\<open>\\<And>n. v n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N v\n  \\<lbrakk>cauchy_in\\<^sub>N N ?u;\n   \\<forall>n. ?u n \\<in> space\\<^sub>N N\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                       tendsto_in\\<^sub>N N ?u x\n  v ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>tendsto_in\\<^sub>N N v y; y \\<in> space\\<^sub>N N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N v y\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  tendsto_in\\<^sub>N N v y\n  y \\<in> space\\<^sub>N N", "have *: \"tendsto_ine\\<^sub>N N v y\""], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N v y\n  y \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N v y", "using tendsto_ine_in \\<open>\\<And>n. v n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N v y\n  y \\<in> space\\<^sub>N N\n  \\<lbrakk>\\<And>n. ?u n \\<in> space\\<^sub>N ?N;\n   ?x \\<in> space\\<^sub>N ?N\\<rbrakk>\n  \\<Longrightarrow> tendsto_ine\\<^sub>N ?N ?u ?x =\n                    tendsto_in\\<^sub>N ?N ?u ?x\n  v ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N v y", "by auto"], ["proof (state)\nthis:\n  tendsto_ine\\<^sub>N N v y\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "have \"tendsto_ine\\<^sub>N N u (y + u M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tendsto_ine\\<^sub>N N u (y + u M)", "unfolding tendsto_ine\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N (u n - (y + u M))) \\<longlonglongrightarrow> 0", "apply (rule LIMSEQ_offset[of _ M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N (u (n + M) - (y + u M)))\n    \\<longlonglongrightarrow> 0", "using *"], ["proof (prove)\nusing this:\n  tendsto_ine\\<^sub>N N v y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N (u (n + M) - (y + u M)))\n    \\<longlonglongrightarrow> 0", "unfolding v_def tendsto_ine\\<^sub>N_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. eNorm N (u (n + M) - u M - y)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. eNorm N (u (n + M) - (y + u M)))\n    \\<longlonglongrightarrow> 0", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  tendsto_ine\\<^sub>N N u (y + u M)\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  tendsto_ine\\<^sub>N N u (y + u M)", "show ?thesis"], ["proof (prove)\nusing this:\n  tendsto_ine\\<^sub>N N u (y + u M)\n\ngoal (1 subgoal):\n 1. \\<exists>x. tendsto_ine\\<^sub>N N u x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. tendsto_ine\\<^sub>N N u x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cauchy_ine\\<^sub>N N ?u \\<Longrightarrow>\n  \\<exists>x. tendsto_ine\\<^sub>N N ?u x\n\ngoal (1 subgoal):\n 1. complete\\<^sub>N N", "then"], ["proof (chain)\npicking this:\n  cauchy_ine\\<^sub>N N ?u \\<Longrightarrow>\n  \\<exists>x. tendsto_ine\\<^sub>N N ?u x", "show ?thesis"], ["proof (prove)\nusing this:\n  cauchy_ine\\<^sub>N N ?u \\<Longrightarrow>\n  \\<exists>x. tendsto_ine\\<^sub>N N ?u x\n\ngoal (1 subgoal):\n 1. complete\\<^sub>N N", "unfolding complete\\<^sub>N_def"], ["proof (prove)\nusing this:\n  cauchy_ine\\<^sub>N N ?u \\<Longrightarrow>\n  \\<exists>x. tendsto_ine\\<^sub>N N ?u x\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       cauchy_ine\\<^sub>N N u \\<longrightarrow> Ex (tendsto_ine\\<^sub>N N u)", "by auto"], ["proof (state)\nthis:\n  complete\\<^sub>N N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cauchy_tendsto_in_subseq:\n  assumes \"\\<And>n. u n \\<in> space\\<^sub>N N\"\n          \"cauchy_in\\<^sub>N N u\"\n          \"strict_mono r\"\n          \"tendsto_in\\<^sub>N N (u o r) x\"\n  shows \"tendsto_in\\<^sub>N N u x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N u x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N u x", "have \"\\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "define f where \"f = e / (2 * defect N)\""], ["proof (state)\nthis:\n  f = e / (2 * defect N)\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "have \"f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e / (2 * defect N)", "using \\<open>e > 0\\<close> defect_ge_1[of N]"], ["proof (prove)\nusing this:\n  0 < e\n  1 \\<le> defect N\n\ngoal (1 subgoal):\n 1. 0 < e / (2 * defect N)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  0 < f\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "obtain M1 where M1: \"\\<And>m n. m \\<ge> M1 \\<Longrightarrow> n \\<ge> M1 \\<Longrightarrow> Norm N (u n - u m) < f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M1.\n        (\\<And>m n.\n            \\<lbrakk>M1 \\<le> m; M1 \\<le> n\\<rbrakk>\n            \\<Longrightarrow> Norm N (u n - u m) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_in\\<^sub>N N u\\<close>"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N u\n\ngoal (1 subgoal):\n 1. (\\<And>M1.\n        (\\<And>m n.\n            \\<lbrakk>M1 \\<le> m; M1 \\<le> n\\<rbrakk>\n            \\<Longrightarrow> Norm N (u n - u m) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n\ngoal (1 subgoal):\n 1. (\\<And>M1.\n        (\\<And>m n.\n            \\<lbrakk>M1 \\<le> m; M1 \\<le> n\\<rbrakk>\n            \\<Longrightarrow> Norm N (u n - u m) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>f > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (u n - u m) < e\n  0 < f\n\ngoal (1 subgoal):\n 1. (\\<And>M1.\n        (\\<And>m n.\n            \\<lbrakk>M1 \\<le> m; M1 \\<le> n\\<rbrakk>\n            \\<Longrightarrow> Norm N (u n - u m) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  \\<lbrakk>M1 \\<le> ?m; M1 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> Norm N (u ?n - u ?m) < f\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "obtain M2 where M2: \"\\<And>n. n \\<ge> M2 \\<Longrightarrow> Norm N ((u o r) n - x) < f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M2.\n        (\\<And>n.\n            M2 \\<le> n \\<Longrightarrow>\n            Norm N ((u \\<circ> r) n - x) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>tendsto_in\\<^sub>N N (u o r) x\\<close> \\<open>f > 0\\<close>"], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N (u \\<circ> r) x\n  0 < f\n\ngoal (1 subgoal):\n 1. (\\<And>M2.\n        (\\<And>n.\n            M2 \\<le> n \\<Longrightarrow>\n            Norm N ((u \\<circ> r) n - x) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding tendsto_in\\<^sub>N_def order_tendsto_iff eventually_sequentially"], ["proof (prove)\nusing this:\n  (\\<forall>l<0.\n      \\<exists>Na.\n         \\<forall>n\\<ge>Na. l < Norm N ((u \\<circ> r) n - x)) \\<and>\n  (\\<forall>ua>0.\n      \\<exists>Na. \\<forall>n\\<ge>Na. Norm N ((u \\<circ> r) n - x) < ua)\n  0 < f\n\ngoal (1 subgoal):\n 1. (\\<And>M2.\n        (\\<And>n.\n            M2 \\<le> n \\<Longrightarrow>\n            Norm N ((u \\<circ> r) n - x) < f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M2 \\<le> ?n \\<Longrightarrow> Norm N ((u \\<circ> r) ?n - x) < f\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "define M where \"M = max M1 M2\""], ["proof (state)\nthis:\n  M = max M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "have \"Norm N (u n - x) < e\" if \"n \\<ge> M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "have \"Norm N (u n - x) = Norm N ((u n - u (r M)) + (u (r M) - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (u n - x) = Norm N (u n - u (r M) + (u (r M) - x))", "by auto"], ["proof (state)\nthis:\n  Norm N (u n - x) = Norm N (u n - u (r M) + (u (r M) - x))\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "also"], ["proof (state)\nthis:\n  Norm N (u n - x) = Norm N (u n - u (r M) + (u (r M) - x))\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "have \"... \\<le> defect N * Norm N (u n - u (r M)) + defect N * Norm N (u (r M) - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (u n - u (r M) + (u (r M) - x))\n    \\<le> defect N * Norm N (u n - u (r M)) +\n          defect N * Norm N (u (r M) - x)", "apply (rule Norm_triangular_ineq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n - u (r M) \\<in> space\\<^sub>N N", "using \\<open>\\<And>n. u n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  u ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. u n - u (r M) \\<in> space\\<^sub>N N", "by simp"], ["proof (state)\nthis:\n  Norm N (u n - u (r M) + (u (r M) - x))\n  \\<le> defect N * Norm N (u n - u (r M)) + defect N * Norm N (u (r M) - x)\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "also"], ["proof (state)\nthis:\n  Norm N (u n - u (r M) + (u (r M) - x))\n  \\<le> defect N * Norm N (u n - u (r M)) + defect N * Norm N (u (r M) - x)\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "have \"... < defect N * f + defect N * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defect N * Norm N (u n - u (r M)) + defect N * Norm N (u (r M) - x)\n    < defect N * f + defect N * f", "apply (auto intro!: add_strict_mono mult_mono simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. defect N * Norm N (u n - u (r M)) < defect N * f\n 2. defect N * Norm N (u (r M) - x) < defect N * f", "using defect_ge_1[of N] \\<open>n \\<ge> M\\<close> seq_suble[OF \\<open>strict_mono r\\<close>, of M] M1 M2 o_def"], ["proof (prove)\nusing this:\n  1 \\<le> defect N\n  M \\<le> n\n  M \\<le> r M\n  \\<lbrakk>M1 \\<le> ?m; M1 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> Norm N (u ?n - u ?m) < f\n  M2 \\<le> ?n \\<Longrightarrow> Norm N ((u \\<circ> r) ?n - x) < f\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (2 subgoals):\n 1. defect N * Norm N (u n - u (r M)) < defect N * f\n 2. defect N * Norm N (u (r M) - x) < defect N * f", "unfolding M_def"], ["proof (prove)\nusing this:\n  1 \\<le> defect N\n  max M1 M2 \\<le> n\n  max M1 M2 \\<le> r (max M1 M2)\n  \\<lbrakk>M1 \\<le> ?m; M1 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> Norm N (u ?n - u ?m) < f\n  M2 \\<le> ?n \\<Longrightarrow> Norm N ((u \\<circ> r) ?n - x) < f\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (2 subgoals):\n 1. defect N * Norm N (u n - u (r (max M1 M2))) < defect N * f\n 2. defect N * Norm N (u (r (max M1 M2)) - x) < defect N * f", "by auto"], ["proof (state)\nthis:\n  defect N * Norm N (u n - u (r M)) + defect N * Norm N (u (r M) - x)\n  < defect N * f + defect N * f\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "finally"], ["proof (chain)\npicking this:\n  Norm N (u n - x) < defect N * f + defect N * f", "show ?thesis"], ["proof (prove)\nusing this:\n  Norm N (u n - x) < defect N * f + defect N * f\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "unfolding f_def"], ["proof (prove)\nusing this:\n  Norm N (u n - x)\n  < defect N * (e / (2 * defect N)) + defect N * (e / (2 * defect N))\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "using \\<open>e > 0\\<close> defect_ge_1[of N]"], ["proof (prove)\nusing this:\n  Norm N (u n - x)\n  < defect N * (e / (2 * defect N)) + defect N * (e / (2 * defect N))\n  0 < e\n  1 \\<le> defect N\n\ngoal (1 subgoal):\n 1. Norm N (u n - x) < e", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  Norm N (u n - x) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<le> ?n \\<Longrightarrow> Norm N (u ?n - x) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "then"], ["proof (chain)\npicking this:\n  M \\<le> ?n \\<Longrightarrow> Norm N (u ?n - x) < e", "show ?thesis"], ["proof (prove)\nusing this:\n  M \\<le> ?n \\<Longrightarrow> Norm N (u ?n - x) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < ?e\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < ?e", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < ?e\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N u x", "unfolding tendsto_in\\<^sub>N_def order_tendsto_iff eventually_sequentially"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < ?e\n\ngoal (1 subgoal):\n 1. (\\<forall>l<0.\n        \\<exists>Na. \\<forall>n\\<ge>Na. l < Norm N (u n - x)) \\<and>\n    (\\<forall>ua>0. \\<exists>Na. \\<forall>n\\<ge>Na. Norm N (u n - x) < ua)", "using Norm_nonneg less_le_trans"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>M. \\<forall>n\\<ge>M. Norm N (u n - x) < ?e\n  0 \\<le> Norm ?N ?x\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. (\\<forall>l<0.\n        \\<exists>Na. \\<forall>n\\<ge>Na. l < Norm N (u n - x)) \\<and>\n    (\\<forall>ua>0. \\<exists>Na. \\<forall>n\\<ge>Na. Norm N (u n - x) < ua)", "by blast"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N u x\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition complete\\<^sub>N_I':\n  assumes \"\\<And>n. c n > 0\"\n          \"\\<And>u. (\\<forall>n. u n \\<in> space\\<^sub>N N) \\<Longrightarrow> (\\<forall>n. Norm N (u n) \\<le> c n) \\<Longrightarrow> \\<exists>x\\<in> space\\<^sub>N N. tendsto_in\\<^sub>N N (\\<lambda>n. (\\<Sum>i\\<in>{0..<n}. u i)) x\"\n  shows \"complete\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete\\<^sub>N N", "proof (rule complete\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "assume \"cauchy_in\\<^sub>N N v\" \"\\<forall>n. v n \\<in> space\\<^sub>N N\""], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N N v\n  \\<forall>n. v n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have *: \"\\<exists>y. (\\<forall>m\\<ge>y. \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and> x < y\" if \"\\<forall>m\\<ge>x. \\<forall>p\\<ge>x. Norm N (v m - v p) < c n\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>m\\<ge>y.\n           \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n       x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>m\\<ge>y.\n           \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n       x < y", "obtain M where i: \"\\<forall>m\\<ge>M. \\<forall>p\\<ge>M. Norm N (v m - v p) < c (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>p\\<ge>M.\n              Norm N (v m - v p) < c (Suc n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cauchy_in\\<^sub>N N v\\<close> \\<open>c (Suc n) > 0\\<close>"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N v\n  0 < c (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>p\\<ge>M.\n              Norm N (v m - v p) < c (Suc n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding cauchy_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (v n - v m) < e\n  0 < c (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>p\\<ge>M.\n              Norm N (v m - v p) < c (Suc n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson zero_less_power)"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>M. \\<forall>p\\<ge>M. Norm N (v m - v p) < c (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>m\\<ge>y.\n           \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n       x < y", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>M. \\<forall>p\\<ge>M. Norm N (v m - v p) < c (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>M. \\<forall>p\\<ge>M. Norm N (v m - v p) < c (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>m\\<ge>y.\n           \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n       x < y", "apply (intro exI[of _ \"max M (x+1)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>M.\n       \\<forall>p\\<ge>M. Norm N (v m - v p) < c (Suc n) \\<Longrightarrow>\n    (\\<forall>m\\<ge>max M (x + 1).\n        \\<forall>p\\<ge>max M (x + 1). Norm N (v m - v p) < c (Suc n)) \\<and>\n    x < max M (x + 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>y.\n     (\\<forall>m\\<ge>y.\n         \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n     x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>?x.\n     \\<forall>p\\<ge>?x. Norm N (v m - v p) < c ?n \\<Longrightarrow>\n  \\<exists>y.\n     (\\<forall>m\\<ge>y.\n         \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc ?n)) \\<and>\n     ?x < y\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have \"\\<exists>r. \\<forall>n. (\\<forall>m\\<ge>r n. \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n) \\<and> r n < r (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       \\<forall>n.\n          (\\<forall>m\\<ge>r n.\n              \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n) \\<and>\n          r n < r (Suc n)", "apply (intro dependent_nat_choice)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x. \\<forall>m\\<ge>x. \\<forall>p\\<ge>x. Norm N (v m - v p) < c 0\n 2. \\<And>x n.\n       \\<forall>m\\<ge>x.\n          \\<forall>p\\<ge>x. Norm N (v m - v p) < c n \\<Longrightarrow>\n       \\<exists>y.\n          (\\<forall>m\\<ge>y.\n              \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n          x < y", "using \\<open>cauchy_in\\<^sub>N N v\\<close> \\<open>\\<And>n. c n > 0\\<close> *"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N v\n  0 < c ?n\n  \\<forall>m\\<ge>?x.\n     \\<forall>p\\<ge>?x. Norm N (v m - v p) < c ?n \\<Longrightarrow>\n  \\<exists>y.\n     (\\<forall>m\\<ge>y.\n         \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc ?n)) \\<and>\n     ?x < y\n\ngoal (2 subgoals):\n 1. \\<exists>x. \\<forall>m\\<ge>x. \\<forall>p\\<ge>x. Norm N (v m - v p) < c 0\n 2. \\<And>x n.\n       \\<forall>m\\<ge>x.\n          \\<forall>p\\<ge>x. Norm N (v m - v p) < c n \\<Longrightarrow>\n       \\<exists>y.\n          (\\<forall>m\\<ge>y.\n              \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n          x < y", "unfolding cauchy_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. Norm N (v n - v m) < e\n  0 < c ?n\n  \\<forall>m\\<ge>?x.\n     \\<forall>p\\<ge>?x. Norm N (v m - v p) < c ?n \\<Longrightarrow>\n  \\<exists>y.\n     (\\<forall>m\\<ge>y.\n         \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc ?n)) \\<and>\n     ?x < y\n\ngoal (2 subgoals):\n 1. \\<exists>x. \\<forall>m\\<ge>x. \\<forall>p\\<ge>x. Norm N (v m - v p) < c 0\n 2. \\<And>x n.\n       \\<forall>m\\<ge>x.\n          \\<forall>p\\<ge>x. Norm N (v m - v p) < c n \\<Longrightarrow>\n       \\<exists>y.\n          (\\<forall>m\\<ge>y.\n              \\<forall>p\\<ge>y. Norm N (v m - v p) < c (Suc n)) \\<and>\n          x < y", "by auto"], ["proof (state)\nthis:\n  \\<exists>r.\n     \\<forall>n.\n        (\\<forall>m\\<ge>r n.\n            \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n) \\<and>\n        r n < r (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     \\<forall>n.\n        (\\<forall>m\\<ge>r n.\n            \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n) \\<and>\n        r n < r (Suc n)", "obtain r where r: \"strict_mono r\" \"\\<And>n. \\<forall>m\\<ge>r n. \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     \\<forall>n.\n        (\\<forall>m\\<ge>r n.\n            \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n) \\<and>\n        r n < r (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         \\<And>n.\n            \\<forall>m\\<ge>r n.\n               \\<forall>p\\<ge>r n. Norm N (v m - v p) < c n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: strict_mono_Suc_iff)"], ["proof (state)\nthis:\n  strict_mono r\n  \\<forall>m\\<ge>r ?n. \\<forall>p\\<ge>r ?n. Norm N (v m - v p) < c ?n\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "define u where \"u = (\\<lambda>n. v (r (Suc n)) - v (r n))\""], ["proof (state)\nthis:\n  u = (\\<lambda>n. v (r (Suc n)) - v (r n))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have \"u n \\<in> space\\<^sub>N N\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n \\<in> space\\<^sub>N N", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (r (Suc n)) - v (r n) \\<in> space\\<^sub>N N", "using \\<open>\\<forall>n. v n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. v n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. v (r (Suc n)) - v (r n) \\<in> space\\<^sub>N N", "by simp"], ["proof (state)\nthis:\n  u ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "moreover"], ["proof (state)\nthis:\n  u ?n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have \"Norm N (u n) \\<le> c n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (u n) \\<le> c n", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (v (r (Suc n)) - v (r n)) \\<le> c n", "using r"], ["proof (prove)\nusing this:\n  strict_mono r\n  \\<forall>m\\<ge>r ?n. \\<forall>p\\<ge>r ?n. Norm N (v m - v p) < c ?n\n\ngoal (1 subgoal):\n 1. Norm N (v (r (Suc n)) - v (r n)) \\<le> c n", "by (simp add: less_imp_le strict_mono_def)"], ["proof (state)\nthis:\n  Norm N (u ?n) \\<le> c ?n\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "ultimately"], ["proof (chain)\npicking this:\n  u ?n \\<in> space\\<^sub>N N\n  Norm N (u ?n) \\<le> c ?n", "obtain y where y: \"y \\<in> space\\<^sub>N N\" \"tendsto_in\\<^sub>N N (\\<lambda>n. (\\<Sum>i\\<in>{0..<n}. u i)) y\""], ["proof (prove)\nusing this:\n  u ?n \\<in> space\\<^sub>N N\n  Norm N (u ?n) \\<le> c ?n\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> space\\<^sub>N N;\n         tendsto_in\\<^sub>N N (\\<lambda>n. sum u {0..<n}) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  u ?n \\<in> space\\<^sub>N N\n  Norm N (u ?n) \\<le> c ?n\n  \\<lbrakk>\\<forall>n. ?u n \\<in> space\\<^sub>N N;\n   \\<forall>n. Norm N (?u n) \\<le> c n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                       tendsto_in\\<^sub>N N (\\<lambda>n. sum ?u {0..<n}) x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> space\\<^sub>N N;\n         tendsto_in\\<^sub>N N (\\<lambda>n. sum u {0..<n}) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> space\\<^sub>N N\n  tendsto_in\\<^sub>N N (\\<lambda>n. sum u {0..<n}) y\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "define x where \"x = y + v (r 0)\""], ["proof (state)\nthis:\n  x = y + v (r 0)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have \"x \\<in> space\\<^sub>N N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space\\<^sub>N N", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y + v (r 0) \\<in> space\\<^sub>N N", "using \\<open>y \\<in> space\\<^sub>N N\\<close> \\<open>\\<forall>n. v n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> space\\<^sub>N N\n  \\<forall>n. v n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. y + v (r 0) \\<in> space\\<^sub>N N", "by simp"], ["proof (state)\nthis:\n  x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "have \"Norm N (v (r n) - x) = Norm N ((\\<Sum>i\\<in>{0..<n}. u i) - y)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm N (v (r n) - x) = Norm N (sum u {0..<n} - y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Norm N (v (r n) - x) = Norm N (sum u {0..<n} - y)", "have \"v (r n) = (\\<Sum>i\\<in>{0..<n}. u i) + v (r 0)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (r n) = sum u {0..<n} + v (r 0)", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (r n) = (\\<Sum>i = 0..<n. v (r (Suc i)) - v (r i)) + v (r 0)", "by (induct n, auto)"], ["proof (state)\nthis:\n  v (r ?n) = sum u {0..<?n} + v (r 0)\n\ngoal (1 subgoal):\n 1. Norm N (v (r n) - x) = Norm N (sum u {0..<n} - y)", "then"], ["proof (chain)\npicking this:\n  v (r ?n) = sum u {0..<?n} + v (r 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  v (r ?n) = sum u {0..<?n} + v (r 0)\n\ngoal (1 subgoal):\n 1. Norm N (v (r n) - x) = Norm N (sum u {0..<n} - y)", "unfolding x_def"], ["proof (prove)\nusing this:\n  v (r ?n) = sum u {0..<?n} + v (r 0)\n\ngoal (1 subgoal):\n 1. Norm N (v (r n) - (y + v (r 0))) = Norm N (sum u {0..<n} - y)", "by (metis add_diff_cancel_right)"], ["proof (state)\nthis:\n  Norm N (v (r n) - x) = Norm N (sum u {0..<n} - y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Norm N (v (r ?n) - x) = Norm N (sum u {0..<?n} - y)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  Norm N (v (r ?n) - x) = Norm N (sum u {0..<?n} - y)", "have \"(\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  Norm N (v (r ?n) - x) = Norm N (sum u {0..<?n} - y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0", "using y(2)"], ["proof (prove)\nusing this:\n  Norm N (v (r ?n) - x) = Norm N (sum u {0..<?n} - y)\n  tendsto_in\\<^sub>N N (\\<lambda>n. sum u {0..<n}) y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0", "unfolding tendsto_in\\<^sub>N_def"], ["proof (prove)\nusing this:\n  Norm N (v (r ?n) - x) = Norm N (sum u {0..<?n} - y)\n  (\\<lambda>n. Norm N (sum u {0..<n} - y)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0", "have \"tendsto_in\\<^sub>N N (v o r) x\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N (v \\<circ> r) x", "unfolding tendsto_in\\<^sub>N_def comp_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Norm N (v (r n) - x)) \\<longlonglongrightarrow> 0", "by force"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N (v \\<circ> r) x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  tendsto_in\\<^sub>N N (v \\<circ> r) x", "have \"tendsto_in\\<^sub>N N v x\""], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N (v \\<circ> r) x\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N v x", "using \\<open>\\<forall>n. v n \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N (v \\<circ> r) x\n  \\<forall>n. v n \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N v x", "by (intro cauchy_tendsto_in_subseq[OF _ \\<open>cauchy_in\\<^sub>N N v\\<close> \\<open>strict_mono r\\<close>], auto)"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N v x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N.\n                            tendsto_in\\<^sub>N N u x", "then"], ["proof (chain)\npicking this:\n  tendsto_in\\<^sub>N N v x", "show \"\\<exists>x\\<in>space\\<^sub>N N. tendsto_in\\<^sub>N N v x\""], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N v x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>space\\<^sub>N N. tendsto_in\\<^sub>N N v x", "using \\<open>x \\<in> space\\<^sub>N N\\<close>"], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N v x\n  x \\<in> space\\<^sub>N N\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>space\\<^sub>N N. tendsto_in\\<^sub>N N v x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>space\\<^sub>N N. tendsto_in\\<^sub>N N v x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next, we show when the two examples of norms we have introduced before, the ambient norm\nin a Banach space, and the norm on bounded continuous functions, are complete. We just have to\ntranslate in our setting the already known completeness of these spaces.\\<close>"], ["", "lemma complete_N_of_norm:\n  \"complete\\<^sub>N (N_of_norm::'a::banach quasinorm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete\\<^sub>N N_of_norm", "proof (rule complete\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "fix u::\"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "assume \"cauchy_in\\<^sub>N N_of_norm u\""], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N N_of_norm u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "then"], ["proof (chain)\npicking this:\n  cauchy_in\\<^sub>N N_of_norm u", "have \"Cauchy u\""], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N N_of_norm u\n\ngoal (1 subgoal):\n 1. Cauchy u", "unfolding Cauchy_def cauchy_in\\<^sub>N_def N_of_norm(2)"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>n\\<ge>M. \\<forall>m\\<ge>M. norm (u n - u m) < e\n\ngoal (1 subgoal):\n 1. \\<forall>e>0.\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (u m) (u n) < e", "by (simp add: dist_norm)"], ["proof (state)\nthis:\n  Cauchy u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "then"], ["proof (chain)\npicking this:\n  Cauchy u", "obtain x where \"u \\<longlonglongrightarrow> x\""], ["proof (prove)\nusing this:\n  Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        u \\<longlonglongrightarrow> x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using convergent_eq_Cauchy"], ["proof (prove)\nusing this:\n  Cauchy u\n  (\\<exists>l. ?S \\<longlonglongrightarrow> l) = Cauchy ?S\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        u \\<longlonglongrightarrow> x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> x", "have \"tendsto_in\\<^sub>N N_of_norm u x\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N N_of_norm u x", "unfolding tendsto_in\\<^sub>N_def N_of_norm(2)"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. norm (u n - x)) \\<longlonglongrightarrow> 0", "using Lim_null tendsto_norm_zero_iff"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> x\n  (?f \\<longlongrightarrow> ?l) ?net =\n  ((\\<lambda>x. ?f x - ?l) \\<longlongrightarrow> (0::?'b)) ?net\n  ((\\<lambda>x. norm (?f x)) \\<longlongrightarrow> 0) ?F =\n  (?f \\<longlongrightarrow> (0::?'b)) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. norm (u n - x)) \\<longlonglongrightarrow> 0", "by fastforce"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N_of_norm u x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "moreover"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N N_of_norm u x\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "have \"x \\<in> space\\<^sub>N N_of_norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space\\<^sub>N N_of_norm", "by auto"], ["proof (state)\nthis:\n  x \\<in> space\\<^sub>N N_of_norm\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N N_of_norm u;\n        \\<forall>n. u n \\<in> space\\<^sub>N N_of_norm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N N_of_norm.\n                            tendsto_in\\<^sub>N N_of_norm u x", "ultimately"], ["proof (chain)\npicking this:\n  tendsto_in\\<^sub>N N_of_norm u x\n  x \\<in> space\\<^sub>N N_of_norm", "show \"\\<exists>x\\<in>space\\<^sub>N N_of_norm. tendsto_in\\<^sub>N N_of_norm u x\""], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N N_of_norm u x\n  x \\<in> space\\<^sub>N N_of_norm\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>space\\<^sub>N N_of_norm. tendsto_in\\<^sub>N N_of_norm u x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>space\\<^sub>N N_of_norm. tendsto_in\\<^sub>N N_of_norm u x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the next statement, the assumption that \\verb+'a+ is a metric space is not necessary,\na topological space would be enough, but a statement about uniform convergence is not available\nin this setting.\nTODO: fix it.\n\\<close>"], ["", "lemma complete_bcontfunN:\n  \"complete\\<^sub>N (bcontfun\\<^sub>N::('a::metric_space \\<Rightarrow> 'b::banach) quasinorm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete\\<^sub>N bcontfun\\<^sub>N", "proof (rule complete\\<^sub>N_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "fix u::\"nat \\<Rightarrow> ('a \\<Rightarrow> 'b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "assume H: \"cauchy_in\\<^sub>N bcontfun\\<^sub>N u\" \"\\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\""], ["proof (state)\nthis:\n  cauchy_in\\<^sub>N bcontfun\\<^sub>N u\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "then"], ["proof (chain)\npicking this:\n  cauchy_in\\<^sub>N bcontfun\\<^sub>N u\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N", "have H2: \"u n \\<in> bcontfun\" for n"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N bcontfun\\<^sub>N u\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. u n \\<in> bcontfun", "using bcontfun\\<^sub>N_space"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N bcontfun\\<^sub>N u\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\n  space\\<^sub>N bcontfun\\<^sub>N = bcontfun\n\ngoal (1 subgoal):\n 1. u n \\<in> bcontfun", "by auto"], ["proof (state)\nthis:\n  u ?n \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "then"], ["proof (chain)\npicking this:\n  u ?n \\<in> bcontfun", "have **: \"Bcontfun(u n - u m) = Bcontfun (u n) - Bcontfun (u m)\" for m n"], ["proof (prove)\nusing this:\n  u ?n \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. Bcontfun (u n - u m) = Bcontfun (u n) - Bcontfun (u m)", "unfolding minus_fun_def minus_bcontfun_def"], ["proof (prove)\nusing this:\n  u ?n \\<in> bcontfun\n\ngoal (1 subgoal):\n 1. Bcontfun (\\<lambda>x. u n x - u m x) =\n    map_fun apply_bcontfun (map_fun apply_bcontfun Bcontfun)\n     (\\<lambda>f g x. f x - g x) (Bcontfun (u n)) (Bcontfun (u m))", "by (simp add: Bcontfun_inverse)"], ["proof (state)\nthis:\n  Bcontfun (u ?n - u ?m) = Bcontfun (u ?n) - Bcontfun (u ?m)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "have *: \"Norm bcontfun\\<^sub>N (u n - u m) = norm (Bcontfun (u n - u m))\" for n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - u m) = norm (Bcontfun (u n - u m))", "unfolding bcontfun\\<^sub>N(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if u n - u m \\<in> bcontfun then norm (Bcontfun (u n - u m)) else 0) =\n    norm (Bcontfun (u n - u m))", "using H(2) bcontfun\\<^sub>N_space"], ["proof (prove)\nusing this:\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\n  space\\<^sub>N bcontfun\\<^sub>N = bcontfun\n\ngoal (1 subgoal):\n 1. (if u n - u m \\<in> bcontfun then norm (Bcontfun (u n - u m)) else 0) =\n    norm (Bcontfun (u n - u m))", "by auto"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N (u ?n - u ?m) = norm (Bcontfun (u ?n - u ?m))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "have \"Cauchy (\\<lambda>n. Bcontfun (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. Bcontfun (u n))", "using H(1)"], ["proof (prove)\nusing this:\n  cauchy_in\\<^sub>N bcontfun\\<^sub>N u\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. Bcontfun (u n))", "unfolding Cauchy_def cauchy_in\\<^sub>N_def dist_norm * **"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M.\n        \\<forall>n\\<ge>M.\n           \\<forall>m\\<ge>M. norm (Bcontfun (u n) - Bcontfun (u m)) < e\n\ngoal (1 subgoal):\n 1. \\<forall>e>0.\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (Bcontfun (u m) - Bcontfun (u n)) < e", "by simp"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. Bcontfun (u n))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "then"], ["proof (chain)\npicking this:\n  Cauchy (\\<lambda>n. Bcontfun (u n))", "obtain v where v: \"(\\<lambda>n. Bcontfun (u n)) \\<longlonglongrightarrow> v\""], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. Bcontfun (u n))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<lambda>n. Bcontfun (u n))\n        \\<longlonglongrightarrow> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using convergent_eq_Cauchy"], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. Bcontfun (u n))\n  (\\<exists>l. ?S \\<longlonglongrightarrow> l) = Cauchy ?S\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<lambda>n. Bcontfun (u n))\n        \\<longlonglongrightarrow> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. Bcontfun (u n)) \\<longlonglongrightarrow> v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "have v_space: \"apply_bcontfun v \\<in> space\\<^sub>N bcontfun\\<^sub>N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_bcontfun v \\<in> space\\<^sub>N bcontfun\\<^sub>N", "unfolding bcontfun\\<^sub>N_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_bcontfun v \\<in> bcontfun", "by (simp add: apply_bcontfun)"], ["proof (state)\nthis:\n  apply_bcontfun v \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "have ***: \"Norm bcontfun\\<^sub>N (u n - v) = norm(Bcontfun (u n) - v)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "have \"Norm bcontfun\\<^sub>N (u n - v) = norm (Bcontfun(u n - v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n - apply_bcontfun v))", "unfolding bcontfun\\<^sub>N(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if u n - apply_bcontfun v \\<in> bcontfun\n     then norm (Bcontfun (u n - apply_bcontfun v)) else 0) =\n    norm (Bcontfun (u n - apply_bcontfun v))", "using H(2) bcontfun\\<^sub>N_space v_space"], ["proof (prove)\nusing this:\n  \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\n  space\\<^sub>N bcontfun\\<^sub>N = bcontfun\n  apply_bcontfun v \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. (if u n - apply_bcontfun v \\<in> bcontfun\n     then norm (Bcontfun (u n - apply_bcontfun v)) else 0) =\n    norm (Bcontfun (u n - apply_bcontfun v))", "by auto"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n  norm (Bcontfun (u n - apply_bcontfun v))\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "moreover"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n  norm (Bcontfun (u n - apply_bcontfun v))\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "have \"Bcontfun(u n - v) = Bcontfun (u n) - v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bcontfun (u n - apply_bcontfun v) = Bcontfun (u n) - v", "unfolding minus_fun_def minus_bcontfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bcontfun (\\<lambda>x. u n x - apply_bcontfun v x) =\n    map_fun apply_bcontfun (map_fun apply_bcontfun Bcontfun)\n     (\\<lambda>f g x. f x - g x) (Bcontfun (u n)) v", "by (simp add: Bcontfun_inverse H2)"], ["proof (state)\nthis:\n  Bcontfun (u n - apply_bcontfun v) = Bcontfun (u n) - v\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "ultimately"], ["proof (chain)\npicking this:\n  Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n  norm (Bcontfun (u n - apply_bcontfun v))\n  Bcontfun (u n - apply_bcontfun v) = Bcontfun (u n) - v", "show ?thesis"], ["proof (prove)\nusing this:\n  Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n  norm (Bcontfun (u n - apply_bcontfun v))\n  Bcontfun (u n - apply_bcontfun v) = Bcontfun (u n) - v\n\ngoal (1 subgoal):\n 1. Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) =\n    norm (Bcontfun (u n) - v)", "by simp"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N (u n - apply_bcontfun v) = norm (Bcontfun (u n) - v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Norm bcontfun\\<^sub>N (u ?n - apply_bcontfun v) =\n  norm (Bcontfun (u ?n) - v)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "have \"tendsto_in\\<^sub>N bcontfun\\<^sub>N u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tendsto_in\\<^sub>N bcontfun\\<^sub>N u (apply_bcontfun v)", "unfolding tendsto_in\\<^sub>N_def ***"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. norm (Bcontfun (u n) - v)) \\<longlonglongrightarrow> 0", "using v Lim_null tendsto_norm_zero_iff"], ["proof (prove)\nusing this:\n  (\\<lambda>n. Bcontfun (u n)) \\<longlonglongrightarrow> v\n  (?f \\<longlongrightarrow> ?l) ?net =\n  ((\\<lambda>x. ?f x - ?l) \\<longlongrightarrow> (0::?'b)) ?net\n  ((\\<lambda>x. norm (?f x)) \\<longlongrightarrow> 0) ?F =\n  (?f \\<longlongrightarrow> (0::?'b)) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. norm (Bcontfun (u n) - v)) \\<longlonglongrightarrow> 0", "by fastforce"], ["proof (state)\nthis:\n  tendsto_in\\<^sub>N bcontfun\\<^sub>N u (apply_bcontfun v)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>cauchy_in\\<^sub>N bcontfun\\<^sub>N u;\n        \\<forall>n. u n \\<in> space\\<^sub>N bcontfun\\<^sub>N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n                            tendsto_in\\<^sub>N bcontfun\\<^sub>N u x", "then"], ["proof (chain)\npicking this:\n  tendsto_in\\<^sub>N bcontfun\\<^sub>N u (apply_bcontfun v)", "show \"\\<exists>v\\<in>space\\<^sub>N bcontfun\\<^sub>N. tendsto_in\\<^sub>N bcontfun\\<^sub>N u v\""], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N bcontfun\\<^sub>N u (apply_bcontfun v)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n       tendsto_in\\<^sub>N bcontfun\\<^sub>N u v", "using v_space"], ["proof (prove)\nusing this:\n  tendsto_in\\<^sub>N bcontfun\\<^sub>N u (apply_bcontfun v)\n  apply_bcontfun v \\<in> space\\<^sub>N bcontfun\\<^sub>N\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n       tendsto_in\\<^sub>N bcontfun\\<^sub>N u v", "by auto"], ["proof (state)\nthis:\n  \\<exists>v\\<in>space\\<^sub>N bcontfun\\<^sub>N.\n     tendsto_in\\<^sub>N bcontfun\\<^sub>N u v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}