{"file_name": "/home/qj213/afp-2021-10-22/thys/Three_Circles/Three_Circles.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Three_Circles", "problem_names": ["lemma pos_real_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} = circle_01_diam\"", "lemma one_circle_01: fixes P::\"real poly\" assumes hP: \"degree P \\<le> p\" and \"P \\<noteq> 0\"\n  and \"proots_count (map_poly of_real P) circle_01_diam = 0\"\nshows \"Bernstein_changes_01 p P = 0\"", "lemma circle_diam_rescale: assumes \"l < r\"\n  shows \"circle_diam l r = (\\<lambda> x . (x*(r - l) + l)) ` circle_01_diam\"", "lemma one_circle: fixes P::\"real poly\" assumes \"l < r\"\n  and \"proots_count (map_poly of_real P) (circle_diam l r) = 0\"\n  and \"P \\<noteq> 0\"\n  and \"degree P \\<le> p\"\nshows \"Bernstein_changes p l r P = 0\"", "lemma upper_circle_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} = upper_circle_01\"", "lemma cnj_upper_circle_01: \"cnj ` upper_circle_01 = lower_circle_01\"", "lemma lower_circle_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x > - sqrt 3 * Re x}} = lower_circle_01\"", "lemma two_circles_01: \n  fixes P::\"real poly\" \n  assumes hP: \"degree P \\<le> p\" and hP0: \"P \\<noteq> 0\" and hp0: \"p \\<noteq> 0\"\n  and h: \"proots_count (map_poly of_real P) \n          (upper_circle_01 \\<union> lower_circle_01) = 1\"\nshows \"Bernstein_changes_01 p P = 1\"", "lemma upper_circle_rescale: assumes \"l < r\"\n  shows \"upper_circle l r = (\\<lambda> x . (x*(r - l) + l)) ` upper_circle_01\"", "lemma lower_circle_rescale: \n  assumes \"l < r\"\n  shows \"lower_circle l r = (\\<lambda> x . (x*(r - l) + l)) ` lower_circle_01\"", "lemma two_circles: \n  fixes P::\"real poly\" and l r::real \n  assumes hlr: \"l < r\"\n  and hP: \"degree P \\<le> p\" \n  and hP0: \"P \\<noteq> 0\" \n  and hp0: \"p \\<noteq> 0\"\n  and h: \"proots_count (map_poly of_real P) \n       (upper_circle l r \\<union> lower_circle l r) = 1\"\nshows \"Bernstein_changes p l r P = 1\"", "theorem three_circles: \n  fixes P::\"real poly\" and l r::real\n  assumes \"l < r\"\n  and hP: \"degree P \\<le> p\" \n  and hP0: \"P \\<noteq> 0\" \n  and hp0: \"p \\<noteq> 0\"\nshows \"proots_count (map_poly of_real P) (circle_diam l r) = 0 \\<Longrightarrow>\n       Bernstein_changes p l r P = 0\"\n  and \"proots_count (map_poly of_real P) \n       (upper_circle l r \\<union> lower_circle l r) = 1 \\<Longrightarrow>\n       Bernstein_changes p l r P = 1\""], "translations": [["", "lemma pos_real_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} = circle_01_diam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} = circle_01_diam", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n    \\<subseteq> circle_01_diam\n 2. circle_01_diam\n    \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "show \"{x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} \\<subseteq> circle_01_diam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n    \\<subseteq> circle_01_diam", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "assume \"x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\""], ["proof (state)\nthis:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "obtain y where h: \"1 / x = y + 1\" and hy: \"0 < Re y\""], ["proof (prove)\nusing this:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>1 / x = y + 1; 0 < Re y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  1 / x = y + 1\n  0 < Re y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "hence hy': \"y = 1 / x - 1\""], ["proof (prove)\nusing this:\n  1 / x = y + 1\n  0 < Re y\n\ngoal (1 subgoal):\n 1. y = 1 / x - 1", "by fastforce"], ["proof (state)\nthis:\n  y = 1 / x - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "hence hy'': \"y + 1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y = 1 / x - 1\n\ngoal (1 subgoal):\n 1. y + 1 \\<noteq> 0", "using h hy"], ["proof (prove)\nusing this:\n  y = 1 / x - 1\n  1 / x = y + 1\n  0 < Re y\n\ngoal (1 subgoal):\n 1. y + 1 \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  y + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "hence \"x = 1 / (y + 1)\""], ["proof (prove)\nusing this:\n  y + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = 1 / (y + 1)", "using h"], ["proof (prove)\nusing this:\n  y + 1 \\<noteq> 0\n  1 / x = y + 1\n\ngoal (1 subgoal):\n 1. x = 1 / (y + 1)", "by (metis div_by_1 divide_divide_eq_right mult.left_neutral)"], ["proof (state)\nthis:\n  x = 1 / (y + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "have \"\\<bar>Re y - 1\\<bar> < \\<bar>Re y + 1\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Re y - 1\\<bar> < \\<bar>Re y + 1\\<bar>", "using hy"], ["proof (prove)\nusing this:\n  0 < Re y\n\ngoal (1 subgoal):\n 1. \\<bar>Re y - 1\\<bar> < \\<bar>Re y + 1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>Re y - 1\\<bar> < \\<bar>Re y + 1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "hence \"cmod (y - 1) < cmod (y + 1)\""], ["proof (prove)\nusing this:\n  \\<bar>Re y - 1\\<bar> < \\<bar>Re y + 1\\<bar>\n\ngoal (1 subgoal):\n 1. cmod (y - 1) < cmod (y + 1)", "by (smt (z3) cmod_Re_le_iff minus_complex.simps(1) minus_complex.simps(2)\n          one_complex.simps plus_complex.simps(1) plus_complex.simps(2))"], ["proof (state)\nthis:\n  cmod (y - 1) < cmod (y + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "hence \"cmod ((y - 1)/(y + 1)) < 1\""], ["proof (prove)\nusing this:\n  cmod (y - 1) < cmod (y + 1)\n\ngoal (1 subgoal):\n 1. cmod ((y - 1) / (y + 1)) < 1", "by (smt (verit) divide_less_eq_1_pos nonzero_norm_divide zero_less_norm_iff)"], ["proof (state)\nthis:\n  cmod ((y - 1) / (y + 1)) < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. 0 < Re x}} \\<Longrightarrow>\n       x \\<in> circle_01_diam", "thus \"x \\<in> circle_01_diam\""], ["proof (prove)\nusing this:\n  cmod ((y - 1) / (y + 1)) < 1\n\ngoal (1 subgoal):\n 1. x \\<in> circle_01_diam", "using hy' hy''"], ["proof (prove)\nusing this:\n  cmod ((y - 1) / (y + 1)) < 1\n  y = 1 / x - 1\n  y + 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> circle_01_diam", "by (auto simp: field_simps norm_minus_commute circle_01_diam_def)"], ["proof (state)\nthis:\n  x \\<in> circle_01_diam\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n  \\<subseteq> circle_01_diam\n\ngoal (1 subgoal):\n 1. circle_01_diam\n    \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "show \"circle_01_diam \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_01_diam\n    \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "assume \"x \\<in> circle_01_diam\""], ["proof (state)\nthis:\n  x \\<in> circle_01_diam\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"cmod (x - 1 / 2) * 2 < 1\""], ["proof (prove)\nusing this:\n  x \\<in> circle_01_diam\n\ngoal (1 subgoal):\n 1. cmod (x - 1 / 2) * 2 < 1", "by (auto simp: circle_01_diam_def)"], ["proof (state)\nthis:\n  cmod (x - 1 / 2) * 2 < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence h: \"x \\<noteq> 0\" and \"cmod (x - 1 / 2) * cmod 2 < 1\""], ["proof (prove)\nusing this:\n  cmod (x - 1 / 2) * 2 < 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 &&& cmod (x - 1 / 2) * cmod 2 < 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n  cmod (x - 1 / 2) * cmod 2 < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"cmod (2*x - 1) < 1\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  cmod (x - 1 / 2) * cmod 2 < 1\n\ngoal (1 subgoal):\n 1. cmod (2 * x - 1) < 1", "by (smt (verit) dbl_simps(3) dbl_simps(5) div_self times_divide_eq_left\n          left_diff_distrib_numeral mult.commute mult_numeral_1\n          norm_eq_zero norm_mult norm_numeral norm_one numeral_One)"], ["proof (state)\nthis:\n  cmod (2 * x - 1) < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"cmod (((1/x - 1) -  1)/((1/x - 1) + 1)) < 1\""], ["proof (prove)\nusing this:\n  cmod (2 * x - 1) < 1\n\ngoal (1 subgoal):\n 1. cmod ((1 / x - 1 - 1) / (1 / x - 1 + 1)) < 1", "by (auto simp: divide_simps norm_minus_commute)"], ["proof (state)\nthis:\n  cmod ((1 / x - 1 - 1) / (1 / x - 1 + 1)) < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"cmod (((1/x - 1) -  1)/ cmod ((1/x - 1) + 1)) < 1\""], ["proof (prove)\nusing this:\n  cmod ((1 / x - 1 - 1) / (1 / x - 1 + 1)) < 1\n\ngoal (1 subgoal):\n 1. cmod ((1 / x - 1 - 1) / complex_of_real (cmod (1 / x - 1 + 1))) < 1", "by (metis (no_types, lifting) abs_norm_cancel norm_divide norm_of_real)"], ["proof (state)\nthis:\n  cmod ((1 / x - 1 - 1) / complex_of_real (cmod (1 / x - 1 + 1))) < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"cmod ((1/x - 1) - 1) < cmod ((1/x - 1) + 1)\""], ["proof (prove)\nusing this:\n  cmod ((1 / x - 1 - 1) / complex_of_real (cmod (1 / x - 1 + 1))) < 1\n\ngoal (1 subgoal):\n 1. cmod (1 / x - 1 - 1) < cmod (1 / x - 1 + 1)", "using h"], ["proof (prove)\nusing this:\n  cmod ((1 / x - 1 - 1) / complex_of_real (cmod (1 / x - 1 + 1))) < 1\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (1 / x - 1 - 1) < cmod (1 / x - 1 + 1)", "by (smt (verit) diff_add_cancel divide_eq_0_iff divide_less_eq_1_pos\n          norm_divide norm_of_real zero_less_norm_iff zero_neq_one)"], ["proof (state)\nthis:\n  cmod (1 / x - 1 - 1) < cmod (1 / x - 1 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"\\<bar>Re (1/x - 1) - 1\\<bar> < \\<bar>Re (1/x - 1) + 1\\<bar>\""], ["proof (prove)\nusing this:\n  cmod (1 / x - 1 - 1) < cmod (1 / x - 1 + 1)\n\ngoal (1 subgoal):\n 1. \\<bar>Re (1 / x - 1) - 1\\<bar> < \\<bar>Re (1 / x - 1) + 1\\<bar>", "by (smt (z3) cmod_Re_le_iff minus_complex.simps(1) minus_complex.simps(2)\n          one_complex.simps plus_complex.simps(1) plus_complex.simps(2))"], ["proof (state)\nthis:\n  \\<bar>Re (1 / x - 1) - 1\\<bar> < \\<bar>Re (1 / x - 1) + 1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"0 < Re (1/x - 1)\""], ["proof (prove)\nusing this:\n  \\<bar>Re (1 / x - 1) - 1\\<bar> < \\<bar>Re (1 / x - 1) + 1\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < Re (1 / x - 1)", "by linarith"], ["proof (state)\nthis:\n  0 < Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "moreover"], ["proof (state)\nthis:\n  0 < Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "have \"1 / x = (1/x - 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / x = 1 / x - 1 + 1", "by simp"], ["proof (state)\nthis:\n  1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "ultimately"], ["proof (chain)\npicking this:\n  0 < Re (1 / x - 1)\n  1 / x = 1 / x - 1 + 1", "have \"0 < Re (1/x - 1) \\<and> 1 / x = (1/x - 1) + 1\""], ["proof (prove)\nusing this:\n  0 < Re (1 / x - 1)\n  1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. 0 < Re (1 / x - 1) \\<and> 1 / x = 1 / x - 1 + 1", "by blast"], ["proof (state)\nthis:\n  0 < Re (1 / x - 1) \\<and> 1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "hence \"\\<exists>xa. 0 < Re xa \\<and> 1 / x = xa + 1\""], ["proof (prove)\nusing this:\n  0 < Re (1 / x - 1) \\<and> 1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. \\<exists>xa. 0 < Re xa \\<and> 1 / x = xa + 1", "by blast"], ["proof (state)\nthis:\n  \\<exists>xa. 0 < Re xa \\<and> 1 / x = xa + 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_01_diam \\<Longrightarrow>\n       x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "thus \"x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\""], ["proof (prove)\nusing this:\n  \\<exists>xa. 0 < Re xa \\<and> 1 / x = xa + 1\n\ngoal (1 subgoal):\n 1. x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circle_01_diam\n  \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_circle_01: fixes P::\"real poly\" assumes hP: \"degree P \\<le> p\" and \"P \\<noteq> 0\"\n  and \"proots_count (map_poly of_real P) circle_01_diam = 0\"\nshows \"Bernstein_changes_01 p P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "let ?Q = \"(reciprocal_poly p P) \\<circ>\\<^sub>p [:1, 1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "have hQ: \"?Q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (1 subgoal):\n 1. reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0", "by (simp add: Missing_Polynomial.pcompose_eq_0 reciprocal_0_iff)"], ["proof (state)\nthis:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence 1: \"changes (coeffs ?Q) \\<ge> proots_count ?Q {x. 0 < x} \\<and> \n        even (changes (coeffs ?Q) - proots_count ?Q {x. 0 < x})\""], ["proof (prove)\nusing this:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])\n          {x. 0 < x})\n    \\<le> changes\n           (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<and>\n    even\n     (changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) -\n      int (proots_count (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])\n            {x. 0 < x}))", "by (rule descartes_sign)"], ["proof (state)\nthis:\n  int (proots_count (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])\n        {x. 0 < x})\n  \\<le> changes\n         (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<and>\n  even\n   (changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) -\n    int (proots_count (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])\n          {x. 0 < x}))\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "have hdeg: \"degree (map_poly complex_of_real P) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly complex_of_real P) \\<le> p", "by (rule le_trans, rule degree_map_poly_le, auto simp: assms)"], ["proof (state)\nthis:\n  degree (map_poly complex_of_real P) \\<le> p\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "have hx: \"\\<And>x. 1 + x = 0 \\<Longrightarrow> 0 < Re x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>1 + x = 0; 0 < Re x\\<rbrakk> \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>1 + x = 0; 0 < Re x\\<rbrakk> \\<Longrightarrow> False", "fix x::complex"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>1 + x = 0; 0 < Re x\\<rbrakk> \\<Longrightarrow> False", "assume \"1 + x = 0\""], ["proof (state)\nthis:\n  1 + x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>1 + x = 0; 0 < Re x\\<rbrakk> \\<Longrightarrow> False", "hence \"x = -1\""], ["proof (prove)\nusing this:\n  1 + x = 0\n\ngoal (1 subgoal):\n 1. x = - 1", "by algebra"], ["proof (state)\nthis:\n  x = - 1\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>1 + x = 0; 0 < Re x\\<rbrakk> \\<Longrightarrow> False", "thus \"0 < Re x \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  x = - 1\n\ngoal (1 subgoal):\n 1. 0 < Re x \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  0 < Re x \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>1 + ?x = 0; 0 < Re ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "have 2: \"proots_count (map_poly of_real P) circle_01_diam =\n           proots_count (map_poly of_real ?Q) {x. 0 < Re x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) circle_01_diam =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x}", "apply (subst pos_real_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x}", "apply (subst of_real_hom.map_poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count\n     (map_poly complex_of_real (reciprocal_poly p P) \\<circ>\\<^sub>p\n      map_poly complex_of_real [:1, 1:])\n     {x. 0 < Re x}", "apply (subst map_poly_reciprocal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree P \\<le> p\n 2. complex_of_real 0 = 0\n 3. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count\n     (reciprocal_poly p (map_poly complex_of_real P) \\<circ>\\<^sub>p\n      map_poly complex_of_real [:1, 1:])\n     {x. 0 < Re x}", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (3 subgoals):\n 1. degree P \\<le> p\n 2. complex_of_real 0 = 0\n 3. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count\n     (reciprocal_poly p (map_poly complex_of_real P) \\<circ>\\<^sub>p\n      map_poly complex_of_real [:1, 1:])\n     {x. 0 < Re x}", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count\n     (reciprocal_poly p (map_poly complex_of_real P) \\<circ>\\<^sub>p\n      map_poly complex_of_real [:1, 1:])\n     {x. 0 < Re x}", "apply (subst proots_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. reciprocal_poly p (map_poly complex_of_real P) \\<noteq> 0\n 2. degree (map_poly complex_of_real [:1, 1:]) = 1\n 3. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (reciprocal_poly p (map_poly complex_of_real P))\n     (poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x})", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (3 subgoals):\n 1. reciprocal_poly p (map_poly complex_of_real P) \\<noteq> 0\n 2. degree (map_poly complex_of_real [:1, 1:]) = 1\n 3. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (reciprocal_poly p (map_poly complex_of_real P))\n     (poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x})", "apply (auto simp: reciprocal_0_iff degree_map_poly)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (reciprocal_poly p (map_poly complex_of_real P))\n     (poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x})", "apply (subst proots_count_reciprocal)"], ["proof (prove)\ngoal (4 subgoals):\n 1. degree (map_poly complex_of_real P) \\<le> p\n 2. map_poly complex_of_real P \\<noteq> 0\n 3. 0 \\<notin> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}\n 4. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (map_poly complex_of_real P)\n     {x. inverse x\n         \\<in> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}}", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (4 subgoals):\n 1. degree (map_poly complex_of_real P) \\<le> p\n 2. map_poly complex_of_real P \\<noteq> 0\n 3. 0 \\<notin> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}\n 4. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (map_poly complex_of_real P)\n     {x. inverse x\n         \\<in> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}}", "apply (auto simp: degree_map_poly inverse_eq_divide)[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<notin> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}\n 2. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (map_poly complex_of_real P)\n     {x. inverse x\n         \\<in> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}}", "using hx"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 + ?x = 0; 0 < Re ?x\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. 0 \\<notin> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}\n 2. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (map_poly complex_of_real P)\n     {x. inverse x\n         \\<in> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}}", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. 0 < Re x}} =\n    proots_count (map_poly complex_of_real P)\n     {x. inverse x\n         \\<in> poly (map_poly complex_of_real [:1, 1:]) ` {x. 0 < Re x}}", "by (auto simp: inverse_eq_divide algebra_simps)"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real P) circle_01_diam =\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x}\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence 3:\"proots_count (map_poly of_real ?Q) {x. 0 < Re x} = 0\""], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P) circle_01_diam =\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x}\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} =\n    0", "using assms(3)"], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P) circle_01_diam =\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x}\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} =\n    0", "by presburger"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} =\n  0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence \"\\<And>x::complex.\n         poly (map_poly of_real (smult (inverse (lead_coeff ?Q)) ?Q)) x = 0 \\<Longrightarrow>\n         Re x \\<le> 0\""], ["proof (prove)\nusing this:\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n        x =\n       0 \\<Longrightarrow>\n       Re x \\<le> 0", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        ?P1 x\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0\n 2. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> ?P1 x\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "fix x::complex"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        ?P1 x\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0\n 2. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> ?P1 x\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "show \"Re x \\<le> 0 \\<Longrightarrow> Re x \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x \\<le> 0 \\<Longrightarrow> Re x \\<le> 0", "by fast"], ["proof (state)\nthis:\n  Re x \\<le> 0 \\<Longrightarrow> Re x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "assume \"\\<not>Re x \\<le> 0\""], ["proof (state)\nthis:\n  \\<not> Re x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "hence h:\"0 < Re x\""], ["proof (prove)\nusing this:\n  \\<not> Re x \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < Re x", "by simp"], ["proof (state)\nthis:\n  0 < Re x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "assume \"poly (map_poly of_real (smult (inverse (lead_coeff ?Q)) ?Q)) x = 0\""], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n   x =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "hence h2:\"poly (map_poly of_real ?Q) x = 0\""], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n   x =\n  0\n\ngoal (1 subgoal):\n 1. poly\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     x =\n    0", "by fastforce"], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   x =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "hence \"order x (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) > 0\""], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   x =\n  0\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))", "using assms"], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   x =\n  0\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))", "by (fastforce simp: order_root pcompose_eq_0 reciprocal_0_iff)"], ["proof (state)\nthis:\n  0 < order x\n       (map_poly complex_of_real\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "hence \"proots_count (map_poly of_real ?Q) {x. 0 < Re x} \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < order x\n       (map_poly complex_of_real\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "have h3: \"finite {x. poly (map_poly complex_of_real \n                (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. poly\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n          x =\n         0}", "apply (rule poly_roots_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real\n     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) \\<noteq>\n    0", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real\n     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) \\<noteq>\n    0", "by (fastforce simp: order_root pcompose_eq_0 reciprocal_0_iff)"], ["proof (state)\nthis:\n  finite\n   {x. poly\n        (map_poly complex_of_real\n          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n        x =\n       0}\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "have \"0 < order x (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))", "using h2 assms"], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   x =\n  0\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))", "by (fastforce simp: order_root pcompose_eq_0 reciprocal_0_iff)"], ["proof (state)\nthis:\n  0 < order x\n       (map_poly complex_of_real\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "also"], ["proof (state)\nthis:\n  0 < order x\n       (map_poly complex_of_real\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "have \"... \\<le> (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                  poly (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) x =\n                  0}.\n           order r (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n    \\<le> (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                           poly\n                            (map_poly complex_of_real\n                              (reciprocal_poly p P \\<circ>\\<^sub>p\n                               [:1, 1:]))\n                            x =\n                           0}.\n             order r\n              (map_poly complex_of_real\n                (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))", "apply (rule member_le_sum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> {x. 0 < Re x \\<and>\n                poly\n                 (map_poly complex_of_real\n                   (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                 x =\n                0}\n 2. \\<And>xa.\n       xa \\<in> {x. 0 < Re x \\<and>\n                    poly\n                     (map_poly complex_of_real\n                       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                     x =\n                    0} -\n                {x} \\<Longrightarrow>\n       0 \\<le> order xa\n                (map_poly complex_of_real\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n 3. finite\n     {x. 0 < Re x \\<and>\n         poly\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n          x =\n         0}", "using h h2 h3"], ["proof (prove)\nusing this:\n  0 < Re x\n  poly\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   x =\n  0\n  finite\n   {x. poly\n        (map_poly complex_of_real\n          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n        x =\n       0}\n\ngoal (3 subgoals):\n 1. x \\<in> {x. 0 < Re x \\<and>\n                poly\n                 (map_poly complex_of_real\n                   (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                 x =\n                0}\n 2. \\<And>xa.\n       xa \\<in> {x. 0 < Re x \\<and>\n                    poly\n                     (map_poly complex_of_real\n                       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                     x =\n                    0} -\n                {x} \\<Longrightarrow>\n       0 \\<le> order xa\n                (map_poly complex_of_real\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n 3. finite\n     {x. 0 < Re x \\<and>\n         poly\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n          x =\n         0}", "by auto"], ["proof (state)\nthis:\n  order x\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n  \\<le> (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                         poly\n                          (map_poly complex_of_real\n                            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                          x =\n                         0}.\n           order r\n            (map_poly complex_of_real\n              (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "finally"], ["proof (chain)\npicking this:\n  0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                       poly\n                        (map_poly complex_of_real\n                          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                        x =\n                       0}.\n         order r\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))", "have \n        \"0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n         poly (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) x = 0}.\n         order r (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\""], ["proof (prove)\nusing this:\n  0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                       poly\n                        (map_poly complex_of_real\n                          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                        x =\n                       0}.\n         order r\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                         poly\n                          (map_poly complex_of_real\n                            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                          x =\n                         0}.\n           order r\n            (map_poly complex_of_real\n              (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))", "."], ["proof (state)\nthis:\n  0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                       poly\n                        (map_poly complex_of_real\n                          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                        x =\n                       0}.\n         order r\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "thus \n        \"0 < order x (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n         proots_count (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} \\<noteq> 0 \""], ["proof (prove)\nusing this:\n  0 < (\\<Sum>r\\<in>{x. 0 < Re x \\<and>\n                       poly\n                        (map_poly complex_of_real\n                          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                        x =\n                       0}.\n         order r\n          (map_poly complex_of_real\n            (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. 0 < order x\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n     {x. 0 < Re x} \\<noteq>\n    0", "by (auto simp: proots_count_def proots_within_def)"], ["proof (state)\nthis:\n  0 < order x\n       (map_poly complex_of_real\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) \\<Longrightarrow>\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} \\<noteq>\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly\n                 (map_poly complex_of_real\n                   (smult\n                     (inverse\n                       (lead_coeff\n                         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                     (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                 x =\n                0;\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n         {x. 0 < Re x} =\n        0;\n        \\<not> Re x \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> Re x \\<le> 0", "thus \"Re x \\<le> 0\""], ["proof (prove)\nusing this:\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. Re x \\<le> 0", "using 3"], ["proof (prove)\nusing this:\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} \\<noteq>\n  0\n  proots_count\n   (map_poly complex_of_real (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n   {x. 0 < Re x} =\n  0\n\ngoal (1 subgoal):\n 1. Re x \\<le> 0", "by blast"], ["proof (state)\nthis:\n  Re x \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n   ?x =\n  0 \\<Longrightarrow>\n  Re ?x \\<le> 0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence \"\\<And>i. coeff (smult (inverse (lead_coeff ?Q)) ?Q) i \\<ge> 0\""], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n   ?x =\n  0 \\<Longrightarrow>\n  Re ?x \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       0 \\<le> coeff\n                (smult\n                  (inverse\n                    (lead_coeff\n                      (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                i", "apply (frule descartes_sign_zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       monic\n        (smult\n          (inverse\n            (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n 2. \\<And>i.\n       0 \\<le> coeff\n                (smult\n                  (inverse\n                    (lead_coeff\n                      (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                (?i i) \\<Longrightarrow>\n       0 \\<le> coeff\n                (smult\n                  (inverse\n                    (lead_coeff\n                      (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                i", "using assms"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n  P \\<noteq> 0\n  proots_count (map_poly complex_of_real P) circle_01_diam = 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       monic\n        (smult\n          (inverse\n            (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n          (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n 2. \\<And>i.\n       0 \\<le> coeff\n                (smult\n                  (inverse\n                    (lead_coeff\n                      (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                (?i i) \\<Longrightarrow>\n       0 \\<le> coeff\n                (smult\n                  (inverse\n                    (lead_coeff\n                      (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                  (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n                i", "by (fastforce simp: pcompose_eq_0 reciprocal_0_iff)"], ["proof (state)\nthis:\n  0 \\<le> coeff\n           (smult\n             (inverse\n               (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n             (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n           ?i\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence \"changes (coeffs (smult (inverse (lead_coeff ?Q)) ?Q)) = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> coeff\n           (smult\n             (inverse\n               (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n             (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))\n           ?i\n\ngoal (1 subgoal):\n 1. changes\n     (coeffs\n       (smult\n         (inverse\n           (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n    0", "by (subst changes_all_nonneg, auto simp: nth_default_coeffs_eq)"], ["proof (state)\nthis:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "hence \"changes (coeffs ?Q) = 0\""], ["proof (prove)\nusing this:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 0", "using hQ"], ["proof (prove)\nusing this:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  0\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 0", "by (auto simp: coeffs_smult changes_scale_const)"], ["proof (state)\nthis:\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 0\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 0", "apply (subst Bernstein_changes_01_eq_changes[\"OF\" hP])"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n    0 \\<Longrightarrow>\n    changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 0", "by blast"], ["proof (state)\nthis:\n  Bernstein_changes_01 p P = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition circle_diam :: \"real \\<Rightarrow> real \\<Rightarrow> complex set\" where\n\"circle_diam l r = {x. cmod ((x - l) - (r - l)/2) < (r - l)/2}\""], ["", "lemma circle_diam_rescale: assumes \"l < r\"\n  shows \"circle_diam l r = (\\<lambda> x . (x*(r - l) + l)) ` circle_01_diam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_diam l r =\n    (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    circle_01_diam", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. circle_diam l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                circle_01_diam\n 2. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    circle_01_diam\n    \\<subseteq> circle_diam l r", "show \"circle_diam l r \\<subseteq> (\\<lambda>x. x * (complex_of_real r - complex_of_real l) +\n        complex_of_real l) ` circle_01_diam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_diam l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                circle_01_diam", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "assume \"x \\<in> circle_diam l r\""], ["proof (state)\nthis:\n  x \\<in> circle_diam l r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "hence \"cmod ((x - l) - (r - l)/2) < (r - l)/2\""], ["proof (prove)\nusing this:\n  x \\<in> circle_diam l r\n\ngoal (1 subgoal):\n 1. cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "by (auto simp: circle_diam_def)"], ["proof (state)\nthis:\n  cmod (x - complex_of_real l - complex_of_real ((r - l) / 2)) < (r - l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "hence \"cmod ((r - l) * ((x - l)/(r - l) - 1/2)) < (r - l)/2\""], ["proof (prove)\nusing this:\n  cmod (x - complex_of_real l - complex_of_real ((r - l) / 2)) < (r - l) / 2\n\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2", "using assms"], ["proof (prove)\nusing this:\n  cmod (x - complex_of_real l - complex_of_real ((r - l) / 2)) < (r - l) / 2\n  l < r\n\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2", "by (subst right_diff_distrib, fastforce)"], ["proof (state)\nthis:\n  cmod\n   (complex_of_real (r - l) *\n    ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n  < (r - l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "hence \"(r - l) * cmod ((x - l)/(r - l) - 1/2) < (r - l) * 1/2\""], ["proof (prove)\nusing this:\n  cmod\n   (complex_of_real (r - l) *\n    ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n  < (r - l) / 2\n\ngoal (1 subgoal):\n 1. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2", "apply (subst(2) abs_of_pos[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    0 < r - l\n 2. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    0 < r - l", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    0 < r - l", "by argo"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2", "apply (subst norm_scaleR[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (r - l) *\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) / 2 \\<Longrightarrow>\n    cmod\n     ((r - l) *\\<^sub>R\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) * 1 / 2", "by (simp add: scaleR_conv_of_real)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (r - l) * cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n  < (r - l) * 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "hence \"cmod ((x - l)/(r - l) - 1/2) < 1/2\""], ["proof (prove)\nusing this:\n  (r - l) * cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n  < (r - l) * 1 / 2\n\ngoal (1 subgoal):\n 1. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2", "apply (subst mult_less_cancel_left_pos[of \"r-l\",symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2 \\<Longrightarrow>\n    0 < r - l\n 2. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2 \\<Longrightarrow>\n    (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2)", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2 \\<Longrightarrow>\n    0 < r - l\n 2. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * 1 / 2 \\<Longrightarrow>\n    (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2)", "by auto"], ["proof (state)\nthis:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "hence\n      \"cmod ((x-l)/(r-l) - 1 / 2) * 2 < 1 \\<and>\n       x = (x-l)/(r-l) * (complex_of_real r - complex_of_real l) + complex_of_real l\""], ["proof (prove)\nusing this:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) * 2\n    < 1 \\<and>\n    x =\n    (x - complex_of_real l) / complex_of_real (r - l) *\n    (complex_of_real r - complex_of_real l) +\n    complex_of_real l", "by force"], ["proof (state)\nthis:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) * 2\n  < 1 \\<and>\n  x =\n  (x - complex_of_real l) / complex_of_real (r - l) *\n  (complex_of_real r - complex_of_real l) +\n  complex_of_real l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> circle_diam l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam", "thus \"x \\<in> (\\<lambda>x. x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n          circle_01_diam\""], ["proof (prove)\nusing this:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) * 2\n  < 1 \\<and>\n  x =\n  (x - complex_of_real l) / complex_of_real (r - l) *\n  (complex_of_real r - complex_of_real l) +\n  complex_of_real l\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x.\n                x * (complex_of_real r - complex_of_real l) +\n                complex_of_real l) `\n            circle_01_diam", "by (force simp: circle_01_diam_def)"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x.\n              x * (complex_of_real r - complex_of_real l) +\n              complex_of_real l) `\n          circle_01_diam\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  circle_diam l r\n  \\<subseteq> (\\<lambda>x.\n                  x * (complex_of_real r - complex_of_real l) +\n                  complex_of_real l) `\n              circle_01_diam\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    circle_01_diam\n    \\<subseteq> circle_diam l r", "show \"(\\<lambda>x. x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n        circle_01_diam \\<subseteq> circle_diam l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    circle_01_diam\n    \\<subseteq> circle_diam l r", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "fix x::complex"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "assume\n      \"x \\<in> (\\<lambda>x. x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n       circle_01_diam\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x.\n              x * (complex_of_real r - complex_of_real l) +\n              complex_of_real l) `\n          circle_01_diam\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>x.\n              x * (complex_of_real r - complex_of_real l) +\n              complex_of_real l) `\n          circle_01_diam", "obtain y::complex where \"x = y * (r - l) + l\" \"cmod (y - 1/2) < 1/2\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x.\n              x * (complex_of_real r - complex_of_real l) +\n              complex_of_real l) `\n          circle_01_diam\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x = y * complex_of_real (r - l) + complex_of_real l;\n         cmod (y - 1 / 2) < 1 / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: circle_01_diam_def)"], ["proof (state)\nthis:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "moreover"], ["proof (state)\nthis:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "hence \"y = (x - l) / (r - l)\""], ["proof (prove)\nusing this:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. y = (x - complex_of_real l) / complex_of_real (r - l)", "using assms"], ["proof (prove)\nusing this:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n  l < r\n\ngoal (1 subgoal):\n 1. y = (x - complex_of_real l) / complex_of_real (r - l)", "by force"], ["proof (state)\nthis:\n  y = (x - complex_of_real l) / complex_of_real (r - l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "ultimately"], ["proof (chain)\npicking this:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n  y = (x - complex_of_real l) / complex_of_real (r - l)", "have \"cmod ((x - l) / (r - l) - 1/2) < 1/2\""], ["proof (prove)\nusing this:\n  x = y * complex_of_real (r - l) + complex_of_real l\n  cmod (y - 1 / 2) < 1 / 2\n  y = (x - complex_of_real l) / complex_of_real (r - l)\n\ngoal (1 subgoal):\n 1. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2", "by presburger"], ["proof (state)\nthis:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "hence \"(r - l) * (cmod ((x - l) / (r - l) - 1/2)) < (r - l) * (1/2)\""], ["proof (prove)\nusing this:\n  cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2\n\ngoal (1 subgoal):\n 1. (r - l) *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2)", "apply (subst mult_less_cancel_left_pos)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < 1 / 2 \\<Longrightarrow>\n    0 < r - l\n 2. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < 1 / 2 \\<Longrightarrow>\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < 1 / 2 \\<Longrightarrow>\n    0 < r - l\n 2. cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < 1 / 2 \\<Longrightarrow>\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2) < 1 / 2", "by auto"], ["proof (state)\nthis:\n  (r - l) * cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n  < (r - l) * (1 / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "hence \"cmod ((x - l) - (r - l)/2) < (r - l)/2\""], ["proof (prove)\nusing this:\n  (r - l) * cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n  < (r - l) * (1 / 2)\n\ngoal (1 subgoal):\n 1. cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "apply (subst(asm) (2) abs_of_pos[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < r - l\n 2. \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2) \\<Longrightarrow>\n    cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. 0 < r - l\n 2. \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2) \\<Longrightarrow>\n    cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "apply argo"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>r - l\\<bar> *\n    cmod ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2)\n    < (r - l) * (1 / 2) \\<Longrightarrow>\n    cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "apply (subst(asm) norm_scaleR[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((r - l) *\\<^sub>R\n      ((x - complex_of_real l) / complex_of_real (r - l) - 1 / 2))\n    < (r - l) * (1 / 2) \\<Longrightarrow>\n    cmod (x - complex_of_real l - complex_of_real ((r - l) / 2))\n    < (r - l) / 2", "by (smt (verit, del_insts)\n          \\<open>x = y * complex_of_real (r - l) + complex_of_real l\\<close>\n          \\<open>y = (x - complex_of_real l) / complex_of_real (r - l)\\<close>\n          add_diff_cancel divide_divide_eq_right divide_numeral_1 mult.commute\n          of_real_1 of_real_add of_real_divide one_add_one scaleR_conv_of_real\n          scale_right_diff_distrib times_divide_eq_right)"], ["proof (state)\nthis:\n  cmod (x - complex_of_real l - complex_of_real ((r - l) / 2)) < (r - l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               circle_01_diam \\<Longrightarrow>\n       x \\<in> circle_diam l r", "thus \"x \\<in> circle_diam l r\""], ["proof (prove)\nusing this:\n  cmod (x - complex_of_real l - complex_of_real ((r - l) / 2)) < (r - l) / 2\n\ngoal (1 subgoal):\n 1. x \\<in> circle_diam l r", "by (force simp: circle_diam_def)"], ["proof (state)\nthis:\n  x \\<in> circle_diam l r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n  circle_01_diam\n  \\<subseteq> circle_diam l r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_circle: fixes P::\"real poly\" assumes \"l < r\"\n  and \"proots_count (map_poly of_real P) (circle_diam l r) = 0\"\n  and \"P \\<noteq> 0\"\n  and \"degree P \\<le> p\"\nshows \"Bernstein_changes p l r P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 0", "proof (subst Bernstein_changes_eq_rescale)"], ["proof (state)\ngoal (3 subgoals):\n 1. l \\<noteq> r\n 2. degree P \\<le> p\n 3. Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n    0", "show \"l \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> r", "using assms(1)"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (1 subgoal):\n 1. l \\<noteq> r", "by force"], ["proof (state)\nthis:\n  l \\<noteq> r\n\ngoal (2 subgoals):\n 1. degree P \\<le> p\n 2. Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n    0", "show \"degree P \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree P \\<le> p", "using assms(4)"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. degree P \\<le> p", "by blast"], ["proof (state)\nthis:\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n    0", "show \"Bernstein_changes_01 p (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n    0", "proof (rule one_circle_01)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p\n 2. P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 3. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "show \"degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p", "using assms(4)"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p", "by (force simp: degree_pcompose)"], ["proof (state)\nthis:\n  degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p\n\ngoal (2 subgoals):\n 1. P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "show \"P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  l < r\n  proots_count (map_poly complex_of_real P) (circle_diam l r) = 0\n  P \\<noteq> 0\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0", "by (smt (z3) degree_0_iff gr_zeroI pCons_eq_0_iff pCons_eq_iff\n                      pcompose_eq_0)"], ["proof (state)\nthis:\n  P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "have \"proots_count (map_poly of_real P) (circle_diam l r) = \n          proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n          circle_01_diam\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam", "apply (subst of_real_hom.map_poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count\n     (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]) \\<circ>\\<^sub>p\n      map_poly complex_of_real [:0, r - l:])\n     circle_01_diam", "apply (subst proots_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]) \\<noteq> 0\n 2. degree (map_poly complex_of_real [:0, r - l:]) = 1\n 3. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]))\n     (poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (metis assms(3) degree_eq_zeroE of_real_poly_eq_0_iff\n          pCons_eq_iff pCons_one pcompose_eq_0 zero_neq_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (map_poly complex_of_real [:0, r - l:]) = 1\n 2. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]))\n     (poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "using assms(1)"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. degree (map_poly complex_of_real [:0, r - l:]) = 1\n 2. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]))\n     (poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:]))\n     (poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (subst of_real_hom.map_poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count\n     (map_poly complex_of_real P \\<circ>\\<^sub>p\n      map_poly complex_of_real [:l, 1:])\n     (poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (subst proots_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_poly complex_of_real P \\<noteq> 0\n 2. degree (map_poly complex_of_real [:l, 1:]) = 1\n 3. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real P)\n     (poly (map_poly complex_of_real [:l, 1:]) `\n      poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (auto simp: assms(3))[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    proots_count (map_poly complex_of_real P)\n     (poly (map_poly complex_of_real [:l, 1:]) `\n      poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (subst circle_diam_rescale[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     ((\\<lambda>x.\n          x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n      circle_01_diam) =\n    proots_count (map_poly complex_of_real P)\n     (poly (map_poly complex_of_real [:l, 1:]) `\n      poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam)", "apply (rule arg_cong[of _ _ \"proots_count (map_poly complex_of_real P)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    circle_01_diam =\n    poly (map_poly complex_of_real [:l, 1:]) `\n    poly (map_poly complex_of_real [:0, r - l:]) ` circle_01_diam", "by fastforce"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real P) (circle_diam l r) =\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   circle_01_diam\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "thus \"proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n          circle_01_diam = 0\""], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P) (circle_diam l r) =\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   circle_01_diam\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "using assms(2)"], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P) (circle_diam l r) =\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   circle_01_diam\n  proots_count (map_poly complex_of_real P) (circle_diam l r) = 0\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     circle_01_diam =\n    0", "by presburger"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   circle_01_diam =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Bernstein_changes_01 p\n   (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>One sign change case\\<close>"], ["", "definition upper_circle_01 :: \"complex set\" where\n\"upper_circle_01 = {x. cmod (x - (1/2 + sqrt(3)/6 * \\<i>)) < sqrt 3 / 3}\""], ["", "lemma upper_circle_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} = upper_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n    upper_circle_01", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n    \\<subseteq> upper_circle_01\n 2. upper_circle_01\n    \\<subseteq> {x. 1 / x\n                    \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "show \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} \\<subseteq> upper_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n    \\<subseteq> upper_circle_01", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "assume \"x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\""], ["proof (state)\nthis:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "obtain y where \"1 / x = y + 1\" and h: \"Im y < sqrt 3 * Re y\""], ["proof (prove)\nusing this:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>1 / x = y + 1; Im y < sqrt 3 * Re y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  1 / x = y + 1\n  Im y < sqrt 3 * Re y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence hy: \"y = 1/x - 1\""], ["proof (prove)\nusing this:\n  1 / x = y + 1\n  Im y < sqrt 3 * Re y\n\ngoal (1 subgoal):\n 1. y = 1 / x - 1", "by simp"], ["proof (state)\nthis:\n  y = 1 / x - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence hx: \"x = 1/(y+1)\""], ["proof (prove)\nusing this:\n  y = 1 / x - 1\n\ngoal (1 subgoal):\n 1. x = 1 / (y + 1)", "by auto"], ["proof (state)\nthis:\n  x = 1 / (y + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "from h"], ["proof (chain)\npicking this:\n  Im y < sqrt 3 * Re y", "have hy1: \"y \\<noteq> -1\""], ["proof (prove)\nusing this:\n  Im y < sqrt 3 * Re y\n\ngoal (1 subgoal):\n 1. y \\<noteq> - 1", "by fastforce"], ["proof (state)\nthis:\n  y \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence hx0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using hy"], ["proof (prove)\nusing this:\n  y \\<noteq> - 1\n  y = 1 / x - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "from h"], ["proof (chain)\npicking this:\n  Im y < sqrt 3 * Re y", "have \"0 < Re ((\\<i> + sqrt 3) * y)\""], ["proof (prove)\nusing this:\n  Im y < sqrt 3 * Re y\n\ngoal (1 subgoal):\n 1. 0 < Re ((\\<i> + complex_of_real (sqrt 3)) * y)", "by fastforce"], ["proof (state)\nthis:\n  0 < Re ((\\<i> + complex_of_real (sqrt 3)) * y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence \"cmod ((\\<i> + sqrt 3) * y - 1) < cmod ((\\<i> + sqrt 3) * y + 1)\""], ["proof (prove)\nusing this:\n  0 < Re ((\\<i> + complex_of_real (sqrt 3)) * y)\n\ngoal (1 subgoal):\n 1. cmod ((\\<i> + complex_of_real (sqrt 3)) * y - 1)\n    < cmod ((\\<i> + complex_of_real (sqrt 3)) * y + 1)", "by (auto simp: cmod_def power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  cmod ((\\<i> + complex_of_real (sqrt 3)) * y - 1)\n  < cmod ((\\<i> + complex_of_real (sqrt 3)) * y + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence 1: \"cmod (((\\<i> + sqrt 3) * y - 1)/((\\<i> + sqrt 3) * y + 1)) < 1\""], ["proof (prove)\nusing this:\n  cmod ((\\<i> + complex_of_real (sqrt 3)) * y - 1)\n  < cmod ((\\<i> + complex_of_real (sqrt 3)) * y + 1)\n\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y + 1))\n    < 1", "by (auto simp: norm_divide divide_simps)"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y + 1))\n  < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "also"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y + 1))\n  < 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "have \"cmod (((\\<i> + sqrt 3) * y - 1)/((\\<i> + sqrt 3) * y + 1)) =\n               cmod (((\\<i> + sqrt 3) * y * x - x)/((\\<i> + sqrt 3) * y * x + x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y + 1)) =\n    cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))", "apply (subst mult_divide_mult_cancel_right[symmetric, OF hx0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y - 1) * x /\n      (((\\<i> + complex_of_real (sqrt 3)) * y + 1) * x)) =\n    cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))", "apply (subst ring_distribs(2)[of _ _ x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y - 1) * x /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + 1 * x)) =\n    cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))", "apply (subst left_diff_distrib[of _ _ x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - 1 * x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + 1 * x)) =\n    cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))", "by simp"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y + 1)) =\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "also"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y - 1) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y + 1)) =\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y * x + x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "have \"... = cmod\n       (((-1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>)) /\n       (( 1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n      ((\\<i> + complex_of_real (sqrt 3)) * y * x + x)) =\n    cmod\n     (((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>)) /\n      ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>)))", "by (auto simp: hy algebra_simps hx0)"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y * x + x)) =\n  cmod\n   (((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>)) /\n    ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "also"], ["proof (state)\nthis:\n  cmod\n   (((\\<i> + complex_of_real (sqrt 3)) * y * x - x) /\n    ((\\<i> + complex_of_real (sqrt 3)) * y * x + x)) =\n  cmod\n   (((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>)) /\n    ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "have \n      \"... = cmod ((-1 - complex_of_real (sqrt 3) - \\<i>) * x +\n                   (complex_of_real (sqrt 3) + \\<i>)) /\n             cmod (( 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n                   (complex_of_real (sqrt 3) + \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>)) /\n      ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>))) =\n    cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>)) /\n    cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))", "by (auto simp: norm_divide)"], ["proof (state)\nthis:\n  cmod\n   (((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>)) /\n    ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n     (complex_of_real (sqrt 3) + \\<i>))) =\n  cmod\n   ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>)) /\n  cmod\n   ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "finally"], ["proof (chain)\npicking this:\n  cmod\n   ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>)) /\n  cmod\n   ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>))\n  < 1", "have \n      \"cmod ((-1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>))\n       < cmod ((1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>))\""], ["proof (prove)\nusing this:\n  cmod\n   ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>)) /\n  cmod\n   ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>))\n  < 1\n\ngoal (1 subgoal):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>))", "proof (subst divide_less_eq_1_pos[symmetric], subst zero_less_norm_iff)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>cmod\n              ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n               (complex_of_real (sqrt 3) + \\<i>)) /\n             cmod\n              ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n               (complex_of_real (sqrt 3) + \\<i>))\n             < 1;\n     cmod\n      ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>)) /\n     cmod\n      ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n       (complex_of_real (sqrt 3) + \\<i>))\n     < 1\\<rbrakk>\n    \\<Longrightarrow> (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n                      (complex_of_real (sqrt 3) + \\<i>) \\<noteq>\n                      0\n 2. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>)) /\n    cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < 1 \\<Longrightarrow>\n    cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>)) /\n    cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < 1", "show \"(1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) \\<noteq>\n    0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) =\n    0 \\<Longrightarrow>\n    False", "have \"-\\<i> + 1 \\<noteq> complex_of_real (sqrt 3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> + 1 \\<noteq> complex_of_real (sqrt 3)", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  - \\<i> + 1 \\<noteq> complex_of_real (sqrt 3)\n\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) =\n    0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  - \\<i> + 1 \\<noteq> complex_of_real (sqrt 3)\n\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) =\n    0 \\<Longrightarrow>\n    False", "assume\n          \"(1 - complex_of_real (sqrt 3) - \\<i>) * x + (complex_of_real (sqrt 3) + \\<i>) = 0\""], ["proof (state)\nthis:\n  (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n  (complex_of_real (sqrt 3) + \\<i>) =\n  0\n\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) =\n    0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  - \\<i> + 1 \\<noteq> complex_of_real (sqrt 3)\n  (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n  (complex_of_real (sqrt 3) + \\<i>) =\n  0", "have\n          \"x = (-complex_of_real (sqrt 3) - \\<i>)/(1 - complex_of_real (sqrt 3) - \\<i>)\""], ["proof (prove)\nusing this:\n  - \\<i> + 1 \\<noteq> complex_of_real (sqrt 3)\n  (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n  (complex_of_real (sqrt 3) + \\<i>) =\n  0\n\ngoal (1 subgoal):\n 1. x =\n    (- complex_of_real (sqrt 3) - \\<i>) /\n    (1 - complex_of_real (sqrt 3) - \\<i>)", "by (auto simp: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  x =\n  (- complex_of_real (sqrt 3) - \\<i>) /\n  (1 - complex_of_real (sqrt 3) - \\<i>)\n\ngoal (1 subgoal):\n 1. (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>) =\n    0 \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  x =\n  (- complex_of_real (sqrt 3) - \\<i>) /\n  (1 - complex_of_real (sqrt 3) - \\<i>)\n\ngoal (1 subgoal):\n 1. False", "using h"], ["proof (prove)\nusing this:\n  x =\n  (- complex_of_real (sqrt 3) - \\<i>) /\n  (1 - complex_of_real (sqrt 3) - \\<i>)\n  Im y < sqrt 3 * Re y\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: hy field_simps Im_divide Re_divide)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - complex_of_real (sqrt 3) - \\<i>) * x +\n  (complex_of_real (sqrt 3) + \\<i>) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>)) /\n    cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < 1 \\<Longrightarrow>\n    cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>)) /\n    cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < 1", "qed"], ["proof (state)\nthis:\n  cmod\n   ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>))\n  < cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "hence \"cmod (x - (1/2 + sqrt(3)/6 * \\<i>)) < sqrt 3 / 3\""], ["proof (prove)\nusing this:\n  cmod\n   ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n    (complex_of_real (sqrt 3) + \\<i>))\n  < cmod\n     ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n\ngoal (1 subgoal):\n 1. cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3", "apply (subst(3) abs_of_pos[symmetric, of 3])"], ["proof (prove)\ngoal (2 subgoals):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    0 < 3\n 2. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>))\n    < sqrt 3 / \\<bar>3\\<bar>", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>))\n    < sqrt 3 / \\<bar>3\\<bar>", "apply (subst real_sqrt_abs2[symmetric], subst real_sqrt_divide[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>))\n    < sqrt (3 / (3 * 3))", "apply (subst cmod_def, subst real_sqrt_less_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    (Re (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)))\\<^sup>2 +\n    (Im (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)))\\<^sup>2\n    < 3 / (3 * 3)", "apply (rule mult_right_less_imp_less[of _ \"sqrt 3 /3\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    ((Re (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)))\\<^sup>2 +\n     (Im (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)))\\<^sup>2) *\n    (sqrt 3 / 3)\n    < 3 / (3 * 3) * (sqrt 3 / 3)\n 2. cmod\n     ((- 1 - complex_of_real (sqrt 3) - \\<i>) * x +\n      (complex_of_real (sqrt 3) + \\<i>))\n    < cmod\n       ((1 - complex_of_real (sqrt 3) - \\<i>) * x +\n        (complex_of_real (sqrt 3) + \\<i>)) \\<Longrightarrow>\n    0 \\<le> sqrt 3 / 3", "by (auto simp: cmod_def power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) `\n                         {x. Im x < sqrt 3 * Re x}} \\<Longrightarrow>\n       x \\<in> upper_circle_01", "thus \"x \\<in> upper_circle_01\""], ["proof (prove)\nusing this:\n  cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3\n\ngoal (1 subgoal):\n 1. x \\<in> upper_circle_01", "by (auto simp: upper_circle_01_def)"], ["proof (state)\nthis:\n  x \\<in> upper_circle_01\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n  \\<subseteq> upper_circle_01\n\ngoal (1 subgoal):\n 1. upper_circle_01\n    \\<subseteq> {x. 1 / x\n                    \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "show \"upper_circle_01 \\<subseteq> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_circle_01\n    \\<subseteq> {x. 1 / x\n                    \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "assume \"x \\<in> upper_circle_01\""], ["proof (state)\nthis:\n  x \\<in> upper_circle_01\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence \"cmod (x - (1/2 + sqrt(3)/6 * \\<i>)) < sqrt 3 / 3\""], ["proof (prove)\nusing this:\n  x \\<in> upper_circle_01\n\ngoal (1 subgoal):\n 1. cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3", "by (force simp: upper_circle_01_def)"], ["proof (state)\nthis:\n  cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence \"sqrt ((Re x - 1/2)^2 + (Im x - sqrt(3)/6)^2) < sqrt (1/3)\""], ["proof (prove)\nusing this:\n  cmod (x - (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)) < sqrt 3 / 3\n\ngoal (1 subgoal):\n 1. sqrt ((Re x - 1 / 2)\\<^sup>2 + (Im x - sqrt 3 / 6)\\<^sup>2)\n    < sqrt (1 / 3)", "by (auto simp: cmod_def sqrt_divide_self_eq real_sqrt_inverse[symmetric])"], ["proof (state)\nthis:\n  sqrt ((Re x - 1 / 2)\\<^sup>2 + (Im x - sqrt 3 / 6)\\<^sup>2) < sqrt (1 / 3)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence 1: \"- Im x * sqrt 3 + (Im x * (Im x * 3) + Re x * (Re x * 3)) < Re x * 3\""], ["proof (prove)\nusing this:\n  sqrt ((Re x - 1 / 2)\\<^sup>2 + (Im x - sqrt 3 / 6)\\<^sup>2) < sqrt (1 / 3)\n\ngoal (1 subgoal):\n 1. - Im x * sqrt 3 + (Im x * (Im x * 3) + Re x * (Re x * 3)) < Re x * 3", "by (auto simp: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  - Im x * sqrt 3 + (Im x * (Im x * 3) + Re x * (Re x * 3)) < Re x * 3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have 2: \"- Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) < Re x * sqrt 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3))\n    < Re x * sqrt 3", "apply (rule mult_right_less_imp_less[of _ \"sqrt 3\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (- Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3))) * sqrt 3\n    < Re x * sqrt 3 * sqrt 3\n 2. 0 \\<le> sqrt 3", "apply (subst mult.assoc[of _ \"sqrt 3\"], subst real_sqrt_mult_self)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (- Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3))) * sqrt 3\n    < Re x * \\<bar>3\\<bar>\n 2. 0 \\<le> sqrt 3", "using 1"], ["proof (prove)\nusing this:\n  - Im x * sqrt 3 + (Im x * (Im x * 3) + Re x * (Re x * 3)) < Re x * 3\n\ngoal (2 subgoals):\n 1. (- Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3))) * sqrt 3\n    < Re x * \\<bar>3\\<bar>\n 2. 0 \\<le> sqrt 3", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) < Re x * sqrt 3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"sqrt 3 + (-Im x) / (Im x * Im x + Re x * Re x) <\n          Re x * sqrt 3 / (Im x * Im x + Re x * Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)\n    < Re x * sqrt 3 / (Im x * Im x + Re x * Re x)", "apply (rule mult_right_less_imp_less[of _ \"(Im x * Im x + Re x * Re x)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)) *\n    (Im x * Im x + Re x * Re x)\n    < Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n      (Im x * Im x + Re x * Re x)\n 2. 0 \\<le> Im x * Im x + Re x * Re x", "apply (rule subst, rule arg_cong2[of _ _ _ _ \"(<)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?a6 =\n    (sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)) *\n    (Im x * Im x + Re x * Re x)\n 2. ?c6 =\n    Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n    (Im x * Im x + Re x * Re x)\n 3. ?a6 < ?c6\n 4. 0 \\<le> Im x * Im x + Re x * Re x", "prefer 3"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?a6 < ?c6\n 2. ?a6 =\n    (sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)) *\n    (Im x * Im x + Re x * Re x)\n 3. ?c6 =\n    Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n    (Im x * Im x + Re x * Re x)\n 4. 0 \\<le> Im x * Im x + Re x * Re x", "apply (rule 2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) =\n    (sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)) *\n    (Im x * Im x + Re x * Re x)\n 2. Re x * sqrt 3 =\n    Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n    (Im x * Im x + Re x * Re x)\n 3. 0 \\<le> Im x * Im x + Re x * Re x", "apply (subst distrib_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) =\n    sqrt 3 * (Im x * Im x + Re x * Re x) +\n    - Im x / (Im x * Im x + Re x * Re x) * (Im x * Im x + Re x * Re x)\n 2. Re x * sqrt 3 =\n    Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n    (Im x * Im x + Re x * Re x)\n 3. 0 \\<le> Im x * Im x + Re x * Re x", "using 2"], ["proof (prove)\nusing this:\n  - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) < Re x * sqrt 3\n\ngoal (3 subgoals):\n 1. - Im x + (Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3)) =\n    sqrt 3 * (Im x * Im x + Re x * Re x) +\n    - Im x / (Im x * Im x + Re x * Re x) * (Im x * Im x + Re x * Re x)\n 2. Re x * sqrt 3 =\n    Re x * sqrt 3 / (Im x * Im x + Re x * Re x) *\n    (Im x * Im x + Re x * Re x)\n 3. 0 \\<le> Im x * Im x + Re x * Re x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3) - Im x\n             < Re x * sqrt 3;\n     Im x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3) =\n                      sqrt 3 * (Im x * Im x + Re x * Re x)\n 2. \\<lbrakk>Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3) - Im x\n             < Re x * sqrt 3;\n     Re x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Im x * (Im x * sqrt 3) + Re x * (Re x * sqrt 3) =\n                      sqrt 3 * (Im x * Im x + Re x * Re x)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)\n  < Re x * sqrt 3 / (Im x * Im x + Re x * Re x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence \"0 < - Im (1/x-1) + sqrt 3 * Re (1/x-1)\""], ["proof (prove)\nusing this:\n  sqrt 3 + - Im x / (Im x * Im x + Re x * Re x)\n  < Re x * sqrt 3 / (Im x * Im x + Re x * Re x)\n\ngoal (1 subgoal):\n 1. 0 < - Im (1 / x - 1) + sqrt 3 * Re (1 / x - 1)", "by (auto simp: power2_eq_square algebra_simps Re_divide Im_divide)"], ["proof (state)\nthis:\n  0 < - Im (1 / x - 1) + sqrt 3 * Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence \"sqrt 3 * Re (1/x-1) > Im (1/x-1)\""], ["proof (prove)\nusing this:\n  0 < - Im (1 / x - 1) + sqrt 3 * Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. Im (1 / x - 1) < sqrt 3 * Re (1 / x - 1)", "by argo"], ["proof (state)\nthis:\n  Im (1 / x - 1) < sqrt 3 * Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "hence \"(1/x-1) \\<in> {x. sqrt 3 * Re x > Im x}\""], ["proof (prove)\nusing this:\n  Im (1 / x - 1) < sqrt 3 * Re (1 / x - 1)\n\ngoal (1 subgoal):\n 1. 1 / x - 1 \\<in> {x. Im x < sqrt 3 * Re x}", "by fast"], ["proof (state)\nthis:\n  1 / x - 1 \\<in> {x. Im x < sqrt 3 * Re x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "moreover"], ["proof (state)\nthis:\n  1 / x - 1 \\<in> {x. Im x < sqrt 3 * Re x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"1/x = (1/x-1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / x = 1 / x - 1 + 1", "by simp"], ["proof (state)\nthis:\n  1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle_01 \\<Longrightarrow>\n       x \\<in> {x. 1 / x\n                   \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "ultimately"], ["proof (chain)\npicking this:\n  1 / x - 1 \\<in> {x. Im x < sqrt 3 * Re x}\n  1 / x = 1 / x - 1 + 1", "show \"x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\nusing this:\n  1 / x - 1 \\<in> {x. Im x < sqrt 3 * Re x}\n  1 / x = 1 / x - 1 + 1\n\ngoal (1 subgoal):\n 1. x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upper_circle_01\n  \\<subseteq> {x. 1 / x\n                  \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lower_circle_01 :: \"complex set\" where\n\"lower_circle_01 = {x. cmod (x - (1/2 - sqrt(3)/6 * \\<i>)) < sqrt 3 / 3}\""], ["", "lemma cnj_upper_circle_01: \"cnj ` upper_circle_01 = lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj ` upper_circle_01 = lower_circle_01", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cnj ` upper_circle_01 \\<subseteq> lower_circle_01\n 2. lower_circle_01 \\<subseteq> cnj ` upper_circle_01", "show \"cnj ` upper_circle_01 \\<subseteq> lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj ` upper_circle_01 \\<subseteq> lower_circle_01", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cnj ` upper_circle_01 \\<Longrightarrow>\n       x \\<in> lower_circle_01", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cnj ` upper_circle_01 \\<Longrightarrow>\n       x \\<in> lower_circle_01", "assume \"x \\<in> cnj ` upper_circle_01\""], ["proof (state)\nthis:\n  x \\<in> cnj ` upper_circle_01\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cnj ` upper_circle_01 \\<Longrightarrow>\n       x \\<in> lower_circle_01", "then"], ["proof (chain)\npicking this:\n  x \\<in> cnj ` upper_circle_01", "obtain y where \"y \\<in> upper_circle_01\" and \"x = cnj y\""], ["proof (prove)\nusing this:\n  x \\<in> cnj ` upper_circle_01\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> upper_circle_01; x = cnj y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> upper_circle_01\n  x = cnj y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cnj ` upper_circle_01 \\<Longrightarrow>\n       x \\<in> lower_circle_01", "thus \"x \\<in> lower_circle_01\""], ["proof (prove)\nusing this:\n  y \\<in> upper_circle_01\n  x = cnj y\n\ngoal (1 subgoal):\n 1. x \\<in> lower_circle_01", "apply (subst lower_circle_01_def, subst complex_mod_cnj[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> upper_circle_01; x = cnj y; y \\<in> upper_circle_01;\n     x = cnj y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {x. cmod\n                                   (cnj (x -\n   (1 / 2 - complex_of_real (sqrt 3 / 6) * \\<i>)))\n                                  < sqrt 3 / 3}", "by (auto simp add: upper_circle_01_def del: complex_mod_cnj)"], ["proof (state)\nthis:\n  x \\<in> lower_circle_01\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cnj ` upper_circle_01 \\<subseteq> lower_circle_01\n\ngoal (1 subgoal):\n 1. lower_circle_01 \\<subseteq> cnj ` upper_circle_01", "show \"lower_circle_01 \\<subseteq> cnj ` upper_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_circle_01 \\<subseteq> cnj ` upper_circle_01", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle_01 \\<Longrightarrow>\n       x \\<in> cnj ` upper_circle_01", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle_01 \\<Longrightarrow>\n       x \\<in> cnj ` upper_circle_01", "assume \"x \\<in> lower_circle_01\""], ["proof (state)\nthis:\n  x \\<in> lower_circle_01\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle_01 \\<Longrightarrow>\n       x \\<in> cnj ` upper_circle_01", "hence \"cnj x \\<in> upper_circle_01\" and \"x = cnj (cnj x)\""], ["proof (prove)\nusing this:\n  x \\<in> lower_circle_01\n\ngoal (1 subgoal):\n 1. cnj x \\<in> upper_circle_01 &&& x = cnj (cnj x)", "apply (subst upper_circle_01_def, subst complex_mod_cnj[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> lower_circle_01; x \\<in> lower_circle_01\\<rbrakk>\n    \\<Longrightarrow> cnj x\n                      \\<in> {x. cmod\n                                 (cnj (x -\n (1 / 2 + complex_of_real (sqrt 3 / 6) * \\<i>)))\n                                < sqrt 3 / 3}\n 2. x = cnj (cnj x)", "by (auto simp add: lower_circle_01_def del: complex_mod_cnj)"], ["proof (state)\nthis:\n  cnj x \\<in> upper_circle_01\n  x = cnj (cnj x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle_01 \\<Longrightarrow>\n       x \\<in> cnj ` upper_circle_01", "thus \"x \\<in> cnj ` upper_circle_01\""], ["proof (prove)\nusing this:\n  cnj x \\<in> upper_circle_01\n  x = cnj (cnj x)\n\ngoal (1 subgoal):\n 1. x \\<in> cnj ` upper_circle_01", "by blast"], ["proof (state)\nthis:\n  x \\<in> cnj ` upper_circle_01\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lower_circle_01 \\<subseteq> cnj ` upper_circle_01\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_circle_map:\n  \"{x::complex. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x > - sqrt 3 * Re x}} = lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    lower_circle_01", "proof (subst cnj_upper_circle_01[symmetric], subst upper_circle_map[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"{x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} = \n        {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re (cnj x) > Im (cnj x)}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}}", "by auto"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n  {x. 1 / x\n      \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "also"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n  {x. 1 / x\n      \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"... = {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}} =\n    {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}}", "apply (subst(2) bij_image_Collect_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. bij cnj\n 2. {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}} =\n    {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) `\n              {y. Im (inv cnj y) < sqrt 3 * Re (inv cnj y)}}", "apply (metis bijI' complex_cnj_cnj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}} =\n    {x. 1 / x\n        \\<in> (\\<lambda>x. x + 1) `\n              {y. Im (inv cnj y) < sqrt 3 * Re (inv cnj y)}}", "by (auto simp: inj_def inj_imp_inv_eq[of _ cnj])"], ["proof (state)\nthis:\n  {x. 1 / x\n      \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}} =\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "also"], ["proof (state)\nthis:\n  {x. 1 / x\n      \\<in> (\\<lambda>x. x + 1) ` {x. Im (cnj x) < sqrt 3 * Re (cnj x)}} =\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"... = {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}} =\n    {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "by (auto simp: image_image)"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}} =\n  {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "also"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` cnj ` {x. Im x < sqrt 3 * Re x}} =\n  {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"... = {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n    {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "by (metis (no_types, lifting) complex_cnj_cnj image_iff)"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n  {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "also"], ["proof (state)\nthis:\n  {x. 1 / x \\<in> cnj ` (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n  {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "have \"... = cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. sqrt 3 * Re x > Im x}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "apply (subst(2) bij_image_Collect_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bij cnj\n 2. {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n    {y. 1 / inv cnj y \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "apply (metis bijI' complex_cnj_cnj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n    {y. 1 / inv cnj y \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "by (auto simp: inj_def inj_imp_inv_eq[of _ cnj])"], ["proof (state)\nthis:\n  {x. cnj (1 / x) \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}} =\n  cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "finally"], ["proof (chain)\npicking this:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n  cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "show \"{x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n          cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\""], ["proof (prove)\nusing this:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n  cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal (1 subgoal):\n 1. {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n    cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}", "."], ["proof (state)\nthis:\n  {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. - sqrt 3 * Re x < Im x}} =\n  cnj ` {x. 1 / x \\<in> (\\<lambda>x. x + 1) ` {x. Im x < sqrt 3 * Re x}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_circles_01: \n  fixes P::\"real poly\" \n  assumes hP: \"degree P \\<le> p\" and hP0: \"P \\<noteq> 0\" and hp0: \"p \\<noteq> 0\"\n  and h: \"proots_count (map_poly of_real P) \n          (upper_circle_01 \\<union> lower_circle_01) = 1\"\nshows \"Bernstein_changes_01 p P = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes_01 p P = 1", "proof (subst Bernstein_changes_01_eq_changes[OF hP])"], ["proof (state)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "let ?Q = \"reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "have hQ0: \"?Q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0", "using hP0"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0", "by (simp add: pcompose_eq_0 hP reciprocal_0_iff)"], ["proof (state)\nthis:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "from h"], ["proof (chain)\npicking this:\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1", "obtain x' where hroot': \"poly (map_poly of_real P) x' = 0\"\n    and hx':\"x' \\<in> upper_circle_01 \\<union> lower_circle_01\""], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>poly (map_poly complex_of_real P) x' = 0;\n         x' \\<in> upper_circle_01 \\<union> lower_circle_01\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using proots_count_pos"], ["proof (prove)\nusing this:\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n  0 < proots_count ?P ?S \\<Longrightarrow>\n  \\<exists>x\\<in>?S. poly ?P x = (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>poly (map_poly complex_of_real P) x' = 0;\n         x' \\<in> upper_circle_01 \\<union> lower_circle_01\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis less_numeral_extra(1))"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real P) x' = 0\n  x' \\<in> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "obtain x where hxx': \"x' = complex_of_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x' = complex_of_real x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"Im x' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"Im x' = 0\" and h: \"\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  Im x' = 0\n  x' = complex_of_real ?x \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Im x' = 0\n  x' = complex_of_real ?x \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  Im x' = 0\n  x' = complex_of_real ?x \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using h[of \"Re x'\"]"], ["proof (prove)\nusing this:\n  Im x' = 0\n  x' = complex_of_real ?x \\<Longrightarrow> thesis\n  x' = complex_of_real (Re x') \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: complex_is_Real_iff)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume hx'': \"Im x' \\<noteq> 0\""], ["proof (state)\nthis:\n  Im x' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 1: \"card {x', cnj x'} = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x', cnj x'} = 2", "proof (subst card_2_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. {x', cnj x'} = {x, y} \\<and> x \\<noteq> y", "from hx''"], ["proof (chain)\npicking this:\n  Im x' \\<noteq> 0", "have \"x' \\<noteq> cnj x'\" and \"{x', cnj x'} = {x', cnj x'}\""], ["proof (prove)\nusing this:\n  Im x' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x' \\<noteq> cnj x' &&& {x', cnj x'} = {x', cnj x'}", "by (metis cnj.simps(2) neg_equal_zero, argo)"], ["proof (state)\nthis:\n  x' \\<noteq> cnj x'\n  {x', cnj x'} = {x', cnj x'}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. {x', cnj x'} = {x, y} \\<and> x \\<noteq> y", "thus \"\\<exists>x y. {x', cnj x'} = {x, y} \\<and> x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x' \\<noteq> cnj x'\n  {x', cnj x'} = {x', cnj x'}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. {x', cnj x'} = {x, y} \\<and> x \\<noteq> y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x y. {x', cnj x'} = {x, y} \\<and> x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {x', cnj x'} = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  card {x', cnj x'} = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"{x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01", "using hx'"], ["proof (prove)\nusing this:\n  x' \\<in> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01", "apply (rule UnE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x' \\<in> upper_circle_01 \\<Longrightarrow>\n    {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n 2. x' \\<in> lower_circle_01 \\<Longrightarrow>\n    {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01", "by (auto simp: cnj_upper_circle_01[symmetric])"], ["proof (state)\nthis:\n  {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<And>x. x \\<in> {x', cnj x'} \\<Longrightarrow> poly (map_poly of_real P) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x', cnj x'} \\<Longrightarrow>\n       poly (map_poly complex_of_real P) x = 0", "using hroot' poly_map_poly_of_real_cnj"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real P) x' = 0\n  poly (map_poly complex_of_real ?p) (cnj ?z) =\n  cnj (poly (map_poly complex_of_real ?p) ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x', cnj x'} \\<Longrightarrow>\n       poly (map_poly complex_of_real P) x = 0", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {x', cnj x'} \\<Longrightarrow>\n  poly (map_poly complex_of_real P) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  card {x', cnj x'} = 2\n  {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n  ?x \\<in> {x', cnj x'} \\<Longrightarrow>\n  poly (map_poly complex_of_real P) ?x = 0", "have\n      \"proots_count (map_poly of_real P) (upper_circle_01 \\<union> lower_circle_01) \\<ge> 2\""], ["proof (prove)\nusing this:\n  card {x', cnj x'} = 2\n  {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n  ?x \\<in> {x', cnj x'} \\<Longrightarrow>\n  poly (map_poly complex_of_real P) ?x = 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> proots_count (map_poly complex_of_real P)\n             (upper_circle_01 \\<union> lower_circle_01)", "apply (subst 1[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>card {x', cnj x'} = 2;\n     {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n     \\<And>x.\n        x \\<in> {x', cnj x'} \\<Longrightarrow>\n        poly (map_poly complex_of_real P) x = 0\\<rbrakk>\n    \\<Longrightarrow> card {x', cnj x'}\n                      \\<le> proots_count (map_poly complex_of_real P)\n                             (upper_circle_01 \\<union> lower_circle_01)", "apply (rule proots_count_of_root_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>card {x', cnj x'} = 2;\n     {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n     \\<And>x.\n        x \\<in> {x', cnj x'} \\<Longrightarrow>\n        poly (map_poly complex_of_real P) x = 0\\<rbrakk>\n    \\<Longrightarrow> map_poly complex_of_real P \\<noteq> 0\n 2. \\<lbrakk>card {x', cnj x'} = 2;\n     {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n     \\<And>x.\n        x \\<in> {x', cnj x'} \\<Longrightarrow>\n        poly (map_poly complex_of_real P) x = 0\\<rbrakk>\n    \\<Longrightarrow> {x', cnj x'}\n                      \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n 3. \\<And>x.\n       \\<lbrakk>card {x', cnj x'} = 2;\n        {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n        \\<And>x.\n           x \\<in> {x', cnj x'} \\<Longrightarrow>\n           poly (map_poly complex_of_real P) x = 0;\n        x \\<in> {x', cnj x'}\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly complex_of_real P) x = 0", "using assms(2) of_real_poly_eq_0_iff"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n  (map_poly of_real ?p = 0) = (?p = 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>card {x', cnj x'} = 2;\n     {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n     \\<And>x.\n        x \\<in> {x', cnj x'} \\<Longrightarrow>\n        poly (map_poly complex_of_real P) x = 0\\<rbrakk>\n    \\<Longrightarrow> map_poly complex_of_real P \\<noteq> 0\n 2. \\<lbrakk>card {x', cnj x'} = 2;\n     {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n     \\<And>x.\n        x \\<in> {x', cnj x'} \\<Longrightarrow>\n        poly (map_poly complex_of_real P) x = 0\\<rbrakk>\n    \\<Longrightarrow> {x', cnj x'}\n                      \\<subseteq> upper_circle_01 \\<union> lower_circle_01\n 3. \\<And>x.\n       \\<lbrakk>card {x', cnj x'} = 2;\n        {x', cnj x'} \\<subseteq> upper_circle_01 \\<union> lower_circle_01;\n        \\<And>x.\n           x \\<in> {x', cnj x'} \\<Longrightarrow>\n           poly (map_poly complex_of_real P) x = 0;\n        x \\<in> {x', cnj x'}\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly complex_of_real P) x = 0", "by (blast, blast, blast)"], ["proof (state)\nthis:\n  2 \\<le> proots_count (map_poly complex_of_real P)\n           (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x' = complex_of_real x \\<Longrightarrow> thesis;\n     Im x' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  2 \\<le> proots_count (map_poly complex_of_real P)\n           (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  2 \\<le> proots_count (map_poly complex_of_real P)\n           (upper_circle_01 \\<union> lower_circle_01)\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. thesis", "by linarith"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' = complex_of_real x\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "hence hroot: \"poly P x = 0\""], ["proof (prove)\nusing this:\n  x' = complex_of_real x\n\ngoal (1 subgoal):\n 1. poly P x = 0", "using hroot'"], ["proof (prove)\nusing this:\n  x' = complex_of_real x\n  poly (map_poly complex_of_real P) x' = 0\n\ngoal (1 subgoal):\n 1. poly P x = 0", "by (metis of_real_0 of_real_eq_iff of_real_poly_map_poly)"], ["proof (state)\nthis:\n  poly P x = 0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "have that: \"3 * sqrt (x * x + 1 / 3 - x) < sqrt 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * sqrt (x * x + 1 / 3 - x) < sqrt 3", "using hx'"], ["proof (prove)\nusing this:\n  x' \\<in> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. 3 * sqrt (x * x + 1 / 3 - x) < sqrt 3", "apply (rule UnE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x' \\<in> upper_circle_01 \\<Longrightarrow>\n    3 * sqrt (x * x + 1 / 3 - x) < sqrt 3\n 2. x' \\<in> lower_circle_01 \\<Longrightarrow>\n    3 * sqrt (x * x + 1 / 3 - x) < sqrt 3", "by (auto simp: cmod_def power2_eq_square algebra_simps upper_circle_01_def\n        lower_circle_01_def hxx')"], ["proof (state)\nthis:\n  3 * sqrt (x * x + 1 / 3 - x) < sqrt 3\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "have hx: \"0 < x \\<and> x < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "have \"3 * sqrt (x * x + 1 / 3 - x) = sqrt (9 * (x * x + 1 / 3 - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * sqrt (x * x + 1 / 3 - x) = sqrt (9 * (x * x + 1 / 3 - x))", "by (subst real_sqrt_mult, simp)"], ["proof (state)\nthis:\n  3 * sqrt (x * x + 1 / 3 - x) = sqrt (9 * (x * x + 1 / 3 - x))\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "hence \"9 * (x * x + 1 / 3 - x) < 3\""], ["proof (prove)\nusing this:\n  3 * sqrt (x * x + 1 / 3 - x) = sqrt (9 * (x * x + 1 / 3 - x))\n\ngoal (1 subgoal):\n 1. 9 * (x * x + 1 / 3 - x) < 3", "using that real_sqrt_less_iff"], ["proof (prove)\nusing this:\n  3 * sqrt (x * x + 1 / 3 - x) = sqrt (9 * (x * x + 1 / 3 - x))\n  3 * sqrt (x * x + 1 / 3 - x) < sqrt 3\n  (sqrt ?x < sqrt ?y) = (?x < ?y)\n\ngoal (1 subgoal):\n 1. 9 * (x * x + 1 / 3 - x) < 3", "by metis"], ["proof (state)\nthis:\n  9 * (x * x + 1 / 3 - x) < 3\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "hence \"x*x - x < 0\""], ["proof (prove)\nusing this:\n  9 * (x * x + 1 / 3 - x) < 3\n\ngoal (1 subgoal):\n 1. x * x - x < 0", "by auto"], ["proof (state)\nthis:\n  x * x - x < 0\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "thus \"0 < x \\<and> x < 1\""], ["proof (prove)\nusing this:\n  x * x - x < 0\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "using mult_eq_0_iff mult_less_cancel_right_disj"], ["proof (prove)\nusing this:\n  x * x - x < 0\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  (?a * ?c < ?b * ?c) =\n  ((0::?'a) < ?c \\<and> ?a < ?b \\<or> ?c < (0::?'a) \\<and> ?b < ?a)\n\ngoal (1 subgoal):\n 1. 0 < x \\<and> x < 1", "by fastforce"], ["proof (state)\nthis:\n  0 < x \\<and> x < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < x \\<and> x < 1\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "let ?y = \"1/x - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "from hroot hx assms"], ["proof (chain)\npicking this:\n  poly P x = 0\n  0 < x \\<and> x < 1\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1", "have \"poly ?Q ?y = 0\""], ["proof (prove)\nusing this:\n  poly P x = 0\n  0 < x \\<and> x < 1\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n  proots_count (map_poly complex_of_real P)\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) (1 / x - 1) = 0", "by (auto simp: poly_pcompose poly_reciprocal)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) (1 / x - 1) = 0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "hence \"[:-?y, 1:] dvd ?Q\""], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) (1 / x - 1) = 0\n\ngoal (1 subgoal):\n 1. [:- (1 / x - 1), 1:] dvd reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]", "using poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) (1 / x - 1) = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- (1 / x - 1), 1:] dvd reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]", "by blast"], ["proof (state)\nthis:\n  [:- (1 / x - 1), 1:] dvd reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "then"], ["proof (chain)\npicking this:\n  [:- (1 / x - 1), 1:] dvd reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]", "obtain R where hR: \"?Q = R * [:-?y, 1:]\""], ["proof (prove)\nusing this:\n  [:- (1 / x - 1), 1:] dvd reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] =\n        R * [:- (1 / x - 1), 1:] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] = R * [:- (1 / x - 1), 1:]\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "hence hR0: \"R \\<noteq> 0\""], ["proof (prove)\nusing this:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] = R * [:- (1 / x - 1), 1:]\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0", "using hQ0"], ["proof (prove)\nusing this:\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] = R * [:- (1 / x - 1), 1:]\n  reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  R \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "interpret map_poly_idom_hom complex_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "have \"normal_poly (smult (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_poly\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R)", "proof (rule normal_poly_of_roots)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2\n 2. monic\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R)", "show \"\\<And>z. poly (map_poly complex_of_real\n          (smult (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) R)) z = 0 \\<Longrightarrow>\n          Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "assume\n        \"poly (map_poly complex_of_real\n         (smult (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) R)) z = 0\""], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R))\n   z =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "hence hroot2: \"poly (map_poly complex_of_real R) z = 0\""], ["proof (prove)\nusing this:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R))\n   z =\n  0\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real R) z = 0", "by (auto simp: map_poly_smult hQ0)"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real R) z = 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       poly\n        (map_poly complex_of_real\n          (smult\n            (inverse\n              (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n            R))\n        z =\n       0 \\<Longrightarrow>\n       Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "show \"Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "assume \"\\<not> (Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2)\""], ["proof (state)\nthis:\n  \\<not> (Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "hence 1: \"0 < Re z \\<or> 4 * (Re z)\\<^sup>2 < (cmod z)\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<not> (Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 < Re z \\<or> 4 * (Re z)\\<^sup>2 < (cmod z)\\<^sup>2", "by linarith"], ["proof (state)\nthis:\n  0 < Re z \\<or> 4 * (Re z)\\<^sup>2 < (cmod z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "hence hz: \"z \\<noteq> -1\""], ["proof (prove)\nusing this:\n  0 < Re z \\<or> 4 * (Re z)\\<^sup>2 < (cmod z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. z \\<noteq> - 1", "by force"], ["proof (state)\nthis:\n  z \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"Im z > - sqrt 3 * Re z \\<or> sqrt 3 * Re z > Im z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "proof (cases \"Im z \\<ge> sqrt 3 * Re z\", cases \"- sqrt 3 * Re z \\<ge> Im z\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "assume 2: \"sqrt 3 * Re z \\<le> Im z\" \"Im z \\<le> - sqrt 3 * Re z\""], ["proof (state)\nthis:\n  sqrt 3 * Re z \\<le> Im z\n  Im z \\<le> - sqrt 3 * Re z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "hence \"sqrt 3 * Re z \\<le> sqrt 3 * - Re z\""], ["proof (prove)\nusing this:\n  sqrt 3 * Re z \\<le> Im z\n  Im z \\<le> - sqrt 3 * Re z\n\ngoal (1 subgoal):\n 1. sqrt 3 * Re z \\<le> sqrt 3 * - Re z", "by force"], ["proof (state)\nthis:\n  sqrt 3 * Re z \\<le> sqrt 3 * - Re z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "hence \"Re z \\<le> - Re z\""], ["proof (prove)\nusing this:\n  sqrt 3 * Re z \\<le> sqrt 3 * - Re z\n\ngoal (1 subgoal):\n 1. Re z \\<le> - Re z", "apply (rule mult_left_le_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sqrt 3", "by fastforce"], ["proof (state)\nthis:\n  Re z \\<le> - Re z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "hence \"Re z \\<le> 0\""], ["proof (prove)\nusing this:\n  Re z \\<le> - Re z\n\ngoal (1 subgoal):\n 1. Re z \\<le> 0", "by simp"], ["proof (state)\nthis:\n  Re z \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "moreover"], ["proof (state)\nthis:\n  Re z \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "have \"(Im z)^2 \\<le> (-sqrt 3 * Re z)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im z)\\<^sup>2 \\<le> (- sqrt 3 * Re z)\\<^sup>2", "apply (subst power2_eq_square, subst power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z * Im z \\<le> - sqrt 3 * Re z * (- sqrt 3 * Re z)", "apply (rule square_bounded_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- sqrt 3 * Re z) \\<le> Im z \\<and> Im z \\<le> - sqrt 3 * Re z", "using 2"], ["proof (prove)\nusing this:\n  sqrt 3 * Re z \\<le> Im z\n  Im z \\<le> - sqrt 3 * Re z\n\ngoal (1 subgoal):\n 1. - (- sqrt 3 * Re z) \\<le> Im z \\<and> Im z \\<le> - sqrt 3 * Re z", "by auto"], ["proof (state)\nthis:\n  (Im z)\\<^sup>2 \\<le> (- sqrt 3 * Re z)\\<^sup>2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "ultimately"], ["proof (chain)\npicking this:\n  Re z \\<le> 0\n  (Im z)\\<^sup>2 \\<le> (- sqrt 3 * Re z)\\<^sup>2", "have False"], ["proof (prove)\nusing this:\n  Re z \\<le> 0\n  (Im z)\\<^sup>2 \\<le> (- sqrt 3 * Re z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. False", "using 1"], ["proof (prove)\nusing this:\n  Re z \\<le> 0\n  (Im z)\\<^sup>2 \\<le> (- sqrt 3 * Re z)\\<^sup>2\n  0 < Re z \\<or> 4 * (Re z)\\<^sup>2 < (cmod z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: power2_eq_square cmod_def algebra_simps)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z; Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 3. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "by fast"], ["proof (state)\nthis:\n  - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sqrt 3 * Re z \\<le> Im z;\n     \\<not> Im z \\<le> - sqrt 3 * Re z\\<rbrakk>\n    \\<Longrightarrow> - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n 2. \\<not> sqrt 3 * Re z \\<le> Im z \\<Longrightarrow>\n    - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z", "qed auto"], ["proof (state)\nthis:\n  - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "hence \"z \\<in> {z. - sqrt 3 * Re z < Im z} \\<union> {z. Im z < sqrt 3 * Re z}\""], ["proof (prove)\nusing this:\n  - sqrt 3 * Re z < Im z \\<or> Im z < sqrt 3 * Re z\n\ngoal (1 subgoal):\n 1. z \\<in> {z. - sqrt 3 * Re z < Im z} \\<union> {z. Im z < sqrt 3 * Re z}", "by blast"], ["proof (state)\nthis:\n  z \\<in> {z. - sqrt 3 * Re z < Im z} \\<union> {z. Im z < sqrt 3 * Re z}\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "hence 1: \"inverse (1 + z) \\<in> upper_circle_01 \\<union> lower_circle_01\""], ["proof (prove)\nusing this:\n  z \\<in> {z. - sqrt 3 * Re z < Im z} \\<union> {z. Im z < sqrt 3 * Re z}\n\ngoal (1 subgoal):\n 1. inverse (1 + z) \\<in> upper_circle_01 \\<union> lower_circle_01", "by (force simp: inverse_eq_divide upper_circle_map[symmetric]\n              lower_circle_map[symmetric])"], ["proof (state)\nthis:\n  inverse (1 + z) \\<in> upper_circle_01 \\<union> lower_circle_01\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have hRdeg': \"degree R < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree R < p", "apply (rule less_le_trans[of \"degree R\" \"degree ?Q\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree R < degree (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])\n 2. degree (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) \\<le> p", "apply (subst hR, subst degree_mult_eq[OF hR0], fastforce, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]) \\<le> p", "by (auto simp: degree_pcompose degree_reciprocal hP)"], ["proof (state)\nthis:\n  degree R < p\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "hence hRdeg: \"degree R \\<le> p\""], ["proof (prove)\nusing this:\n  degree R < p\n\ngoal (1 subgoal):\n 1. degree R \\<le> p", "by fastforce"], ["proof (state)\nthis:\n  degree R \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have 2: \"map_poly complex_of_real (reciprocal_poly p (R \\<circ>\\<^sub>p [:-1, 1:])) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])) \\<noteq>\n    0", "apply (subst of_real_poly_eq_0_iff, subst reciprocal_0_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. R \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0", "apply (force simp: hRdeg degree_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0", "using hR0 pcompose_eq_0"], ["proof (prove)\nusing this:\n  R \\<noteq> 0\n  degree ?q \\<noteq> 0 \\<Longrightarrow>\n  (?p \\<circ>\\<^sub>p ?q = 0) = (?p = 0)\n\ngoal (1 subgoal):\n 1. R \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0", "by (metis degree_eq_zeroE gr_zeroI pCons_eq_iff pCons_one zero_neq_one)"], ["proof (state)\nthis:\n  map_poly complex_of_real\n   (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have 3: \n          \"poly (map_poly complex_of_real (reciprocal_poly p (R \\<circ>\\<^sub>p [:-1, 1:])))\n                 (inverse (1 + z)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (inverse (1 + z)) =\n    0", "apply (subst map_poly_reciprocal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. complex_of_real 0 = 0\n 3. poly\n     (reciprocal_poly p\n       (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (inverse (1 + z)) =\n    0", "using hRdeg"], ["proof (prove)\nusing this:\n  degree R \\<le> p\n\ngoal (3 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. complex_of_real 0 = 0\n 3. poly\n     (reciprocal_poly p\n       (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (inverse (1 + z)) =\n    0", "apply (force simp: degree_pcompose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. complex_of_real 0 = 0\n 2. poly\n     (reciprocal_poly p\n       (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (inverse (1 + z)) =\n    0", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (reciprocal_poly p\n       (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (inverse (1 + z)) =\n    0", "apply (subst poly_reciprocal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])) \\<le> p\n 2. inverse (1 + z) \\<noteq> 0\n 3. inverse (1 + z) ^ p *\n    poly (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:]))\n     (inverse (inverse (1 + z))) =\n    0", "using hRdeg"], ["proof (prove)\nusing this:\n  degree R \\<le> p\n\ngoal (3 subgoals):\n 1. degree (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:])) \\<le> p\n 2. inverse (1 + z) \\<noteq> 0\n 3. inverse (1 + z) ^ p *\n    poly (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:]))\n     (inverse (inverse (1 + z))) =\n    0", "apply (force simp: degree_map_poly degree_pcompose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inverse (1 + z) \\<noteq> 0\n 2. inverse (1 + z) ^ p *\n    poly (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:]))\n     (inverse (inverse (1 + z))) =\n    0", "using hz"], ["proof (prove)\nusing this:\n  z \\<noteq> - 1\n\ngoal (2 subgoals):\n 1. inverse (1 + z) \\<noteq> 0\n 2. inverse (1 + z) ^ p *\n    poly (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:]))\n     (inverse (inverse (1 + z))) =\n    0", "apply (metis inverse_nonzero_iff_nonzero neg_eq_iff_add_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (1 + z) ^ p *\n    poly (map_poly complex_of_real (R \\<circ>\\<^sub>p [:- 1, 1:]))\n     (inverse (inverse (1 + z))) =\n    0", "by (auto simp: of_real_hom.map_poly_pcompose poly_pcompose hroot2)"], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n   (inverse (1 + z)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"proots_count (map_poly of_real (reciprocal_poly p (R \\<circ>\\<^sub>p [:-1, 1:])))\n               (upper_circle_01 \\<union> lower_circle_01) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "by (rule proots_count_of_root[OF 2 1 3])"], ["proof (state)\nthis:\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"proots_count\n                     (map_poly complex_of_real\n                     (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n                     (upper_circle_01 \\<union> lower_circle_01) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "apply (subst map_poly_reciprocal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. complex_of_real 0 = 0\n 3. 0 < proots_count\n         (reciprocal_poly p\n           (map_poly complex_of_real\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "using hp0 less_eq_Suc_le"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (?n < ?m) = (Suc ?n \\<le> ?m)\n\ngoal (3 subgoals):\n 1. degree ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. complex_of_real 0 = 0\n 3. 0 < proots_count\n         (reciprocal_poly p\n           (map_poly complex_of_real\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "apply (simp add: degree_pcompose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. complex_of_real 0 = 0\n 2. 0 < proots_count\n         (reciprocal_poly p\n           (map_poly complex_of_real\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count\n         (reciprocal_poly p\n           (map_poly complex_of_real\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "apply (subst proots_count_reciprocal)"], ["proof (prove)\ngoal (4 subgoals):\n 1. degree\n     (map_poly complex_of_real\n       ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n    \\<le> p\n 2. map_poly complex_of_real\n     ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<noteq>\n    0\n 3. 0 \\<notin> upper_circle_01 \\<union> lower_circle_01\n 4. 0 < proots_count\n         (map_poly complex_of_real\n           ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "using hp0 less_eq_Suc_le"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (?n < ?m) = (Suc ?n \\<le> ?m)\n\ngoal (4 subgoals):\n 1. degree\n     (map_poly complex_of_real\n       ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n    \\<le> p\n 2. map_poly complex_of_real\n     ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<noteq>\n    0\n 3. 0 \\<notin> upper_circle_01 \\<union> lower_circle_01\n 4. 0 < proots_count\n         (map_poly complex_of_real\n           ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "apply (simp add: degree_pcompose degree_map_poly)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_poly complex_of_real\n     ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<noteq>\n    0\n 2. 0 \\<notin> upper_circle_01 \\<union> lower_circle_01\n 3. 0 < proots_count\n         (map_poly complex_of_real\n           ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "apply (auto simp: pcompose_pCons)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<notin> upper_circle_01 \\<union> lower_circle_01\n 2. 0 < proots_count\n         (map_poly complex_of_real\n           ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "apply (auto simp: cmod_def power2_eq_square real_sqrt_divide\n                    real_div_sqrt upper_circle_01_def lower_circle_01_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count\n         (map_poly complex_of_real\n           ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:]))\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "apply (subst of_real_hom.map_poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count\n         (map_poly complex_of_real [:1 - 1 / x, 1:] \\<circ>\\<^sub>p\n          map_poly complex_of_real [:- 1, 1:])\n         {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01}", "apply (subst proots_pcompose, fastforce, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count (map_poly complex_of_real [:1 - 1 / x, 1:])\n         (poly (map_poly complex_of_real [:- 1, 1:]) `\n          {x. inverse x \\<in> upper_circle_01 \\<union> lower_circle_01})", "apply (subst lower_circle_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count (map_poly complex_of_real [:1 - 1 / x, 1:])\n         (poly (map_poly complex_of_real [:- 1, 1:]) `\n          {x. inverse x\n              \\<in> upper_circle_01 \\<union>\n                    {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. - sqrt 3 * Re x < Im x}}})", "apply (subst upper_circle_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count (map_poly complex_of_real [:1 - 1 / x, 1:])\n         (poly (map_poly complex_of_real [:- 1, 1:]) `\n          {x. inverse x\n              \\<in> {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. Im x < sqrt 3 * Re x}} \\<union>\n                    {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. - sqrt 3 * Re x < Im x}}})", "apply (rule proots_count_of_root[of _ \"of_real (1/x - 1)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_poly complex_of_real [:1 - 1 / x, 1:] \\<noteq> 0\n 2. complex_of_real (1 / x - 1)\n    \\<in> poly (map_poly complex_of_real [:- 1, 1:]) `\n          {x. inverse x\n              \\<in> {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. Im x < sqrt 3 * Re x}} \\<union>\n                    {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. - sqrt 3 * Re x < Im x}}}\n 3. poly (map_poly complex_of_real [:1 - 1 / x, 1:])\n     (complex_of_real (1 / x - 1)) =\n    0", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. complex_of_real (1 / x - 1)\n    \\<in> poly (map_poly complex_of_real [:- 1, 1:]) `\n          {x. inverse x\n              \\<in> {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. Im x < sqrt 3 * Re x}} \\<union>\n                    {x. 1 / x\n                        \\<in> (\\<lambda>x. x + 1) `\n                              {x. - sqrt 3 * Re x < Im x}}}\n 2. poly (map_poly complex_of_real [:1 - 1 / x, 1:])\n     (complex_of_real (1 / x - 1)) =\n    0", "apply (auto simp: bij_image_Collect_eq bij_def inj_def image_iff\n                    inverse_eq_divide inj_imp_inv_eq[of _ \"\\<lambda> x. x+1\"] hx)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real [:1 - 1 / x, 1:])\n     (complex_of_real (1 / x - 1)) =\n    0", "by force"], ["proof (state)\nthis:\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)", "have \"proots_count\n                 (map_poly complex_of_real (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n                 (upper_circle_01 \\<union> lower_circle_01) +\n            proots_count\n             (map_poly complex_of_real\n               (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n             (upper_circle_01 \\<union> lower_circle_01) > 1\""], ["proof (prove)\nusing this:\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n  0 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. 1 < proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01) +\n        proots_count\n         (map_poly complex_of_real\n           (reciprocal_poly p\n             ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n         (upper_circle_01 \\<union> lower_circle_01)", "by fastforce"], ["proof (state)\nthis:\n  1 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01) +\n      proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 < proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01) +\n      proots_count\n       (map_poly complex_of_real\n         (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n       (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"... = proots_count (map_poly complex_of_real\n                   (monom 1 p * reciprocal_poly p (?Q \\<circ>\\<^sub>p [:- 1, 1:])))\n           (upper_circle_01 \\<union> lower_circle_01)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (monom 1 p *\n        reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst eq_commute, subst hR, subst pcompose_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (monom 1 p *\n        reciprocal_poly p\n         (R \\<circ>\\<^sub>p [:- 1, 1:] *\n          [:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst reciprocal_mult, subst degree_mult_eq)"], ["proof (prove)\ngoal (6 subgoals):\n 1. R \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0\n 2. [:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0\n 3. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) +\n    degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])\n    \\<le> p\n 4. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 5. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 6. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hR0"], ["proof (prove)\nusing this:\n  R \\<noteq> 0\n\ngoal (6 subgoals):\n 1. R \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0\n 2. [:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0\n 3. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) +\n    degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])\n    \\<le> p\n 4. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 5. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 6. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (fastforce simp: pcompose_eq_0)"], ["proof (prove)\ngoal (5 subgoals):\n 1. [:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:] \\<noteq> 0\n 2. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) +\n    degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])\n    \\<le> p\n 3. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 4. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 5. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (fastforce simp: pcompose_pCons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) +\n    degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])\n    \\<le> p\n 2. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 3. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 4. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hRdeg'"], ["proof (prove)\nusing this:\n  degree R < p\n\ngoal (4 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) +\n    degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])\n    \\<le> p\n 2. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 3. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 4. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (simp add: degree_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 3. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hRdeg"], ["proof (prove)\nusing this:\n  degree R \\<le> p\n\ngoal (3 subgoals):\n 1. degree (R \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 3. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (simp add: degree_pcompose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hp0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:]) \\<le> p\n 2. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (auto simp: degree_pcompose)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:]) *\n        reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])) *\n      map_poly complex_of_real\n       (reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])) *\n    map_poly complex_of_real\n     (reciprocal_poly p\n       ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])) \\<noteq>\n    0\n 2. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hp0 hRdeg' hR0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree R < p\n  R \\<noteq> 0\n\ngoal (2 subgoals):\n 1. map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])) *\n    map_poly complex_of_real\n     (reciprocal_poly p\n       ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])) \\<noteq>\n    0\n 2. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (fastforce simp: reciprocal_0_iff degree_pcompose pcompose_eq_0\n                 pcompose_pCons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         ([:- (1 / x - 1), 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "by simp"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) +\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  proots_count\n   (map_poly complex_of_real\n     (monom 1 p *\n      reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p (R \\<circ>\\<^sub>p [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) +\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p ([:1 - 1 / x, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  proots_count\n   (map_poly complex_of_real\n     (monom 1 p *\n      reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"... = proots_count\n           (map_poly complex_of_real\n             (reciprocal_poly p (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p [:- 1, 1:])))\n           (upper_circle_01 \\<union> lower_circle_01)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (monom 1 p *\n        reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst hom_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real (monom 1 p) *\n      map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_poly complex_of_real (monom 1 p) *\n    map_poly complex_of_real\n     (reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])) \\<noteq>\n    0\n 2. proots_count (map_poly complex_of_real (monom 1 p))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "using hp0 hP hP0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree P \\<le> p\n  P \\<noteq> 0\n\ngoal (2 subgoals):\n 1. map_poly complex_of_real (monom 1 p) *\n    map_poly complex_of_real\n     (reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])) \\<noteq>\n    0\n 2. proots_count (map_poly complex_of_real (monom 1 p))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (auto simp: map_poly_reciprocal degree_pcompose\n                  degree_reciprocal of_real_hom.map_poly_pcompose\n                  reciprocal_0_iff degree_map_poly pcompose_eq_0)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real (monom 1 p))\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst map_poly_monom, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (monom (complex_of_real 1) p)\n     (upper_circle_01 \\<union> lower_circle_01) +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (subst of_real_1, subst proots_count_monom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<notin> upper_circle_01 \\<union> lower_circle_01\n 2. 0 +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "apply (auto simp: cmod_def power2_eq_square real_sqrt_divide\n                  real_div_sqrt upper_circle_01_def lower_circle_01_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 +\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01)", "by presburger"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (monom 1 p *\n      reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (monom 1 p *\n      reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01)\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (reciprocal_poly p\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n          [:- 1, 1:])))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "by (auto simp: pcompose_assoc[\"symmetric\"] pcompose_pCons\n              reciprocal_reciprocal hP h)"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (reciprocal_poly p\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:] \\<circ>\\<^sub>p\n        [:- 1, 1:])))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. \\<not> (Re z \\<le> 0 \\<and>\n            (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  1 < 1", "show False"], ["proof (prove)\nusing this:\n  1 < 1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re z \\<le> 0 \\<and> (cmod z)\\<^sup>2 \\<le> 4 * (Re z)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly\n   (map_poly complex_of_real\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R))\n   ?z =\n  0 \\<Longrightarrow>\n  Re ?z \\<le> 0 \\<and> (cmod ?z)\\<^sup>2 \\<le> 4 * (Re ?z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. monic\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R)", "show \"lead_coeff\n         (smult (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) R) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       R)", "by (auto simp: hR degree_add_eq_right hR0 coeff_eq_0)"], ["proof (state)\nthis:\n  monic\n   (smult\n     (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n     R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normal_poly\n   (smult\n     (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n     R)\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "hence \"changes (coeffs (smult (inverse (lead_coeff ?Q)) ?Q)) = 1\""], ["proof (prove)\nusing this:\n  normal_poly\n   (smult\n     (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n     R)\n\ngoal (1 subgoal):\n 1. changes\n     (coeffs\n       (smult\n         (inverse\n           (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n    1", "apply (subst hR, subst mult_smult_left[symmetric], rule normal_changes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normal_poly\n              (smult\n                (inverse\n                  (lead_coeff\n                    (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n                R);\n     normal_poly\n      (smult\n        (inverse\n          (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n        R)\\<rbrakk>\n    \\<Longrightarrow> 0 < 1 / x - 1", "by (auto simp: hx)"], ["proof (state)\nthis:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  1\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "moreover"], ["proof (state)\nthis:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  1\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "have \"changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n      changes (coeffs (smult (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n        (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n    changes\n     (coeffs\n       (smult\n         (inverse\n           (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n         (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))", "by (auto simp: pcompose_eq_0 reciprocal_0_iff hP hP0 coeffs_smult\n        changes_scale_const[symmetric])"], ["proof (state)\nthis:\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "ultimately"], ["proof (chain)\npicking this:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  1\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))", "show \"changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1\""], ["proof (prove)\nusing this:\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:]))) =\n  1\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) =\n  changes\n   (coeffs\n     (smult\n       (inverse (lead_coeff (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n       (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])))\n\ngoal (1 subgoal):\n 1. changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1", "by argo"], ["proof (state)\nthis:\n  changes (coeffs (reciprocal_poly p P \\<circ>\\<^sub>p [:1, 1:])) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition upper_circle :: \"real \\<Rightarrow> real \\<Rightarrow> complex set\" where\n\"upper_circle l r = {x::complex.\n  cmod ((x-of_real l)/(of_real (r-l)) - (1/2 + of_real (sqrt(3))/6 * \\<i>)) < sqrt 3 / 3}\""], ["", "lemma upper_circle_rescale: assumes \"l < r\"\n  shows \"upper_circle l r = (\\<lambda> x . (x*(r - l) + l)) ` upper_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_circle l r =\n    (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    upper_circle_01", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. upper_circle l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                upper_circle_01\n 2. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    upper_circle_01\n    \\<subseteq> upper_circle l r", "show \"upper_circle l r \\<subseteq>\n        (\\<lambda>x. x * (of_real r - of_real l) + of_real l) ` upper_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_circle l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                upper_circle_01", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               upper_circle_01", "apply (rule image_eqI[of _ _ \"(_ - of_real l)/(of_real r - of_real l)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       x =\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l) *\n       (complex_of_real r - complex_of_real l) +\n       complex_of_real l\n 2. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l)\n       \\<in> upper_circle_01", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       x =\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l) *\n       (complex_of_real r - complex_of_real l) +\n       complex_of_real l\n 2. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l)\n       \\<in> upper_circle_01", "apply (auto simp: divide_simps)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> upper_circle l r \\<Longrightarrow>\n       (x - complex_of_real l) / (complex_of_real r - complex_of_real l)\n       \\<in> upper_circle_01", "by (auto simp: upper_circle_01_def upper_circle_def)"], ["proof (state)\nthis:\n  upper_circle l r\n  \\<subseteq> (\\<lambda>x.\n                  x * (complex_of_real r - complex_of_real l) +\n                  complex_of_real l) `\n              upper_circle_01\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    upper_circle_01\n    \\<subseteq> upper_circle l r", "show \"(\\<lambda>x. x * (of_real r - of_real l) + of_real l) ` upper_circle_01 \\<subseteq>\n        upper_circle l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    upper_circle_01\n    \\<subseteq> upper_circle l r", "apply (rule subsetI, subst(asm) image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>upper_circle_01.\n          x =\n          xa * (complex_of_real r - complex_of_real l) +\n          complex_of_real l \\<Longrightarrow>\n       x \\<in> upper_circle l r", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>upper_circle_01.\n          x =\n          xa * (complex_of_real r - complex_of_real l) +\n          complex_of_real l \\<Longrightarrow>\n       x \\<in> upper_circle l r", "by (auto simp: upper_circle_01_def upper_circle_def)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n  upper_circle_01\n  \\<subseteq> upper_circle l r\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lower_circle :: \"real \\<Rightarrow> real \\<Rightarrow> complex set\" where\n\"lower_circle l r = {x::complex.\n cmod ((x-of_real l)/(of_real (r-l)) - (1/2 - of_real (sqrt(3))/6 * \\<i>)) < sqrt 3 / 3}\""], ["", "lemma lower_circle_rescale: \n  assumes \"l < r\"\n  shows \"lower_circle l r = (\\<lambda> x . (x*(r - l) + l)) ` lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_circle l r =\n    (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    lower_circle_01", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lower_circle l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                lower_circle_01\n 2. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    lower_circle_01\n    \\<subseteq> lower_circle l r", "show \"lower_circle l r \\<subseteq> (\\<lambda>x. x * (of_real r - of_real l) + of_real l) `\n        lower_circle_01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_circle l r\n    \\<subseteq> (\\<lambda>x.\n                    x * (complex_of_real r - complex_of_real l) +\n                    complex_of_real l) `\n                lower_circle_01", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       x \\<in> (\\<lambda>x.\n                   x * (complex_of_real r - complex_of_real l) +\n                   complex_of_real l) `\n               lower_circle_01", "apply (rule image_eqI[of _ _ \"(_ - of_real l)/(of_real r - of_real l)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       x =\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l) *\n       (complex_of_real r - complex_of_real l) +\n       complex_of_real l\n 2. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l)\n       \\<in> lower_circle_01", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       x =\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l) *\n       (complex_of_real r - complex_of_real l) +\n       complex_of_real l\n 2. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       (?uu7 x - complex_of_real l) /\n       (complex_of_real r - complex_of_real l)\n       \\<in> lower_circle_01", "apply (auto simp: divide_simps)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lower_circle l r \\<Longrightarrow>\n       (x - complex_of_real l) / (complex_of_real r - complex_of_real l)\n       \\<in> lower_circle_01", "by (auto simp: lower_circle_01_def lower_circle_def)"], ["proof (state)\nthis:\n  lower_circle l r\n  \\<subseteq> (\\<lambda>x.\n                  x * (complex_of_real r - complex_of_real l) +\n                  complex_of_real l) `\n              lower_circle_01\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    lower_circle_01\n    \\<subseteq> lower_circle l r", "show \"(\\<lambda>x. x * (of_real r - of_real l) + of_real l) ` lower_circle_01 \\<subseteq>\n        lower_circle l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n    lower_circle_01\n    \\<subseteq> lower_circle l r", "apply (rule subsetI, subst(asm) image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>lower_circle_01.\n          x =\n          xa * (complex_of_real r - complex_of_real l) +\n          complex_of_real l \\<Longrightarrow>\n       x \\<in> lower_circle l r", "using assms"], ["proof (prove)\nusing this:\n  l < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa\\<in>lower_circle_01.\n          x =\n          xa * (complex_of_real r - complex_of_real l) +\n          complex_of_real l \\<Longrightarrow>\n       x \\<in> lower_circle l r", "by (auto simp: lower_circle_01_def lower_circle_def)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x * (complex_of_real r - complex_of_real l) + complex_of_real l) `\n  lower_circle_01\n  \\<subseteq> lower_circle l r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_circles: \n  fixes P::\"real poly\" and l r::real \n  assumes hlr: \"l < r\"\n  and hP: \"degree P \\<le> p\" \n  and hP0: \"P \\<noteq> 0\" \n  and hp0: \"p \\<noteq> 0\"\n  and h: \"proots_count (map_poly of_real P) \n       (upper_circle l r \\<union> lower_circle l r) = 1\"\nshows \"Bernstein_changes p l r P = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 1", "have 1: \"Bernstein_changes p l r P =\n           Bernstein_changes_01 p (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P =\n    Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:])", "using assms"], ["proof (prove)\nusing this:\n  l < r\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n  proots_count (map_poly complex_of_real P)\n   (upper_circle l r \\<union> lower_circle l r) =\n  1\n\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P =\n    Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:])", "by (force simp: Bernstein_changes_eq_rescale)"], ["proof (state)\nthis:\n  Bernstein_changes p l r P =\n  Bernstein_changes_01 p\n   (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:])\n\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 1", "have \"proots_count (map_poly complex_of_real (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "using assms"], ["proof (prove)\nusing this:\n  l < r\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n  proots_count (map_poly complex_of_real P)\n   (upper_circle l r \\<union> lower_circle l r) =\n  1\n\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "by (auto simp: upper_circle_rescale lower_circle_rescale proots_pcompose image_Un\n        of_real_hom.map_poly_pcompose pcompose_eq_0 image_image algebra_simps)"], ["proof (state)\nthis:\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  proots_count\n   (map_poly complex_of_real\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n   (upper_circle_01 \\<union> lower_circle_01) =\n  1\n\ngoal (1 subgoal):\n 1. Bernstein_changes p l r P = 1", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    Bernstein_changes_01 p\n     (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) =\n    1", "apply (rule two_circles_01)"], ["proof (prove)\ngoal (4 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 3. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 4. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "using hP"], ["proof (prove)\nusing this:\n  degree P \\<le> p\n\ngoal (4 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    degree (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]) \\<le> p\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 3. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 4. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "apply (force simp: degree_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 3. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "using hP0 hlr"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n  l < r\n\ngoal (3 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:] \\<noteq> 0\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 3. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "apply (fastforce simp: pcompose_eq_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "using hp0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 2. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1 \\<Longrightarrow>\n    proots_count\n     (map_poly complex_of_real\n       (P \\<circ>\\<^sub>p [:l, 1:] \\<circ>\\<^sub>p [:0, r - l:]))\n     (upper_circle_01 \\<union> lower_circle_01) =\n    1", "by blast"], ["proof (state)\nthis:\n  Bernstein_changes p l r P = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The theorem of three circles\\<close>"], ["", "theorem three_circles: \n  fixes P::\"real poly\" and l r::real\n  assumes \"l < r\"\n  and hP: \"degree P \\<le> p\" \n  and hP0: \"P \\<noteq> 0\" \n  and hp0: \"p \\<noteq> 0\"\nshows \"proots_count (map_poly of_real P) (circle_diam l r) = 0 \\<Longrightarrow>\n       Bernstein_changes p l r P = 0\"\n  and \"proots_count (map_poly of_real P) \n       (upper_circle l r \\<union> lower_circle l r) = 1 \\<Longrightarrow>\n       Bernstein_changes p l r P = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proots_count (map_poly complex_of_real P) (circle_diam l r) =\n     0 \\<Longrightarrow>\n     Bernstein_changes p l r P = 0) &&&\n    (proots_count (map_poly complex_of_real P)\n      (upper_circle l r \\<union> lower_circle l r) =\n     1 \\<Longrightarrow>\n     Bernstein_changes p l r P = 1)", "apply (rule one_circle)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    l < r\n 2. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    proots_count (map_poly complex_of_real P) (circle_diam l r) = 0\n 3. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    P \\<noteq> 0\n 4. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    degree P \\<le> p\n 5. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    Bernstein_changes p l r P = 1", "using assms"], ["proof (prove)\nusing this:\n  l < r\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (5 subgoals):\n 1. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    l < r\n 2. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    proots_count (map_poly complex_of_real P) (circle_diam l r) = 0\n 3. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    P \\<noteq> 0\n 4. proots_count (map_poly complex_of_real P) (circle_diam l r) =\n    0 \\<Longrightarrow>\n    degree P \\<le> p\n 5. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    Bernstein_changes p l r P = 1", "apply auto[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    Bernstein_changes p l r P = 1", "apply (rule two_circles)"], ["proof (prove)\ngoal (5 subgoals):\n 1. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    l < r\n 2. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    degree P \\<le> p\n 3. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    P \\<noteq> 0\n 4. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 5. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1", "using assms"], ["proof (prove)\nusing this:\n  l < r\n  degree P \\<le> p\n  P \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (5 subgoals):\n 1. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    l < r\n 2. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    degree P \\<le> p\n 3. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    P \\<noteq> 0\n 4. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    p \\<noteq> 0\n 5. proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1 \\<Longrightarrow>\n    proots_count (map_poly complex_of_real P)\n     (upper_circle l r \\<union> lower_circle l r) =\n    1", "by auto"], ["", "end"]]}