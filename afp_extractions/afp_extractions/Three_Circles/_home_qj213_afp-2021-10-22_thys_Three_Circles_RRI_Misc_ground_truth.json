{"file_name": "/home/qj213/afp-2021-10-22/thys/Three_Circles/RRI_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Three_Circles", "problem_names": ["lemma Setcompr_subset: \"\\<And>f P S. {f x | x. P x} \\<subseteq> S = (\\<forall> x. P x \\<longrightarrow> f x \\<in> S)\"", "lemma map_cong':\n  assumes \"xs = map h ys\" and \"\\<And>y. y \\<in> set ys \\<Longrightarrow> f (h y) = g y\"\n  shows \"map f xs = map g ys\"", "lemma nth_default_replicate_eq: \n    \"nth_default dflt (replicate n x) i = (if i < n then x else dflt)\"", "lemma square_bounded_less: \n  fixes a b::\"'a :: linordered_ring_strict\"\n  shows \"-a < b \\<and> b < a \\<Longrightarrow> b*b < a*a\"", "lemma square_bounded_le: \n  fixes a b::\"'a :: linordered_ring_strict\"\n  shows \"-a \\<le> b \\<and> b \\<le> a \\<Longrightarrow> b*b \\<le> a*a\"", "lemma card_le_dim_spanning:\n  assumes BV: \"B \\<subseteq> V\"\n    and VB: \"V \\<subseteq> span B\"\n    and fB: \"finite B\"\n    and dVB: \"dim V \\<ge> card B\"\n  shows \"independent B\"", "lemma smult_power: \"smult (x^n) (p^n) = smult x p ^ n\"", "lemma reflect_poly_monom: \"reflect_poly (monom n i) = monom n 0\"", "lemma poly_eq_by_eval: \n  fixes P Q :: \"'a::{comm_ring_1,ring_no_zero_divisors,ring_char_0} poly\"\n  assumes h: \"\\<And>x. poly P x = poly Q x\" shows \"P = Q\"", "lemma poly_binomial: \n  \"[:(1::'a::comm_ring_1), 1:]^n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\"", "lemma degree_0_iff: \"degree P = 0 \\<longleftrightarrow> (\\<exists>a. P = [:a:])\"", "lemma degree_subspace: \"poly_vs.subspace {x. degree x \\<le> n}\"", "lemma monom_span: \n  \"poly_vs.span {monom 1 x | x. x \\<le> p} = {(x::'a::field poly). degree x \\<le> p}\"\n(is \"?L = ?R\")", "lemma monom_independent: \n  \"poly_vs.independent {monom (1::'a::field) x | x. x \\<le> p}\"", "lemma dim_degree: \"poly_vs.dim {x. degree x \\<le> n} = n + 1\"", "lemma degree_div: \n  fixes p q::\"('a::idom_divide) poly\" \n  assumes \"q dvd p\"\n  shows \"degree (p div q) = degree p - degree q\"", "lemma lead_coeff_div: \n  fixes p q::\"('a::{idom_divide, inverse}) poly\" \n  assumes \"q dvd p\"\n  shows \"lead_coeff (p div q) = lead_coeff p / lead_coeff q\"", "lemma complex_poly_eq: \n  \"r = map_poly of_real (map_poly Re r) + smult \\<i> (map_poly of_real (map_poly Im r))\"", "lemma complex_poly_cong: \n  \"(map_poly Re p = map_poly Re q \\<and> map_poly Im p = map_poly Im q) = (p = q)\"", "lemma map_poly_Im_of_real: \"map_poly Im (map_poly of_real p) = 0\"", "lemma mult_map_poly_imp_map_poly: \n  assumes \"map_poly complex_of_real q = r * map_poly complex_of_real p\" \n          \"p \\<noteq> 0\"\n  shows \"r = map_poly complex_of_real (map_poly Re r)\"", "lemma map_poly_dvd: \n  fixes p q::\"real poly\"\n  assumes hdvd: \"map_poly complex_of_real p dvd \n                    map_poly complex_of_real q\" \"q \\<noteq> 0\"\n  shows \"p dvd q\"", "lemma div_poly_eq_0: \n  fixes p q::\"('a::idom_divide) poly\" \n  assumes \"q dvd p\" \"poly (p div q) x = 0\" \"q \\<noteq> 0\"\n  shows \"poly p x = 0\"", "lemma poly_map_poly_of_real_cnj: \n    \"poly (map_poly of_real p) (cnj z) = cnj (poly (map_poly of_real p) z)\"", "lemma real_poly_roots_induct: \n  fixes P::\"real poly \\<Rightarrow> bool\" and p::\"real poly\"\n  assumes IH_real: \"\\<And>p x. P p \\<Longrightarrow> P (p * [:-x, 1:])\"\n      and IH_complex: \"\\<And>p a b. b \\<noteq> 0 \\<Longrightarrow> P p \n              \\<Longrightarrow> P (p * [: a*a + b*b, -2*a, 1 :])\"\n      and H0: \"\\<And>a. P [:a:]\"\n  defines \"d \\<equiv> degree p\"\n  shows \"P p\"", "lemma reciprocal_0: \"reciprocal_poly p 0 = 0\"", "lemma reciprocal_1: \"reciprocal_poly p 1 = monom 1 p\"", "lemma coeff_reciprocal: \n  assumes hi: \"i \\<le> p\" and hP: \"degree P \\<le> p\"\n  shows \"coeff (reciprocal_poly p P) i = coeff P (p - i)\"", "lemma coeff_reciprocal_less: \n  assumes hn: \"p < i\" and hP: \"degree P \\<le> p\"\n  shows \"coeff (reciprocal_poly p P) i = 0\"", "lemma reciprocal_monom: \n  assumes \"n \\<le> p\"\n  shows \"reciprocal_poly p (monom a n) = monom a (p-n)\"", "lemma reciprocal_degree: \"reciprocal_poly (degree P) P = reflect_poly P\"", "lemma degree_reciprocal:\n  fixes P :: \"('a::zero) poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"degree (reciprocal_poly p P) \\<le> p\"", "lemma reciprocal_0_iff: \n  assumes hP: \"degree P \\<le> p\" \n  shows \"(reciprocal_poly p P = 0) = (P = 0)\"", "lemma poly_reciprocal: \n  fixes P::\"'a::field poly\"\n  assumes hp: \"degree P \\<le> p\" and hx: \"x \\<noteq> 0\"\n  shows \"poly (reciprocal_poly p P) x = x^p * (poly P (inverse x))\"", "lemma reciprocal_fcompose: \n  fixes P::\"('a::{ring_char_0,field}) poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p P = monom 1 (p - degree P) * fcompose P 1 [:0, 1:]\"", "lemma reciprocal_reciprocal: \n  fixes P :: \"'a::{field,ring_char_0} poly\"\n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p (reciprocal_poly p P) = P\"", "lemma reciprocal_smult: \n  fixes P :: \"'a::idom poly\" \n  assumes h: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\"", "lemma reciprocal_add: \n  fixes P Q :: \"'a::comm_semiring_0 poly\"\n  assumes \"degree P \\<le> p\" and \"degree Q \\<le> p\" \n  shows \"reciprocal_poly p (P + Q) = reciprocal_poly p P + reciprocal_poly p Q\" \n(is \"?L = ?R\")", "lemma reciprocal_diff: \n  fixes P Q :: \"'a::comm_ring poly\"\n  assumes \"degree P \\<le> p\" and \"degree Q \\<le> p\" \n  shows \"reciprocal_poly p (P - Q) = reciprocal_poly p P - reciprocal_poly p Q\"", "lemma reciprocal_sum: \n  fixes P :: \"'a \\<Rightarrow> 'b::comm_semiring_0 poly\" \n  assumes hP: \"\\<And>k. degree (P k) \\<le> p\"\n  shows \"reciprocal_poly p (\\<Sum>k\\<in>A. P k) = (\\<Sum>k\\<in>A. reciprocal_poly p (P k))\"", "lemma reciprocal_mult: \n  fixes P Q::\"'a::{ring_char_0,field} poly\" \n  assumes \"degree (P * Q) \\<le> p\"\n    and \"degree P \\<le> p\" and \"degree Q \\<le> p\"\n  shows \"monom 1 p * reciprocal_poly p (P * Q) = \n         reciprocal_poly p P * reciprocal_poly p Q\"", "lemma reciprocal_reflect_poly: \n  fixes P::\"'a::{ring_char_0,field} poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p P = monom 1 (p - degree P) * reflect_poly P\"", "lemma map_poly_reciprocal: \n  assumes \"degree P \\<le> p\" and \"f 0 = 0\" \n  shows \"map_poly f (reciprocal_poly p P)  = reciprocal_poly p (map_poly f P)\"", "lemma proots_count_monom: \n  assumes \"0 \\<notin> A\" \n  shows \"proots_count (monom 1 d) A = 0\"", "lemma proots_count_reciprocal: \n  fixes P::\"'a::{ring_char_0,field} poly\"\n  assumes hP: \"degree P \\<le> p\" and h0: \"P \\<noteq> 0\" and h0': \"0 \\<notin> A\"\n  shows \"proots_count (reciprocal_poly p P) A = proots_count P {x. inverse x \\<in> A}\"", "lemma proots_count_reciprocal': \n  fixes P::\"real poly\"\n  assumes hP: \"degree P \\<le> p\" and h0: \"P \\<noteq> 0\"\n  shows \"proots_count P {x. 0 < x \\<and> x < 1} = \n         proots_count (reciprocal_poly p P) {x. 1 < x}\"", "lemma proots_count_pos: \n  assumes \"proots_count P S > 0\" \n  shows \"\\<exists>x \\<in> S. poly P x = 0\"", "lemma proots_count_of_root_set: \n  assumes \"P \\<noteq> 0\" \"R \\<subseteq> S\" and \"\\<And>x. x\\<in>R \\<Longrightarrow> poly P x = 0\"\n  shows \"proots_count P S \\<ge> card R\"", "lemma proots_count_of_root: assumes \"P \\<noteq> 0\" \"x\\<in>S\" \"poly P x = 0\"\n  shows \"proots_count P S > 0\"", "lemma changes_nonneg: \"0 \\<le> changes xs\"", "lemma changes_replicate_0: shows \"changes (replicate n 0) = 0\"", "lemma changes_append_replicate_0: \"changes (xs @ replicate n 0) = changes xs\"", "lemma changes_scale_Cons: \n  fixes xs:: \"real list\" assumes hs: \"s > 0\"\n  shows \"changes (s * x # xs) = changes (x # xs)\"", "lemma changes_scale: \n  fixes xs::\"('a::linordered_idom) list\"\n  assumes hs: \"\\<And>i. i < n \\<Longrightarrow> s i > 0\" and hn: \"length xs \\<le> n\"\n  shows \"changes [s i * (nth_default 0 xs i). i \\<leftarrow> [0..<n]] = changes xs\"", "lemma changes_scale_const: fixes xs::\"'a::linordered_idom list\" \n  assumes hs: \"s \\<noteq> 0\"\n  shows \"changes (map ((*) s) xs) = changes xs\"", "lemma changes_snoc: fixes xs::\"'a::linordered_idom list\" \n  shows \"changes (xs @ [b, a]) = (if a * b < 0 then 1 + changes (xs @ [b])\n         else if b = 0 then changes (xs @ [a]) else changes (xs @ [b]))\"", "lemma changes_rev: fixes xs:: \"'a::linordered_idom list\" \n  shows \"changes (rev xs) = changes xs\"", "lemma changes_rev_about: fixes xs:: \"'a::linordered_idom list\" \n  shows \"changes (replicate (p - length xs) 0 @ rev xs) = changes xs\"", "lemma changes_add_between: \n  assumes \"a \\<le> x\" and \"x \\<le> b\"\n  shows \"changes (as @ [a, b] @ bs) = changes (as @ [a, x, b] @ bs)\"", "lemma changes_all_nonneg: assumes \"\\<And>i. nth_default 0 xs i \\<ge> 0\" shows \"changes xs = 0\"", "lemma changes_pCons: \"changes (coeffs (pCons 0 f)) = changes (coeffs f)\"", "lemma changes_increasing: \n  assumes \"\\<And>i. i < length xs - 1 \\<Longrightarrow> xs ! (i + 1) \\<ge> xs ! i\" \n    and \"length xs > 1\"\n    and \"hd xs < 0\" \n    and \"last xs > 0\"\n  shows \"changes xs = 1\""], "translations": [["", "lemma Setcompr_subset: \"\\<And>f P S. {f x | x. P x} \\<subseteq> S = (\\<forall> x. P x \\<longrightarrow> f x \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f P S.\n       ({f x |x. P x} \\<subseteq> S) =\n       (\\<forall>x. P x \\<longrightarrow> f x \\<in> S)", "by blast"], ["", "lemma map_cong':\n  assumes \"xs = map h ys\" and \"\\<And>y. y \\<in> set ys \\<Longrightarrow> f (h y) = g y\"\n  shows \"map f xs = map g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = map g ys", "using assms map_replicate_trivial"], ["proof (prove)\nusing this:\n  xs = map h ys\n  ?y \\<in> set ys \\<Longrightarrow> f (h ?y) = g ?y\n  map (\\<lambda>i. ?x) [0..<?i] = replicate ?i ?x\n\ngoal (1 subgoal):\n 1. map f xs = map g ys", "by simp"], ["", "lemma nth_default_replicate_eq: \n    \"nth_default dflt (replicate n x) i = (if i < n then x else dflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default dflt (replicate n x) i = (if i < n then x else dflt)", "by (auto simp: nth_default_def)"], ["", "lemma square_bounded_less: \n  fixes a b::\"'a :: linordered_ring_strict\"\n  shows \"-a < b \\<and> b < a \\<Longrightarrow> b*b < a*a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a < b \\<and> b < a \\<Longrightarrow> b * b < a * a", "by (metis (no_types, lifting) leD leI minus_less_iff minus_mult_minus mult_strict_mono'\n      neg_less_eq_nonneg neg_less_pos verit_minus_simplify(4) zero_le_mult_iff zero_le_square)"], ["", "lemma square_bounded_le: \n  fixes a b::\"'a :: linordered_ring_strict\"\n  shows \"-a \\<le> b \\<and> b \\<le> a \\<Longrightarrow> b*b \\<le> a*a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<le> b \\<and> b \\<le> a \\<Longrightarrow> b * b \\<le> a * a", "by (metis le_less minus_mult_minus square_bounded_less)"], ["", "context vector_space\nbegin"], ["", "lemma card_le_dim_spanning:\n  assumes BV: \"B \\<subseteq> V\"\n    and VB: \"V \\<subseteq> span B\"\n    and fB: \"finite B\"\n    and dVB: \"dim V \\<ge> card B\"\n  shows \"independent B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.independent B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.independent B", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. local.independent B", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. local.independent B", "assume a: \"a \\<in> B\" \"a \\<in> span (B - {a})\""], ["proof (state)\nthis:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "from a fB"], ["proof (chain)\npicking this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n  finite B", "have c0: \"card B \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n  finite B\n\ngoal (1 subgoal):\n 1. card B \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.independent B", "from a fB"], ["proof (chain)\npicking this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n  finite B", "have cb: \"card (B - {a}) = card B - 1\""], ["proof (prove)\nusing this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n  finite B\n\ngoal (1 subgoal):\n 1. card (B - {a}) = card B - 1", "by auto"], ["proof (state)\nthis:\n  card (B - {a}) = card B - 1\n\ngoal (1 subgoal):\n 1. local.independent B", "{"], ["proof (state)\nthis:\n  card (B - {a}) = card B - 1\n\ngoal (1 subgoal):\n 1. local.independent B", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. local.independent B", "assume x: \"x \\<in> V\""], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. local.independent B", "from a"], ["proof (chain)\npicking this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})", "have eq: \"insert a (B - {a}) = B\""], ["proof (prove)\nusing this:\n  a \\<in> B\n  a \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. insert a (B - {a}) = B", "by blast"], ["proof (state)\nthis:\n  insert a (B - {a}) = B\n\ngoal (1 subgoal):\n 1. local.independent B", "from x VB"], ["proof (chain)\npicking this:\n  x \\<in> V\n  V \\<subseteq> local.span B", "have x': \"x \\<in> span B\""], ["proof (prove)\nusing this:\n  x \\<in> V\n  V \\<subseteq> local.span B\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "by blast"], ["proof (state)\nthis:\n  x \\<in> local.span B\n\ngoal (1 subgoal):\n 1. local.independent B", "from span_trans[OF a(2), unfolded eq, OF x']"], ["proof (chain)\npicking this:\n  x \\<in> local.span (B - {a})", "have \"x \\<in> span (B - {a})\""], ["proof (prove)\nusing this:\n  x \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. x \\<in> local.span (B - {a})", "."], ["proof (state)\nthis:\n  x \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> V \\<Longrightarrow> ?x2 \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> V \\<Longrightarrow> ?x2 \\<in> local.span (B - {a})", "have th1: \"V \\<subseteq> span (B - {a})\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> V \\<Longrightarrow> ?x2 \\<in> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. V \\<subseteq> local.span (B - {a})", "by blast"], ["proof (state)\nthis:\n  V \\<subseteq> local.span (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "have th2: \"finite (B - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (B - {a})", "using fB"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite (B - {a})", "by auto"], ["proof (state)\nthis:\n  finite (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "from dim_le_card[OF th1 th2]"], ["proof (chain)\npicking this:\n  local.dim V \\<le> card (B - {a})", "have c: \"dim V \\<le> card (B - {a})\""], ["proof (prove)\nusing this:\n  local.dim V \\<le> card (B - {a})\n\ngoal (1 subgoal):\n 1. local.dim V \\<le> card (B - {a})", "."], ["proof (state)\nthis:\n  local.dim V \\<le> card (B - {a})\n\ngoal (1 subgoal):\n 1. local.independent B", "from c c0 dVB cb"], ["proof (chain)\npicking this:\n  local.dim V \\<le> card (B - {a})\n  card B \\<noteq> 0\n  card B \\<le> local.dim V\n  card (B - {a}) = card B - 1", "have False"], ["proof (prove)\nusing this:\n  local.dim V \\<le> card (B - {a})\n  card B \\<noteq> 0\n  card B \\<le> local.dim V\n  card (B - {a}) = card B - 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. local.independent B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 \\<in> B; ?a2 \\<in> local.span (B - {?a2})\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.independent B", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a2 \\<in> B; ?a2 \\<in> local.span (B - {?a2})\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a2 \\<in> B; ?a2 \\<in> local.span (B - {?a2})\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.independent B", "unfolding dependent_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a2 \\<in> B; ?a2 \\<in> local.span (B - {?a2})\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>B. a \\<in> local.span (B - {a}))", "by blast"], ["proof (state)\nthis:\n  local.independent B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Misc results about polynomials\\<close>"], ["", "lemma smult_power: \"smult (x^n) (p^n) = smult x p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (x ^ n) (p ^ n) = smult x p ^ n", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. smult (x ^ 0) (p ^ 0) = smult x p ^ 0\n 2. \\<And>n.\n       smult (x ^ n) (p ^ n) = smult x p ^ n \\<Longrightarrow>\n       smult (x ^ Suc n) (p ^ Suc n) = smult x p ^ Suc n", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (x ^ 0) (p ^ 0) = smult x p ^ 0", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       smult (x ^ n) (p ^ n) = smult x p ^ n \\<Longrightarrow>\n       smult (x ^ Suc n) (p ^ Suc n) = smult x p ^ Suc n", "by (metis (no_types, hide_lams) mult_smult_left mult_smult_right \n      power_Suc smult_smult)"], ["", "lemma reflect_poly_monom: \"reflect_poly (monom n i) = monom n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (monom n i) = monom n 0", "apply (induction i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. reflect_poly (monom n 0) = monom n 0\n 2. \\<And>i.\n       reflect_poly (monom n i) = monom n 0 \\<Longrightarrow>\n       reflect_poly (monom n (Suc i)) = monom n 0", "by (auto simp: coeffs_eq_iff coeffs_monom coeffs_reflect_poly)"], ["", "lemma poly_eq_by_eval: \n  fixes P Q :: \"'a::{comm_ring_1,ring_no_zero_divisors,ring_char_0} poly\"\n  assumes h: \"\\<And>x. poly P x = poly Q x\" shows \"P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P = Q", "have \"poly P = poly Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly P = poly Q", "using h"], ["proof (prove)\nusing this:\n  poly P ?x = poly Q ?x\n\ngoal (1 subgoal):\n 1. poly P = poly Q", "by fast"], ["proof (state)\nthis:\n  poly P = poly Q\n\ngoal (1 subgoal):\n 1. P = Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly P = poly Q\n\ngoal (1 subgoal):\n 1. P = Q", "by (auto simp: poly_eq_poly_eq_iff)"], ["proof (state)\nthis:\n  P = Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_binomial: \n  \"[:(1::'a::comm_ring_1), 1:]^n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "have \"[:(1::'a::comm_ring_1), 1:]^n = (monom 1 1 + 1)^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (monom (1::'a) 1 + 1) ^ n", "by (metis (no_types, lifting) add.left_neutral add.right_neutral add_pCons\n        monom_altdef pCons_one power_one_right smult_1_left)"], ["proof (state)\nthis:\n  [:1::'a, 1::'a:] ^ n = (monom (1::'a) 1 + 1) ^ n\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "also"], ["proof (state)\nthis:\n  [:1::'a, 1::'a:] ^ n = (monom (1::'a) 1 + 1) ^ n\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "have \"... = (\\<Sum>k\\<le>n. of_nat (n choose k) * monom 1 1 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monom (1::'a) 1 + 1) ^ n =\n    (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k)", "apply (subst binomial_ring)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n.\n        of_nat (n choose k) * monom (1::'a) 1 ^ k * 1 ^ (n - k)) =\n    (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k)", "by force"], ["proof (state)\nthis:\n  (monom (1::'a) 1 + 1) ^ n =\n  (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k)\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "also"], ["proof (state)\nthis:\n  (monom (1::'a) 1 + 1) ^ n =\n  (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k)\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "have \"... = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k) =\n    (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "by (auto simp: monom_altdef of_nat_poly)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n. of_nat (n choose k) * monom (1::'a) 1 ^ k) =\n  (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "finally"], ["proof (chain)\npicking this:\n  [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "show ?thesis"], ["proof (prove)\nusing this:\n  [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\n\ngoal (1 subgoal):\n 1. [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)", "."], ["proof (state)\nthis:\n  [:1::'a, 1::'a:] ^ n = (\\<Sum>k\\<le>n. monom (of_nat (n choose k)) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_0_iff: \"degree P = 0 \\<longleftrightarrow> (\\<exists>a. P = [:a:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree P = 0) = (\\<exists>a. P = [:a:])", "by (meson degree_eq_zeroE degree_pCons_0)"], ["", "interpretation poly_vs: vector_space smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space smult", "by (simp add: vector_space_def smult_add_right smult_add_left)"], ["", "lemma degree_subspace: \"poly_vs.subspace {x. degree x \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_vs.subspace {x. degree x \\<le> n}", "by (auto simp: poly_vs.subspace_def degree_add_le)"], ["", "lemma monom_span: \n  \"poly_vs.span {monom 1 x | x. x \\<le> p} = {(x::'a::field poly). degree x \\<le> p}\"\n(is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_vs.span {monom (1::'a) x |x. x \\<le> p} = {x. degree x \\<le> p}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n    \\<subseteq> {x. degree x \\<le> p}\n 2. {x. degree x \\<le> p}\n    \\<subseteq> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "show \"?L \\<subseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n    \\<subseteq> {x. degree x \\<le> p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "assume \"x \\<in> ?L\""], ["proof (state)\nthis:\n  x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "moreover"], ["proof (state)\nthis:\n  x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "have hfin: \"finite {P. \\<exists>x \\<in> {..p}. P = monom 1 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {P. \\<exists>x\\<in>{..p}. P = monom (1::'b) x}", "by auto"], ["proof (state)\nthis:\n  finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b1) x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n  finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b1) x}", "have \n      \"x \\<in> range (\\<lambda>u. \\<Sum>v\\<in>{monom 1 x | x. x \\<in> {..p}}. smult (u v) v)\""], ["proof (prove)\nusing this:\n  x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n  finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b1) x}\n\ngoal (1 subgoal):\n 1. x \\<in> range\n             (\\<lambda>u.\n                 \\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n                   smult (u v) v)", "by (simp add: poly_vs.span_finite)"], ["proof (state)\nthis:\n  x \\<in> range\n           (\\<lambda>u.\n               \\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n                 smult (u v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "hence \"\\<exists> u. x = (\\<Sum>v\\<in>{monom 1 x | x. x \\<in> {..p}}. smult (u v) v)\""], ["proof (prove)\nusing this:\n  x \\<in> range\n           (\\<lambda>u.\n               \\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n                 smult (u v) v)\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       x = (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}. smult (u v) v)", "by (auto simp: image_iff)"], ["proof (state)\nthis:\n  \\<exists>u.\n     x = (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}. smult (u v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     x = (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}. smult (u v) v)", "obtain u \n      where p': \"x = (\\<Sum>v\\<in>{monom 1 x | x. x \\<in> {..p}}. smult (u v) v)\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     x = (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}. smult (u v) v)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        x =\n        (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n           smult (u v) v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}. smult (u v) v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "have \"\\<And>v. v \\<in> {monom 1 x | x. x \\<in> {..p}} \\<Longrightarrow> degree (smult (u v) v) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       degree (smult (u v) v) \\<le> p", "by (auto simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  ?v1 \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n  degree (smult (u ?v1) ?v1) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "hence \"degree x \\<le> p\""], ["proof (prove)\nusing this:\n  ?v1 \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n  degree (smult (u ?v1) ?v1) \\<le> p\n\ngoal (1 subgoal):\n 1. degree x \\<le> p", "using hfin"], ["proof (prove)\nusing this:\n  ?v1 \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n  degree (smult (u ?v1) ?v1) \\<le> p\n  finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b1) x}\n\ngoal (1 subgoal):\n 1. degree x \\<le> p", "apply (subst p')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                v \\<in> {monom (1::'a) x |x.\n                         x \\<in> {..p}} \\<Longrightarrow>\n                degree (smult (u v) v) \\<le> p;\n     finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b4) x}\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n                          smult (u v) v)\n                      \\<le> p", "apply (rule degree_sum_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                v \\<in> {monom (1::'a) x |x.\n                         x \\<in> {..p}} \\<Longrightarrow>\n                degree (smult (u v) v) \\<le> p;\n     finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b4) x}\\<rbrakk>\n    \\<Longrightarrow> finite {monom (1::'a) x |x. x \\<in> {..p}}\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> {monom (1::'a) x |x.\n                            x \\<in> {..p}} \\<Longrightarrow>\n                   degree (smult (u v) v) \\<le> p;\n        finite {P. \\<exists>x\\<in>{..p}. P = monom (1::?'b4) x};\n        pa \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\\<rbrakk>\n       \\<Longrightarrow> degree (smult (u pa) pa) \\<le> p", "by auto"], ["proof (state)\nthis:\n  degree x \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> poly_vs.span\n                {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       x \\<in> {x. degree x \\<le> p}", "thus \"x \\<in> {x. degree x \\<le> p}\""], ["proof (prove)\nusing this:\n  degree x \\<le> p\n\ngoal (1 subgoal):\n 1. x \\<in> {x. degree x \\<le> p}", "by force"], ["proof (state)\nthis:\n  x \\<in> {x. degree x \\<le> p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n  \\<subseteq> {x. degree x \\<le> p}\n\ngoal (1 subgoal):\n 1. {x. degree x \\<le> p}\n    \\<subseteq> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. degree x \\<le> p}\n    \\<subseteq> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "show \"?R \\<subseteq> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. degree x \\<le> p}\n    \\<subseteq> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "assume \"x \\<in> ?R\""], ["proof (state)\nthis:\n  x \\<in> {x. degree x \\<le> p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "hence \"degree x \\<le> p\""], ["proof (prove)\nusing this:\n  x \\<in> {x. degree x \\<le> p}\n\ngoal (1 subgoal):\n 1. degree x \\<le> p", "by force"], ["proof (state)\nthis:\n  degree x \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "hence \"x = (\\<Sum>i\\<le>p. monom (coeff x i) i)\""], ["proof (prove)\nusing this:\n  degree x \\<le> p\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>i\\<le>p. monom (coeff x i) i)", "by (simp add: poly_as_sum_of_monoms')"], ["proof (state)\nthis:\n  x = (\\<Sum>i\\<le>p. monom (coeff x i) i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "also"], ["proof (state)\nthis:\n  x = (\\<Sum>i\\<le>p. monom (coeff x i) i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "have\n      \"... = (\\<Sum>i\\<le>p. smult (coeff x (degree (monom (1::'a) i))) (monom 1 i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>p. monom (coeff x i) i) =\n    (\\<Sum>i\\<le>p.\n        smult (coeff x (degree (monom (1::'a) i))) (monom (1::'a) i))", "by (auto simp add: smult_monom degree_monom_eq)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>p. monom (coeff x i) i) =\n  (\\<Sum>i\\<le>p.\n      smult (coeff x (degree (monom (1::'a) i))) (monom (1::'a) i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>p. monom (coeff x i) i) =\n  (\\<Sum>i\\<le>p.\n      smult (coeff x (degree (monom (1::'a) i))) (monom (1::'a) i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "have\n      \"... = (\\<Sum>v\\<in>{monom 1 x | x. x \\<in> {..p}}. smult ((\\<lambda>v. coeff x (degree v)) v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>p.\n        smult (coeff x (degree (monom (1::'a) i))) (monom (1::'a) i)) =\n    (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n       smult (coeff x (degree v)) v)", "proof (rule sum.reindex_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?l {monom (1::'a) x |x. x \\<in> {..p}}\n 2. {..p} = ?l ` {monom (1::'a) x |x. x \\<in> {..p}}\n 3. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (?l xa))))\n        (monom (1::'a) (?l xa)) =\n       smult (coeff x (degree xa)) xa", "show \"inj_on degree {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on degree {monom (1::'a) x |x. x \\<in> {..p}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (state)\nthis:\n  x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"\\<exists> a. x = monom 1 a\""], ["proof (prove)\nusing this:\n  x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<exists>a. x = monom (1::'a) a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. x = monom (1::'a) a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. x = monom (1::'a) a", "obtain a where hx: \"x = monom 1 a\""], ["proof (prove)\nusing this:\n  \\<exists>a. x = monom (1::'a) a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        x = monom (1::'a) a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = monom (1::'a) a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (state)\nthis:\n  y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"\\<exists> b. y = monom 1 b\""], ["proof (prove)\nusing this:\n  y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<exists>b. y = monom (1::'a) b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. y = monom (1::'a) b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. y = monom (1::'a) b", "obtain b where hy: \"y = monom 1 b\""], ["proof (prove)\nusing this:\n  \\<exists>b. y = monom (1::'a) b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        y = monom (1::'a) b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = monom (1::'a) b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"degree x = degree y\""], ["proof (state)\nthis:\n  degree x = degree y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        y \\<in> {monom (1::'a) x |x. x \\<in> {..p}};\n        degree x = degree y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  degree x = degree y\n\ngoal (1 subgoal):\n 1. x = y", "using hx hy"], ["proof (prove)\nusing this:\n  degree x = degree y\n  x = monom (1::'a) a\n  y = monom (1::'a) b\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on degree {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (2 subgoals):\n 1. {..p} = degree ` {monom (1::'a) x |x. x \\<in> {..p}}\n 2. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "show \"{..p} = degree ` {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..p} = degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<in> {..p}}\n 2. degree ` {monom (1::'a) x |x. x \\<in> {..p}} \\<subseteq> {..p}", "show \"{..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "assume \"x \\<in> {..p}\""], ["proof (state)\nthis:\n  x \\<in> {..p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "hence \"monom (1::'a) x \\<in> {monom 1 x |x. x \\<in> {..p}}\""], ["proof (prove)\nusing this:\n  x \\<in> {..p}\n\ngoal (1 subgoal):\n 1. monom (1::'a) x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}", "by force"], ["proof (state)\nthis:\n  monom (1::'a) x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "moreover"], ["proof (state)\nthis:\n  monom (1::'a) x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "have \"degree (monom (1::'a) x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) x) = x", "by (simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  degree (monom (1::'a) x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "ultimately"], ["proof (chain)\npicking this:\n  monom (1::'a) x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n  degree (monom (1::'a) x) = x", "show \"x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (prove)\nusing this:\n  monom (1::'a) x \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n  degree (monom (1::'a) x) = x\n\ngoal (1 subgoal):\n 1. x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}", "by auto"], ["proof (state)\nthis:\n  x \\<in> degree ` {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. degree ` {monom (1::'a) x |x. x \\<in> {..p}} \\<subseteq> {..p}", "show \"degree ` {monom (1::'a) x |x. x \\<in> {..p}} \\<subseteq> {..p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ` {monom (1::'a) x |x. x \\<in> {..p}} \\<subseteq> {..p}", "by (auto simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  degree ` {monom (1::'a) x |x. x \\<in> {..p}} \\<subseteq> {..p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {..p} = degree ` {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "assume \"y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\""], ["proof (state)\nthis:\n  y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "hence \"\\<exists>z \\<in> {..p}. y = monom (1::'a) z\""], ["proof (prove)\nusing this:\n  y \\<in> {monom (1::'a) x |x. x \\<in> {..p}}\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>{..p}. y = monom (1::'a) z", "by blast"], ["proof (state)\nthis:\n  \\<exists>z\\<in>{..p}. y = monom (1::'a) z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>{..p}. y = monom (1::'a) z", "obtain z where \"y = monom (1::'a) z\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>{..p}. y = monom (1::'a) z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        y = monom (1::'a) z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = monom (1::'a) z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {monom (1::'a) x |x. x \\<in> {..p}} \\<Longrightarrow>\n       smult (coeff x (degree (monom (1::'a) (degree xa))))\n        (monom (1::'a) (degree xa)) =\n       smult (coeff x (degree xa)) xa", "thus \n        \"smult (coeff x (degree (monom (1::'a) (degree y)))) (monom (1::'a) (degree y)) =\n         smult (coeff x (degree y)) y\""], ["proof (prove)\nusing this:\n  y = monom (1::'a) z\n\ngoal (1 subgoal):\n 1. smult (coeff x (degree (monom (1::'a) (degree y))))\n     (monom (1::'a) (degree y)) =\n    smult (coeff x (degree y)) y", "by (simp add: smult_monom degree_monom_eq)"], ["proof (state)\nthis:\n  smult (coeff x (degree (monom (1::'a) (degree y))))\n   (monom (1::'a) (degree y)) =\n  smult (coeff x (degree y)) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>p.\n      smult (coeff x (degree (monom (1::'a) i))) (monom (1::'a) i)) =\n  (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n     smult (coeff x (degree v)) v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "finally"], ["proof (chain)\npicking this:\n  x =\n  (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n     smult (coeff x (degree v)) v)", "have \"x = (\\<Sum>v\\<in>{monom 1 x | x. x \\<in> {..p}}. \n                      smult ((\\<lambda>v. coeff x (degree v)) v) v)\""], ["proof (prove)\nusing this:\n  x =\n  (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n     smult (coeff x (degree v)) v)\n\ngoal (1 subgoal):\n 1. x =\n    (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n       smult (coeff x (degree v)) v)", "."], ["proof (state)\nthis:\n  x =\n  (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n     smult (coeff x (degree v)) v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. degree x \\<le> p} \\<Longrightarrow>\n       x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "thus \"x \\<in> ?L\""], ["proof (prove)\nusing this:\n  x =\n  (\\<Sum>v\\<in>{monom (1::'a) x |x. x \\<in> {..p}}.\n     smult (coeff x (degree v)) v)\n\ngoal (1 subgoal):\n 1. x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}", "by (auto simp add: poly_vs.span_finite)"], ["proof (state)\nthis:\n  x \\<in> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. degree x \\<le> p}\n  \\<subseteq> poly_vs.span {monom (1::'a) x |x. x \\<le> p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monom_independent: \n  \"poly_vs.independent {monom (1::'a::field) x | x. x \\<le> p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_vs.independent {monom (1::'a) x |x. x \\<le> p}", "proof (rule poly_vs.independent_if_scalars_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "fix f::\"'a poly \\<Rightarrow> 'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "assume h: \"(\\<Sum>x\\<in>{monom 1 x |x. x \\<le> p}. smult (f x) x) = 0\""], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) = 0\n\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "have h': \"(\\<Sum>i\\<le>p. monom (f (monom (1::'a) i)) i) = \n            (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>p. monom (f (monom (1::'a) i)) i) =\n    (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x)", "proof (rule sum.reindex_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?l {monom (1::'a) x |x. x \\<le> p}\n 2. {..p} = ?l ` {monom (1::'a) x |x. x \\<le> p}\n 3. \\<And>x.\n       x \\<in> {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       monom (f (monom (1::'a) (?l x))) (?l x) = smult (f x) x", "show \"inj_on degree {monom (1::'a) x |x. x \\<le> p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on degree {monom (1::'a) x |x. x \\<le> p}", "by (smt (verit) degree_monom_eq inj_on_def mem_Collect_eq zero_neq_one)"], ["proof (state)\nthis:\n  inj_on degree {monom (1::'a) x |x. x \\<le> p}\n\ngoal (2 subgoals):\n 1. {..p} = degree ` {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>x.\n       x \\<in> {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       monom (f (monom (1::'a) (degree x))) (degree x) = smult (f x) x", "show \"{..p} = degree ` {monom (1::'a) x |x. x \\<le> p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..p} = degree ` {monom (1::'a) x |x. x \\<le> p}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<le> p}\n 2. degree ` {monom (1::'a) x |x. x \\<le> p} \\<subseteq> {..p}", "show \"{..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<le> p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<le> p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}", "assume \"x \\<in> {..p}\""], ["proof (state)\nthis:\n  x \\<in> {..p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {..p}", "have \"x = degree (monom (1::'a) x) \\<and> x \\<le> p\""], ["proof (prove)\nusing this:\n  x \\<in> {..p}\n\ngoal (1 subgoal):\n 1. x = degree (monom (1::'a) x) \\<and> x \\<le> p", "by (auto simp: degree_monom_eq)"], ["proof (state)\nthis:\n  x = degree (monom (1::'a) x) \\<and> x \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..p} \\<Longrightarrow>\n       x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}", "thus \"x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}\""], ["proof (prove)\nusing this:\n  x = degree (monom (1::'a) x) \\<and> x \\<le> p\n\ngoal (1 subgoal):\n 1. x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}", "by blast"], ["proof (state)\nthis:\n  x \\<in> degree ` {monom (1::'a) x |x. x \\<le> p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {..p} \\<subseteq> degree ` {monom (1::'a) x |x. x \\<le> p}\n\ngoal (1 subgoal):\n 1. degree ` {monom (1::'a) x |x. x \\<le> p} \\<subseteq> {..p}", "show \"degree ` {monom (1::'a) x |x. x \\<le> p} \\<subseteq> {..p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ` {monom (1::'a) x |x. x \\<le> p} \\<subseteq> {..p}", "by (force simp: degree_monom_eq)"], ["proof (state)\nthis:\n  degree ` {monom (1::'a) x |x. x \\<le> p} \\<subseteq> {..p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {..p} = degree ` {monom (1::'a) x |x. x \\<le> p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {monom (1::'a) x |x. x \\<le> p} \\<Longrightarrow>\n       monom (f (monom (1::'a) (degree x))) (degree x) = smult (f x) x", "qed (auto simp: degree_monom_eq smult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>p. monom (f (monom (1::'a) i)) i) =\n  (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x)\n\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "fix x::\"'a poly\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "assume \"x \\<in> {monom 1 x |x. x \\<le> p}\""], ["proof (state)\nthis:\n  x \\<in> {monom (1::'a) x |x. x \\<le> p}\n\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {monom (1::'a) x |x. x \\<le> p}", "obtain y where \"y \\<le> p\" and \"x = monom 1 y\""], ["proof (prove)\nusing this:\n  x \\<in> {monom (1::'a) x |x. x \\<le> p}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<le> p; x = monom (1::'a) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<le> p\n  x = monom (1::'a) y\n\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "hence \"f x = coeff (\\<Sum>x\\<in>{monom 1 x |x. x \\<le> p}. smult (f x) x) y\""], ["proof (prove)\nusing this:\n  y \\<le> p\n  x = monom (1::'a) y\n\ngoal (1 subgoal):\n 1. f x =\n    coeff (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) y", "by (auto simp: coeff_sum h'[symmetric])"], ["proof (state)\nthis:\n  f x = coeff (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) y\n\ngoal (2 subgoals):\n 1. finite {monom (1::'a) x |x. x \\<le> p}\n 2. \\<And>f x.\n       \\<lbrakk>(\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}.\n                   smult (f x) x) =\n                0;\n        x \\<in> {monom (1::'a) x |x. x \\<le> p}\\<rbrakk>\n       \\<Longrightarrow> f x = (0::'a)", "thus \"f x = 0\""], ["proof (prove)\nusing this:\n  f x = coeff (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) y\n\ngoal (1 subgoal):\n 1. f x = (0::'a)", "using h"], ["proof (prove)\nusing this:\n  f x = coeff (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) y\n  (\\<Sum>x\\<in>{monom (1::'a) x |x. x \\<le> p}. smult (f x) x) = 0\n\ngoal (1 subgoal):\n 1. f x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  f x = (0::'a)\n\ngoal (1 subgoal):\n 1. finite {monom (1::'a) x |x. x \\<le> p}", "qed force"], ["", "lemma dim_degree: \"poly_vs.dim {x. degree x \\<le> n} = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_vs.dim {x. degree x \\<le> n} = n + 1", "using poly_vs.dim_eq_card_independent[OF monom_independent]"], ["proof (prove)\nusing this:\n  poly_vs.dim {monom (1::?'a) x |x. x \\<le> ?p1} =\n  card {monom (1::?'a) x |x. x \\<le> ?p1}\n\ngoal (1 subgoal):\n 1. poly_vs.dim {x. degree x \\<le> n} = n + 1", "by (auto simp: monom_span[symmetric] card_image image_Collect[symmetric]\n      inj_on_def monom_eq_iff')"], ["", "lemma degree_div: \n  fixes p q::\"('a::idom_divide) poly\" \n  assumes \"q dvd p\"\n  shows \"degree (p div q) = degree p - degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p div q) = degree p - degree q", "using assms"], ["proof (prove)\nusing this:\n  q dvd p\n\ngoal (1 subgoal):\n 1. degree (p div q) = degree p - degree q", "by (metis (no_types, lifting) add_diff_cancel_left' degree_0 degree_mult_eq \n      diff_add_zero diff_zero div_by_0 dvd_div_eq_0_iff dvd_mult_div_cancel)"], ["", "lemma lead_coeff_div: \n  fixes p q::\"('a::{idom_divide, inverse}) poly\" \n  assumes \"q dvd p\"\n  shows \"lead_coeff (p div q) = lead_coeff p / lead_coeff q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (p div q) = lead_coeff p / lead_coeff q", "using assms"], ["proof (prove)\nusing this:\n  q dvd p\n\ngoal (1 subgoal):\n 1. lead_coeff (p div q) = lead_coeff p / lead_coeff q", "by (smt (z3) div_by_0 dvd_div_mult_self lead_coeff_mult leading_coeff_0_iff\n      nonzero_mult_div_cancel_right)"], ["", "lemma complex_poly_eq: \n  \"r = map_poly of_real (map_poly Re r) + smult \\<i> (map_poly of_real (map_poly Im r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r =\n    map_poly complex_of_real (map_poly Re r) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r))", "by (auto simp: poly_eq_iff coeff_map_poly complex_eq)"], ["", "lemma complex_poly_cong: \n  \"(map_poly Re p = map_poly Re q \\<and> map_poly Im p = map_poly Im q) = (p = q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly Re p = map_poly Re q \\<and> map_poly Im p = map_poly Im q) =\n    (p = q)", "by (metis complex_poly_eq)"], ["", "lemma map_poly_Im_of_real: \"map_poly Im (map_poly of_real p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly Im (map_poly complex_of_real p) = 0", "by (auto simp: poly_eq_iff coeff_map_poly)"], ["", "lemma mult_map_poly_imp_map_poly: \n  assumes \"map_poly complex_of_real q = r * map_poly complex_of_real p\" \n          \"p \\<noteq> 0\"\n  shows \"r = map_poly complex_of_real (map_poly Re r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "have h: \"Im \\<circ> (*) \\<i> \\<circ> complex_of_real = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im \\<circ> (*) \\<i> \\<circ> complex_of_real = id", "by fastforce"], ["proof (state)\nthis:\n  Im \\<circ> (*) \\<i> \\<circ> complex_of_real = id\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "have \"map_poly complex_of_real q = r * map_poly complex_of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real q = r * map_poly complex_of_real p", "using assms"], ["proof (prove)\nusing this:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q = r * map_poly complex_of_real p", "by blast"], ["proof (state)\nthis:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "also"], ["proof (state)\nthis:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "have \"... = (map_poly of_real (map_poly Re r) + \n                    smult \\<i> (map_poly of_real (map_poly Im r))) *\n                   map_poly complex_of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * map_poly complex_of_real p =\n    (map_poly complex_of_real (map_poly Re r) +\n     smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n    map_poly complex_of_real p", "using complex_poly_eq"], ["proof (prove)\nusing this:\n  ?r =\n  map_poly complex_of_real (map_poly Re ?r) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im ?r))\n\ngoal (1 subgoal):\n 1. r * map_poly complex_of_real p =\n    (map_poly complex_of_real (map_poly Re r) +\n     smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n    map_poly complex_of_real p", "by fastforce"], ["proof (state)\nthis:\n  r * map_poly complex_of_real p =\n  (map_poly complex_of_real (map_poly Re r) +\n   smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n  map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "also"], ["proof (state)\nthis:\n  r * map_poly complex_of_real p =\n  (map_poly complex_of_real (map_poly Re r) +\n   smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n  map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "have \"... = map_poly of_real (map_poly Re r * p) + \n                   smult \\<i> (map_poly of_real (map_poly Im r * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly complex_of_real (map_poly Re r) +\n     smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n    map_poly complex_of_real p =\n    map_poly complex_of_real (map_poly Re r * p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r * p))", "by (simp add: mult_poly_add_left)"], ["proof (state)\nthis:\n  (map_poly complex_of_real (map_poly Re r) +\n   smult \\<i> (map_poly complex_of_real (map_poly Im r))) *\n  map_poly complex_of_real p =\n  map_poly complex_of_real (map_poly Re r * p) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im r * p))\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "finally"], ["proof (chain)\npicking this:\n  map_poly complex_of_real q =\n  map_poly complex_of_real (map_poly Re r * p) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im r * p))", "have \"map_poly complex_of_real q = \n                map_poly of_real (map_poly Re r * p) + \n                smult \\<i> (map_poly of_real (map_poly Im r * p))\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real q =\n  map_poly complex_of_real (map_poly Re r * p) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im r * p))\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q =\n    map_poly complex_of_real (map_poly Re r * p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r * p))", "."], ["proof (state)\nthis:\n  map_poly complex_of_real q =\n  map_poly complex_of_real (map_poly Re r * p) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im r * p))\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "hence \"0 = map_poly Im (map_poly of_real (map_poly Re r * p) + \n             smult \\<i> (map_poly of_real (map_poly Im r * p)))\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real q =\n  map_poly complex_of_real (map_poly Re r * p) +\n  smult \\<i> (map_poly complex_of_real (map_poly Im r * p))\n\ngoal (1 subgoal):\n 1. 0 =\n    map_poly Im\n     (map_poly complex_of_real (map_poly Re r * p) +\n      smult \\<i> (map_poly complex_of_real (map_poly Im r * p)))", "by (auto simp: complex_poly_cong[symmetric] map_poly_Im_of_real)"], ["proof (state)\nthis:\n  0 =\n  map_poly Im\n   (map_poly complex_of_real (map_poly Re r * p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r * p)))\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "also"], ["proof (state)\nthis:\n  0 =\n  map_poly Im\n   (map_poly complex_of_real (map_poly Re r * p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r * p)))\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "have \"... = map_poly of_real (map_poly Im r * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly Im\n     (map_poly complex_of_real (map_poly Re r * p) +\n      smult \\<i> (map_poly complex_of_real (map_poly Im r * p))) =\n    map_poly of_real (map_poly Im r * p)", "apply (rule poly_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff\n        (map_poly Im\n          (map_poly complex_of_real (map_poly Re r * p) +\n           smult \\<i> (map_poly complex_of_real (map_poly Im r * p))))\n        n =\n       coeff (map_poly of_real (map_poly Im r * p)) n", "by (auto simp: coeff_map_poly coeff_mult)"], ["proof (state)\nthis:\n  map_poly Im\n   (map_poly complex_of_real (map_poly Re r * p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r * p))) =\n  map_poly of_real (map_poly Im r * p)\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "finally"], ["proof (chain)\npicking this:\n  0 = map_poly of_real (map_poly Im r * p)", "have \"0 = map_poly complex_of_real (map_poly Im r) *\n                    map_poly complex_of_real p\""], ["proof (prove)\nusing this:\n  0 = map_poly of_real (map_poly Im r * p)\n\ngoal (1 subgoal):\n 1. 0 =\n    map_poly complex_of_real (map_poly Im r) * map_poly complex_of_real p", "by auto"], ["proof (state)\nthis:\n  0 = map_poly complex_of_real (map_poly Im r) * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "hence \"map_poly complex_of_real (map_poly Im r) = 0\""], ["proof (prove)\nusing this:\n  0 = map_poly complex_of_real (map_poly Im r) * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real (map_poly Im r) = 0", "using assms"], ["proof (prove)\nusing this:\n  0 = map_poly complex_of_real (map_poly Im r) * map_poly complex_of_real p\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real (map_poly Im r) = 0", "by fastforce"], ["proof (state)\nthis:\n  map_poly complex_of_real (map_poly Im r) = 0\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_poly complex_of_real (map_poly Im r) = 0\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "apply (subst complex_poly_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (map_poly Im r) = 0 \\<Longrightarrow>\n    map_poly complex_of_real (map_poly Re r) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im r)) =\n    map_poly complex_of_real (map_poly Re r)", "by auto"], ["proof (state)\nthis:\n  r = map_poly complex_of_real (map_poly Re r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_dvd: \n  fixes p q::\"real poly\"\n  assumes hdvd: \"map_poly complex_of_real p dvd \n                    map_poly complex_of_real q\" \"q \\<noteq> 0\"\n  shows \"p dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd q", "from hdvd"], ["proof (chain)\npicking this:\n  map_poly complex_of_real p dvd map_poly complex_of_real q\n  q \\<noteq> 0", "obtain r \n    where h:\"map_poly complex_of_real q = r * map_poly complex_of_real p\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real p dvd map_poly complex_of_real q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        map_poly complex_of_real q =\n        r * map_poly complex_of_real p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. p dvd q", "hence \"r = map_poly complex_of_real (map_poly Re r)\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "using mult_map_poly_imp_map_poly assms"], ["proof (prove)\nusing this:\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n  \\<lbrakk>map_poly complex_of_real ?q = ?r * map_poly complex_of_real ?p;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?r = map_poly complex_of_real (map_poly Re ?r)\n  map_poly complex_of_real p dvd map_poly complex_of_real q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r = map_poly complex_of_real (map_poly Re r)", "by force"], ["proof (state)\nthis:\n  r = map_poly complex_of_real (map_poly Re r)\n\ngoal (1 subgoal):\n 1. p dvd q", "hence \"map_poly complex_of_real q = map_poly complex_of_real (p * map_poly Re r)\""], ["proof (prove)\nusing this:\n  r = map_poly complex_of_real (map_poly Re r)\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q =\n    map_poly complex_of_real (p * map_poly Re r)", "using h"], ["proof (prove)\nusing this:\n  r = map_poly complex_of_real (map_poly Re r)\n  map_poly complex_of_real q = r * map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q =\n    map_poly complex_of_real (p * map_poly Re r)", "by auto"], ["proof (state)\nthis:\n  map_poly complex_of_real q = map_poly complex_of_real (p * map_poly Re r)\n\ngoal (1 subgoal):\n 1. p dvd q", "hence \"q = p * map_poly Re r\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real q = map_poly complex_of_real (p * map_poly Re r)\n\ngoal (1 subgoal):\n 1. q = p * map_poly Re r", "using of_real_poly_eq_iff"], ["proof (prove)\nusing this:\n  map_poly complex_of_real q = map_poly complex_of_real (p * map_poly Re r)\n  (map_poly of_real ?p = map_poly of_real ?q) = (?p = ?q)\n\ngoal (1 subgoal):\n 1. q = p * map_poly Re r", "by blast"], ["proof (state)\nthis:\n  q = p * map_poly Re r\n\ngoal (1 subgoal):\n 1. p dvd q", "thus \"p dvd q\""], ["proof (prove)\nusing this:\n  q = p * map_poly Re r\n\ngoal (1 subgoal):\n 1. p dvd q", "by force"], ["proof (state)\nthis:\n  p dvd q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_poly_eq_0: \n  fixes p q::\"('a::idom_divide) poly\" \n  assumes \"q dvd p\" \"poly (p div q) x = 0\" \"q \\<noteq> 0\"\n  shows \"poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  q dvd p\n  poly (p div q) x = (0::'a)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x = (0::'a)", "by fastforce"], ["", "lemma poly_map_poly_of_real_cnj: \n    \"poly (map_poly of_real p) (cnj z) = cnj (poly (map_poly of_real p) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real p) (cnj z) =\n    cnj (poly (map_poly complex_of_real p) z)", "apply (induction p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly (map_poly complex_of_real 0) (cnj z) =\n    cnj (poly (map_poly complex_of_real 0) z)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (map_poly complex_of_real p) (cnj z) =\n        cnj (poly (map_poly complex_of_real p) z)\\<rbrakk>\n       \\<Longrightarrow> poly (map_poly complex_of_real (pCons a p))\n                          (cnj z) =\n                         cnj (poly (map_poly complex_of_real (pCons a p)) z)", "by auto"], ["", "text \\<open>\nAn induction rule on real polynomials, if $P \\neq 0$ then either $(X-x)|P$ or \n$(X-z)(X-cnj z)|P$, we induct by dividing by these polynomials.\n\\<close>"], ["", "lemma real_poly_roots_induct: \n  fixes P::\"real poly \\<Rightarrow> bool\" and p::\"real poly\"\n  assumes IH_real: \"\\<And>p x. P p \\<Longrightarrow> P (p * [:-x, 1:])\"\n      and IH_complex: \"\\<And>p a b. b \\<noteq> 0 \\<Longrightarrow> P p \n              \\<Longrightarrow> P (p * [: a*a + b*b, -2*a, 1 :])\"\n      and H0: \"\\<And>a. P [:a:]\"\n  defines \"d \\<equiv> degree p\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using d_def"], ["proof (prove)\nusing this:\n  d \\<equiv> degree p\n\ngoal (1 subgoal):\n 1. P p", "proof (induction d arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "fix p::\"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "assume IH: \"(\\<And>q. degree q < degree p \\<Longrightarrow> P q)\""], ["proof (state)\nthis:\n  degree ?q < degree p \\<Longrightarrow> P ?q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "show \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (cases \"0 = degree p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 = degree p \\<Longrightarrow> P p\n 2. 0 \\<noteq> degree p \\<Longrightarrow> P p", "fix p::\"real poly\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 = degree pa__ \\<Longrightarrow> P pa__\n 2. 0 \\<noteq> degree pa__ \\<Longrightarrow> P pa__", "assume \"0 = degree p\""], ["proof (state)\nthis:\n  0 = degree p\n\ngoal (2 subgoals):\n 1. 0 = degree pa__ \\<Longrightarrow> P pa__\n 2. 0 \\<noteq> degree pa__ \\<Longrightarrow> P pa__", "hence \"\\<exists> a. p = [:a:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n\ngoal (1 subgoal):\n 1. \\<exists>a. p = [:a:]", "by (simp add: degree_0_iff)"], ["proof (state)\nthis:\n  \\<exists>a. p = [:a:]\n\ngoal (2 subgoals):\n 1. 0 = degree pa__ \\<Longrightarrow> P pa__\n 2. 0 \\<noteq> degree pa__ \\<Longrightarrow> P pa__", "thus \"P p\""], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n\ngoal (1 subgoal):\n 1. P p", "using H0"], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n  P [:?a:]\n\ngoal (1 subgoal):\n 1. P p", "by blast"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> degree pa__ \\<Longrightarrow> P pa__", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<noteq> degree p \\<Longrightarrow> P p", "assume hdeg: \"0 \\<noteq> degree p\""], ["proof (state)\nthis:\n  0 \\<noteq> degree p\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> degree p \\<Longrightarrow> P p", "hence \"\\<not> constant (poly (map_poly of_real p))\""], ["proof (prove)\nusing this:\n  0 \\<noteq> degree p\n\ngoal (1 subgoal):\n 1. \\<not> constant (poly (map_poly of_real p))", "by (metis (no_types, hide_lams) constant_def constant_degree\n          of_real_eq_iff of_real_poly_map_poly)"], ["proof (state)\nthis:\n  \\<not> constant (poly (map_poly of_real p))\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> degree p \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  \\<not> constant (poly (map_poly of_real p))", "obtain z::complex where h: \"poly (map_poly of_real p) z = 0\""], ["proof (prove)\nusing this:\n  \\<not> constant (poly (map_poly of_real p))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        poly (map_poly complex_of_real p) z = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using fundamental_theorem_of_algebra"], ["proof (prove)\nusing this:\n  \\<not> constant (poly (map_poly of_real p))\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        poly (map_poly complex_of_real p) z = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real p) z = 0\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> degree p \\<Longrightarrow> P p", "show \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "assume \"Im z = 0\""], ["proof (state)\nthis:\n  Im z = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "hence \"z = Re z\""], ["proof (prove)\nusing this:\n  Im z = 0\n\ngoal (1 subgoal):\n 1. z = complex_of_real (Re z)", "by (simp add: complex_is_Real_iff)"], ["proof (state)\nthis:\n  z = complex_of_real (Re z)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  z = complex_of_real (Re z)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "have \"[:-z, 1:] dvd map_poly of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- z, 1:] dvd map_poly complex_of_real p", "using h poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real p) z = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- z, 1:] dvd map_poly complex_of_real p", "by blast"], ["proof (state)\nthis:\n  [:- z, 1:] dvd map_poly complex_of_real p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  z = complex_of_real (Re z)\n  [:- z, 1:] dvd map_poly complex_of_real p", "have \"[:-(Re z), 1:] dvd p\""], ["proof (prove)\nusing this:\n  z = complex_of_real (Re z)\n  [:- z, 1:] dvd map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. [:- Re z, 1:] dvd p", "by (smt (z3) dvd_iff_poly_eq_0 h of_real_0 of_real_eq_iff of_real_poly_map_poly)"], ["proof (state)\nthis:\n  [:- Re z, 1:] dvd p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "hence 2:\"P (p div [:-Re z, 1:])\""], ["proof (prove)\nusing this:\n  [:- Re z, 1:] dvd p\n\ngoal (1 subgoal):\n 1. P (p div [:- Re z, 1:])", "apply (subst IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:- Re z, 1:] dvd p \\<Longrightarrow>\n    degree (p div [:- Re z, 1:]) < degree p\n 2. [:- Re z, 1:] dvd p \\<Longrightarrow> True", "using hdeg"], ["proof (prove)\nusing this:\n  0 \\<noteq> degree p\n\ngoal (2 subgoals):\n 1. [:- Re z, 1:] dvd p \\<Longrightarrow>\n    degree (p div [:- Re z, 1:]) < degree p\n 2. [:- Re z, 1:] dvd p \\<Longrightarrow> True", "by (auto simp: degree_div)"], ["proof (state)\nthis:\n  P (p div [:- Re z, 1:])\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  P (p div [:- Re z, 1:])\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "have 1:\"p = (p div [:- Re z, 1:]) * [:-Re z, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p div [:- Re z, 1:] * [:- Re z, 1:]", "by (metis \\<open>[:- Re z, 1:] dvd p\\<close> dvd_div_mult_self)"], ["proof (state)\nthis:\n  p = p div [:- Re z, 1:] * [:- Re z, 1:]\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> P p\n 2. \\<not> ?P \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  P (p div [:- Re z, 1:])\n  p = p div [:- Re z, 1:] * [:- Re z, 1:]", "show \"P p\""], ["proof (prove)\nusing this:\n  P (p div [:- Re z, 1:])\n  p = p div [:- Re z, 1:] * [:- Re z, 1:]\n\ngoal (1 subgoal):\n 1. P p", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (p div [:- Re z, 1:]);\n     p = p div [:- Re z, 1:] * [:- Re z, 1:]\\<rbrakk>\n    \\<Longrightarrow> P (p div [:- Re z, 1:] * [:- Re z, 1:])", "by (rule IH_real[OF 2])"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "assume \"Im z \\<noteq> 0\""], ["proof (state)\nthis:\n  Im z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "hence hcnj: \"cnj z \\<noteq> z\""], ["proof (prove)\nusing this:\n  Im z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj z \\<noteq> z", "by (metis cnj.simps(2) neg_equal_zero)"], ["proof (state)\nthis:\n  cnj z \\<noteq> z\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "have h2: \"poly (map_poly of_real p) (cnj z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real p) (cnj z) = 0", "using h poly_map_poly_of_real_cnj"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real p) z = 0\n  poly (map_poly complex_of_real ?p) (cnj ?z) =\n  cnj (poly (map_poly complex_of_real ?p) ?z)\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real p) (cnj z) = 0", "by force"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real p) (cnj z) = 0\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "have \"[:-z, 1:] * [:-cnj z, 1:] dvd map_poly of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- z, 1:] * [:- cnj z, 1:] dvd map_poly complex_of_real p", "proof (rule divides_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. [:- z, 1:] dvd map_poly complex_of_real p\n 2. [:- cnj z, 1:] dvd map_poly complex_of_real p\n 3. coprime [:- z, 1:] [:- cnj z, 1:]", "have \"\\<And>c. c dvd [:-z, 1:] \\<Longrightarrow> c dvd [:- cnj z, 1:] \\<Longrightarrow> is_unit c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "assume h:\"c dvd [:-z, 1:]\""], ["proof (state)\nthis:\n  c dvd [:- z, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "hence \"degree c \\<le> 1\""], ["proof (prove)\nusing this:\n  c dvd [:- z, 1:]\n\ngoal (1 subgoal):\n 1. degree c \\<le> 1", "using divides_degree"], ["proof (prove)\nusing this:\n  c dvd [:- z, 1:]\n  ?p dvd ?q \\<Longrightarrow> degree ?p \\<le> degree ?q \\<or> ?q = 0\n\ngoal (1 subgoal):\n 1. degree c \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  degree c \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "hence \"degree c = 0 \\<or> degree c = 1\""], ["proof (prove)\nusing this:\n  degree c \\<le> 1\n\ngoal (1 subgoal):\n 1. degree c = 0 \\<or> degree c = 1", "by linarith"], ["proof (state)\nthis:\n  degree c = 0 \\<or> degree c = 1\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd [:- z, 1:]; c dvd [:- cnj z, 1:]\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "thus \"c dvd [:- cnj z, 1:] \\<Longrightarrow> is_unit c\""], ["proof (prove)\nusing this:\n  degree c = 0 \\<or> degree c = 1\n\ngoal (1 subgoal):\n 1. c dvd [:- cnj z, 1:] \\<Longrightarrow> is_unit c", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 0\\<rbrakk>\n    \\<Longrightarrow> is_unit c\n 2. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "assume \"degree c = 0\""], ["proof (state)\nthis:\n  degree c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 0\\<rbrakk>\n    \\<Longrightarrow> is_unit c\n 2. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "moreover"], ["proof (state)\nthis:\n  degree c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 0\\<rbrakk>\n    \\<Longrightarrow> is_unit c\n 2. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "have \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using h"], ["proof (prove)\nusing this:\n  c dvd [:- z, 1:]\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 0\\<rbrakk>\n    \\<Longrightarrow> is_unit c\n 2. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "ultimately"], ["proof (chain)\npicking this:\n  degree c = 0\n  c \\<noteq> 0", "show \"is_unit c\""], ["proof (prove)\nusing this:\n  degree c = 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit c", "by (simp add: is_unit_iff_degree)"], ["proof (state)\nthis:\n  is_unit c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "assume hdeg: \"degree c = 1\""], ["proof (state)\nthis:\n  degree c = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  degree c = 1", "obtain x where 1:\"[:-z, 1:] = x*c\""], ["proof (prove)\nusing this:\n  degree c = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x. [:- z, 1:] = x * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using h"], ["proof (prove)\nusing this:\n  degree c = 1\n  c dvd [:- z, 1:]\n\ngoal (1 subgoal):\n 1. (\\<And>x. [:- z, 1:] = x * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  [:- z, 1:] = x * c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "hence \"degree [:-z, 1:] = degree x + degree c\""], ["proof (prove)\nusing this:\n  [:- z, 1:] = x * c\n\ngoal (1 subgoal):\n 1. degree [:- z, 1:] = degree x + degree c", "by (metis add.inverse_neutral degree_mult_eq mult_cancel_right\n                  mult_poly_0_left pCons_eq_0_iff zero_neq_neg_one)"], ["proof (state)\nthis:\n  degree [:- z, 1:] = degree x + degree c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "hence \"degree x = 0\""], ["proof (prove)\nusing this:\n  degree [:- z, 1:] = degree x + degree c\n\ngoal (1 subgoal):\n 1. degree x = 0", "using hdeg"], ["proof (prove)\nusing this:\n  degree [:- z, 1:] = degree x + degree c\n  degree c = 1\n\ngoal (1 subgoal):\n 1. degree x = 0", "by auto"], ["proof (state)\nthis:\n  degree x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  degree x = 0", "obtain x' where 2: \"x = [:x':]\""], ["proof (prove)\nusing this:\n  degree x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = [:x':] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_0_iff"], ["proof (prove)\nusing this:\n  degree x = 0\n  (degree ?P = 0) = (\\<exists>a. ?P = [:a:])\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = [:x':] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = [:x':]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "assume \"c dvd [:-cnj z, 1:]\""], ["proof (state)\nthis:\n  c dvd [:- cnj z, 1:]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  c dvd [:- cnj z, 1:]", "obtain y where 3: \"[:-cnj z, 1:] = y*c\""], ["proof (prove)\nusing this:\n  c dvd [:- cnj z, 1:]\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        [:- cnj z, 1:] = y * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  [:- cnj z, 1:] = y * c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "hence \"degree [:-cnj z, 1:] = degree y + degree c\""], ["proof (prove)\nusing this:\n  [:- cnj z, 1:] = y * c\n\ngoal (1 subgoal):\n 1. degree [:- cnj z, 1:] = degree y + degree c", "by (metis add.inverse_neutral degree_mult_eq mult_cancel_right\n                  mult_poly_0_left pCons_eq_0_iff zero_neq_neg_one)"], ["proof (state)\nthis:\n  degree [:- cnj z, 1:] = degree y + degree c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "hence \"degree y = 0\""], ["proof (prove)\nusing this:\n  degree [:- cnj z, 1:] = degree y + degree c\n\ngoal (1 subgoal):\n 1. degree y = 0", "using hdeg"], ["proof (prove)\nusing this:\n  degree [:- cnj z, 1:] = degree y + degree c\n  degree c = 1\n\ngoal (1 subgoal):\n 1. degree y = 0", "by auto"], ["proof (state)\nthis:\n  degree y = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  degree y = 0", "obtain y' where 4: \"y = [:y':]\""], ["proof (prove)\nusing this:\n  degree y = 0\n\ngoal (1 subgoal):\n 1. (\\<And>y'. y = [:y':] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_0_iff"], ["proof (prove)\nusing this:\n  degree y = 0\n  (degree ?P = 0) = (\\<exists>a. ?P = [:a:])\n\ngoal (1 subgoal):\n 1. (\\<And>y'. y = [:y':] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y = [:y':]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "moreover"], ["proof (state)\nthis:\n  y = [:y':]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "from hdeg"], ["proof (chain)\npicking this:\n  degree c = 1", "obtain a b where 5:\"c = [:a, b:]\" and 6: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree c = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>c = [:a, b:]; b \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson degree_eq_oneE)"], ["proof (state)\nthis:\n  c = [:a, b:]\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "from 1 2 5 6"], ["proof (chain)\npicking this:\n  [:- z, 1:] = x * c\n  x = [:x':]\n  c = [:a, b:]\n  b \\<noteq> 0", "have \"x' = inverse b\""], ["proof (prove)\nusing this:\n  [:- z, 1:] = x * c\n  x = [:x':]\n  c = [:a, b:]\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x' = inverse b", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  x' = inverse b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "moreover"], ["proof (state)\nthis:\n  x' = inverse b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "from 3 4 5 6"], ["proof (chain)\npicking this:\n  [:- cnj z, 1:] = y * c\n  y = [:y':]\n  c = [:a, b:]\n  b \\<noteq> 0", "have \"y' = inverse b\""], ["proof (prove)\nusing this:\n  [:- cnj z, 1:] = y * c\n  y = [:y':]\n  c = [:a, b:]\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y' = inverse b", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  y' = inverse b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "ultimately"], ["proof (chain)\npicking this:\n  y = [:y':]\n  x' = inverse b\n  y' = inverse b", "have \"x = y\""], ["proof (prove)\nusing this:\n  y = [:y':]\n  x' = inverse b\n  y' = inverse b\n\ngoal (1 subgoal):\n 1. x = y", "using 2 4"], ["proof (prove)\nusing this:\n  y = [:y':]\n  x' = inverse b\n  y' = inverse b\n  x = [:x':]\n  y = [:y':]\n\ngoal (1 subgoal):\n 1. x = y", "by presburger"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "then"], ["proof (chain)\npicking this:\n  x = y", "have \"z = cnj z\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. z = cnj z", "using 1 3"], ["proof (prove)\nusing this:\n  x = y\n  [:- z, 1:] = x * c\n  [:- cnj z, 1:] = y * c\n\ngoal (1 subgoal):\n 1. z = cnj z", "by (metis neg_equal_iff_equal pCons_eq_iff)"], ["proof (state)\nthis:\n  z = cnj z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c dvd [:- cnj z, 1:]; degree c = 1\\<rbrakk>\n    \\<Longrightarrow> is_unit c", "thus \"is_unit c\""], ["proof (prove)\nusing this:\n  z = cnj z\n\ngoal (1 subgoal):\n 1. is_unit c", "using hcnj"], ["proof (prove)\nusing this:\n  z = cnj z\n  cnj z \\<noteq> z\n\ngoal (1 subgoal):\n 1. is_unit c", "by argo"], ["proof (state)\nthis:\n  is_unit c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c dvd [:- cnj z, 1:] \\<Longrightarrow> is_unit c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?c1 dvd [:- z, 1:]; ?c1 dvd [:- cnj z, 1:]\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c1\n\ngoal (3 subgoals):\n 1. [:- z, 1:] dvd map_poly complex_of_real p\n 2. [:- cnj z, 1:] dvd map_poly complex_of_real p\n 3. coprime [:- z, 1:] [:- cnj z, 1:]", "thus \"coprime [:- z, 1:] [:- cnj z, 1:]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?c1 dvd [:- z, 1:]; ?c1 dvd [:- cnj z, 1:]\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c1\n\ngoal (1 subgoal):\n 1. coprime [:- z, 1:] [:- cnj z, 1:]", "by (meson not_coprimeE)"], ["proof (state)\nthis:\n  coprime [:- z, 1:] [:- cnj z, 1:]\n\ngoal (2 subgoals):\n 1. [:- z, 1:] dvd map_poly complex_of_real p\n 2. [:- cnj z, 1:] dvd map_poly complex_of_real p", "show \"[:- z, 1:] dvd map_poly complex_of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- z, 1:] dvd map_poly complex_of_real p", "using h poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real p) z = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- z, 1:] dvd map_poly complex_of_real p", "by auto"], ["proof (state)\nthis:\n  [:- z, 1:] dvd map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. [:- cnj z, 1:] dvd map_poly complex_of_real p", "show \"[:- cnj z, 1:] dvd map_poly complex_of_real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- cnj z, 1:] dvd map_poly complex_of_real p", "using h2 poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real p) (cnj z) = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- cnj z, 1:] dvd map_poly complex_of_real p", "by blast"], ["proof (state)\nthis:\n  [:- cnj z, 1:] dvd map_poly complex_of_real p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:- z, 1:] * [:- cnj z, 1:] dvd map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  [:- z, 1:] * [:- cnj z, 1:] dvd map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "have \"[:- z, 1:] * [:- cnj z, 1:] = \n                     map_poly of_real [:Re z*Re z + Im z*Im z, -2*Re z, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- z, 1:] * [:- cnj z, 1:] =\n    map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]", "by (auto simp: complex_eqI)"], ["proof (state)\nthis:\n  [:- z, 1:] * [:- cnj z, 1:] =\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  [:- z, 1:] * [:- cnj z, 1:] dvd map_poly complex_of_real p\n  [:- z, 1:] * [:- cnj z, 1:] =\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]", "have hdvd: \n        \"map_poly complex_of_real [:Re z*Re z + Im z*Im z, -2*Re z, 1:] dvd\n         map_poly complex_of_real p\""], ["proof (prove)\nusing this:\n  [:- z, 1:] * [:- cnj z, 1:] dvd map_poly complex_of_real p\n  [:- z, 1:] * [:- cnj z, 1:] =\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real\n     [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd\n    map_poly complex_of_real p", "by force"], ["proof (state)\nthis:\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd\n  map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "hence \"[:Re z*Re z + Im z*Im z, -2*Re z, 1:] dvd p\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd\n  map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p", "using map_poly_dvd"], ["proof (prove)\nusing this:\n  map_poly complex_of_real [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd\n  map_poly complex_of_real p\n  \\<lbrakk>map_poly complex_of_real ?p dvd map_poly complex_of_real ?q;\n   ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?q\n\ngoal (1 subgoal):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p", "by blast"], ["proof (state)\nthis:\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "hence 2:\"P (p div [:Re z*Re z + Im z*Im z, -2*Re z, 1:])\""], ["proof (prove)\nusing this:\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p\n\ngoal (1 subgoal):\n 1. P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])", "apply (subst IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p \\<Longrightarrow>\n    degree (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]) < degree p\n 2. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p \\<Longrightarrow>\n    True", "using hdeg"], ["proof (prove)\nusing this:\n  0 \\<noteq> degree p\n\ngoal (2 subgoals):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p \\<Longrightarrow>\n    degree (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]) < degree p\n 2. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p \\<Longrightarrow>\n    True", "by (auto simp: degree_div)"], ["proof (state)\nthis:\n  P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "moreover"], ["proof (state)\nthis:\n  P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "have 1:\n        \"p = (p div [:Re z*Re z + Im z*Im z, -2*Re z, 1:]) * \n                    [:Re z*Re z + Im z*Im z, -2*Re z, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n    [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]", "apply (subst dvd_div_mult_self)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p\n 2. p = p", "using \\<open>[:Re z*Re z + Im z*Im z, -2*Re z, 1:] dvd p\\<close>"], ["proof (prove)\nusing this:\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p\n\ngoal (2 subgoals):\n 1. [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] dvd p\n 2. p = p", "by auto"], ["proof (state)\nthis:\n  p =\n  p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\n\ngoal (1 subgoal):\n 1. Im z \\<noteq> 0 \\<Longrightarrow> P p", "ultimately"], ["proof (chain)\npicking this:\n  P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])\n  p =\n  p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]", "show \"P p\""], ["proof (prove)\nusing this:\n  P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])\n  p =\n  p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n  [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\n\ngoal (1 subgoal):\n 1. P p", "apply (subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]);\n     p =\n     p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n     [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\\<rbrakk>\n    \\<Longrightarrow> P (p div\n                         [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n                         [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])", "apply (rule IH_complex[of  \"Im z\" _ \"Re z\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]);\n     p =\n     p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n     [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\\<rbrakk>\n    \\<Longrightarrow> Im z \\<noteq> 0\n 2. \\<lbrakk>P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]);\n     p =\n     p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n     [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\\<rbrakk>\n    \\<Longrightarrow> P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])", "apply (meson \\<open>Im z \\<noteq> 0\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]);\n     p =\n     p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:] *\n     [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:]\\<rbrakk>\n    \\<Longrightarrow> P (p div [:Re z * Re z + Im z * Im z, - 2 * Re z, 1:])", "by blast"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The reciprocal polynomial\\<close>"], ["", "definition reciprocal_poly :: \"nat \\<Rightarrow> 'a::zero poly \\<Rightarrow> 'a poly\"\n  where \"reciprocal_poly p P = \n          Poly (rev ((coeffs P) @ (replicate (p - degree P) 0)))\""], ["", "lemma reciprocal_0: \"reciprocal_poly p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p 0 = 0", "by (simp add: reciprocal_poly_def)"], ["", "lemma reciprocal_1: \"reciprocal_poly p 1 = monom 1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p 1 = monom (1::'a) p", "by (simp add: reciprocal_poly_def monom_altdef Poly_append)"], ["", "lemma coeff_reciprocal: \n  assumes hi: \"i \\<le> p\" and hP: \"degree P \\<le> p\"\n  shows \"coeff (reciprocal_poly p P) i = coeff P (p - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = coeff P (p - i)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = coeff P (p - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "assume \"i < p - degree P\""], ["proof (state)\nthis:\n  i < p - degree P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = coeff P (p - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "hence \"degree P < p - i\""], ["proof (prove)\nusing this:\n  i < p - degree P\n\ngoal (1 subgoal):\n 1. degree P < p - i", "using hP"], ["proof (prove)\nusing this:\n  i < p - degree P\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. degree P < p - i", "by linarith"], ["proof (state)\nthis:\n  degree P < p - i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = coeff P (p - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "thus \"coeff (reciprocal_poly p P) i = coeff P (p - i)\""], ["proof (prove)\nusing this:\n  degree P < p - i\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = coeff P (p - i)", "by (auto simp: reciprocal_poly_def nth_default_append coeff_eq_0)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = coeff P (p - i)\n\ngoal (1 subgoal):\n 1. \\<not> i < p - degree P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < p - degree P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "assume h: \"\\<not>i < p - degree P\""], ["proof (state)\nthis:\n  \\<not> i < p - degree P\n\ngoal (1 subgoal):\n 1. \\<not> i < p - degree P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "show \"coeff (reciprocal_poly p P) i = coeff P (p - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = coeff P (p - i)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = coeff P (p - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "assume \"P = 0\""], ["proof (state)\nthis:\n  P = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = coeff P (p - i)\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "thus \"coeff (reciprocal_poly p P) i = coeff P (p - i)\""], ["proof (prove)\nusing this:\n  P = 0\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = coeff P (p - i)", "by (simp add: reciprocal_0)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = coeff P (p - i)\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "assume hP': \"P \\<noteq> 0\""], ["proof (state)\nthis:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "have \"degree P \\<ge> p - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - i \\<le> degree P", "using h hP"], ["proof (prove)\nusing this:\n  \\<not> i < p - degree P\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. p - i \\<le> degree P", "by linarith"], ["proof (state)\nthis:\n  p - i \\<le> degree P\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "moreover"], ["proof (state)\nthis:\n  p - i \\<le> degree P\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "hence \"(i - (p - degree P)) < length (rev (coeffs P))\""], ["proof (prove)\nusing this:\n  p - i \\<le> degree P\n\ngoal (1 subgoal):\n 1. i - (p - degree P) < length (rev (coeffs P))", "using hP' hP hi"], ["proof (prove)\nusing this:\n  p - i \\<le> degree P\n  P \\<noteq> 0\n  degree P \\<le> p\n  i \\<le> p\n\ngoal (1 subgoal):\n 1. i - (p - degree P) < length (rev (coeffs P))", "by (auto simp: length_coeffs)"], ["proof (state)\nthis:\n  i - (p - degree P) < length (rev (coeffs P))\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow>\n    coeff (reciprocal_poly p P) i = coeff P (p - i)", "thus \"coeff (reciprocal_poly p P) i = coeff P (p - i)\""], ["proof (prove)\nusing this:\n  i - (p - degree P) < length (rev (coeffs P))\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = coeff P (p - i)", "by (auto simp: reciprocal_poly_def nth_default_append coeff_eq_0 hP hP' \n          nth_default_nth rev_nth calculation coeffs_nth length_coeffs_degree)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = coeff P (p - i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = coeff P (p - i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_reciprocal_less: \n  assumes hn: \"p < i\" and hP: \"degree P \\<le> p\"\n  shows \"coeff (reciprocal_poly p P) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = (0::'a)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)\n 2. \\<not> ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)", "assume \"P = 0\""], ["proof (state)\nthis:\n  P = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)\n 2. \\<not> ?P \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P = 0\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = (0::'a)", "by (auto simp: reciprocal_0)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = (0::'a)\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)", "assume \"P \\<noteq> 0\""], ["proof (state)\nthis:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0 \\<Longrightarrow> coeff (reciprocal_poly p P) i = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = (0::'a)", "using hn"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n  p < i\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) i = (0::'a)", "by (auto simp: reciprocal_poly_def nth_default_append \n        nth_default_eq_dflt_iff hP length_coeffs)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_monom: \n  assumes \"n \\<le> p\"\n  shows \"reciprocal_poly p (monom a n) = monom a (p-n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (monom a n) = monom a (p - n)", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)", "case True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)", "then"], ["proof (chain)\npicking this:\n  a = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (monom a n) = monom a (p - n)", "by (simp add: reciprocal_0)"], ["proof (state)\nthis:\n  reciprocal_poly p (monom a n) = monom a (p - n)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (monom a n) = monom a (p - n)", "with \\<open>n\\<le>p\\<close>"], ["proof (chain)\npicking this:\n  n \\<le> p\n  a \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> p\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (monom a n) = monom a (p - n)", "apply (rule_tac poly_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>n \\<le> p; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> coeff (reciprocal_poly p (monom a n)) na =\n                         coeff (monom a (p - n)) na", "by (metis coeff_monom coeff_reciprocal coeff_reciprocal_less \n        diff_diff_cancel diff_le_self lead_coeff_monom not_le_imp_less)"], ["proof (state)\nthis:\n  reciprocal_poly p (monom a n) = monom a (p - n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_degree: \"reciprocal_poly (degree P) P = reflect_poly P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly (degree P) P = reflect_poly P", "by (auto simp add: reciprocal_poly_def reflect_poly_def)"], ["", "lemma degree_reciprocal:\n  fixes P :: \"('a::zero) poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"degree (reciprocal_poly p P) \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (reciprocal_poly p P) \\<le> p", "proof (auto simp add: reciprocal_poly_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P)))\n    \\<le> p", "have \"degree (reciprocal_poly p P) \\<le> \n        length (replicate (p - degree P) (0::'a) @ rev (coeffs P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (reciprocal_poly p P)\n    \\<le> length (replicate (p - degree P) (0::'a) @ rev (coeffs P))", "by (metis degree_Poly reciprocal_poly_def rev_append rev_replicate)"], ["proof (state)\nthis:\n  degree (reciprocal_poly p P)\n  \\<le> length (replicate (p - degree P) (0::'a) @ rev (coeffs P))\n\ngoal (1 subgoal):\n 1. degree (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P)))\n    \\<le> p", "thus \"degree (Poly (replicate (p - degree P) 0 @ rev (coeffs P))) \\<le> p\""], ["proof (prove)\nusing this:\n  degree (reciprocal_poly p P)\n  \\<le> length (replicate (p - degree P) (0::'a) @ rev (coeffs P))\n\ngoal (1 subgoal):\n 1. degree (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P)))\n    \\<le> p", "by (smt Suc_le_mono add_Suc_right coeffs_Poly degree_0 hP le_SucE le_SucI \n        le_add_diff_inverse2 le_zero_eq length_append length_coeffs_degree\n        length_replicate length_rev length_strip_while_le reciprocal_0\n        reciprocal_poly_def rev_append rev_replicate)"], ["proof (state)\nthis:\n  degree (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_0_iff: \n  assumes hP: \"degree P \\<le> p\" \n  shows \"(reciprocal_poly p P = 0) = (P = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reciprocal_poly p P = 0) = (P = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. reciprocal_poly p P = 0 \\<Longrightarrow> P = 0\n 2. P = 0 \\<Longrightarrow> reciprocal_poly p P = 0", "assume h: \"reciprocal_poly p P = 0\""], ["proof (state)\nthis:\n  reciprocal_poly p P = 0\n\ngoal (2 subgoals):\n 1. reciprocal_poly p P = 0 \\<Longrightarrow> P = 0\n 2. P = 0 \\<Longrightarrow> reciprocal_poly p P = 0", "show \"P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = 0", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff P n = coeff 0 n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff P n = coeff 0 n", "show \"coeff P n = coeff 0 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff P n = coeff 0 n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff P n = coeff 0 n\n 2. \\<not> ?P \\<Longrightarrow> coeff P n = coeff 0 n", "assume hn: \"n \\<le> p\""], ["proof (state)\nthis:\n  n \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff P n = coeff 0 n\n 2. \\<not> ?P \\<Longrightarrow> coeff P n = coeff 0 n", "hence \"p - n \\<le> p\""], ["proof (prove)\nusing this:\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. p - n \\<le> p", "by auto"], ["proof (state)\nthis:\n  p - n \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff P n = coeff 0 n\n 2. \\<not> ?P \\<Longrightarrow> coeff P n = coeff 0 n", "hence \"coeff (reciprocal_poly p P) (p - n) = coeff P n\""], ["proof (prove)\nusing this:\n  p - n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) (p - n) = coeff P n", "using hP hn"], ["proof (prove)\nusing this:\n  p - n \\<le> p\n  degree P \\<le> p\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) (p - n) = coeff P n", "by (auto simp: coeff_reciprocal)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) (p - n) = coeff P n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> coeff P n = coeff 0 n\n 2. \\<not> ?P \\<Longrightarrow> coeff P n = coeff 0 n", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff (reciprocal_poly p P) (p - n) = coeff P n\n\ngoal (1 subgoal):\n 1. coeff P n = coeff 0 n", "using h"], ["proof (prove)\nusing this:\n  coeff (reciprocal_poly p P) (p - n) = coeff P n\n  reciprocal_poly p P = 0\n\ngoal (1 subgoal):\n 1. coeff P n = coeff 0 n", "by auto"], ["proof (state)\nthis:\n  coeff P n = coeff 0 n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow> coeff P n = coeff 0 n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow> coeff P n = coeff 0 n", "assume hn: \"\\<not> n \\<le> p\""], ["proof (state)\nthis:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow> coeff P n = coeff 0 n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff P n = coeff 0 n", "using hP"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. coeff P n = coeff 0 n", "by (metis coeff_0 dual_order.trans le_degree)"], ["proof (state)\nthis:\n  coeff P n = coeff 0 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff P n = coeff 0 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P = 0\n\ngoal (1 subgoal):\n 1. P = 0 \\<Longrightarrow> reciprocal_poly p P = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P = 0 \\<Longrightarrow> reciprocal_poly p P = 0", "assume \"P = 0\""], ["proof (state)\nthis:\n  P = 0\n\ngoal (1 subgoal):\n 1. P = 0 \\<Longrightarrow> reciprocal_poly p P = 0", "thus \"reciprocal_poly p P = 0\""], ["proof (prove)\nusing this:\n  P = 0\n\ngoal (1 subgoal):\n 1. reciprocal_poly p P = 0", "using reciprocal_0"], ["proof (prove)\nusing this:\n  P = 0\n  reciprocal_poly ?p 0 = 0\n\ngoal (1 subgoal):\n 1. reciprocal_poly p P = 0", "by fast"], ["proof (state)\nthis:\n  reciprocal_poly p P = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_reciprocal: \n  fixes P::\"'a::field poly\"\n  assumes hp: \"degree P \\<le> p\" and hx: \"x \\<noteq> 0\"\n  shows \"poly (reciprocal_poly p P) x = x^p * (poly P (inverse x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "have \"poly (reciprocal_poly p P) x\n      = poly ((Poly ((replicate (p - degree P) 0) @ rev (coeffs P)))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x =\n    poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x", "by (auto simp add: hx reflect_poly_def reciprocal_poly_def)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x =\n  poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "also"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x =\n  poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "have \"... = poly ((monom 1 (p - degree P)) * (reflect_poly P)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x =\n    poly (monom (1::'a) (p - degree P) * reflect_poly P) x", "by (auto simp add: reflect_poly_def Poly_append)"], ["proof (state)\nthis:\n  poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x =\n  poly (monom (1::'a) (p - degree P) * reflect_poly P) x\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "also"], ["proof (state)\nthis:\n  poly (Poly (replicate (p - degree P) (0::'a) @ rev (coeffs P))) x =\n  poly (monom (1::'a) (p - degree P) * reflect_poly P) x\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "have \"... = x^(p - degree P) *  x ^ degree P * poly P (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom (1::'a) (p - degree P) * reflect_poly P) x =\n    x ^ (p - degree P) * x ^ degree P * poly P (inverse x)", "by (auto simp add: poly_reflect_poly_nz poly_monom hx)"], ["proof (state)\nthis:\n  poly (monom (1::'a) (p - degree P) * reflect_poly P) x =\n  x ^ (p - degree P) * x ^ degree P * poly P (inverse x)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "also"], ["proof (state)\nthis:\n  poly (monom (1::'a) (p - degree P) * reflect_poly P) x =\n  x ^ (p - degree P) * x ^ degree P * poly P (inverse x)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "have \"... = x^p * poly P (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ (p - degree P) * x ^ degree P * poly P (inverse x) =\n    x ^ p * poly P (inverse x)", "by (auto simp add: hp power_add[symmetric])"], ["proof (state)\nthis:\n  x ^ (p - degree P) * x ^ degree P * poly P (inverse x) =\n  x ^ p * poly P (inverse x)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "finally"], ["proof (chain)\npicking this:\n  poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)", "."], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x = x ^ p * poly P (inverse x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_fcompose: \n  fixes P::\"('a::{ring_char_0,field}) poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p P = monom 1 (p - degree P) * fcompose P 1 [:0, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p P =\n    monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]", "proof (rule poly_eq_by_eval, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "fix x::'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "assume hx: \"x = 0\""], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "hence \"poly (reciprocal_poly p P) x = coeff P p\""], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = coeff P p", "using hP"], ["proof (prove)\nusing this:\n  x = (0::'a)\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x = coeff P p", "by (auto simp: poly_0_coeff_0 coeff_reciprocal)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x = coeff P p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "moreover"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x = coeff P p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "have \"poly (monom 1 (p - degree P) \n    * fcompose P 1 [:0, 1:]) x = coeff P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p\n 2. \\<not> ?P \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "assume \"degree P = p\""], ["proof (state)\nthis:\n  degree P = p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p\n 2. \\<not> ?P \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree P = p\n\ngoal (1 subgoal):\n 1. poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "apply (induction P arbitrary: p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       degree 0 = p \\<Longrightarrow>\n       poly (monom (1::'a) (p - degree 0) * fcompose 0 1 [:0::'a, 1::'a:])\n        x =\n       coeff 0 p\n 2. \\<And>a P p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> P \\<noteq> 0;\n        \\<And>p.\n           degree P = p \\<Longrightarrow>\n           poly\n            (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:])\n            x =\n           coeff P p;\n        degree (pCons a P) = p\\<rbrakk>\n       \\<Longrightarrow> poly\n                          (monom (1::'a) (p - degree (pCons a P)) *\n                           fcompose (pCons a P) 1 [:0::'a, 1::'a:])\n                          x =\n                         coeff (pCons a P) p", "using hx"], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       degree 0 = p \\<Longrightarrow>\n       poly (monom (1::'a) (p - degree 0) * fcompose 0 1 [:0::'a, 1::'a:])\n        x =\n       coeff 0 p\n 2. \\<And>a P p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> P \\<noteq> 0;\n        \\<And>p.\n           degree P = p \\<Longrightarrow>\n           poly\n            (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:])\n            x =\n           coeff P p;\n        degree (pCons a P) = p\\<rbrakk>\n       \\<Longrightarrow> poly\n                          (monom (1::'a) (p - degree (pCons a P)) *\n                           fcompose (pCons a P) 1 [:0::'a, 1::'a:])\n                          x =\n                         coeff (pCons a P) p", "by (auto simp: poly_monom degree_0_iff fcompose_pCons)"], ["proof (state)\nthis:\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n  coeff P p\n\ngoal (1 subgoal):\n 1. degree P \\<noteq> p \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree P \\<noteq> p \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "assume \"degree P \\<noteq> p\""], ["proof (state)\nthis:\n  degree P \\<noteq> p\n\ngoal (1 subgoal):\n 1. degree P \\<noteq> p \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "hence \"degree P < p\""], ["proof (prove)\nusing this:\n  degree P \\<noteq> p\n\ngoal (1 subgoal):\n 1. degree P < p", "using hP"], ["proof (prove)\nusing this:\n  degree P \\<noteq> p\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. degree P < p", "by auto"], ["proof (state)\nthis:\n  degree P < p\n\ngoal (1 subgoal):\n 1. degree P \\<noteq> p \\<Longrightarrow>\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree P < p\n\ngoal (1 subgoal):\n 1. poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "using hx"], ["proof (prove)\nusing this:\n  degree P < p\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n    coeff P p", "by (auto simp: poly_monom coeff_eq_0)"], ["proof (state)\nthis:\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n  coeff P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n  coeff P p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "ultimately"], ["proof (chain)\npicking this:\n  poly (reciprocal_poly p P) x = coeff P p\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n  coeff P p", "show \"poly (reciprocal_poly p P) x = poly (monom 1 (p - degree P) * fcompose P 1 [:0, 1:]) x\""], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p P) x = coeff P p\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x =\n  coeff P p\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x =\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "by presburger"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x =\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> (0::'a) \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> (0::'a) \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> (0::'a) \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> (0::'a) \\<Longrightarrow>\n       poly (reciprocal_poly p P) x =\n       poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "thus \"poly (reciprocal_poly p P) x = \n        poly (monom 1 (p - degree P) * fcompose P 1 [:0, 1:]) x\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x =\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "using hP"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p P) x =\n    poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x", "by (auto simp: poly_reciprocal poly_fcompose inverse_eq_divide\n        poly_monom power_diff)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p P) x =\n  poly (monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:]) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_reciprocal: \n  fixes P :: \"'a::{field,ring_char_0} poly\"\n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p (reciprocal_poly p P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (reciprocal_poly p P) = P", "proof (rule poly_eq_by_eval)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "show \"poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\n 2. \\<not> ?P \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "assume \"x = 0\""], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\n 2. \\<not> ?P \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "thus \"poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\""], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "using hP"], ["proof (prove)\nusing this:\n  x = (0::'a)\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "by (auto simp: poly_0_coeff_0 coeff_reciprocal degree_reciprocal)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "assume hx: \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "hence \"poly (reciprocal_poly p (reciprocal_poly p P)) x \n        = x ^ p * (inverse x ^ p * poly P x)\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x =\n    x ^ p * (inverse x ^ p * poly P x)", "using hP"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x =\n    x ^ p * (inverse x ^ p * poly P x)", "by (auto simp: poly_reciprocal degree_reciprocal)"], ["proof (state)\nthis:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x =\n  x ^ p * (inverse x ^ p * poly P x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "thus \"poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\""], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x =\n  x ^ p * (inverse x ^ p * poly P x)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "using hP hx left_right_inverse_power right_inverse"], ["proof (prove)\nusing this:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x =\n  x ^ p * (inverse x ^ p * poly P x)\n  degree P \\<le> p\n  x \\<noteq> (0::'a)\n  ?x * ?y = (1::?'a) \\<Longrightarrow> ?x ^ ?n * ?y ^ ?n = (1::?'a)\n  ?a \\<noteq> (0::?'a) \\<Longrightarrow> ?a * inverse ?a = (1::?'a)\n\ngoal (1 subgoal):\n 1. poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x", "by auto"], ["proof (state)\nthis:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (reciprocal_poly p (reciprocal_poly p P)) x = poly P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_smult: \n  fixes P :: \"'a::idom poly\" \n  assumes h: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\n 2. \\<not> ?P \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "assume \"n = 0\""], ["proof (state)\nthis:\n  n = (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\n 2. \\<not> ?P \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = (0::'a)\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "by (auto simp add: reciprocal_poly_def)"], ["proof (state)\nthis:\n  reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "assume \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)", "by (auto simp add: reciprocal_poly_def smult_Poly coeffs_smult \n        rev_map[symmetric])"], ["proof (state)\nthis:\n  reciprocal_poly p (smult n P) = smult n (reciprocal_poly p P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_add: \n  fixes P Q :: \"'a::comm_semiring_0 poly\"\n  assumes \"degree P \\<le> p\" and \"degree Q \\<le> p\" \n  shows \"reciprocal_poly p (P + Q) = reciprocal_poly p P + reciprocal_poly p Q\" \n(is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (P + Q) = reciprocal_poly p P + reciprocal_poly p Q", "proof (rule poly_eqI, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n\n 2. \\<And>n.\n       \\<not> ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n\n 2. \\<And>n.\n       \\<not> ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "assume \"n \\<le> p\""], ["proof (state)\nthis:\n  n \\<le> p\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n\n 2. \\<And>n.\n       \\<not> ?P2 n \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "then"], ["proof (chain)\npicking this:\n  n \\<le> p", "show \"coeff ?L n = coeff ?R n\""], ["proof (prove)\nusing this:\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p (P + Q)) n =\n    coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> p\n  degree P \\<le> p\n  degree Q \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p (P + Q)) n =\n    coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "by (auto simp: degree_add_le coeff_reciprocal)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p (P + Q)) n =\n  coeff (reciprocal_poly p P + reciprocal_poly p Q) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n \\<le> p \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n \\<le> p \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n \\<le> p \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "assume \"\\<not>n \\<le> p\""], ["proof (state)\nthis:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n \\<le> p \\<Longrightarrow>\n       coeff (reciprocal_poly p (P + Q)) n =\n       coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "then"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> p", "show \"coeff ?L n = coeff ?R n\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p (P + Q)) n =\n    coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "using assms"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n  degree P \\<le> p\n  degree Q \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p (P + Q)) n =\n    coeff (reciprocal_poly p P + reciprocal_poly p Q) n", "by (auto simp: degree_add_le coeff_reciprocal_less)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p (P + Q)) n =\n  coeff (reciprocal_poly p P + reciprocal_poly p Q) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_diff: \n  fixes P Q :: \"'a::comm_ring poly\"\n  assumes \"degree P \\<le> p\" and \"degree Q \\<le> p\" \n  shows \"reciprocal_poly p (P - Q) = reciprocal_poly p P - reciprocal_poly p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (P - Q) = reciprocal_poly p P - reciprocal_poly p Q", "by (metis (no_types, lifting) ab_group_add_class.ab_diff_conv_add_uminus assms\n      add_diff_cancel degree_add_le degree_minus diff_add_cancel reciprocal_add)"], ["", "lemma reciprocal_sum: \n  fixes P :: \"'a \\<Rightarrow> 'b::comm_semiring_0 poly\" \n  assumes hP: \"\\<And>k. degree (P k) \\<le> p\"\n  shows \"reciprocal_poly p (\\<Sum>k\\<in>A. P k) = (\\<Sum>k\\<in>A. reciprocal_poly p (P k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (sum P A) = (\\<Sum>k\\<in>A. reciprocal_poly p (P k))", "proof (induct A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       reciprocal_poly p (sum P A) =\n       (\\<Sum>k\\<in>A. reciprocal_poly p (P k))\n 2. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "case (infinite A)"], ["proof (state)\nthis:\n  infinite A\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       reciprocal_poly p (sum P A) =\n       (\\<Sum>k\\<in>A. reciprocal_poly p (P k))\n 2. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "then"], ["proof (chain)\npicking this:\n  infinite A", "show ?case"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (sum P A) = (\\<Sum>k\\<in>A. reciprocal_poly p (P k))", "by (simp add: reciprocal_0)"], ["proof (state)\nthis:\n  reciprocal_poly p (sum P A) = (\\<Sum>k\\<in>A. reciprocal_poly p (P k))\n\ngoal (2 subgoals):\n 1. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))", "by (simp add: reciprocal_0)"], ["proof (state)\nthis:\n  reciprocal_poly p (sum P {}) = (\\<Sum>k\\<in>{}. reciprocal_poly p (P k))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "assume \"x \\<notin> F\"\n     and \"reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\"\n     and \"finite F\""], ["proof (state)\nthis:\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "moreover"], ["proof (state)\nthis:\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "hence \"reciprocal_poly p (sum P (insert x F)) \n      = reciprocal_poly p (P x) + reciprocal_poly p (sum P F)\""], ["proof (prove)\nusing this:\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n  finite F\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (sum P (insert x F)) =\n    reciprocal_poly p (P x) + reciprocal_poly p (sum P F)", "by (auto simp add: reciprocal_add hP degree_sum_le)"], ["proof (state)\nthis:\n  reciprocal_poly p (sum P (insert x F)) =\n  reciprocal_poly p (P x) + reciprocal_poly p (sum P F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        reciprocal_poly p (sum P F) =\n        (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\\<rbrakk>\n       \\<Longrightarrow> reciprocal_poly p (sum P (insert x F)) =\n                         (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n  finite F\n  reciprocal_poly p (sum P (insert x F)) =\n  reciprocal_poly p (P x) + reciprocal_poly p (sum P F)", "show \"reciprocal_poly p (sum P (insert x F)) \n      = (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))\""], ["proof (prove)\nusing this:\n  x \\<notin> F\n  reciprocal_poly p (sum P F) = (\\<Sum>k\\<in>F. reciprocal_poly p (P k))\n  finite F\n  reciprocal_poly p (sum P (insert x F)) =\n  reciprocal_poly p (P x) + reciprocal_poly p (sum P F)\n\ngoal (1 subgoal):\n 1. reciprocal_poly p (sum P (insert x F)) =\n    (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))", "by (auto simp: Groups_Big.comm_monoid_add_class.sum.insert_if)"], ["proof (state)\nthis:\n  reciprocal_poly p (sum P (insert x F)) =\n  (\\<Sum>k\\<in>insert x F. reciprocal_poly p (P k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_mult: \n  fixes P Q::\"'a::{ring_char_0,field} poly\" \n  assumes \"degree (P * Q) \\<le> p\"\n    and \"degree P \\<le> p\" and \"degree Q \\<le> p\"\n  shows \"monom 1 p * reciprocal_poly p (P * Q) = \n         reciprocal_poly p P * reciprocal_poly p Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "proof (cases \"P=0 \\<or> Q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P = 0 \\<or> Q = 0 \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q\n 2. \\<not> (P = 0 \\<or> Q = 0) \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "case True"], ["proof (state)\nthis:\n  P = 0 \\<or> Q = 0\n\ngoal (2 subgoals):\n 1. P = 0 \\<or> Q = 0 \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q\n 2. \\<not> (P = 0 \\<or> Q = 0) \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "then"], ["proof (chain)\npicking this:\n  P = 0 \\<or> Q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  P = 0 \\<or> Q = 0\n\ngoal (1 subgoal):\n 1. monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "using assms(1)"], ["proof (prove)\nusing this:\n  P = 0 \\<or> Q = 0\n  degree (P * Q) \\<le> p\n\ngoal (1 subgoal):\n 1. monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "by (auto simp: reciprocal_fcompose fcompose_mult)"], ["proof (state)\nthis:\n  monom (1::'a) p * reciprocal_poly p (P * Q) =\n  reciprocal_poly p P * reciprocal_poly p Q\n\ngoal (1 subgoal):\n 1. \\<not> (P = 0 \\<or> Q = 0) \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (P = 0 \\<or> Q = 0) \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "case False"], ["proof (state)\nthis:\n  \\<not> (P = 0 \\<or> Q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (P = 0 \\<or> Q = 0) \\<Longrightarrow>\n    monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "then"], ["proof (chain)\npicking this:\n  \\<not> (P = 0 \\<or> Q = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (P = 0 \\<or> Q = 0)\n\ngoal (1 subgoal):\n 1. monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (P = 0 \\<or> Q = 0)\n  degree (P * Q) \\<le> p\n  degree P \\<le> p\n  degree Q \\<le> p\n\ngoal (1 subgoal):\n 1. monom (1::'a) p * reciprocal_poly p (P * Q) =\n    reciprocal_poly p P * reciprocal_poly p Q", "by (auto simp: degree_mult_eq mult_monom reciprocal_fcompose fcompose_mult)"], ["proof (state)\nthis:\n  monom (1::'a) p * reciprocal_poly p (P * Q) =\n  reciprocal_poly p P * reciprocal_poly p Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reciprocal_reflect_poly: \n  fixes P::\"'a::{ring_char_0,field} poly\" \n  assumes hP: \"degree P \\<le> p\"\n  shows \"reciprocal_poly p P = monom 1 (p - degree P) * reflect_poly P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reciprocal_poly p P = monom (1::'a) (p - degree P) * reflect_poly P", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (reciprocal_poly p P) n =\n       coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (reciprocal_poly p P) n =\n       coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "show \"coeff (reciprocal_poly p P) n = \n    coeff (monom 1 (p - degree P) * reflect_poly P) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "assume \"n \\<le> p\""], ["proof (state)\nthis:\n  n \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n\n 2. \\<not> ?P \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "using hP"], ["proof (prove)\nusing this:\n  n \\<le> p\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "by (auto simp: coeff_reciprocal coeff_monom_mult coeff_reflect_poly coeff_eq_0)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) n =\n  coeff (monom (1::'a) (p - degree P) * reflect_poly P) n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "assume \"\\<not> n \\<le> p\""], ["proof (state)\nthis:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "using hP"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n  degree P \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (reciprocal_poly p P) n =\n    coeff (monom (1::'a) (p - degree P) * reflect_poly P) n", "by (auto simp: coeff_reciprocal_less coeff_monom_mult coeff_reflect_poly)"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) n =\n  coeff (monom (1::'a) (p - degree P) * reflect_poly P) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (reciprocal_poly p P) n =\n  coeff (monom (1::'a) (p - degree P) * reflect_poly P) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_poly_reciprocal: \n  assumes \"degree P \\<le> p\" and \"f 0 = 0\" \n  shows \"map_poly f (reciprocal_poly p P)  = reciprocal_poly p (map_poly f P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (reciprocal_poly p P) = reciprocal_poly p (map_poly f P)", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly f (reciprocal_poly p P)) n =\n       coeff (reciprocal_poly p (map_poly f P)) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly f (reciprocal_poly p P)) n =\n       coeff (reciprocal_poly p (map_poly f P)) n", "show \"coeff (map_poly f (reciprocal_poly p P)) n =\n         coeff (reciprocal_poly p (map_poly f P)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "proof (cases \"n\\<le>p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n\n 2. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "case True"], ["proof (state)\nthis:\n  n \\<le> p\n\ngoal (2 subgoals):\n 1. n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n\n 2. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "then"], ["proof (chain)\npicking this:\n  n \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "apply (subst coeff_reciprocal[OF True])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> p \\<Longrightarrow> degree (map_poly f P) \\<le> p\n 2. n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (map_poly f P) (p - n)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> p \\<Longrightarrow> degree (map_poly f P) \\<le> p", "by (meson assms(1) assms(2) degree_map_poly_le le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (map_poly f P) (p - n)", "by (simp add: assms(1) assms(2) coeff_map_poly coeff_reciprocal)"], ["proof (state)\nthis:\n  coeff (map_poly f (reciprocal_poly p P)) n =\n  coeff (reciprocal_poly p (map_poly f P)) n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> p \\<Longrightarrow>\n    coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "then"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> p\n\ngoal (1 subgoal):\n 1. coeff (map_poly f (reciprocal_poly p P)) n =\n    coeff (reciprocal_poly p (map_poly f P)) n", "by (metis assms(1) assms(2) coeff_map_poly coeff_reciprocal_less \n          degree_map_poly_le dual_order.trans leI)"], ["proof (state)\nthis:\n  coeff (map_poly f (reciprocal_poly p P)) n =\n  coeff (reciprocal_poly p (map_poly f P)) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (map_poly f (reciprocal_poly p P)) n =\n  coeff (reciprocal_poly p (map_poly f P)) n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More about @{term proots_count}\\<close>"], ["", "lemma proots_count_monom: \n  assumes \"0 \\<notin> A\" \n  shows \"proots_count (monom 1 d) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (monom (1::'a) d) A = 0", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> A\n\ngoal (1 subgoal):\n 1. proots_count (monom (1::'a) d) A = 0", "by (auto simp: proots_count_def poly_monom)"], ["", "lemma proots_count_reciprocal: \n  fixes P::\"'a::{ring_char_0,field} poly\"\n  assumes hP: \"degree P \\<le> p\" and h0: \"P \\<noteq> 0\" and h0': \"0 \\<notin> A\"\n  shows \"proots_count (reciprocal_poly p P) A = proots_count P {x. inverse x \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "have \"proots_count (reciprocal_poly p P) A = \n        proots_count (fcompose P 1 [:0, 1:]) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A", "apply (subst reciprocal_fcompose[OF hP], subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:] \\<noteq> 0\n 2. proots_count (monom (1::'a) (p - degree P)) A +\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:] \\<noteq> 0", "using h0"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monom (1::'a) (p - degree P) * fcompose P 1 [:0::'a, 1::'a:] \\<noteq> 0", "by (metis hP reciprocal_0_iff reciprocal_fcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (monom (1::'a) (p - degree P)) A +\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (monom (1::'a) (p - degree P)) A +\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A", "using h0'"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> A\n\ngoal (1 subgoal):\n 1. proots_count (monom (1::'a) (p - degree P)) A +\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n    proots_count (fcompose P 1 [:0::'a, 1::'a:]) A", "by (auto simp: proots_count_monom)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  proots_count (reciprocal_poly p P) A =\n  proots_count (fcompose P 1 [:0::'a, 1::'a:]) A\n\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "also"], ["proof (state)\nthis:\n  proots_count (reciprocal_poly p P) A =\n  proots_count (fcompose P 1 [:0::'a, 1::'a:]) A\n\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "have \"... = proots_count P {x. inverse x \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n    proots_count P {x. inverse x \\<in> A}", "proof (rule proots_fcompose_bij_eq[symmetric])"], ["proof (state)\ngoal (6 subgoals):\n 1. bij_betw (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A\n     {x. inverse x \\<in> A}\n 2. P \\<noteq> 0\n 3. \\<forall>x\\<in>A. poly [:0::'a, 1::'a:] x \\<noteq> (0::'a)\n 4. max (degree 1) (degree [:0::'a, 1::'a:]) \\<le> 1\n 5. \\<forall>c. 1 \\<noteq> smult c [:0::'a, 1::'a:]\n 6. infinite UNIV", "show \"bij_betw (\\<lambda>x. poly 1 x / poly [:0, 1:] x) A {x. inverse x \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A\n     {x. inverse x \\<in> A}", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A\n 2. (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A =\n    {x. inverse x \\<in> A}", "show \"inj_on (\\<lambda>x. poly 1 x / poly [:0, 1:] x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A =\n    {x. inverse x \\<in> A}", "show \"(\\<lambda>x. poly 1 x / poly [:0, 1:] x) ` A = {x. inverse x \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A =\n    {x. inverse x \\<in> A}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A\n    \\<subseteq> {x. inverse x \\<in> A}\n 2. {x. inverse x \\<in> A}\n    \\<subseteq> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "show \"(\\<lambda>x. poly 1 x / poly [:0, 1:] x) ` A \\<subseteq> {x. inverse x \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A\n    \\<subseteq> {x. inverse x \\<in> A}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A\n  \\<subseteq> {x. inverse x \\<in> A}\n\ngoal (1 subgoal):\n 1. {x. inverse x \\<in> A}\n    \\<subseteq> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "show \"{x. inverse x \\<in> A} \\<subseteq> (\\<lambda>x. poly 1 x / poly [:0, 1:] x) ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. inverse x \\<in> A}\n    \\<subseteq> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. inverse x \\<in> A} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. inverse x \\<in> A} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "assume \"x \\<in> {x::'a. inverse x \\<in> A}\""], ["proof (state)\nthis:\n  x \\<in> {x. inverse x \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. inverse x \\<in> A} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "hence \"x = poly 1 (inverse x) / poly [:0, 1:] (inverse x) \\<and> inverse x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> {x. inverse x \\<in> A}\n\ngoal (1 subgoal):\n 1. x = poly 1 (inverse x) / poly [:0::'a, 1::'a:] (inverse x) \\<and>\n    inverse x \\<in> A", "by (auto simp: inverse_eq_divide)"], ["proof (state)\nthis:\n  x = poly 1 (inverse x) / poly [:0::'a, 1::'a:] (inverse x) \\<and>\n  inverse x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. inverse x \\<in> A} \\<Longrightarrow>\n       x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "thus \"x \\<in> (\\<lambda>x. poly 1 x / poly [:0, 1:] x) ` A\""], ["proof (prove)\nusing this:\n  x = poly 1 (inverse x) / poly [:0::'a, 1::'a:] (inverse x) \\<and>\n  inverse x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x. inverse x \\<in> A}\n  \\<subseteq> (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) ` A =\n  {x. inverse x \\<in> A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>x. poly 1 x / poly [:0::'a, 1::'a:] x) A\n   {x. inverse x \\<in> A}\n\ngoal (5 subgoals):\n 1. P \\<noteq> 0\n 2. \\<forall>x\\<in>A. poly [:0::'a, 1::'a:] x \\<noteq> (0::'a)\n 3. max (degree 1) (degree [:0::'a, 1::'a:]) \\<le> 1\n 4. \\<forall>c. 1 \\<noteq> smult c [:0::'a, 1::'a:]\n 5. infinite UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. P \\<noteq> 0\n 2. \\<forall>x\\<in>A. poly [:0::'a, 1::'a:] x \\<noteq> (0::'a)\n 3. max (degree 1) (degree [:0::'a, 1::'a:]) \\<le> 1\n 4. \\<forall>c. 1 \\<noteq> smult c [:0::'a, 1::'a:]\n 5. infinite UNIV", "show \"\\<forall>c. 1 \\<noteq> smult c [:0, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. 1 \\<noteq> smult c [:0::'b, 1::'b:]", "by (metis coeff_pCons_0 degree_1 lead_coeff_1 pCons_0_0 pcompose_0'\n          pcompose_smult smult_0_right zero_neq_one)"], ["proof (state)\nthis:\n  \\<forall>c. 1 \\<noteq> smult c [:0::?'b1, 1::?'b1:]\n\ngoal (4 subgoals):\n 1. P \\<noteq> 0\n 2. \\<forall>x\\<in>A. poly [:0::'a, 1::'a:] x \\<noteq> (0::'a)\n 3. max (degree 1) (degree [:0::'a, 1::'a:]) \\<le> 1\n 4. infinite UNIV", "qed (auto simp: assms infinite_UNIV_char_0)"], ["proof (state)\nthis:\n  proots_count (fcompose P 1 [:0::'a, 1::'a:]) A =\n  proots_count P {x. inverse x \\<in> A}\n\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "finally"], ["proof (chain)\npicking this:\n  proots_count (reciprocal_poly p P) A =\n  proots_count P {x. inverse x \\<in> A}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count (reciprocal_poly p P) A =\n  proots_count P {x. inverse x \\<in> A}\n\ngoal (1 subgoal):\n 1. proots_count (reciprocal_poly p P) A =\n    proots_count P {x. inverse x \\<in> A}", "by linarith"], ["proof (state)\nthis:\n  proots_count (reciprocal_poly p P) A =\n  proots_count P {x. inverse x \\<in> A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_reciprocal': \n  fixes P::\"real poly\"\n  assumes hP: \"degree P \\<le> p\" and h0: \"P \\<noteq> 0\"\n  shows \"proots_count P {x. 0 < x \\<and> x < 1} = \n         proots_count (reciprocal_poly p P) {x. 1 < x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count P {x. 0 < x \\<and> x < 1} =\n    proots_count (reciprocal_poly p P) {x. 1 < x}", "proof (subst proots_count_reciprocal)"], ["proof (state)\ngoal (4 subgoals):\n 1. degree P \\<le> p\n 2. P \\<noteq> 0\n 3. 0 \\<notin> Collect ((<) 1)\n 4. proots_count P {x. 0 < x \\<and> x < 1} =\n    proots_count P {x. inverse x \\<in> Collect ((<) 1)}", "show \"proots_count P {x. 0 < x \\<and> x < 1} =\n      proots_count P {x. inverse x \\<in> Collect ((<) 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count P {x. 0 < x \\<and> x < 1} =\n    proots_count P {x. inverse x \\<in> Collect ((<) 1)}", "apply (rule arg_cong[of _ _ \"proots_count P\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. 0 < x \\<and> x < 1} = {x. inverse x \\<in> Collect ((<) 1)}", "using one_less_inverse_iff"], ["proof (prove)\nusing this:\n  ((1::?'a) < inverse ?x) = ((0::?'a) < ?x \\<and> ?x < (1::?'a))\n\ngoal (1 subgoal):\n 1. {x. 0 < x \\<and> x < 1} = {x. inverse x \\<in> Collect ((<) 1)}", "by fastforce"], ["proof (state)\nthis:\n  proots_count P {x. 0 < x \\<and> x < 1} =\n  proots_count P {x. inverse x \\<in> Collect ((<) 1)}\n\ngoal (3 subgoals):\n 1. degree P \\<le> p\n 2. P \\<noteq> 0\n 3. 0 \\<notin> Collect ((<) 1)", "qed (use assms in auto)"], ["", "lemma proots_count_pos: \n  assumes \"proots_count P S > 0\" \n  shows \"\\<exists>x \\<in> S. poly P x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. poly P x = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a)) \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>x\\<in>S. poly P x = 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a)) \\<Longrightarrow> False", "hence \"\\<And>x. x \\<in> S \\<Longrightarrow> poly P x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> poly P x \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> poly P ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a)) \\<Longrightarrow> False", "hence \"\\<And>x. x \\<in> S \\<Longrightarrow> order x P = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> poly P ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> order x P = 0", "using order_0I"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> poly P ?x \\<noteq> (0::'a)\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> order x P = 0", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> order ?x P = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a)) \\<Longrightarrow> False", "hence \"proots_count P S = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> order ?x P = 0\n\ngoal (1 subgoal):\n 1. proots_count P S = 0", "by (force simp: proots_count_def)"], ["proof (state)\nthis:\n  proots_count P S = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S. poly P x = (0::'a)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  proots_count P S = 0\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  proots_count P S = 0\n  0 < proots_count P S\n\ngoal (1 subgoal):\n 1. False", "by presburger"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_of_root_set: \n  assumes \"P \\<noteq> 0\" \"R \\<subseteq> S\" and \"\\<And>x. x\\<in>R \\<Longrightarrow> poly P x = 0\"\n  shows \"proots_count P S \\<ge> card R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "have \"card R \\<le> card (proots_within P S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card R \\<le> card (proots_within P S)", "apply (rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (proots_within P S)\n 2. R \\<subseteq> proots_within P S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within P S)", "using assms"], ["proof (prove)\nusing this:\n  P \\<noteq> 0\n  R \\<subseteq> S\n  ?x \\<in> R \\<Longrightarrow> poly P ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. finite (proots_within P S)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> proots_within P S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> proots_within P S", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  R \\<subseteq> S\n  ?x \\<in> R \\<Longrightarrow> poly P ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. R \\<subseteq> proots_within P S", "by (auto simp: proots_within_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card R \\<le> card (proots_within P S)\n\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "also"], ["proof (state)\nthis:\n  card R \\<le> card (proots_within P S)\n\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "have \"... \\<le> proots_count P S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within P S) \\<le> proots_count P S", "by (rule card_proots_within_leq[OF assms(1)])"], ["proof (state)\nthis:\n  card (proots_within P S) \\<le> proots_count P S\n\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "finally"], ["proof (chain)\npicking this:\n  card R \\<le> proots_count P S", "show ?thesis"], ["proof (prove)\nusing this:\n  card R \\<le> proots_count P S\n\ngoal (1 subgoal):\n 1. card R \\<le> proots_count P S", "."], ["proof (state)\nthis:\n  card R \\<le> proots_count P S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_of_root: assumes \"P \\<noteq> 0\" \"x\\<in>S\" \"poly P x = 0\"\n  shows \"proots_count P S > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < proots_count P S", "using proots_count_of_root_set[of P \"{x}\" S] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<noteq> 0; {x} \\<subseteq> S;\n   \\<And>xa. xa \\<in> {x} \\<Longrightarrow> poly P xa = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card {x} \\<le> proots_count P S\n  P \\<noteq> 0\n  x \\<in> S\n  poly P x = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < proots_count P S", "by force"], ["", "subsection \\<open>More about @{term changes}\\<close>"], ["", "lemma changes_nonneg: \"0 \\<le> changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> changes xs", "apply (induction xs rule: changes.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> changes []\n 2. \\<And>uu_. 0 \\<le> changes [uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                0 \\<le> changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> 0 \\<le> changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> 0 \\<le> changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> changes (x1 # x2 # xs)", "by simp_all"], ["", "lemma changes_replicate_0: shows \"changes (replicate n 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (replicate n (0::'a)) = 0", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. changes (replicate 0 (0::'a)) = 0\n 2. \\<And>n.\n       changes (replicate n (0::'a)) = 0 \\<Longrightarrow>\n       changes (replicate (Suc n) (0::'a)) = 0", "by auto"], ["", "lemma changes_append_replicate_0: \"changes (xs @ replicate n 0) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (xs @ replicate n (0::'a)) = changes xs", "proof (induction xs rule: changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. changes ([] @ replicate n (0::'a)) = changes []\n 2. \\<And>uu_. changes ([uu_] @ replicate n (0::'a)) = changes [uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ replicate n (0::'a)) =\n                changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ replicate n (0::'a)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ replicate n (0::'a)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ replicate n (0::'a)) =\n                         changes (x1 # x2 # xs)", "case (2 uu)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. changes ([] @ replicate n (0::'a)) = changes []\n 2. \\<And>uu_. changes ([uu_] @ replicate n (0::'a)) = changes [uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ replicate n (0::'a)) =\n                changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ replicate n (0::'a)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ replicate n (0::'a)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ replicate n (0::'a)) =\n                         changes (x1 # x2 # xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ([uu] @ replicate n (0::'a)) = changes [uu]", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. changes ([uu] @ replicate 0 (0::'a)) = changes [uu]\n 2. \\<And>n.\n       changes ([uu] @ replicate n (0::'a)) = changes [uu] \\<Longrightarrow>\n       changes ([uu] @ replicate (Suc n) (0::'a)) = changes [uu]", "by auto"], ["proof (state)\nthis:\n  changes ([uu] @ replicate n (0::'a)) = changes [uu]\n\ngoal (2 subgoals):\n 1. changes ([] @ replicate n (0::'a)) = changes []\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ replicate n (0::'a)) =\n                changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ replicate n (0::'a)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ replicate n (0::'a)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ replicate n (0::'a)) =\n                         changes (x1 # x2 # xs)", "qed (auto simp: changes_replicate_0)"], ["", "lemma changes_scale_Cons: \n  fixes xs:: \"real list\" assumes hs: \"s > 0\"\n  shows \"changes (s * x # xs) = changes (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (s * x # xs) = changes (x # xs)", "apply (induction xs rule: changes.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. changes [s * x] = changes [x]\n 2. \\<And>uu_. changes [s * x, uu_] = changes [x, uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < 0 \\<Longrightarrow>\n                changes (s * x # x2 # xs) = changes (x # x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < 0; x2 = 0\\<rbrakk>\n        \\<Longrightarrow> changes (s * x # x1 # xs) = changes (x # x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < 0; x2 \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> changes (s * x # x2 # xs) =\n                          changes (x # x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (s * x # x1 # x2 # xs) =\n                         changes (x # x1 # x2 # xs)", "using assms"], ["proof (prove)\nusing this:\n  0 < s\n\ngoal (3 subgoals):\n 1. changes [s * x] = changes [x]\n 2. \\<And>uu_. changes [s * x, uu_] = changes [x, uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < 0 \\<Longrightarrow>\n                changes (s * x # x2 # xs) = changes (x # x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < 0; x2 = 0\\<rbrakk>\n        \\<Longrightarrow> changes (s * x # x1 # xs) = changes (x # x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < 0; x2 \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> changes (s * x # x2 # xs) =\n                          changes (x # x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (s * x # x1 # x2 # xs) =\n                         changes (x # x1 # x2 # xs)", "by (auto simp: mult_less_0_iff zero_less_mult_iff)"], ["", "lemma changes_scale: \n  fixes xs::\"('a::linordered_idom) list\"\n  assumes hs: \"\\<And>i. i < n \\<Longrightarrow> s i > 0\" and hn: \"length xs \\<le> n\"\n  shows \"changes [s i * (nth_default 0 xs i). i \\<leftarrow> [0..<n]] = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) xs i) [0..<n]) =\n    changes xs", "using assms"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length xs \\<le> n\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) xs i) [0..<n]) =\n    changes xs", "proof (induction xs arbitrary: s n rule: changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i. s i * nth_default (0::'a) [] i)\n                            [0..<n]) =\n                         changes []\n 2. \\<And>uu_ s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [uu_] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i * nth_default (0::'a) [uu_] i)\n                            [0..<n]) =\n                         changes [uu_]\n 3. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "case 1"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length [] \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i. s i * nth_default (0::'a) [] i)\n                            [0..<n]) =\n                         changes []\n 2. \\<And>uu_ s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [uu_] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i * nth_default (0::'a) [uu_] i)\n                            [0..<n]) =\n                         changes [uu_]\n 3. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) [] i) [0..<n]) =\n    changes []", "by (auto simp: map_replicate_const changes_replicate_0)"], ["proof (state)\nthis:\n  changes (map (\\<lambda>i. s i * nth_default (0::'a) [] i) [0..<n]) =\n  changes []\n\ngoal (2 subgoals):\n 1. \\<And>uu_ s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [uu_] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i * nth_default (0::'a) [uu_] i)\n                            [0..<n]) =\n                         changes [uu_]\n 2. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_ s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [uu_] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i * nth_default (0::'a) [uu_] i)\n                            [0..<n]) =\n                         changes [uu_]\n 2. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "case (2 uu)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length [uu] \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>uu_ s n.\n       \\<lbrakk>\\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length [uu_] \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i * nth_default (0::'a) [uu_] i)\n                            [0..<n]) =\n                         changes [uu_]\n 2. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n    changes [uu]", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n    changes [uu]\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n    changes [uu]\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n    changes [uu]", "by force"], ["proof (state)\nthis:\n  changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n  changes [uu]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "hence \"map (\\<lambda>i. s i * nth_default 0 [uu] i) [0..<n] = [s 0 * uu] @ replicate m 0\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n    [s 0 * uu] @ replicate m (0::'a)", "proof (induction m arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "case (Suc m n)"], ["proof (state)\nthis:\n  ?n = Suc m \\<Longrightarrow>\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<?n] =\n  [s 0 * uu] @ replicate m (0::'a)\n  n = Suc (Suc m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  ?n = Suc m \\<Longrightarrow>\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<?n] =\n  [s 0 * uu] @ replicate m (0::'a)\n  n = Suc (Suc m)", "have \"map (\\<lambda>i. s i * nth_default 0 [uu] i) [0..<Suc m] = \n                     [s 0 * uu] @ replicate m 0\""], ["proof (prove)\nusing this:\n  ?n = Suc m \\<Longrightarrow>\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<?n] =\n  [s 0 * uu] @ replicate m (0::'a)\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<Suc m] =\n    [s 0 * uu] @ replicate m (0::'a)", "by meson"], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<Suc m] =\n  [s 0 * uu] @ replicate m (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "hence \"map (\\<lambda>i. s i * nth_default 0 [uu] i) [0..<n] =\n             [s 0 * uu] @ replicate m 0 @ [0]\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<Suc m] =\n  [s 0 * uu] @ replicate m (0::'a)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n    [s 0 * uu] @ replicate m (0::'a) @ [0::'a]", "using Suc"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<Suc m] =\n  [s 0 * uu] @ replicate m (0::'a)\n  ?n = Suc m \\<Longrightarrow>\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<?n] =\n  [s 0 * uu] @ replicate m (0::'a)\n  n = Suc (Suc m)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n    [s 0 * uu] @ replicate m (0::'a) @ [0::'a]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate m (0::'a) @ [0::'a]\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate m (0::'a) @ [0::'a]\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "have \"... = [s 0 * uu] @ replicate (Suc m) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [s 0 * uu] @ replicate m (0::'a) @ [0::'a] =\n    [s 0 * uu] @ replicate (Suc m) (0::'a)", "by (simp add: replicate_append_same)"], ["proof (state)\nthis:\n  [s 0 * uu] @ replicate m (0::'a) @ [0::'a] =\n  [s 0 * uu] @ replicate (Suc m) (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = Suc m \\<Longrightarrow>\n                   map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                    [0..<n] =\n                   [s 0 * uu] @ replicate m (0::'a);\n        n = Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. s i * nth_default (0::'a) [uu] i)\n                          [0..<n] =\n                         [s 0 * uu] @ replicate (Suc m) (0::'a)", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate (Suc m) (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate (Suc m) (0::'a)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n    [s 0 * uu] @ replicate (Suc m) (0::'a)", "."], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate (Suc m) (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n = Suc 0 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n       [s 0 * uu] @ replicate 0 (0::'a)", "qed fastforce"], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate m (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       changes\n        (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n       changes [uu]", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate m (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n] =\n  [s 0 * uu] @ replicate m (0::'a)\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n    changes [uu]", "by (metis changes.simps(2) changes_append_replicate_0)"], ["proof (state)\nthis:\n  changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n  changes [uu]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes (map (\\<lambda>i. s i * nth_default (0::'a) [uu] i) [0..<n]) =\n  changes [uu]\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "case (3 a b xs s n)"], ["proof (state)\nthis:\n  \\<lbrakk>a * b < (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b = (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (a # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (a # xs) i)\n                       [0..<?n]) =\n                    changes (a # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b \\<noteq> (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length (a # b # xs) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "obtain m where hn: \"n = m + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. n = m + 2 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 3(5)"], ["proof (prove)\nusing this:\n  length (a # b # xs) \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = m + 2 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis add_2_eq_Suc' diff_diff_cancel diff_le_self length_Suc_conv \n        nat_arith.suc1 ordered_cancel_comm_monoid_diff_class.add_diff_inverse)"], ["proof (state)\nthis:\n  n = m + 2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "hence h: \n    \"map (\\<lambda>i. s i * nth_default 0 (a # b # xs) i) [0..<n] = \n      s 0 * a # s 1 * b # map (\\<lambda>i. \n      (\\<lambda> i. s (i+2)) i * nth_default 0 (xs) i) [0..<m]\""], ["proof (prove)\nusing this:\n  n = m + 2\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n] =\n    s 0 * a #\n    s 1 * b # map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]", "apply (induction m arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       n = 0 + 2 \\<Longrightarrow>\n       map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n] =\n       s 0 * a #\n       s 1 * b #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<0]\n 2. \\<And>m n.\n       \\<lbrakk>\\<And>n.\n                   n = m + 2 \\<Longrightarrow>\n                   map (\\<lambda>i.\n                           s i * nth_default (0::'a) (a # b # xs) i)\n                    [0..<n] =\n                   s 0 * a #\n                   s 1 * b #\n                   map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i)\n                    [0..<m];\n        n = Suc m + 2\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i.\n                                 s i * nth_default (0::'a) (a # b # xs) i)\n                          [0..<n] =\n                         s 0 * a #\n                         s 1 * b #\n                         map (\\<lambda>i.\n                                 s (i + 2) * nth_default (0::'a) xs i)\n                          [0..<Suc m]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n] =\n  s 0 * a #\n  s 1 * b # map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "consider (neg)\"a*b<0\" | (nil)\"b=0\" | (pos)\"\\<not>a*b<0 \\<and> \\<not>b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * b < (0::'a) \\<Longrightarrow> thesis;\n     b = (0::'a) \\<Longrightarrow> thesis;\n     \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>a * b < (0::'a) \\<Longrightarrow> ?thesis;\n   b = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs s n.\n       \\<lbrakk>\\<And>s n.\n                   \\<lbrakk>x1 * x2 < (0::'a);\n                    \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n                    length (x2 # xs) \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> changes\n(map (\\<lambda>i. s i * nth_default (0::'a) (x2 # xs) i) [0..<n]) =\n                                     changes (x2 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x1 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x1 # xs) i)\n                                [0..<n]) =\n                             changes (x1 # xs);\n        \\<And>s n.\n           \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n            \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n            length (x2 # xs) \\<le> n\\<rbrakk>\n           \\<Longrightarrow> changes\n                              (map (\\<lambda>i.\n s i * nth_default (0::'a) (x2 # xs) i)\n                                [0..<n]) =\n                             changes (x2 # xs);\n        \\<And>i. i < n \\<Longrightarrow> (0::'a) < s i;\n        length (x1 # x2 # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> changes\n                          (map (\\<lambda>i.\n                                   s i *\n                                   nth_default (0::'a) (x1 # x2 # xs) i)\n                            [0..<n]) =\n                         changes (x1 # x2 # xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a * b < (0::'a) \\<Longrightarrow> ?thesis;\n   b = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * b < (0::'a) \\<Longrightarrow> ?thesis;\n   b = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "case neg"], ["proof (state)\nthis:\n  a * b < (0::'a)\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "hence \n      \"changes (map (\\<lambda>i. s i * nth_default 0 (a # b # xs) i) [0..<n]) =\n        1 + changes (s 1 * b # map (\\<lambda>i. (\\<lambda> i. s (i+2)) i \n                                        * nth_default 0 (xs) i) [0..<m])\""], ["proof (prove)\nusing this:\n  a * b < (0::'a)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    1 +\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "apply (subst h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    1 +\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "using 3(4)[of 0] 3(4)[of 1] hn"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> (0::'a) < s 0\n  1 < n \\<Longrightarrow> (0::'a) < s 1\n  n = m + 2\n\ngoal (1 subgoal):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    1 +\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "by (metis (no_types, lifting) changes.simps(3) mult_less_0_iff pos2\n          mult_pos_pos one_less_numeral_iff semiring_norm(76) trans_less_add2)"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  1 +\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  1 +\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have \n      \"... = 1 + changes (map (\\<lambda>i. s (Suc i) * nth_default 0 (b # xs) i) [0..<Suc m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 +\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    1 +\n    changes\n     (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n       [0..<Suc m])", "apply (rule arg_cong[of _ _ \"\\<lambda> x. 1 + changes x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n    map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i) [0..<Suc m]", "apply (induction m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<0] =\n    map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i) [0..<Suc 0]\n 2. \\<And>m.\n       s 1 * b #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n       map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n        [0..<Suc m] \\<Longrightarrow>\n       s 1 * b #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<Suc m] =\n       map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n        [0..<Suc (Suc m)]", "by auto"], ["proof (state)\nthis:\n  1 +\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  1 +\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m])\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  1 +\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  1 +\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m])\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have \"... = changes (a # b # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 +\n    changes\n     (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n       [0..<Suc m]) =\n    changes (a # b # xs)", "apply (subst 3(1)[OF neg])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i. i < Suc m \\<Longrightarrow> (0::'a) < s (Suc i)\n 2. length (b # xs) \\<le> Suc m\n 3. 1 + changes (b # xs) = changes (a # b # xs)", "using 3 neg hn"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * b < (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b = (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (a # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (a # xs) i)\n                       [0..<?n]) =\n                    changes (a # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b \\<noteq> (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length (a # b # xs) \\<le> n\n  a * b < (0::'a)\n  n = m + 2\n\ngoal (3 subgoals):\n 1. \\<And>i. i < Suc m \\<Longrightarrow> (0::'a) < s (Suc i)\n 2. length (b # xs) \\<le> Suc m\n 3. 1 + changes (b # xs) = changes (a # b # xs)", "by auto"], ["proof (state)\nthis:\n  1 +\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m]) =\n  changes (a # b # xs)\n\ngoal (3 subgoals):\n 1. a * b < (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 3. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "finally"], ["proof (chain)\npicking this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "."], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "case nil"], ["proof (state)\nthis:\n  b = (0::'a)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "hence \"changes (map (\\<lambda>i. s i * nth_default 0 (a # b # xs) i) [0..<n]) =\n           changes (s 0 * a # map (\\<lambda>i. (\\<lambda> i. s (i+2)) i * nth_default 0 (xs) i) [0..<m])\""], ["proof (prove)\nusing this:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes\n     (s 0 * a #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "apply (subst h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (s 0 * a #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "using 3(4)[of 0] 3(4)[of 1] hn"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> (0::'a) < s 0\n  1 < n \\<Longrightarrow> (0::'a) < s 1\n  n = m + 2\n\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (s 0 * a #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "by auto"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes\n   (s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes\n   (s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have \n      \"... = changes (map \n               (\\<lambda>i. s (if i = 0 then 0 else Suc i) * nth_default 0 (a # xs) i) \n              [0..<Suc m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (s 0 * a #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (map (\\<lambda>i.\n              s (if i = 0 then 0 else Suc i) *\n              nth_default (0::'a) (a # xs) i)\n       [0..<Suc m])", "apply (rule arg_cong[of _ _ \"\\<lambda> x. changes x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n    map (\\<lambda>i.\n            s (if i = 0 then 0 else Suc i) * nth_default (0::'a) (a # xs) i)\n     [0..<Suc m]", "apply (induction m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<0] =\n    map (\\<lambda>i.\n            s (if i = 0 then 0 else Suc i) * nth_default (0::'a) (a # xs) i)\n     [0..<Suc 0]\n 2. \\<And>m.\n       s 0 * a #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n       map (\\<lambda>i.\n               s (if i = 0 then 0 else Suc i) *\n               nth_default (0::'a) (a # xs) i)\n        [0..<Suc m] \\<Longrightarrow>\n       s 0 * a #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<Suc m] =\n       map (\\<lambda>i.\n               s (if i = 0 then 0 else Suc i) *\n               nth_default (0::'a) (a # xs) i)\n        [0..<Suc (Suc m)]", "by auto"], ["proof (state)\nthis:\n  changes\n   (s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  changes\n   (map (\\<lambda>i.\n            s (if i = 0 then 0 else Suc i) * nth_default (0::'a) (a # xs) i)\n     [0..<Suc m])\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  changes\n   (s 0 * a #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  changes\n   (map (\\<lambda>i.\n            s (if i = 0 then 0 else Suc i) * nth_default (0::'a) (a # xs) i)\n     [0..<Suc m])\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have \"... = changes (a # b # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i.\n              s (if i = 0 then 0 else Suc i) *\n              nth_default (0::'a) (a # xs) i)\n       [0..<Suc m]) =\n    changes (a # b # xs)", "apply (subst 3(2))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<not> a * b < (0::'a)\n 2. b = (0::'a)\n 3. \\<And>i.\n       i < Suc m \\<Longrightarrow> (0::'a) < s (if i = 0 then 0 else Suc i)\n 4. length (a # xs) \\<le> Suc m\n 5. changes (a # xs) = changes (a # b # xs)", "using 3 nil hn"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * b < (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b = (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (a # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (a # xs) i)\n                       [0..<?n]) =\n                    changes (a # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b \\<noteq> (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length (a # b # xs) \\<le> n\n  b = (0::'a)\n  n = m + 2\n\ngoal (5 subgoals):\n 1. \\<not> a * b < (0::'a)\n 2. b = (0::'a)\n 3. \\<And>i.\n       i < Suc m \\<Longrightarrow> (0::'a) < s (if i = 0 then 0 else Suc i)\n 4. length (a # xs) \\<le> Suc m\n 5. changes (a # xs) = changes (a # b # xs)", "by auto"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i.\n            s (if i = 0 then 0 else Suc i) * nth_default (0::'a) (a # xs) i)\n     [0..<Suc m]) =\n  changes (a # b # xs)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)\n 2. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "finally"], ["proof (chain)\npicking this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "."], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "case pos"], ["proof (state)\nthis:\n  \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "hence \"changes (map (\\<lambda>i. s i * nth_default 0 (a # b # xs) i) [0..<n]) =\n           changes (s 1 * b # map (\\<lambda>i. (\\<lambda> i. s (i+2)) i * nth_default 0 (xs) i) [0..<m])\""], ["proof (prove)\nusing this:\n  \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "apply (subst h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "using 3(4)[of 0] 3(4)[of 1] hn"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> (0::'a) < s 0\n  1 < n \\<Longrightarrow> (0::'a) < s 1\n  n = m + 2\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (s 0 * a #\n      s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])", "by (metis (no_types, lifting) changes.simps(3) divisors_zero \n          mult_less_0_iff nat_1_add_1 not_square_less_zero one_less_numeral_iff\n          semiring_norm(76) trans_less_add2 zero_less_mult_pos zero_less_two)"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m])\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have\n      \"... = changes (map (\\<lambda>i. s (Suc i) * nth_default 0 (b # xs) i) [0..<Suc m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (s 1 * b #\n      map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n    changes\n     (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n       [0..<Suc m])", "apply (rule arg_cong[of _ _ \"\\<lambda> x. changes x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n    map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i) [0..<Suc m]", "apply (induction m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<0] =\n    map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i) [0..<Suc 0]\n 2. \\<And>m.\n       s 1 * b #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m] =\n       map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n        [0..<Suc m] \\<Longrightarrow>\n       s 1 * b #\n       map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<Suc m] =\n       map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n        [0..<Suc (Suc m)]", "by auto"], ["proof (state)\nthis:\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m])\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "also"], ["proof (state)\nthis:\n  changes\n   (s 1 * b #\n    map (\\<lambda>i. s (i + 2) * nth_default (0::'a) xs i) [0..<m]) =\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m])\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "have \"... = changes (a # b # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n       [0..<Suc m]) =\n    changes (a # b # xs)", "apply (subst 3(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<not> a * b < (0::'a)\n 2. b \\<noteq> (0::'a)\n 3. \\<And>i. i < Suc m \\<Longrightarrow> (0::'a) < s (Suc i)\n 4. length (b # xs) \\<le> Suc m\n 5. changes (b # xs) = changes (a # b # xs)", "using 3 pos hn"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * b < (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b = (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (a # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (a # xs) i)\n                       [0..<?n]) =\n                    changes (a # xs)\n  \\<lbrakk>\\<not> a * b < (0::'a); b \\<noteq> (0::'a);\n   \\<And>i. i < ?n \\<Longrightarrow> (0::'a) < ?s i;\n   length (b # xs) \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> changes\n                     (map (\\<lambda>i.\n                              ?s i * nth_default (0::'a) (b # xs) i)\n                       [0..<?n]) =\n                    changes (b # xs)\n  ?i < n \\<Longrightarrow> (0::'a) < s ?i\n  length (a # b # xs) \\<le> n\n  \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a)\n  n = m + 2\n\ngoal (5 subgoals):\n 1. \\<not> a * b < (0::'a)\n 2. b \\<noteq> (0::'a)\n 3. \\<And>i. i < Suc m \\<Longrightarrow> (0::'a) < s (Suc i)\n 4. length (b # xs) \\<le> Suc m\n 5. changes (b # xs) = changes (a # b # xs)", "by auto"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s (Suc i) * nth_default (0::'a) (b # xs) i)\n     [0..<Suc m]) =\n  changes (a # b # xs)\n\ngoal (1 subgoal):\n 1. \\<not> a * b < (0::'a) \\<and> b \\<noteq> (0::'a) \\<Longrightarrow>\n    changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "finally"], ["proof (chain)\npicking this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n    changes (a # b # xs)", "."], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes\n   (map (\\<lambda>i. s i * nth_default (0::'a) (a # b # xs) i) [0..<n]) =\n  changes (a # b # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_scale_const: fixes xs::\"'a::linordered_idom list\" \n  assumes hs: \"s \\<noteq> 0\"\n  shows \"changes (map ((*) s) xs) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map ((*) s) xs) = changes xs", "apply (induction xs rule: changes.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. changes (map ((*) s) []) = changes []\n 2. \\<And>uu_. changes (map ((*) s) [uu_]) = changes [uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (map ((*) s) (x2 # xs)) = changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x1 # xs)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x2 # xs)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (map ((*) s) (x1 # x2 # xs)) =\n                         changes (x1 # x2 # xs)", "apply (simp, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (map ((*) s) (x2 # xs)) = changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x1 # xs)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x2 # xs)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (map ((*) s) (x1 # x2 # xs)) =\n                         changes (x1 # x2 # xs)", "using hs"], ["proof (prove)\nusing this:\n  s \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (map ((*) s) (x2 # xs)) = changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x1 # xs)) =\n                          changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (map ((*) s) (x2 # xs)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (map ((*) s) (x1 # x2 # xs)) =\n                         changes (x1 # x2 # xs)", "by (auto simp: mult_less_0_iff zero_less_mult_iff)"], ["", "lemma changes_snoc: fixes xs::\"'a::linordered_idom list\" \n  shows \"changes (xs @ [b, a]) = (if a * b < 0 then 1 + changes (xs @ [b])\n         else if b = 0 then changes (xs @ [a]) else changes (xs @ [b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (xs @ [b, a]) =\n    (if a * b < (0::'a) then 1 + changes (xs @ [b])\n     else if b = (0::'a) then changes (xs @ [a]) else changes (xs @ [b]))", "apply (induction xs rule: changes.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. changes ([] @ [b, a]) =\n    (if a * b < (0::'a) then 1 + changes ([] @ [b])\n     else if b = (0::'a) then changes ([] @ [a]) else changes ([] @ [b]))\n 2. \\<And>uu_.\n       changes ([uu_] @ [b, a]) =\n       (if a * b < (0::'a) then 1 + changes ([uu_] @ [b])\n        else if b = (0::'a) then changes ([uu_] @ [a])\n             else changes ([uu_] @ [b]))\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [b, a]) =\n                (if a * b < (0::'a) then 1 + changes ((x2 # xs) @ [b])\n                 else if b = (0::'a) then changes ((x2 # xs) @ [a])\n                      else changes ((x2 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x1 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x1 # xs) @ [a])\n                                else changes ((x1 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x2 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x2 # xs) @ [a])\n                                else changes ((x2 # xs) @ [b]))\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [b, a]) =\n                         (if a * b < (0::'a)\n                          then 1 + changes ((x1 # x2 # xs) @ [b])\n                          else if b = (0::'a)\n                               then changes ((x1 # x2 # xs) @ [a])\n                               else changes ((x1 # x2 # xs) @ [b]))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ([] @ [b, a]) =\n    (if a * b < (0::'a) then 1 + changes ([] @ [b])\n     else if b = (0::'a) then changes ([] @ [a]) else changes ([] @ [b]))", "by (force simp: mult_less_0_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       changes ([uu_] @ [b, a]) =\n       (if a * b < (0::'a) then 1 + changes ([uu_] @ [b])\n        else if b = (0::'a) then changes ([uu_] @ [a])\n             else changes ([uu_] @ [b]))\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [b, a]) =\n                (if a * b < (0::'a) then 1 + changes ((x2 # xs) @ [b])\n                 else if b = (0::'a) then changes ((x2 # xs) @ [a])\n                      else changes ((x2 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x1 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x1 # xs) @ [a])\n                                else changes ((x1 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x2 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x2 # xs) @ [a])\n                                else changes ((x2 # xs) @ [b]))\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [b, a]) =\n                         (if a * b < (0::'a)\n                          then 1 + changes ((x1 # x2 # xs) @ [b])\n                          else if b = (0::'a)\n                               then changes ((x1 # x2 # xs) @ [a])\n                               else changes ((x1 # x2 # xs) @ [b]))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ([uu_] @ [b, a]) =\n    (if a * b < (0::'a) then 1 + changes ([uu_] @ [b])\n     else if b = (0::'a) then changes ([uu_] @ [a])\n          else changes ([uu_] @ [b]))", "by (force simp: mult_less_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [b, a]) =\n                (if a * b < (0::'a) then 1 + changes ((x2 # xs) @ [b])\n                 else if b = (0::'a) then changes ((x2 # xs) @ [a])\n                      else changes ((x2 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x1 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x1 # xs) @ [a])\n                                else changes ((x1 # xs) @ [b]));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [b, a]) =\n                          (if a * b < (0::'a)\n                           then 1 + changes ((x2 # xs) @ [b])\n                           else if b = (0::'a)\n                                then changes ((x2 # xs) @ [a])\n                                else changes ((x2 # xs) @ [b]))\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [b, a]) =\n                         (if a * b < (0::'a)\n                          then 1 + changes ((x1 # x2 # xs) @ [b])\n                          else if b = (0::'a)\n                               then changes ((x1 # x2 # xs) @ [a])\n                               else changes ((x1 # x2 # xs) @ [b]))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x1_ * x2_ < (0::'a) \\<Longrightarrow>\n             changes ((x2_ # xs_) @ [b, a]) =\n             (if a * b < (0::'a) then 1 + changes ((x2_ # xs_) @ [b])\n              else if b = (0::'a) then changes ((x2_ # xs_) @ [a])\n                   else changes ((x2_ # xs_) @ [b]));\n     \\<lbrakk>\\<not> x1_ * x2_ < (0::'a); x2_ = (0::'a)\\<rbrakk>\n     \\<Longrightarrow> changes ((x1_ # xs_) @ [b, a]) =\n                       (if a * b < (0::'a)\n                        then 1 + changes ((x1_ # xs_) @ [b])\n                        else if b = (0::'a) then changes ((x1_ # xs_) @ [a])\n                             else changes ((x1_ # xs_) @ [b]));\n     \\<lbrakk>\\<not> x1_ * x2_ < (0::'a); x2_ \\<noteq> (0::'a)\\<rbrakk>\n     \\<Longrightarrow> changes ((x2_ # xs_) @ [b, a]) =\n                       (if a * b < (0::'a)\n                        then 1 + changes ((x2_ # xs_) @ [b])\n                        else if b = (0::'a) then changes ((x2_ # xs_) @ [a])\n                             else changes ((x2_ # xs_) @ [b]))\\<rbrakk>\n    \\<Longrightarrow> changes ((x1_ # x2_ # xs_) @ [b, a]) =\n                      (if a * b < (0::'a)\n                       then 1 + changes ((x1_ # x2_ # xs_) @ [b])\n                       else if b = (0::'a)\n                            then changes ((x1_ # x2_ # xs_) @ [a])\n                            else changes ((x1_ # x2_ # xs_) @ [b]))", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma changes_rev: fixes xs:: \"'a::linordered_idom list\" \n  shows \"changes (rev xs) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (rev xs) = changes xs", "apply (induction xs rule: changes.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. changes (rev []) = changes []\n 2. \\<And>uu_. changes (rev [uu_]) = changes [uu_]\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (rev (x2 # xs)) = changes (x2 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (rev (x1 # xs)) = changes (x1 # xs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (rev (x2 # xs)) =\n                          changes (x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (rev (x1 # x2 # xs)) =\n                         changes (x1 # x2 # xs)", "by (auto simp: changes_snoc)"], ["", "lemma changes_rev_about: fixes xs:: \"'a::linordered_idom list\" \n  shows \"changes (replicate (p - length xs) 0 @ rev xs) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (replicate (p - length xs) (0::'a) @ rev xs) = changes xs", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. changes (replicate (0 - length xs) (0::'a) @ rev xs) = changes xs\n 2. \\<And>p.\n       changes (replicate (p - length xs) (0::'a) @ rev xs) =\n       changes xs \\<Longrightarrow>\n       changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs", "case (Suc p)"], ["proof (state)\nthis:\n  changes (replicate (p - length xs) (0::'a) @ rev xs) = changes xs\n\ngoal (2 subgoals):\n 1. changes (replicate (0 - length xs) (0::'a) @ rev xs) = changes xs\n 2. \\<And>p.\n       changes (replicate (p - length xs) (0::'a) @ rev xs) =\n       changes xs \\<Longrightarrow>\n       changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs", "then"], ["proof (chain)\npicking this:\n  changes (replicate (p - length xs) (0::'a) @ rev xs) = changes xs", "show ?case"], ["proof (prove)\nusing this:\n  changes (replicate (p - length xs) (0::'a) @ rev xs) = changes xs\n\ngoal (1 subgoal):\n 1. changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs\n 2. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs", "assume \"\\<not>Suc p \\<le> length xs\""], ["proof (state)\nthis:\n  \\<not> Suc p \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs\n 2. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs", "hence \"Suc p - length xs = Suc (p - length xs)\""], ["proof (prove)\nusing this:\n  \\<not> Suc p \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc p - length xs = Suc (p - length xs)", "by linarith"], ["proof (state)\nthis:\n  Suc p - length xs = Suc (p - length xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs\n 2. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs", "thus ?case"], ["proof (prove)\nusing this:\n  Suc p - length xs = Suc (p - length xs)\n\ngoal (1 subgoal):\n 1. changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs", "using Suc.IH changes_rev"], ["proof (prove)\nusing this:\n  Suc p - length xs = Suc (p - length xs)\n  changes (replicate (p - length xs) (0::'a) @ rev xs) = changes xs\n  changes (rev ?xs) = changes ?xs\n\ngoal (1 subgoal):\n 1. changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs", "by auto"], ["proof (state)\nthis:\n  changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (replicate (p - length xs) (0::'a) @ rev xs) =\n             changes xs;\n     \\<not> \\<not> Suc p \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> changes\n                       (replicate (Suc p - length xs) (0::'a) @ rev xs) =\n                      changes xs", "qed (auto simp: changes_rev)"], ["proof (state)\nthis:\n  changes (replicate (Suc p - length xs) (0::'a) @ rev xs) = changes xs\n\ngoal (1 subgoal):\n 1. changes (replicate (0 - length xs) (0::'a) @ rev xs) = changes xs", "qed (auto simp: changes_rev)"], ["", "lemma changes_add_between: \n  assumes \"a \\<le> x\" and \"x \\<le> b\"\n  shows \"changes (as @ [a, b] @ bs) = changes (as @ [a, x, b] @ bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (as @ [a, b] @ bs) = changes (as @ [a, x, b] @ bs)", "proof (induction as rule: changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. changes ([] @ [a, b] @ bs) = changes ([] @ [a, x, b] @ bs)\n 2. \\<And>uu_.\n       changes ([uu_] @ [a, b] @ bs) = changes ([uu_] @ [a, x, b] @ bs)\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. changes ([] @ [a, b] @ bs) = changes ([] @ [a, x, b] @ bs)\n 2. \\<And>uu_.\n       changes ([uu_] @ [a, b] @ bs) = changes ([uu_] @ [a, x, b] @ bs)\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ([] @ [a, b] @ bs) = changes ([] @ [a, x, b] @ bs)", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. changes ([] @ [a, b] @ bs) = changes ([] @ [a, x, b] @ bs)", "apply (induction bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n    \\<Longrightarrow> changes ([] @ [a, b] @ []) =\n                      changes ([] @ [a, x, b] @ [])\n 2. \\<And>aa bs.\n       \\<lbrakk>\\<lbrakk>a \\<le> x; x \\<le> b\\<rbrakk>\n                \\<Longrightarrow> changes ([] @ [a, b] @ bs) =\n                                  changes ([] @ [a, x, b] @ bs);\n        a \\<le> x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> changes ([] @ [a, b] @ aa # bs) =\n                         changes ([] @ [a, x, b] @ aa # bs)", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  changes ([] @ [a, b] @ bs) = changes ([] @ [a, x, b] @ bs)\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       changes ([uu_] @ [a, b] @ bs) = changes ([uu_] @ [a, x, b] @ bs)\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       changes ([uu_] @ [a, b] @ bs) = changes ([uu_] @ [a, x, b] @ bs)\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "case (2 c)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       changes ([uu_] @ [a, b] @ bs) = changes ([uu_] @ [a, x, b] @ bs)\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ([c] @ [a, b] @ bs) = changes ([c] @ [a, x, b] @ bs)", "apply (induction bs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. changes ([c] @ [a, b] @ []) = changes ([c] @ [a, x, b] @ [])\n 2. \\<And>aa bs.\n       changes ([c] @ [a, b] @ bs) =\n       changes ([c] @ [a, x, b] @ bs) \\<Longrightarrow>\n       changes ([c] @ [a, b] @ aa # bs) =\n       changes ([c] @ [a, x, b] @ aa # bs)", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> x\n  x \\<le> b\n\ngoal (2 subgoals):\n 1. changes ([c] @ [a, b] @ []) = changes ([c] @ [a, x, b] @ [])\n 2. \\<And>aa bs.\n       changes ([c] @ [a, b] @ bs) =\n       changes ([c] @ [a, x, b] @ bs) \\<Longrightarrow>\n       changes ([c] @ [a, b] @ aa # bs) =\n       changes ([c] @ [a, x, b] @ aa # bs)", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  changes ([c] @ [a, b] @ bs) = changes ([c] @ [a, x, b] @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "case (3 y z as)"], ["proof (state)\nthis:\n  y * z < (0::'a) \\<Longrightarrow>\n  changes ((z # as) @ [a, b] @ bs) = changes ((z # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((y # as) @ [a, b] @ bs) =\n                    changes ((y # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((z # as) @ [a, b] @ bs) =\n                    changes ((z # as) @ [a, x, b] @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes ((x2 # xs) @ [a, b] @ bs) =\n                changes ((x2 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x1 # xs) @ [a, b] @ bs) =\n                          changes ((x1 # xs) @ [a, x, b] @ bs);\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes ((x2 # xs) @ [a, b] @ bs) =\n                          changes ((x2 # xs) @ [a, x, b] @ bs)\\<rbrakk>\n       \\<Longrightarrow> changes ((x1 # x2 # xs) @ [a, b] @ bs) =\n                         changes ((x1 # x2 # xs) @ [a, x, b] @ bs)", "then"], ["proof (chain)\npicking this:\n  y * z < (0::'a) \\<Longrightarrow>\n  changes ((z # as) @ [a, b] @ bs) = changes ((z # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((y # as) @ [a, b] @ bs) =\n                    changes ((y # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((z # as) @ [a, b] @ bs) =\n                    changes ((z # as) @ [a, x, b] @ bs)", "show ?case"], ["proof (prove)\nusing this:\n  y * z < (0::'a) \\<Longrightarrow>\n  changes ((z # as) @ [a, b] @ bs) = changes ((z # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((y # as) @ [a, b] @ bs) =\n                    changes ((y # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((z # as) @ [a, b] @ bs) =\n                    changes ((z # as) @ [a, x, b] @ bs)\n\ngoal (1 subgoal):\n 1. changes ((y # z # as) @ [a, b] @ bs) =\n    changes ((y # z # as) @ [a, x, b] @ bs)", "using assms"], ["proof (prove)\nusing this:\n  y * z < (0::'a) \\<Longrightarrow>\n  changes ((z # as) @ [a, b] @ bs) = changes ((z # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((y # as) @ [a, b] @ bs) =\n                    changes ((y # as) @ [a, x, b] @ bs)\n  \\<lbrakk>\\<not> y * z < (0::'a); z \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes ((z # as) @ [a, b] @ bs) =\n                    changes ((z # as) @ [a, x, b] @ bs)\n  a \\<le> x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. changes ((y # z # as) @ [a, b] @ bs) =\n    changes ((y # z # as) @ [a, x, b] @ bs)", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  changes ((y # z # as) @ [a, b] @ bs) =\n  changes ((y # z # as) @ [a, x, b] @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_all_nonneg: assumes \"\\<And>i. nth_default 0 xs i \\<ge> 0\" shows \"changes xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes xs = 0", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> nth_default (0::'a) xs ?i\n\ngoal (1 subgoal):\n 1. changes xs = 0", "proof (induction xs rule: changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "case (3 x1 x2 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>x1 * x2 < (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x1 * x2 < (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "assume \"(\\<And>i. 0 \\<le> nth_default 0 (x1 # x2 # xs) i)\""], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "moreover"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "hence \"(\\<And>i. 0 \\<le> nth_default 0 (x1 # xs) i)\" \n    and \"(\\<And>i. 0 \\<le> nth_default 0 (x2 # xs) i)\"\n    and \"x1 * x2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (1 subgoal):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i) &&&\n    (\\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i) &&&\n    (0::'a) \\<le> x1 * x2", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n 2. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\n 3. (\\<And>i.\n        (0::'a)\n        \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n    (0::'a) \\<le> x1 * x2", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n 2. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\n 3. (\\<And>i.\n        (0::'a)\n        \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n    (0::'a) \\<le> x1 * x2", "assume h:\"(\\<And>i. 0 \\<le> nth_default 0 (x1 # x2 # xs) i)\""], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n 2. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\n 3. (\\<And>i.\n        (0::'a)\n        \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n    (0::'a) \\<le> x1 * x2", "show \"0 \\<le> nth_default 0 (x1 # xs) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "using h[of 0]"], ["proof (prove)\nusing this:\n  i = 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "by force"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "case (Suc nat)"], ["proof (state)\nthis:\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "then"], ["proof (chain)\npicking this:\n  i = Suc nat", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "using h[of \"Suc (Suc nat)\"]"], ["proof (prove)\nusing this:\n  i = Suc nat\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) (Suc (Suc nat))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i", "by force"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       (\\<And>i.\n           (0::'a)\n           \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n       (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\n 2. (\\<And>i.\n        (0::'a)\n        \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n    (0::'a) \\<le> x1 * x2", "show \"0 \\<le> nth_default 0 (x2 # xs) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i", "using h[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) (Suc i)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (0::'a)\n        \\<le> nth_default (0::'a) (x1 # x2 # xs) i) \\<Longrightarrow>\n    (0::'a) \\<le> x1 * x2", "show \"x1*x2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x1 * x2", "using h[of 0] h[of 1]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) 1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x1 * x2", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> x1 * x2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x2 # xs) ?i\n  (0::'a) \\<le> x1 * x2\n\ngoal (3 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 0;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 0;\n        \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) i\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>x1 * x2 < (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x2 # xs) ?i\n  (0::'a) \\<le> x1 * x2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 * x2 < (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x1 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = 0\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n   \\<And>i. (0::'a) \\<le> nth_default (0::'a) (x2 # xs) i\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = 0\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x1 # x2 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x1 # xs) ?i\n  (0::'a) \\<le> nth_default (0::'a) (x2 # xs) ?i\n  (0::'a) \\<le> x1 * x2\n\ngoal (1 subgoal):\n 1. changes (x1 # x2 # xs) = 0", "by auto"], ["proof (state)\nthis:\n  changes (x1 # x2 # xs) = 0\n\ngoal (2 subgoals):\n 1. (\\<And>i. (0::'a) \\<le> nth_default (0::'a) [] i) \\<Longrightarrow>\n    changes [] = 0\n 2. \\<And>uu_.\n       (\\<And>i.\n           (0::'a) \\<le> nth_default (0::'a) [uu_] i) \\<Longrightarrow>\n       changes [uu_] = 0", "qed auto"], ["", "lemma changes_pCons: \"changes (coeffs (pCons 0 f)) = changes (coeffs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (coeffs (pCons (0::'a) f)) = changes (coeffs f)", "by (auto simp: cCons_def)"], ["", "lemma changes_increasing: \n  assumes \"\\<And>i. i < length xs - 1 \\<Longrightarrow> xs ! (i + 1) \\<ge> xs ! i\" \n    and \"length xs > 1\"\n    and \"hd xs < 0\" \n    and \"last xs > 0\"\n  shows \"changes xs = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes xs = 1", "using assms"], ["proof (prove)\nusing this:\n  ?i < length xs - 1 \\<Longrightarrow> xs ! ?i \\<le> xs ! (?i + 1)\n  1 < length xs\n  hd xs < (0::'a)\n  (0::'a) < last xs\n\ngoal (1 subgoal):\n 1. changes xs = 1", "proof (induction xs rule:changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] - 1 \\<Longrightarrow>\n                [] ! i \\<le> [] ! (i + 1);\n     1 < length []; hd [] < (0::'a); (0::'a) < last []\\<rbrakk>\n    \\<Longrightarrow> changes [] = 1\n 2. \\<And>uu_.\n       \\<lbrakk>\\<And>i.\n                   i < length [uu_] - 1 \\<Longrightarrow>\n                   [uu_] ! i \\<le> [uu_] ! (i + 1);\n        1 < length [uu_]; hd [uu_] < (0::'a); (0::'a) < last [uu_]\\<rbrakk>\n       \\<Longrightarrow> changes [uu_] = 1\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    i < length (x2 # xs) - 1 \\<Longrightarrow>\n                    (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n                 1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n                 (0::'a) < last (x2 # xs)\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i.\n            i < length (x1 # xs) - 1 \\<Longrightarrow>\n            (x1 # xs) ! i \\<le> (x1 # xs) ! (i + 1);\n         1 < length (x1 # xs); hd (x1 # xs) < (0::'a);\n         (0::'a) < last (x1 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i.\n            i < length (x2 # xs) - 1 \\<Longrightarrow>\n            (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n         1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n         (0::'a) < last (x2 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<And>i.\n           i < length (x1 # x2 # xs) - 1 \\<Longrightarrow>\n           (x1 # x2 # xs) ! i \\<le> (x1 # x2 # xs) ! (i + 1);\n        1 < length (x1 # x2 # xs); hd (x1 # x2 # xs) < (0::'a);\n        (0::'a) < last (x1 # x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 1", "case (3 x y xs)"], ["proof (state)\nthis:\n  \\<lbrakk>x * y < (0::'a);\n   \\<And>i.\n      i < length (y # xs) - 1 \\<Longrightarrow>\n      (y # xs) ! i \\<le> (y # xs) ! (i + 1);\n   1 < length (y # xs); hd (y # xs) < (0::'a);\n   (0::'a) < last (y # xs)\\<rbrakk>\n  \\<Longrightarrow> changes (y # xs) = 1\n  \\<lbrakk>\\<not> x * y < (0::'a); y = (0::'a);\n   \\<And>i.\n      i < length (x # xs) - 1 \\<Longrightarrow>\n      (x # xs) ! i \\<le> (x # xs) ! (i + 1);\n   1 < length (x # xs); hd (x # xs) < (0::'a);\n   (0::'a) < last (x # xs)\\<rbrakk>\n  \\<Longrightarrow> changes (x # xs) = 1\n  \\<lbrakk>\\<not> x * y < (0::'a); y \\<noteq> (0::'a);\n   \\<And>i.\n      i < length (y # xs) - 1 \\<Longrightarrow>\n      (y # xs) ! i \\<le> (y # xs) ! (i + 1);\n   1 < length (y # xs); hd (y # xs) < (0::'a);\n   (0::'a) < last (y # xs)\\<rbrakk>\n  \\<Longrightarrow> changes (y # xs) = 1\n  ?i < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! ?i \\<le> (x # y # xs) ! (?i + 1)\n  1 < length (x # y # xs)\n  hd (x # y # xs) < (0::'a)\n  (0::'a) < last (x # y # xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] - 1 \\<Longrightarrow>\n                [] ! i \\<le> [] ! (i + 1);\n     1 < length []; hd [] < (0::'a); (0::'a) < last []\\<rbrakk>\n    \\<Longrightarrow> changes [] = 1\n 2. \\<And>uu_.\n       \\<lbrakk>\\<And>i.\n                   i < length [uu_] - 1 \\<Longrightarrow>\n                   [uu_] ! i \\<le> [uu_] ! (i + 1);\n        1 < length [uu_]; hd [uu_] < (0::'a); (0::'a) < last [uu_]\\<rbrakk>\n       \\<Longrightarrow> changes [uu_] = 1\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    i < length (x2 # xs) - 1 \\<Longrightarrow>\n                    (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n                 1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n                 (0::'a) < last (x2 # xs)\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i.\n            i < length (x1 # xs) - 1 \\<Longrightarrow>\n            (x1 # xs) ! i \\<le> (x1 # xs) ! (i + 1);\n         1 < length (x1 # xs); hd (x1 # xs) < (0::'a);\n         (0::'a) < last (x1 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i.\n            i < length (x2 # xs) - 1 \\<Longrightarrow>\n            (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n         1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n         (0::'a) < last (x2 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<And>i.\n           i < length (x1 # x2 # xs) - 1 \\<Longrightarrow>\n           (x1 # x2 # xs) ! i \\<le> (x1 # x2 # xs) ! (i + 1);\n        1 < length (x1 # x2 # xs); hd (x1 # x2 # xs) < (0::'a);\n        (0::'a) < last (x1 # x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 1", "consider (neg)\"x*y<0\" | (nil)\"y=0\" | (pos)\"\\<not>x*y<0 \\<and> \\<not>y=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x * y < (0::'a) \\<Longrightarrow> thesis;\n     y = (0::'a) \\<Longrightarrow> thesis;\n     \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>x * y < (0::'a) \\<Longrightarrow> ?thesis;\n   y = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] - 1 \\<Longrightarrow>\n                [] ! i \\<le> [] ! (i + 1);\n     1 < length []; hd [] < (0::'a); (0::'a) < last []\\<rbrakk>\n    \\<Longrightarrow> changes [] = 1\n 2. \\<And>uu_.\n       \\<lbrakk>\\<And>i.\n                   i < length [uu_] - 1 \\<Longrightarrow>\n                   [uu_] ! i \\<le> [uu_] ! (i + 1);\n        1 < length [uu_]; hd [uu_] < (0::'a); (0::'a) < last [uu_]\\<rbrakk>\n       \\<Longrightarrow> changes [uu_] = 1\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>\\<lbrakk>x1 * x2 < (0::'a);\n                 \\<And>i.\n                    i < length (x2 # xs) - 1 \\<Longrightarrow>\n                    (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n                 1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n                 (0::'a) < last (x2 # xs)\\<rbrakk>\n                \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a);\n         \\<And>i.\n            i < length (x1 # xs) - 1 \\<Longrightarrow>\n            (x1 # xs) ! i \\<le> (x1 # xs) ! (i + 1);\n         1 < length (x1 # xs); hd (x1 # xs) < (0::'a);\n         (0::'a) < last (x1 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = 1;\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a);\n         \\<And>i.\n            i < length (x2 # xs) - 1 \\<Longrightarrow>\n            (x2 # xs) ! i \\<le> (x2 # xs) ! (i + 1);\n         1 < length (x2 # xs); hd (x2 # xs) < (0::'a);\n         (0::'a) < last (x2 # xs)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) = 1;\n        \\<And>i.\n           i < length (x1 # x2 # xs) - 1 \\<Longrightarrow>\n           (x1 # x2 # xs) ! i \\<le> (x1 # x2 # xs) ! (i + 1);\n        1 < length (x1 # x2 # xs); hd (x1 # x2 # xs) < (0::'a);\n        (0::'a) < last (x1 # x2 # xs)\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) = 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x * y < (0::'a) \\<Longrightarrow> ?thesis;\n   y = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x * y < (0::'a) \\<Longrightarrow> ?thesis;\n   y = (0::'a) \\<Longrightarrow> ?thesis;\n   \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 3. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "case neg"], ["proof (state)\nthis:\n  x * y < (0::'a)\n\ngoal (3 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 3. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "have \"changes (y # xs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (y # xs) = 0", "proof (rule changes_all_nonneg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "show \"0 \\<le> nth_default 0 (y # xs) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "proof (cases \"i < length (y # xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i\n 2. \\<not> i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "case True"], ["proof (state)\nthis:\n  i < length (y # xs)\n\ngoal (2 subgoals):\n 1. i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i\n 2. \\<not> i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "then"], ["proof (chain)\npicking this:\n  i < length (y # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length (y # xs)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "using 3(4)[of i]"], ["proof (prove)\nusing this:\n  i < length (y # xs)\n  i < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! i \\<le> (x # y # xs) ! (i + 1)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "apply (induction i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length (y # xs);\n     0 < length (x # y # xs) - 1 \\<Longrightarrow>\n     (x # y # xs) ! 0 \\<le> (x # y # xs) ! (0 + 1)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length (y # xs);\n                 i < length (x # y # xs) - 1 \\<Longrightarrow>\n                 (x # y # xs) ! i \\<le> (x # y # xs) ! (i + 1)\\<rbrakk>\n                \\<Longrightarrow> (0::'a)\n                                  \\<le> nth_default (0::'a) (y # xs) i;\n        Suc i < length (y # xs);\n        Suc i < length (x # y # xs) - 1 \\<Longrightarrow>\n        (x # y # xs) ! Suc i \\<le> (x # y # xs) ! (Suc i + 1)\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) (Suc i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length (y # xs);\n     0 < length (x # y # xs) - 1 \\<Longrightarrow>\n     (x # y # xs) ! 0 \\<le> (x # y # xs) ! (0 + 1)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) 0", "using 3(6) neg"], ["proof (prove)\nusing this:\n  hd (x # y # xs) < (0::'a)\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length (y # xs);\n     0 < length (x # y # xs) - 1 \\<Longrightarrow>\n     (x # y # xs) ! 0 \\<le> (x # y # xs) ! (0 + 1)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) 0", "by (fastforce simp: mult_less_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length (y # xs);\n                 i < length (x # y # xs) - 1 \\<Longrightarrow>\n                 (x # y # xs) ! i \\<le> (x # y # xs) ! (i + 1)\\<rbrakk>\n                \\<Longrightarrow> (0::'a)\n                                  \\<le> nth_default (0::'a) (y # xs) i;\n        Suc i < length (y # xs);\n        Suc i < length (x # y # xs) - 1 \\<Longrightarrow>\n        (x # y # xs) ! Suc i \\<le> (x # y # xs) ! (Suc i + 1)\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) (Suc i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i_ < length (y # xs);\n              i_ < length (x # y # xs) - 1 \\<Longrightarrow>\n              (x # y # xs) ! i_ \\<le> (x # y # xs) ! (i_ + 1)\\<rbrakk>\n             \\<Longrightarrow> (0::'a)\n                               \\<le> nth_default (0::'a) (y # xs) i_;\n     Suc i_ < length (y # xs);\n     Suc i_ < length (x # y # xs) - 1 \\<Longrightarrow>\n     (x # y # xs) ! Suc i_ \\<le> (x # y # xs) ! (Suc i_ + 1)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) (Suc i_)", "using 3(4)"], ["proof (prove)\nusing this:\n  ?i < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! ?i \\<le> (x # y # xs) ! (?i + 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>i_ < length (y # xs);\n              i_ < length (x # y # xs) - 1 \\<Longrightarrow>\n              (x # y # xs) ! i_ \\<le> (x # y # xs) ! (i_ + 1)\\<rbrakk>\n             \\<Longrightarrow> (0::'a)\n                               \\<le> nth_default (0::'a) (y # xs) i_;\n     Suc i_ < length (y # xs);\n     Suc i_ < length (x # y # xs) - 1 \\<Longrightarrow>\n     (x # y # xs) ! Suc i_ \\<le> (x # y # xs) ! (Suc i_ + 1)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> nth_default (0::'a) (y # xs) (Suc i_)", "by (auto simp: nth_default_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (y # xs) i\n\ngoal (1 subgoal):\n 1. \\<not> i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "case False"], ["proof (state)\nthis:\n  \\<not> i < length (y # xs)\n\ngoal (1 subgoal):\n 1. \\<not> i < length (y # xs) \\<Longrightarrow>\n    (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "then"], ["proof (chain)\npicking this:\n  \\<not> i < length (y # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < length (y # xs)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> nth_default (0::'a) (y # xs) i", "by (simp add: nth_default_def)"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (y # xs) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) \\<le> nth_default (0::'a) (y # xs) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes (y # xs) = 0\n\ngoal (3 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 3. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "thus \"changes (x # y # xs) = 1\""], ["proof (prove)\nusing this:\n  changes (y # xs) = 0\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "using neg"], ["proof (prove)\nusing this:\n  changes (y # xs) = 0\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "by force"], ["proof (state)\nthis:\n  changes (x # y # xs) = 1\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "case nil"], ["proof (state)\nthis:\n  y = (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "hence \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using 3(7)"], ["proof (prove)\nusing this:\n  y = (0::'a)\n  (0::'a) < last (x # y # xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by force"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "have h: \"\\<And>i. i < length (x # xs) - 1 \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "assume \"i < length (x # xs) - 1\""], ["proof (state)\nthis:\n  i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "thus \"(x # xs) ! i \\<le> (x # xs) ! (i + 1)\""], ["proof (prove)\nusing this:\n  i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "apply (cases \"i = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (x # xs) - 1; i = 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)\n 2. \\<lbrakk>i < length (x # xs) - 1; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (x # xs) - 1; i = 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "using 3(4)[of 0] 3(4)[of 1] \\<open>xs \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  0 < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! 0 \\<le> (x # y # xs) ! (0 + 1)\n  1 < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! 1 \\<le> (x # y # xs) ! (1 + 1)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (x # xs) - 1; i = 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (x # xs) - 1; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "using 3(4)[of \"i+1\"]"], ["proof (prove)\nusing this:\n  i + 1 < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! (i + 1) \\<le> (x # y # xs) ! (i + 1 + 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (x # xs) - 1; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (x # xs) ! i \\<le> (x # xs) ! (i + 1)", "by simp"], ["proof (state)\nthis:\n  (x # xs) ! i \\<le> (x # xs) ! (i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (x # xs) - 1 \\<Longrightarrow>\n  (x # xs) ! ?i \\<le> (x # xs) ! (?i + 1)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "have \"changes (x # xs) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (x # xs) = 1", "apply (rule 3(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<not> x * y < (0::'a)\n 2. y = (0::'a)\n 3. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)\n 4. 1 < length (x # xs)\n 5. hd (x # xs) < (0::'a)\n 6. (0::'a) < last (x # xs)", "using nil h \\<open>xs \\<noteq> []\\<close> 3(6) 3(7)"], ["proof (prove)\nusing this:\n  y = (0::'a)\n  ?i < length (x # xs) - 1 \\<Longrightarrow>\n  (x # xs) ! ?i \\<le> (x # xs) ! (?i + 1)\n  xs \\<noteq> []\n  hd (x # y # xs) < (0::'a)\n  (0::'a) < last (x # y # xs)\n\ngoal (6 subgoals):\n 1. \\<not> x * y < (0::'a)\n 2. y = (0::'a)\n 3. \\<And>i.\n       i < length (x # xs) - 1 \\<Longrightarrow>\n       (x # xs) ! i \\<le> (x # xs) ! (i + 1)\n 4. 1 < length (x # xs)\n 5. hd (x # xs) < (0::'a)\n 6. (0::'a) < last (x # xs)", "by auto"], ["proof (state)\nthis:\n  changes (x # xs) = 1\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> changes (x # y # xs) = 1\n 2. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes (x # xs) = 1\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "using nil"], ["proof (prove)\nusing this:\n  changes (x # xs) = 1\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "by force"], ["proof (state)\nthis:\n  changes (x # y # xs) = 1\n\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "case pos"], ["proof (state)\nthis:\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "hence \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using 3(6) 3(7)"], ["proof (prove)\nusing this:\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n  hd (x # y # xs) < (0::'a)\n  (0::'a) < last (x # y # xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (fastforce simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "have \"changes (y # xs) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (y # xs) = 1", "proof (rule 3(3))"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<not> x * y < (0::'a)\n 2. y \\<noteq> (0::'a)\n 3. \\<And>i.\n       i < length (y # xs) - 1 \\<Longrightarrow>\n       (y # xs) ! i \\<le> (y # xs) ! (i + 1)\n 4. 1 < length (y # xs)\n 5. hd (y # xs) < (0::'a)\n 6. (0::'a) < last (y # xs)", "show \"\\<not> x * y < 0\" \"y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) &&& y \\<noteq> (0::'a)", "using pos"], ["proof (prove)\nusing this:\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) &&& y \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<not> x * y < (0::'a)\n  y \\<noteq> (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>i.\n       i < length (y # xs) - 1 \\<Longrightarrow>\n       (y # xs) ! i \\<le> (y # xs) ! (i + 1)\n 2. 1 < length (y # xs)\n 3. hd (y # xs) < (0::'a)\n 4. (0::'a) < last (y # xs)", "show \"\\<And>i. i < length (y # xs) - 1 \n        \\<Longrightarrow> (y # xs) ! i \\<le> (y # xs) ! (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (y # xs) - 1 \\<Longrightarrow>\n       (y # xs) ! i \\<le> (y # xs) ! (i + 1)", "using 3(4)"], ["proof (prove)\nusing this:\n  ?i < length (x # y # xs) - 1 \\<Longrightarrow>\n  (x # y # xs) ! ?i \\<le> (x # y # xs) ! (?i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (y # xs) - 1 \\<Longrightarrow>\n       (y # xs) ! i \\<le> (y # xs) ! (i + 1)", "by force"], ["proof (state)\nthis:\n  ?i < length (y # xs) - 1 \\<Longrightarrow>\n  (y # xs) ! ?i \\<le> (y # xs) ! (?i + 1)\n\ngoal (3 subgoals):\n 1. 1 < length (y # xs)\n 2. hd (y # xs) < (0::'a)\n 3. (0::'a) < last (y # xs)", "show \"1 < length (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length (y # xs)", "using \\<open>xs \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 < length (y # xs)", "by force"], ["proof (state)\nthis:\n  1 < length (y # xs)\n\ngoal (2 subgoals):\n 1. hd (y # xs) < (0::'a)\n 2. (0::'a) < last (y # xs)", "show \"hd (y # xs) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (y # xs) < (0::'a)", "using 3(6) pos"], ["proof (prove)\nusing this:\n  hd (x # y # xs) < (0::'a)\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. hd (y # xs) < (0::'a)", "by (force simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  hd (y # xs) < (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < last (y # xs)", "show \"0 < last (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < last (y # xs)", "using 3(7)"], ["proof (prove)\nusing this:\n  (0::'a) < last (x # y # xs)\n\ngoal (1 subgoal):\n 1. (0::'a) < last (y # xs)", "by force"], ["proof (state)\nthis:\n  (0::'a) < last (y # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes (y # xs) = 1\n\ngoal (1 subgoal):\n 1. \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a) \\<Longrightarrow>\n    changes (x # y # xs) = 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes (y # xs) = 1\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "using pos"], ["proof (prove)\nusing this:\n  changes (y # xs) = 1\n  \\<not> x * y < (0::'a) \\<and> y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes (x # y # xs) = 1", "by auto"], ["proof (state)\nthis:\n  changes (x # y # xs) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes (x # y # xs) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                i < length [] - 1 \\<Longrightarrow>\n                [] ! i \\<le> [] ! (i + 1);\n     1 < length []; hd [] < (0::'a); (0::'a) < last []\\<rbrakk>\n    \\<Longrightarrow> changes [] = 1\n 2. \\<And>uu_.\n       \\<lbrakk>\\<And>i.\n                   i < length [uu_] - 1 \\<Longrightarrow>\n                   [uu_] ! i \\<le> [uu_] ! (i + 1);\n        1 < length [uu_]; hd [uu_] < (0::'a); (0::'a) < last [uu_]\\<rbrakk>\n       \\<Longrightarrow> changes [uu_] = 1", "qed auto"], ["", "end"]]}