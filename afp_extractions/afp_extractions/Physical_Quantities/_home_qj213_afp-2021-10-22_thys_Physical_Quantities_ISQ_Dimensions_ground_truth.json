{"file_name": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities/ISQ_Dimensions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities", "problem_names": ["lemma UNIV_unitary: \"UNIV = {a::'a}\"", "lemma eq_unit: \"(a::'a) = b\"", "lemma unitary_intro: \"(UNIV::'s set) = {a} \\<Longrightarrow> OFCLASS('s, unitary_class)\"", "lemma mk_dimvec_inj: \"inj_on (mk_dimvec :: 'n list \\<Rightarrow> ('n::ring_1, 'd::enum) dimvec) {xs. length xs = CARD('d)}\"", "lemma mk_dimvec_eq_iff [simp]: \n  assumes \"length x = CARD('d)\" \"length y = CARD('d)\"\n  shows \"((mk_dimvec x :: ('n::ring_1, 'd::enum) dimvec) = mk_dimvec y) \\<longleftrightarrow> (x = y)\"", "lemma one_mk_dimvec [code, si_def]: \"(1::('n::ring_1, 'a::enum) dimvec) = mk_dimvec (replicate CARD('a) 0)\"", "lemma times_mk_dimvec [code, si_def]:\n  \"(mk_dimvec xs * mk_dimvec ys :: ('n::ring_1, 'a::enum) dimvec) = \n  (if (length xs = CARD('a) \\<and> length ys = CARD('a))\n    then mk_dimvec (map (\\<lambda> (x, y). x + y) (zip xs ys))\n    else if length xs = CARD('a) then mk_dimvec xs else mk_dimvec ys)\"", "lemma power_mk_dimvec [si_def]:\n  \"(power (mk_dimvec xs) n :: ('n::ring_1, 'a::enum) dimvec) = \n    (if (length xs = CARD('a)) then mk_dimvec (map ((*) (of_nat n)) xs) else mk_dimvec xs)\"", "lemma inverse_mk_dimvec [code, si_def]:\n  \"(inverse (mk_dimvec xs) :: ('n::ring_1, 'a::enum) dimvec) = \n   (if (length xs = CARD('a)) then mk_dimvec (map uminus xs) else 1)\"", "lemma divide_mk_dimvec [code, si_def]:\n  \"(mk_dimvec xs / mk_dimvec ys :: ('n::ring_1, 'a::enum) dimvec) = \n  (if (length xs = CARD('a) \\<and> length ys = CARD('a))\n    then mk_dimvec (map (\\<lambda> (x, y). x - y) (zip xs ys))\n    else if length ys = CARD('a) then mk_dimvec (map uminus ys) else mk_dimvec xs)\"", "lemma mk_BaseDim_neq [simp]: \"x \\<noteq> y \\<Longrightarrow> mk_BaseDim x \\<noteq> mk_BaseDim y\"", "lemma mk_BaseDim_code [code]: \"mk_BaseDim (d::'d::enum) = mk_dimvec (list_update (replicate CARD('d) 0) (enum_ind d) 1)\"", "lemma is_BaseDim_mk [simp]: \"is_BaseDim (mk_BaseDim x)\"", "lemma sdim_UNIV: \"(UNIV :: sdim set) = {Length, Mass, Time, Current, Temperature, Amount, Intensity}\"", "lemma CARD_sdim [simp]: \"CARD(sdim) = 7\"", "lemma sdim_enum [simp]:\n  \"enum_ind Length = 0\" \"enum_ind Mass = 1\" \"enum_ind Time = 2\" \"enum_ind Current = 3\"\n  \"enum_ind Temperature = 4\" \"enum_ind Amount = 5\" \"enum_ind Intensity = 6\"", "lemma BD_mk_dimvec [si_def]: \n  \"\\<^bold>L = mk_dimvec [1, 0, 0, 0, 0, 0, 0]\"\n  \"\\<^bold>M = mk_dimvec [0, 1, 0, 0, 0, 0, 0]\"\n  \"\\<^bold>T = mk_dimvec [0, 0, 1, 0, 0, 0, 0]\"\n  \"\\<^bold>I = mk_dimvec [0, 0, 0, 1, 0, 0, 0]\"\n  \"\\<^bold>\\<Theta> = mk_dimvec [0, 0, 0, 0, 1, 0, 0]\"\n  \"\\<^bold>N = mk_dimvec [0, 0, 0, 0, 0, 1, 0]\"\n  \"\\<^bold>J = mk_dimvec [0, 0, 0, 0, 0, 0, 1]\"", "lemma seven_BaseDimensions: \"card BaseDimensions = 7\"", "lemma \"\\<^bold>L\\<cdot>\\<^bold>M\\<cdot>\\<^bold>T\\<^sup>-\\<^sup>2 = mk_dimvec [1, 1, - 2, 0, 0, 0, 0]\"", "lemma base_dimension_types [simp]: \n  \"is_BaseDim QD(Length)\" \"is_BaseDim QD(Mass)\" \"is_BaseDim QD(Time)\" \"is_BaseDim QD(Current)\" \n  \"is_BaseDim QD(Temperature)\" \"is_BaseDim QD(Amount)\" \"is_BaseDim QD(Intensity)\""], "translations": [["", "lemma UNIV_unitary: \"UNIV = {a::'a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV = {a}", "have \"card(UNIV :: 'a set) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = 1", "by (simp add: local.unitary_unit_pres)"], ["proof (state)\nthis:\n  CARD('a) = 1\n\ngoal (1 subgoal):\n 1. UNIV = {a}", "thus ?thesis"], ["proof (prove)\nusing this:\n  CARD('a) = 1\n\ngoal (1 subgoal):\n 1. UNIV = {a}", "by (metis (full_types) UNIV_I card_1_singletonE empty_iff insert_iff)"], ["proof (state)\nthis:\n  UNIV = {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_unit: \"(a::'a) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "by (metis (full_types) UNIV_unitary iso_tuple_UNIV_I singletonD)"], ["", "end"], ["", "lemma unitary_intro: \"(UNIV::'s set) = {a} \\<Longrightarrow> OFCLASS('s, unitary_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {a} \\<Longrightarrow> OFCLASS('s, unitary_class)", "apply (intro_classes, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. UNIV = {a} \\<Longrightarrow> finite UNIV\n 2. UNIV = {a} \\<Longrightarrow> CARD('s) = Suc 0", "using finite.simps"], ["proof (prove)\nusing this:\n  finite ?a =\n  (?a = {} \\<or> (\\<exists>A a. ?a = insert a A \\<and> finite A))\n\ngoal (2 subgoals):\n 1. UNIV = {a} \\<Longrightarrow> finite UNIV\n 2. UNIV = {a} \\<Longrightarrow> CARD('s) = Suc 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {a} \\<Longrightarrow> CARD('s) = Suc 0", "using card_1_singleton_iff"], ["proof (prove)\nusing this:\n  (card ?A = Suc 0) = (\\<exists>x. ?A = {x})\n\ngoal (1 subgoal):\n 1. UNIV = {a} \\<Longrightarrow> CARD('s) = Suc 0", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "named_theorems si_def and si_eq"], ["", "instantiation unit :: comm_monoid_add\nbegin"], ["", "definition \"zero_unit = ()\""], ["", "definition \"plus_unit (x::unit) (y::unit) = ()\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "qed (simp_all)"], ["", "end"], ["", "instantiation unit :: comm_monoid_mult\nbegin"], ["", "definition \"one_unit = ()\""], ["", "definition \"times_unit (x::unit) (y::unit) = ()\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, comm_monoid_mult_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\n 2. \\<And>a b. a \\<cdot> b = b \\<cdot> a\n 3. \\<And>a. 1 \\<cdot> a = a", "qed (simp_all)"], ["", "end"], ["", "instantiation unit :: inverse\nbegin"], ["", "definition \"inverse_unit (x::unit) = ()\""], ["", "definition \"divide_unit (x::unit) (y::unit) = ()\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, inverse_class)", ".."], ["", "end"], ["", "instance unit :: ab_group_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, ab_group_mult_class)", "by (intro_classes, simp_all)"], ["", "subsection \\<open> Dimension Vectors \\<close>"], ["", "text \\<open> Quantity dimensions are used to distinguish quantities of different kinds. Only quantities\n  of the same kind can be compared and combined: it is a mistake to add a length to a mass, for\n  example. Dimensions are often expressed in terms of seven base quantities, which can be combined \n  to form derived quantities. Consequently, a dimension associates with each of the base quantities \n  an integer that denotes the power to which it is raised. We use a special vector type to represent\n  dimensions, and then specialise this to the seven major dimensions. \\<close>"], ["", "typedef ('n, 'd) dimvec = \"UNIV :: ('d::enum \\<Rightarrow> 'n) set\"\n  morphisms dim_nth dim_lambda"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "declare dim_lambda_inject [simplified, simp]"], ["", "declare dim_nth_inverse [simp]"], ["", "declare dim_lambda_inverse [simplified, simp]"], ["", "instantiation dimvec :: (zero, enum) \"one\"\nbegin"], ["", "definition one_dimvec :: \"('a, 'b) dimvec\" where \"one_dimvec = dim_lambda (\\<lambda> i. 0)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) dimvec, one_class)", ".."], ["", "end"], ["", "instantiation dimvec :: (plus, enum) times\nbegin"], ["", "definition times_dimvec :: \"('a, 'b) dimvec \\<Rightarrow> ('a, 'b) dimvec \\<Rightarrow> ('a, 'b) dimvec\" where\n\"times_dimvec x y = dim_lambda (\\<lambda> i. dim_nth x i + dim_nth y i)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) dimvec, times_class)", ".."], ["", "end"], ["", "instance dimvec :: (comm_monoid_add, enum) comm_monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) dimvec, comm_monoid_mult_class)", "by ((intro_classes; simp add: times_dimvec_def one_dimvec_def fun_eq_iff add.assoc), simp add: add.commute)"], ["", "text \\<open> We also define the inverse and division operations, and an abelian group, which will allow\n  us to perform dimensional analysis. \\<close>"], ["", "instantiation dimvec :: (\"{plus,uminus}\", enum) inverse\nbegin"], ["", "definition inverse_dimvec :: \"('a, 'b) dimvec \\<Rightarrow> ('a, 'b) dimvec\" where\n\"inverse_dimvec x = dim_lambda (\\<lambda> i. - dim_nth x i)\""], ["", "definition divide_dimvec :: \"('a, 'b) dimvec \\<Rightarrow> ('a, 'b) dimvec \\<Rightarrow> ('a, 'b) dimvec\" where\n[code_unfold]: \"divide_dimvec x y = x * (inverse y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) dimvec, inverse_class)", ".."], ["", "end"], ["", "instance dimvec :: (ab_group_add, enum) ab_group_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) dimvec, ab_group_mult_class)", "by (intro_classes, simp_all add: inverse_dimvec_def one_dimvec_def times_dimvec_def divide_dimvec_def)"], ["", "subsection \\<open> Code Generation \\<close>"], ["", "text \\<open> Dimension vectors can be represented using lists, which enables code generation and thus\n  efficient proof. \\<close>"], ["", "definition mk_dimvec :: \"'n list \\<Rightarrow> ('n::ring_1, 'd::enum) dimvec\" \n  where \"mk_dimvec ds = (if (length ds = CARD('d)) then dim_lambda (\\<lambda> d. ds ! enum_ind d) else 1)\""], ["", "code_datatype mk_dimvec"], ["", "lemma mk_dimvec_inj: \"inj_on (mk_dimvec :: 'n list \\<Rightarrow> ('n::ring_1, 'd::enum) dimvec) {xs. length xs = CARD('d)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mk_dimvec {xs. length xs = CARD('d)}", "proof (rule inj_onI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mk_dimvec x = mk_dimvec y; length x = CARD('d);\n        length y = CARD('d)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: \"'n list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mk_dimvec x = mk_dimvec y; length x = CARD('d);\n        length y = CARD('d)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a: \"(mk_dimvec x :: ('n, 'd) dimvec) = mk_dimvec y\" \"length x = CARD('d)\" \"length y = CARD('d)\""], ["proof (state)\nthis:\n  mk_dimvec x = mk_dimvec y\n  length x = CARD('d)\n  length y = CARD('d)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mk_dimvec x = mk_dimvec y; length x = CARD('d);\n        length y = CARD('d)\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i", "assume \"i < length x\""], ["proof (state)\nthis:\n  i < length x\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i", "with a"], ["proof (chain)\npicking this:\n  mk_dimvec x = mk_dimvec y\n  length x = CARD('d)\n  length y = CARD('d)\n  i < length x", "have \"enum_ind (ENUM('d) ! i) = i\""], ["proof (prove)\nusing this:\n  mk_dimvec x = mk_dimvec y\n  length x = CARD('d)\n  length y = CARD('d)\n  i < length x\n\ngoal (1 subgoal):\n 1. enum_ind (enum_class.enum ! i) = i", "by (simp)"], ["proof (state)\nthis:\n  enum_ind (enum_class.enum ! i) = i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x \\<Longrightarrow> x ! i = y ! i", "with a"], ["proof (chain)\npicking this:\n  mk_dimvec x = mk_dimvec y\n  length x = CARD('d)\n  length y = CARD('d)\n  enum_ind (enum_class.enum ! i) = i", "show \"x ! i = y ! i\""], ["proof (prove)\nusing this:\n  mk_dimvec x = mk_dimvec y\n  length x = CARD('d)\n  length y = CARD('d)\n  enum_ind (enum_class.enum ! i) = i\n\ngoal (1 subgoal):\n 1. x ! i = y ! i", "by (auto simp add: mk_dimvec_def fun_eq_iff, metis)"], ["proof (state)\nthis:\n  x ! i = y ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length x \\<Longrightarrow> x ! ?i = y ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mk_dimvec x = mk_dimvec y; length x = CARD('d);\n        length y = CARD('d)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  ?i < length x \\<Longrightarrow> x ! ?i = y ! ?i", "show \"x = y\""], ["proof (prove)\nusing this:\n  ?i < length x \\<Longrightarrow> x ! ?i = y ! ?i\n\ngoal (1 subgoal):\n 1. x = y", "by (metis a(2) a(3) nth_equalityI)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_dimvec_eq_iff [simp]: \n  assumes \"length x = CARD('d)\" \"length y = CARD('d)\"\n  shows \"((mk_dimvec x :: ('n::ring_1, 'd::enum) dimvec) = mk_dimvec y) \\<longleftrightarrow> (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk_dimvec x = mk_dimvec y) = (x = y)", "by (rule inj_on_eq_iff[OF mk_dimvec_inj], simp_all add: assms)"], ["", "lemma one_mk_dimvec [code, si_def]: \"(1::('n::ring_1, 'a::enum) dimvec) = mk_dimvec (replicate CARD('a) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = mk_dimvec (replicate CARD('a) (0::'n))", "by (auto simp add: mk_dimvec_def one_dimvec_def)"], ["", "lemma times_mk_dimvec [code, si_def]:\n  \"(mk_dimvec xs * mk_dimvec ys :: ('n::ring_1, 'a::enum) dimvec) = \n  (if (length xs = CARD('a) \\<and> length ys = CARD('a))\n    then mk_dimvec (map (\\<lambda> (x, y). x + y) (zip xs ys))\n    else if length xs = CARD('a) then mk_dimvec xs else mk_dimvec ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_dimvec xs \\<cdot> mk_dimvec ys =\n    (if length xs = CARD('a) \\<and> length ys = CARD('a)\n     then mk_dimvec (map2 (+) xs ys)\n     else if length xs = CARD('a) then mk_dimvec xs else mk_dimvec ys)", "by (auto simp add: times_dimvec_def mk_dimvec_def fun_eq_iff one_dimvec_def)"], ["", "lemma power_mk_dimvec [si_def]:\n  \"(power (mk_dimvec xs) n :: ('n::ring_1, 'a::enum) dimvec) = \n    (if (length xs = CARD('a)) then mk_dimvec (map ((*) (of_nat n)) xs) else mk_dimvec xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_dimvec xs ^ n =\n    (if length xs = CARD('a) then mk_dimvec (map ((\\<cdot>) (of_nat n)) xs)\n     else mk_dimvec xs)", "by (induct n, simp add: one_dimvec_def mk_dimvec_def)\n     (auto simp add: times_mk_dimvec zip_map_map[where f=\"id\", simplified] comp_def split_beta' zip_same_conv_map distrib_right mult.commute)"], ["", "lemma inverse_mk_dimvec [code, si_def]:\n  \"(inverse (mk_dimvec xs) :: ('n::ring_1, 'a::enum) dimvec) = \n   (if (length xs = CARD('a)) then mk_dimvec (map uminus xs) else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (mk_dimvec xs) =\n    (if length xs = CARD('a) then mk_dimvec (map uminus xs) else 1)", "by (auto simp add: inverse_dimvec_def one_dimvec_def mk_dimvec_def fun_eq_iff)"], ["", "lemma divide_mk_dimvec [code, si_def]:\n  \"(mk_dimvec xs / mk_dimvec ys :: ('n::ring_1, 'a::enum) dimvec) = \n  (if (length xs = CARD('a) \\<and> length ys = CARD('a))\n    then mk_dimvec (map (\\<lambda> (x, y). x - y) (zip xs ys))\n    else if length ys = CARD('a) then mk_dimvec (map uminus ys) else mk_dimvec xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_dimvec xs / mk_dimvec ys =\n    (if length xs = CARD('a) \\<and> length ys = CARD('a)\n     then mk_dimvec (map2 (-) xs ys)\n     else if length ys = CARD('a) then mk_dimvec (map uminus ys)\n          else mk_dimvec xs)", "by (auto simp add: divide_dimvec_def inverse_mk_dimvec times_mk_dimvec zip_map_map[where f=\"id\", simplified] comp_def split_beta')"], ["", "text \\<open> A base dimension is a dimension where precisely one component has power 1: it is the \n  dimension of a base quantity. Here we define the seven base dimensions. \\<close>"], ["", "definition mk_BaseDim :: \"'d::enum \\<Rightarrow> (int, 'd) dimvec\" where\n\"mk_BaseDim d = dim_lambda (\\<lambda> i. if (i = d) then 1 else 0)\""], ["", "lemma mk_BaseDim_neq [simp]: \"x \\<noteq> y \\<Longrightarrow> mk_BaseDim x \\<noteq> mk_BaseDim y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> mk_BaseDim x \\<noteq> mk_BaseDim y", "by (auto simp add: mk_BaseDim_def fun_eq_iff)"], ["", "lemma mk_BaseDim_code [code]: \"mk_BaseDim (d::'d::enum) = mk_dimvec (list_update (replicate CARD('d) 0) (enum_ind d) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_BaseDim d = mk_dimvec ((replicate CARD('d) 0)[enum_ind d := 1])", "by (auto simp add: mk_BaseDim_def mk_dimvec_def fun_eq_iff)"], ["", "definition is_BaseDim :: \"(int, 'd::enum) dimvec \\<Rightarrow> bool\" \n  where \"is_BaseDim x \\<equiv> (\\<exists> i. x = dim_lambda ((\\<lambda> x. 0)(i := 1)))\""], ["", "lemma is_BaseDim_mk [simp]: \"is_BaseDim (mk_BaseDim x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_BaseDim (mk_BaseDim x)", "by (auto simp add: mk_BaseDim_def is_BaseDim_def fun_eq_iff)"], ["", "subsection \\<open> Dimension Semantic Domain \\<close>"], ["", "text \\<open> We next specialise dimension vectors to the usual seven place vector. \\<close>"], ["", "datatype sdim = Length | Mass | Time | Current | Temperature | Amount | Intensity"], ["", "lemma sdim_UNIV: \"(UNIV :: sdim set) = {Length, Mass, Time, Current, Temperature, Amount, Intensity}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {Length, Mass, Time, Current, Temperature, Amount, Intensity}", "using sdim.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Length \\<Longrightarrow> ?P; ?y = Mass \\<Longrightarrow> ?P;\n   ?y = Time \\<Longrightarrow> ?P; ?y = Current \\<Longrightarrow> ?P;\n   ?y = Temperature \\<Longrightarrow> ?P; ?y = Amount \\<Longrightarrow> ?P;\n   ?y = Intensity \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = {Length, Mass, Time, Current, Temperature, Amount, Intensity}", "by blast"], ["", "lemma CARD_sdim [simp]: \"CARD(sdim) = 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD(sdim) = 7", "by (simp add: sdim_UNIV)"], ["", "instantiation sdim :: enum\nbegin"], ["", "definition \"enum_sdim = [Length, Mass, Time, Current, Temperature, Amount, Intensity]\""], ["", "definition \"enum_all_sdim P \\<longleftrightarrow> P Length \\<and> P Mass \\<and> P Time \\<and> P Current \\<and> P Temperature \\<and> P Amount \\<and> P Intensity\""], ["", "definition \"enum_ex_sdim P \\<longleftrightarrow> P Length \\<or> P Mass \\<or> P Time \\<or> P Current \\<or> P Temperature \\<or> P Amount \\<or> P Intensity\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(sdim, enum_class)", "by (intro_classes, simp_all add: sdim_UNIV enum_sdim_def enum_all_sdim_def enum_ex_sdim_def)"], ["", "end"], ["", "instantiation sdim :: card_UNIV \nbegin"], ["", "definition \"finite_UNIV = Phantom(sdim) True\""], ["", "definition \"card_UNIV = Phantom(sdim) 7\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(sdim, card_UNIV_class)", "by (intro_classes, simp_all add: finite_UNIV_sdim_def card_UNIV_sdim_def)"], ["", "end"], ["", "lemma sdim_enum [simp]:\n  \"enum_ind Length = 0\" \"enum_ind Mass = 1\" \"enum_ind Time = 2\" \"enum_ind Current = 3\"\n  \"enum_ind Temperature = 4\" \"enum_ind Amount = 5\" \"enum_ind Intensity = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enum_ind Length = 0 &&& enum_ind Mass = 1 &&& enum_ind Time = 2) &&&\n    (enum_ind Current = 3 &&& enum_ind Temperature = 4) &&&\n    enum_ind Amount = 5 &&& enum_ind Intensity = 6", "by (simp_all add: enum_ind_def enum_sdim_def)"], ["", "type_synonym Dimension = \"(int, sdim) dimvec\""], ["", "abbreviation LengthBD      (\"\\<^bold>L\") where \"\\<^bold>L \\<equiv> mk_BaseDim Length\""], ["", "abbreviation MassBD        (\"\\<^bold>M\") where \"\\<^bold>M \\<equiv> mk_BaseDim Mass\""], ["", "abbreviation TimeBD        (\"\\<^bold>T\") where \"\\<^bold>T \\<equiv> mk_BaseDim Time\""], ["", "abbreviation CurrentBD     (\"\\<^bold>I\") where \"\\<^bold>I \\<equiv> mk_BaseDim Current\""], ["", "abbreviation TemperatureBD (\"\\<^bold>\\<Theta>\") where \"\\<^bold>\\<Theta> \\<equiv> mk_BaseDim Temperature\""], ["", "abbreviation AmountBD      (\"\\<^bold>N\") where \"\\<^bold>N \\<equiv> mk_BaseDim Amount\""], ["", "abbreviation IntensityBD   (\"\\<^bold>J\") where \"\\<^bold>J \\<equiv> mk_BaseDim Intensity\""], ["", "abbreviation \"BaseDimensions \\<equiv> {\\<^bold>L, \\<^bold>M, \\<^bold>T, \\<^bold>I, \\<^bold>\\<Theta>, \\<^bold>N, \\<^bold>J}\""], ["", "lemma BD_mk_dimvec [si_def]: \n  \"\\<^bold>L = mk_dimvec [1, 0, 0, 0, 0, 0, 0]\"\n  \"\\<^bold>M = mk_dimvec [0, 1, 0, 0, 0, 0, 0]\"\n  \"\\<^bold>T = mk_dimvec [0, 0, 1, 0, 0, 0, 0]\"\n  \"\\<^bold>I = mk_dimvec [0, 0, 0, 1, 0, 0, 0]\"\n  \"\\<^bold>\\<Theta> = mk_dimvec [0, 0, 0, 0, 1, 0, 0]\"\n  \"\\<^bold>N = mk_dimvec [0, 0, 0, 0, 0, 1, 0]\"\n  \"\\<^bold>J = mk_dimvec [0, 0, 0, 0, 0, 0, 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>L = mk_dimvec [1, 0, 0, 0, 0, 0, 0] &&&\n     \\<^bold>M = mk_dimvec [0, 1, 0, 0, 0, 0, 0] &&&\n     \\<^bold>T = mk_dimvec [0, 0, 1, 0, 0, 0, 0]) &&&\n    (\\<^bold>I = mk_dimvec [0, 0, 0, 1, 0, 0, 0] &&&\n     \\<^bold>\\<Theta> = mk_dimvec [0, 0, 0, 0, 1, 0, 0]) &&&\n    \\<^bold>N = mk_dimvec [0, 0, 0, 0, 0, 1, 0] &&&\n    \\<^bold>J = mk_dimvec [0, 0, 0, 0, 0, 0, 1]", "by (simp_all add: mk_BaseDim_code eval_nat_numeral)"], ["", "text \\<open> The following lemma confirms that there are indeed seven unique base dimensions. \\<close>"], ["", "lemma seven_BaseDimensions: \"card BaseDimensions = 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card BaseDimensions = 7", "by simp"], ["", "text \\<open> We can use the base dimensions and algebra to form dimension expressions. Some examples\n  are shown below. \\<close>"], ["", "term \"\\<^bold>L\\<cdot>\\<^bold>M\\<cdot>\\<^bold>T\\<^sup>-\\<^sup>2\""], ["", "term \"\\<^bold>M\\<cdot>\\<^bold>L\\<^sup>-\\<^sup>3\""], ["", "value \"\\<^bold>L\\<cdot>\\<^bold>M\\<cdot>\\<^bold>T\\<^sup>-\\<^sup>2\""], ["", "lemma \"\\<^bold>L\\<cdot>\\<^bold>M\\<cdot>\\<^bold>T\\<^sup>-\\<^sup>2 = mk_dimvec [1, 1, - 2, 0, 0, 0, 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>L \\<cdot> \\<^bold>M \\<cdot> inverse (\\<^bold>T\\<^sup>2) =\n    mk_dimvec [1, 1, - 2, 0, 0, 0, 0]", "by (simp add: si_def)"], ["", "subsection \\<open> Dimension Type Expressions \\<close>"], ["", "subsubsection \\<open> Classification \\<close>"], ["", "text \\<open> We provide a syntax for dimension type expressions, which allows representation of \n  dimensions as types in Isabelle. This will allow us to represent quantities that are parametrised \n  by a particular dimension type. We first must characterise the subclass of types that represent a \n  dimension.\n\n  The mechanism in Isabelle to characterize a certain subclass of Isabelle type expressions\n  are \\<^emph>\\<open>type classes\\<close>. The following type class is used to link particular Isabelle types\n  to an instance of the type \\<^typ>\\<open>Dimension\\<close>. It requires that any such type has the cardinality\n  \\<^term>\\<open>1\\<close>, since a dimension type is used only to mark a quantity.\n  \\<close>"], ["", "class dim_type = unitary +\n  fixes   dim_ty_sem :: \"'a itself \\<Rightarrow> Dimension\""], ["", "syntax\n  \"_QD\" :: \"type \\<Rightarrow> logic\" (\"QD'(_')\")"], ["", "translations\n  \"QD('a)\" == \"CONST dim_ty_sem TYPE('a)\""], ["", "text \\<open> The notation \\<^term>\\<open>QD('a::dim_type)\\<close> allows to obtain the dimension of a dimension type\n  \\<^typ>\\<open>'a\\<close>. \n\n  The subset of basic dimension types can be characterized by the following type class: \\<close>"], ["", "class basedim_type = dim_type +\n  assumes is_BaseDim: \"is_BaseDim QD('a)\""], ["", "subsubsection \\<open> Base Dimension Type Expressions \\<close>"], ["", "text \\<open> The definition of the basic dimension type constructors is straightforward via a\n  one-elementary set, \\<^typ>\\<open>unit set\\<close>. The latter is adequate since we need just an abstract syntax \n  for type expressions, so just one value for the \\<^verbatim>\\<open>dimension\\<close>-type symbols. We define types for\n  each of the seven base dimensions, and also for dimensionless quantities. \\<close>"], ["", "typedef Length      = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Length"], ["", "typedef Mass        = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Mass"], ["", "typedef Time        = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Time"], ["", "typedef Current     = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Current"], ["", "typedef Temperature = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Temperature"], ["", "typedef Amount      = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Amount"], ["", "typedef Intensity   = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_Intensity"], ["", "typedef NoDimension = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_NoDimension"], ["", "type_synonym M = Mass"], ["", "type_synonym L = Length"], ["", "type_synonym T = Time"], ["", "type_synonym I = Current"], ["", "type_synonym \\<Theta> = Temperature"], ["", "type_synonym N = Amount"], ["", "type_synonym J = Intensity"], ["", "type_notation NoDimension (\"\\<one>\")"], ["", "translations\n  (type) \"M\" <= (type) \"Mass\"\n  (type) \"L\" <= (type) \"Length\"\n  (type) \"T\" <= (type) \"Time\"\n  (type) \"I\" <= (type) \"Current\"\n  (type) \"\\<Theta>\" <= (type) \"Temperature\"\n  (type) \"N\" <= (type) \"Amount\"\n  (type) \"J\" <= (type) \"Intensity\""], ["", "text\\<open> Next, we embed the base dimensions into the dimension type expressions by instantiating the \n  class \\<^class>\\<open>basedim_type\\<close> with each of the base dimension types. \\<close>"], ["", "instantiation Length :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Length (_::Length itself) = \\<^bold>L\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(L, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Length_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Mass :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Mass (_::Mass itself) = \\<^bold>M\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(M, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Mass_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Time :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Time (_::Time itself) = \\<^bold>T\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(T, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Time_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Current :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Current (_::Current itself) = \\<^bold>I\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(I, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Current_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Temperature :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Temperature (_::Temperature itself) = \\<^bold>\\<Theta>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<Theta>, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Temperature_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Amount :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Amount (_::Amount itself) = \\<^bold>N\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(N, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Amount_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation Intensity :: basedim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_Intensity (_::Intensity itself) = \\<^bold>J\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(J, basedim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_Intensity_def, (transfer, simp)+)"], ["", "end"], ["", "instantiation NoDimension :: dim_type\nbegin"], ["", "definition [si_eq]: \"dim_ty_sem_NoDimension (_::NoDimension itself) = (1::Dimension)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<one>, dim_type_class)", "by (intro_classes, auto simp add: dim_ty_sem_NoDimension_def, (transfer, simp)+)"], ["", "end"], ["", "lemma base_dimension_types [simp]: \n  \"is_BaseDim QD(Length)\" \"is_BaseDim QD(Mass)\" \"is_BaseDim QD(Time)\" \"is_BaseDim QD(Current)\" \n  \"is_BaseDim QD(Temperature)\" \"is_BaseDim QD(Amount)\" \"is_BaseDim QD(Intensity)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_BaseDim QD(L) &&& is_BaseDim QD(M) &&& is_BaseDim QD(T)) &&&\n    (is_BaseDim QD(I) &&& is_BaseDim QD(\\<Theta>)) &&&\n    is_BaseDim QD(N) &&& is_BaseDim QD(J)", "by (simp_all add: is_BaseDim)"], ["", "subsubsection \\<open> Dimension Type Constructors: Inner Product and Inverse \\<close>"], ["", "text\\<open> Dimension type expressions can be constructed by multiplication and division of the base\n  dimension types above. Consequently, we need to define multiplication and inverse operators\n  at the type level as well. On the class of dimension types (in which we have already inserted \n  the base dimension types), the definitions of the type constructors for inner product and inverse is \n  straightforward. \\<close>"], ["", "typedef ('a::dim_type, 'b::dim_type) DimTimes (infixl \"\\<cdot>\" 69) = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_DimTimes"], ["", "text \\<open> The type \\<^typ>\\<open>('a,'b) DimTimes\\<close> is parameterised by two types, \\<^typ>\\<open>'a\\<close> and \\<^typ>\\<open>'b\\<close> that must\n  both be elements of the \\<^class>\\<open>dim_type\\<close> class. As with the base dimensions, it is a unitary type\n  as its purpose is to represent dimension type expressions. We instantiate \\<^class>\\<open>dim_type\\<close> with\n  this type, where the semantics of a product dimension expression is the product of the underlying\n  dimensions. This means that multiplication of two dimension types yields a dimension type. \\<close>"], ["", "instantiation DimTimes :: (dim_type, dim_type) dim_type\nbegin"], ["", "definition dim_ty_sem_DimTimes :: \"('a \\<cdot> 'b) itself \\<Rightarrow> Dimension\" where\n  [si_eq]: \"dim_ty_sem_DimTimes x = QD('a) * QD('b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<cdot> 'b, dim_type_class)", "by (intro_classes, simp_all add: dim_ty_sem_DimTimes_def, (transfer, simp)+)"], ["", "end"], ["", "text \\<open> Similarly, we define inversion of dimension types and prove that dimension types are \n  closed under this. \\<close>"], ["", "typedef 'a DimInv (\"(_\\<^sup>-\\<^sup>1)\" [999] 999) = \"UNIV :: unit set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_DimInv"], ["", "instantiation DimInv :: (dim_type) dim_type\nbegin"], ["", "definition dim_ty_sem_DimInv :: \"('a\\<^sup>-\\<^sup>1) itself \\<Rightarrow> Dimension\" where\n  [si_eq]: \"dim_ty_sem_DimInv x = inverse QD('a)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sup>-\\<^sup>1, dim_type_class)", "by (intro_classes, simp_all add: dim_ty_sem_DimInv_def, (transfer, simp)+)"], ["", "end"], ["", "subsubsection \\<open> Dimension Type Syntax \\<close>"], ["", "text \\<open> A division is expressed, as usual, by multiplication with an inverted dimension. \\<close>"], ["", "type_synonym ('a, 'b) DimDiv = \"'a \\<cdot> ('b\\<^sup>-\\<^sup>1)\" (infixl \"'/\" 69)"], ["", "text \\<open> A number of further type synonyms allow for more compact notation: \\<close>"], ["", "type_synonym 'a DimSquare = \"'a \\<cdot> 'a\" (\"(_)\\<^sup>2\" [999] 999)"], ["", "type_synonym 'a DimCube = \"'a \\<cdot> 'a \\<cdot> 'a\" (\"(_)\\<^sup>3\" [999] 999)"], ["", "type_synonym 'a DimQuart = \"'a \\<cdot> 'a \\<cdot> 'a \\<cdot> 'a\" (\"(_)\\<^sup>4\" [999] 999)"], ["", "type_synonym 'a DimInvSquare = \"('a\\<^sup>2)\\<^sup>-\\<^sup>1\" (\"(_)\\<^sup>-\\<^sup>2\" [999] 999)"], ["", "type_synonym 'a DimInvCube = \"('a\\<^sup>3)\\<^sup>-\\<^sup>1\" (\"(_)\\<^sup>-\\<^sup>3\" [999] 999)"], ["", "type_synonym 'a DimInvQuart = \"('a\\<^sup>4)\\<^sup>-\\<^sup>1\" (\"(_)\\<^sup>-\\<^sup>4\" [999] 999)"], ["", "translations (type) \"'a\\<^sup>-\\<^sup>2\" <= (type) \"('a\\<^sup>2)\\<^sup>-\\<^sup>1\""], ["", "translations (type) \"'a\\<^sup>-\\<^sup>3\" <= (type) \"('a\\<^sup>3)\\<^sup>-\\<^sup>1\""], ["", "translations (type) \"'a\\<^sup>-\\<^sup>4\" <= (type) \"('a\\<^sup>4)\\<^sup>-\\<^sup>1\""], ["", "print_translation \\<open>\n  [(@{type_syntax DimTimes}, \n    fn ctx => fn [a, b] => \n      if (a = b) \n          then Const (@{type_syntax DimSquare}, dummyT) $ a\n          else case a of\n            Const (@{type_syntax DimTimes}, _) $ a1 $ a2 =>\n              if (a1 = a2 andalso a2 = b) \n                then Const (@{type_syntax DimCube}, dummyT) $ a1 \n                else case a1 of\n                  Const (@{type_syntax DimTimes}, _) $ a11 $ a12 =>\n                    if (a11 = a12 andalso a12 = a2 andalso a2 = b)\n                      then Const (@{type_syntax DimQuart}, dummyT) $ a11\n                      else raise Match |\n            _ => raise Match)]\n\\<close>"], ["", "subsubsection \\<open> Derived Dimension Types \\<close>"], ["", "type_synonym Area = \"L\\<^sup>2\""], ["", "type_synonym Volume = \"L\\<^sup>3\""], ["", "type_synonym Acceleration = \"L\\<cdot>T\\<^sup>-\\<^sup>1\""], ["", "type_synonym Frequency = \"T\\<^sup>-\\<^sup>1\""], ["", "type_synonym Energy = \"L\\<^sup>2\\<cdot>M\\<cdot>T\\<^sup>-\\<^sup>2\""], ["", "type_synonym Power = \"L\\<^sup>2\\<cdot>M\\<cdot>T\\<^sup>-\\<^sup>3\""], ["", "type_synonym Force = \"L\\<cdot>M\\<cdot>T\\<^sup>-\\<^sup>2\""], ["", "type_synonym Pressure = \"L\\<^sup>-\\<^sup>1\\<cdot>M\\<cdot>T\\<^sup>-\\<^sup>2\""], ["", "type_synonym Charge = \"I\\<cdot>T\""], ["", "type_synonym PotentialDifference = \"L\\<^sup>2\\<cdot>M\\<cdot>T\\<^sup>-\\<^sup>3\\<cdot>I\\<^sup>-\\<^sup>1\""], ["", "type_synonym Capacitance = \"L\\<^sup>-\\<^sup>2\\<cdot>M\\<^sup>-\\<^sup>1\\<cdot>T\\<^sup>4\\<cdot>I\\<^sup>2\""], ["", "subsection \\<open> ML Functions \\<close>"], ["", "text \\<open> We define ML functions for converting a dimension to an integer vector, and vice-versa.\n  These are useful for normalising dimension types. \\<close>"], ["", "ML \\<open> \nsignature DIMENSION_TYPE = \nsig\n  val dim_to_typ: int list -> typ\n  val typ_to_dim: typ -> int list\n  val normalise: typ -> typ\nend\n\nstructure Dimension_Type : DIMENSION_TYPE =\nstruct\n  \n  val dims = [@{typ L}, @{typ M}, @{typ T}, @{typ I}, @{typ \\<Theta>}, @{typ N}, @{typ J}];\n\n  fun typ_to_dim (Type (@{type_name Length}, [])) = [1, 0, 0, 0, 0, 0, 0] |\n      typ_to_dim (Type (@{type_name Mass}, []))   = [0, 1, 0, 0, 0, 0, 0] |\n      typ_to_dim (Type (@{type_name Time}, []))   = [0, 0, 1, 0, 0, 0, 0] |\n      typ_to_dim (Type (@{type_name Current}, []))   = [0, 0, 0, 1, 0, 0, 0] |\n      typ_to_dim (Type (@{type_name Temperature}, []))   = [0, 0, 0, 0, 1, 0, 0] |\n      typ_to_dim (Type (@{type_name Amount}, []))   = [0, 0, 0, 0, 0, 1, 0] |\n      typ_to_dim (Type (@{type_name Intensity}, []))   = [0, 0, 0, 0, 0, 0, 1] |\n      typ_to_dim (Type (@{type_name NoDimension}, []))   = [0, 0, 0, 0, 0, 0, 0] |\n      typ_to_dim (Type (@{type_name DimInv}, [x])) = map (fn x => 0 - x) (typ_to_dim x) |\n      typ_to_dim (Type (@{type_name DimTimes}, [x, y])) \n         = map (fn (x, y) => x + y) (ListPair.zip (typ_to_dim x, typ_to_dim y)) |\n      typ_to_dim _ = raise Match;\n\n  fun DimPow 0 _ = Type (@{type_name NoDimension}, []) |\n      DimPow 1 t = t |\n      DimPow n t = (if (n > 0) then Type (@{type_name DimTimes}, [DimPow (n - 1) t, t]) \n                               else Type (@{type_name DimInv}, [DimPow (0 - n) t]));\n\n  fun dim_to_typ ds = \n    let val dts = map (fn (n, d) => DimPow n d) (filter (fn (n, _) => n <> 0) (ListPair.zip (ds, dims)))\n    in if (dts = []) then @{typ NoDimension} else\n          foldl1 (fn (x, y) => Type (@{type_name DimTimes}, [x, y])) dts \n    end;\n\n  val normalise = dim_to_typ o typ_to_dim;\n\nend;\n\nDimension_Type.typ_to_dim @{typ \"L\\<^sup>-\\<^sup>2\\<cdot>M\\<^sup>-\\<^sup>1\\<cdot>T\\<^sup>4\\<cdot>I\\<^sup>2\\<cdot>M\"};\nDimension_Type.normalise @{typ \"L\\<^sup>-\\<^sup>2\\<cdot>M\\<^sup>-\\<^sup>1\\<cdot>T\\<^sup>4\\<cdot>I\\<^sup>2\\<cdot>M\"};\n\\<close>"], ["", "end"]]}