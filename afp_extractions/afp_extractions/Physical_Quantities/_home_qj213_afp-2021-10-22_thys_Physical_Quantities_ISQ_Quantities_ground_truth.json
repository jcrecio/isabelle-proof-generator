{"file_name": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities/ISQ_Quantities.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities", "problem_names": ["lemma Quantity_eq_intro:\n  assumes \"mag x = mag y\" \"dim x = dim y\" \"more x = more y\"\n  shows \"x = y\"", "lemma mag_times  [simp]: \"mag (x \\<cdot> y) = mag x \\<cdot> mag y\"", "lemma dim_times  [simp]: \"dim (x \\<cdot> y) = dim x \\<cdot> dim y\"", "lemma more_times [simp]: \"more (x \\<cdot> y) = more x \\<cdot> more y\"", "lemma mag_zero  [simp]:  \"mag 0 = 0\"", "lemma dim_zero  [simp]:  \"dim 0 = 1\"", "lemma more_zero [simp]: \"more 0 = 0\"", "lemma mag_one  [simp]: \"mag 1 = 1\"", "lemma dim_one  [simp]: \"dim 1 = 1\"", "lemma more_one [simp]: \"more 1 = 1\"", "lemma mag_inverse [simp]: \"mag (inverse x) = inverse (mag x)\"", "lemma dim_inverse [simp]: \"dim (inverse x) = inverse (dim x)\"", "lemma more_inverse [simp]: \"more (inverse x) = inverse (more x)\"", "lemma mag_divide [simp]: \"mag (x / y) = mag x / mag y\"", "lemma dim_divide [simp]: \"dim (x / y) = dim x / dim y\"", "lemma more_divide [simp]: \"more (x / y) = more x / more y\"", "lemma unit_system_intro: \"(UNIV::'s set) = {a} \\<Longrightarrow> OFCLASS('s, unit_system_class)\"", "lemma mmore [simp]: \"mmore \\<lparr> unit_sys = x, \\<dots> = y \\<rparr> = y\"", "lemma mmore_ext [simp]: \"\\<lparr>unit_sys = unit, \\<dots> = mmore a\\<rparr> = a\"", "lemma Measurement_System_eq_intro:\n  assumes \"mag x = mag y\" \"dim x = dim y\" \"more x = more y\"\n  shows \"x = y\"", "lemma qequiv_refl [simp]: \"a \\<cong>\\<^sub>Q a\"", "lemma qequiv_sym: \"a \\<cong>\\<^sub>Q b \\<Longrightarrow> b \\<cong>\\<^sub>Q a\"", "lemma qequiv_trans: \"\\<lbrakk> a \\<cong>\\<^sub>Q b; b \\<cong>\\<^sub>Q c \\<rbrakk> \\<Longrightarrow> a \\<cong>\\<^sub>Q c\"", "theorem qeq_iff_same_dim:\n  fixes x y :: \"'a['d::dim_type, 's::unit_system]\"\n  shows \"x \\<cong>\\<^sub>Q y \\<longleftrightarrow> x = y\"", "lemma coerceQuant_eq_iff:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\"\n  shows \"(coerceQuantT TYPE('d\\<^sub>2) x) \\<cong>\\<^sub>Q x\"", "lemma coerceQuant_eq_iff2:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\" and \"y = (coerceQuantT TYPE('d\\<^sub>2) x)\"\n  shows \"x \\<cong>\\<^sub>Q y\"", "lemma updown_eq_iff:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" fixes y :: \"'a['d\\<^sub>2::dim_type, 's]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\" and \"y = (toQ (fromQ x))\"\n  shows \"x \\<cong>\\<^sub>Q y\"", "lemma qeq: \n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" fixes y :: \"'a['d\\<^sub>2::dim_type, 's]\"\n  assumes \"x \\<cong>\\<^sub>Q y\"\n  shows \"QD('d\\<^sub>1) = QD('d\\<^sub>2)\""], "translations": [["", "lemma Quantity_eq_intro:\n  assumes \"mag x = mag y\" \"dim x = dim y\" \"more x = more y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (simp add: assms eq_unit)"], ["", "text \\<open> We can define several arithmetic operators on quantities. Multiplication takes multiplies\n  both the magnitudes and the dimensions. \\<close>"], ["", "instantiation Quantity_ext :: (times, enum, times) times\nbegin"], ["", "definition times_Quantity_ext :: \n    \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" \n    where  [si_def]: \"times_Quantity_ext x y = \\<lparr> mag = mag x \\<cdot> mag y, dim = dim x \\<cdot> dim y, \n                                                 \\<dots> = more x \\<cdot> more y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, times_class)", ".."], ["", "end"], ["", "lemma mag_times  [simp]: \"mag (x \\<cdot> y) = mag x \\<cdot> mag y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mag (x \\<cdot> y) = mag x \\<cdot> mag y", "by (simp add: times_Quantity_ext_def)"], ["", "lemma dim_times  [simp]: \"dim (x \\<cdot> y) = dim x \\<cdot> dim y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim (x \\<cdot> y) = Quantity.dim x \\<cdot> Quantity.dim y", "by (simp add: times_Quantity_ext_def)"], ["", "lemma more_times [simp]: \"more (x \\<cdot> y) = more x \\<cdot> more y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more (x \\<cdot> y) = more x \\<cdot> more y", "by (simp add: times_Quantity_ext_def)"], ["", "text \\<open> The zero and one quantities are both dimensionless quantities with magnitude of \\<^term>\\<open>0\\<close> and\n  \\<^term>\\<open>1\\<close>, respectively. \\<close>"], ["", "instantiation Quantity_ext :: (zero, enum, zero) zero\nbegin"], ["", "definition \"zero_Quantity_ext = \\<lparr> mag = 0, dim = 1, \\<dots> = 0 \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, zero_class)", ".."], ["", "end"], ["", "lemma mag_zero  [simp]:  \"mag 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mag 0 = (0::'a)", "by (simp add: zero_Quantity_ext_def)"], ["", "lemma dim_zero  [simp]:  \"dim 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim 0 = 1", "by (simp add: zero_Quantity_ext_def)"], ["", "lemma more_zero [simp]: \"more 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more 0 = (0::'a)", "by (simp add: zero_Quantity_ext_def)"], ["", "instantiation Quantity_ext :: (one, enum, one) one\nbegin"], ["", "definition    [si_def]: \"one_Quantity_ext = \\<lparr> mag = 1, dim = 1, \\<dots> = 1 \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, one_class)", ".."], ["", "end"], ["", "lemma mag_one  [simp]: \"mag 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mag 1 = (1::'a)", "by (simp add: one_Quantity_ext_def)"], ["", "lemma dim_one  [simp]: \"dim 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim 1 = 1", "by (simp add: one_Quantity_ext_def)"], ["", "lemma more_one [simp]: \"more 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more 1 = (1::'a)", "by (simp add: one_Quantity_ext_def)"], ["", "text \\<open> Quantity inversion inverts both the magnitude and the dimension. Similarly, division of\n  one quantity by another, divides both the magnitudes and the dimensions. \\<close>"], ["", "instantiation Quantity_ext :: (inverse, enum, inverse) inverse\nbegin"], ["", "definition inverse_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" where \n  [si_def]: \"inverse_Quantity_ext x = \\<lparr> mag = inverse (mag x), dim = inverse (dim x), \\<dots> = inverse (more x) \\<rparr>\""], ["", "definition divide_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" where\n  [si_def]: \"divide_Quantity_ext x y = \\<lparr> mag = mag x / mag y, dim = dim x / dim y, \\<dots> = more x / more y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, inverse_class)", ".."], ["", "end"], ["", "lemma mag_inverse [simp]: \"mag (inverse x) = inverse (mag x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mag (inverse x) = inverse (mag x)", "by (simp add: inverse_Quantity_ext_def)"], ["", "lemma dim_inverse [simp]: \"dim (inverse x) = inverse (dim x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim (inverse x) = inverse (Quantity.dim x)", "by (simp add: inverse_Quantity_ext_def)"], ["", "lemma more_inverse [simp]: \"more (inverse x) = inverse (more x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more (inverse x) = inverse (more x)", "by (simp add: inverse_Quantity_ext_def)"], ["", "lemma mag_divide [simp]: \"mag (x / y) = mag x / mag y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mag (x / y) = mag x / mag y", "by (simp add: divide_Quantity_ext_def)"], ["", "lemma dim_divide [simp]: \"dim (x / y) = dim x / dim y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim (x / y) = Quantity.dim x / Quantity.dim y", "by (simp add: divide_Quantity_ext_def)"], ["", "lemma more_divide [simp]: \"more (x / y) = more x / more y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. more (x / y) = more x / more y", "by (simp add: divide_Quantity_ext_def)"], ["", "text \\<open> As for dimensions, quantities form a commutative monoid and an abelian group. \\<close>"], ["", "instance Quantity_ext :: (comm_monoid_mult, enum, comm_monoid_mult) comm_monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, comm_monoid_mult_class)", "by (intro_classes, simp_all add: eq_unit one_Quantity_ext_def times_Quantity_ext_def mult.assoc\n     ,simp add: mult.commute)"], ["", "instance Quantity_ext :: (ab_group_mult, enum, ab_group_mult) ab_group_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, ab_group_mult_class)", "by (intro_classes, rule Quantity_eq_intro, simp_all add: eq_unit)"], ["", "text \\<open> We can also define a partial order on quantities. \\<close>"], ["", "instantiation Quantity_ext :: (ord, enum, ord) ord\nbegin"], ["", "definition less_eq_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> bool\"\n    where \"less_eq_Quantity_ext x y = (mag x \\<le> mag y \\<and> dim x = dim y \\<and> more x \\<le> more y)\""], ["", "definition less_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> bool\"\n    where \"less_Quantity_ext x y = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, ord_class)", ".."], ["", "end"], ["", "instance Quantity_ext :: (order, enum, order) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, order_class)", "by (intro_classes, auto simp add: less_Quantity_ext_def less_eq_Quantity_ext_def eq_unit)"], ["", "text \\<open> We can define plus and minus as well, but these are partial operators as they are defined\n  only when the quantities have the same dimension. \\<close>"], ["", "instantiation Quantity_ext :: (plus, enum, plus) plus\nbegin"], ["", "definition plus_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" \n    where [si_def]:\n    \"dim x = dim y \\<Longrightarrow> \n     plus_Quantity_ext x y = \\<lparr> mag = mag x + mag y, dim = dim x, \\<dots> = more x + more y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, plus_class)", ".."], ["", "end"], ["", "instantiation Quantity_ext :: (uminus, enum, uminus) uminus\nbegin"], ["", "definition uminus_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" where \n  [si_def]: \"uminus_Quantity_ext x = \\<lparr> mag = - mag x , dim = dim x, \\<dots> = - more x \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, uminus_class)", ".."], ["", "end"], ["", "instantiation Quantity_ext :: (minus, enum, minus) minus\nbegin"], ["", "definition minus_Quantity_ext :: \"('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme \\<Rightarrow> ('a, 'b, 'c) Quantity_scheme\" where \n  [si_def]:\n    \"dim x = dim y \\<Longrightarrow> \n      minus_Quantity_ext x y = \\<lparr> mag = mag x - mag y, dim = dim x, \\<dots> = more x - more y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b, 'c) Quantity_scheme, minus_class)", ".."], ["", "end"], ["", "subsection \\<open> Measurement Systems \\<close>"], ["", "class unit_system = unitary"], ["", "lemma unit_system_intro: \"(UNIV::'s set) = {a} \\<Longrightarrow> OFCLASS('s, unit_system_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {a} \\<Longrightarrow> OFCLASS('s, unit_system_class)", "by (simp add: unit_system_class_def, rule unitary_intro)"], ["", "record ('a, 'd::enum, 's::unit_system) Measurement_System = \"('a, 'd::enum) Quantity\" +\n  unit_sys  :: 's \\<comment> \\<open> The system of units being employed \\<close>"], ["", "definition \"mmore = Record.iso_tuple_snd Measurement_System_ext_Tuple_Iso\""], ["", "lemma mmore [simp]: \"mmore \\<lparr> unit_sys = x, \\<dots> = y \\<rparr> = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmore \\<lparr>unit_sys = x, \\<dots> = y\\<rparr> = y", "by (metis Measurement_System.ext_inject Measurement_System.ext_surjective comp_id mmore_def)"], ["", "lemma mmore_ext [simp]: \"\\<lparr>unit_sys = unit, \\<dots> = mmore a\\<rparr> = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>unit_sys = unit, \\<dots> = mmore a\\<rparr> = a", "apply (case_tac a, rename_tac b, case_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b aa ba.\n       \\<lbrakk>a = Abs_Measurement_System_ext b; b \\<in> UNIV;\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>unit_sys = unit,\n                            \\<dots> = mmore a\\<rparr> =\n                         a", "apply (simp add: Measurement_System_ext_def mmore_def Measurement_System_ext_Tuple_Iso_def Record.iso_tuple_snd_def Record.iso_tuple_cons_def Abs_Measurement_System_ext_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b aa ba.\n       \\<lbrakk>a = Abs_Measurement_System_ext (aa, ba);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Abs_Measurement_System_ext (unit, ba) =\n                         Abs_Measurement_System_ext (aa, ba)", "apply (rename_tac x y z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>a = Abs_Measurement_System_ext (y, z); x = (y, z)\\<rbrakk>\n       \\<Longrightarrow> Abs_Measurement_System_ext (unit, z) =\n                         Abs_Measurement_System_ext (y, z)", "apply (subgoal_tac \"unit = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>a = Abs_Measurement_System_ext (y, z); x = (y, z);\n        unit = y\\<rbrakk>\n       \\<Longrightarrow> Abs_Measurement_System_ext (unit, z) =\n                         Abs_Measurement_System_ext (y, z)\n 2. \\<And>x y z.\n       \\<lbrakk>a = Abs_Measurement_System_ext (y, z); x = (y, z)\\<rbrakk>\n       \\<Longrightarrow> unit = y", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>a = Abs_Measurement_System_ext (y, z); x = (y, z)\\<rbrakk>\n       \\<Longrightarrow> unit = y", "apply (simp add: eq_unit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Measurement_System_eq_intro:\n  assumes \"mag x = mag y\" \"dim x = dim y\" \"more x = more y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (rule Quantity_eq_intro, simp_all add: assms)\n     (metis Measurement_System.surjective Quantity.select_convs(3) assms(3) mmore mmore_ext)"], ["", "instantiation Measurement_System_ext :: (unit_system, \"zero\") \"zero\"\nbegin"], ["", "definition zero_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext\" \n    where  [si_def]: \"zero_Measurement_System_ext = \\<lparr> unit_sys = unit, \\<dots> = 0 \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, zero_class)", ".."], ["", "end"], ["", "instantiation Measurement_System_ext :: (unit_system, \"one\") \"one\"\nbegin"], ["", "definition one_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext\"\n    where  [si_def]: \"one_Measurement_System_ext = \\<lparr> unit_sys = unit, \\<dots> = 1 \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, one_class)", ".."], ["", "end"], ["", "instantiation Measurement_System_ext :: (unit_system, times) times\nbegin"], ["", "definition times_Measurement_System_ext :: \n    \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" \n    where  [si_def]: \"times_Measurement_System_ext x y = \\<lparr> unit_sys = unit, \\<dots> = mmore x \\<cdot> mmore y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, times_class)", ".."], ["", "end"], ["", "instantiation Measurement_System_ext :: (unit_system, inverse) inverse\nbegin"], ["", "definition inverse_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" where \n  [si_def]: \"inverse_Measurement_System_ext x = \\<lparr> unit_sys = unit, \\<dots> = inverse (mmore x) \\<rparr>\""], ["", "definition divide_Measurement_System_ext ::\n  \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" \n  where [si_def]: \"divide_Measurement_System_ext x y = \\<lparr> unit_sys = unit, \\<dots> = mmore x / mmore y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, inverse_class)", ".."], ["", "end"], ["", "instance Measurement_System_ext :: (unit_system, comm_monoid_mult) comm_monoid_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     (\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, comm_monoid_mult_class)", "by (intro_classes, simp_all add: eq_unit one_Measurement_System_ext_def times_Measurement_System_ext_def mult.assoc, simp add: mult.commute)"], ["", "instance Measurement_System_ext :: (unit_system, ab_group_mult) ab_group_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     (\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, ab_group_mult_class)", "by (intro_classes, simp_all add: si_def)"], ["", "instantiation Measurement_System_ext :: (unit_system, ord) ord\nbegin"], ["", "definition less_eq_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> bool\"\n    where \"less_eq_Measurement_System_ext x y = (mmore x \\<le> mmore y)\""], ["", "definition less_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> bool\"\n    where \"less_Measurement_System_ext x y = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, ord_class)", ".."], ["", "end"], ["", "instance Measurement_System_ext :: (unit_system, order) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, order_class)", "by (intro_classes, simp_all add: less_eq_Measurement_System_ext_def less_Measurement_System_ext_def, metis mmore_ext)"], ["", "instantiation Measurement_System_ext :: (unit_system, plus) plus\nbegin"], ["", "definition plus_Measurement_System_ext :: \n  \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" \n    where [si_def]:\n    \"plus_Measurement_System_ext x y = \\<lparr> unit_sys = unit, \\<dots> = mmore x + mmore y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, plus_class)", ".."], ["", "end"], ["", "instantiation Measurement_System_ext :: (unit_system, uminus) uminus\nbegin"], ["", "definition uminus_Measurement_System_ext :: \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" where \n  [si_def]: \"uminus_Measurement_System_ext x = \\<lparr> unit_sys = unit, \\<dots> = - mmore x \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, uminus_class)", ".."], ["", "end"], ["", "instantiation Measurement_System_ext :: (unit_system, minus) minus\nbegin"], ["", "definition minus_Measurement_System_ext :: \n    \"('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext \\<Rightarrow> ('a, 'b) Measurement_System_ext\" where\n  [si_def]:\n    \"minus_Measurement_System_ext x y = \\<lparr> unit_sys = unit, \\<dots> = mmore x - mmore y \\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(\\<lparr>unit_sys :: 'a, \\<dots> :: 'b\\<rparr>, minus_class)", ".."], ["", "end"], ["", "subsection \\<open> Dimension Typed Quantities \\<close>"], ["", "text \\<open> We can now define the type of quantities with parametrised dimension types. \\<close>"], ["", "typedef (overloaded) ('n, 'd::dim_type, 's::unit_system) QuantT (\"_[_, _]\" [999,0,0] 999) \n                     = \"{x :: ('n, sdim, 's) Measurement_System. dim x = QD('d)}\"\n  morphisms fromQ toQ"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. Quantity.dim x = QD('d)}", "by (rule_tac x=\"\\<lparr> mag = undefined, dim = QD('d), unit_sys = unit \\<rparr>\" in exI, simp)"], ["", "setup_lifting type_definition_QuantT"], ["", "text \\<open> A dimension typed quantity is parameterised by two types: \\<^typ>\\<open>'a\\<close>, the numeric type for the\n  magntitude, and \\<^typ>\\<open>'d\\<close> for the dimension expression, which is an element of \\<^class>\\<open>dim_type\\<close>. \n  The type \\<^typ>\\<open>('n, 'd, 's) QuantT\\<close> is to \\<^typ>\\<open>('n, 'd, 's) Measurement_System\\<close> as dimension types \n  are to \\<^typ>\\<open>Dimension\\<close>. Specifically, an element of \\<^typ>\\<open>('n', 'd, 's) QuantT\\<close> is a quantity whose \n  dimension is \\<^typ>\\<open>'d\\<close>.\n\n  Intuitively, the formula \\<^term>\\<open>x :: 'n['d, 's]\\<close> can be read as ``$x$ is a quantity of \\<^typ>\\<open>'d\\<close>'',\n  for example it might be a quantity of length, or a quantity of mass. \\<close>"], ["", "text \\<open> Since quantities can have dimension type expressions that are distinct, but denote the same\n  dimension, it is necessary to define the following function for coercion between two dimension\n  expressions. This requires that the underlying dimensions are the same. \\<close>"], ["", "definition coerceQuantT :: \"'d\\<^sub>2 itself \\<Rightarrow> 'a['d\\<^sub>1::dim_type, 's::unit_system] \\<Rightarrow> 'a['d\\<^sub>2::dim_type, 's]\" where\n[si_def]: \"QD('d\\<^sub>1) = QD('d\\<^sub>2) \\<Longrightarrow> coerceQuantT t x = (toQ (fromQ x))\""], ["", "syntax\n  \"_QCOERCE\" :: \"type \\<Rightarrow> logic \\<Rightarrow> logic\" (\"QCOERCE[_]\")"], ["", "translations\n  \"QCOERCE['t]\" == \"CONST coerceQuantT TYPE('t)\""], ["", "subsection \\<open> Predicates on Typed Quantities \\<close>"], ["", "text \\<open> The standard HOL order \\<^term>\\<open>(\\<le>)\\<close> and equality \\<^term>\\<open>(=)\\<close> have the homogeneous type\n  \\<^typ>\\<open>'a \\<Rightarrow> 'a \\<Rightarrow> bool\\<close> and so they cannot compare values of different types. Consequently,\n  we define a heterogeneous order and equivalence on typed quantities. \\<close>"], ["", "lift_definition qless_eq :: \"'n::order['a::dim_type, 's::unit_system] \\<Rightarrow> 'n['b::dim_type, 's] \\<Rightarrow> bool\" (infix \"\\<lesssim>\\<^sub>Q\" 50) \n  is \"(\\<le>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition qequiv :: \"'n['a::dim_type, 's::unit_system] \\<Rightarrow> 'n['b::dim_type, 's] \\<Rightarrow> bool\" (infix \"\\<cong>\\<^sub>Q\" 50) \n  is \"(=)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open> These are both fundamentally the same as the usual order and equality relations, but they\n  permit potentially different dimension types, \\<^typ>\\<open>'a\\<close> and \\<^typ>\\<open>'b\\<close>. Two typed quantities are\n  comparable only when the two dimension types have the same semantic dimension.\n\\<close>"], ["", "lemma qequiv_refl [simp]: \"a \\<cong>\\<^sub>Q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cong>\\<^sub>Q a", "by (simp add: qequiv_def)"], ["", "lemma qequiv_sym: \"a \\<cong>\\<^sub>Q b \\<Longrightarrow> b \\<cong>\\<^sub>Q a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cong>\\<^sub>Q b \\<Longrightarrow> b \\<cong>\\<^sub>Q a", "by (simp add: qequiv_def)"], ["", "lemma qequiv_trans: \"\\<lbrakk> a \\<cong>\\<^sub>Q b; b \\<cong>\\<^sub>Q c \\<rbrakk> \\<Longrightarrow> a \\<cong>\\<^sub>Q c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<cong>\\<^sub>Q b; b \\<cong>\\<^sub>Q c\\<rbrakk>\n    \\<Longrightarrow> a \\<cong>\\<^sub>Q c", "by (simp add: qequiv_def)"], ["", "theorem qeq_iff_same_dim:\n  fixes x y :: \"'a['d::dim_type, 's::unit_system]\"\n  shows \"x \\<cong>\\<^sub>Q y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cong>\\<^sub>Q y) = (x = y)", "by (transfer, simp)"], ["", "lemma coerceQuant_eq_iff:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\"\n  shows \"(coerceQuantT TYPE('d\\<^sub>2) x) \\<cong>\\<^sub>Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QCOERCE['d\\<^sub>2] x \\<cong>\\<^sub>Q x", "by (metis qequiv.rep_eq assms coerceQuantT_def toQ_cases toQ_inverse)"], ["", "lemma coerceQuant_eq_iff2:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\" and \"y = (coerceQuantT TYPE('d\\<^sub>2) x)\"\n  shows \"x \\<cong>\\<^sub>Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cong>\\<^sub>Q y", "using qequiv_sym assms(1) assms(2) coerceQuant_eq_iff"], ["proof (prove)\nusing this:\n  ?a \\<cong>\\<^sub>Q ?b \\<Longrightarrow> ?b \\<cong>\\<^sub>Q ?a\n  QD('d\\<^sub>1) = QD('d\\<^sub>2)\n  y = QCOERCE['d\\<^sub>2] x\n  QD(?'d\\<^sub>1) = QD(?'d\\<^sub>2) \\<Longrightarrow>\n  QCOERCE[?'d\\<^sub>2] ?x \\<cong>\\<^sub>Q ?x\n\ngoal (1 subgoal):\n 1. x \\<cong>\\<^sub>Q y", "by blast"], ["", "lemma updown_eq_iff:\n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" fixes y :: \"'a['d\\<^sub>2::dim_type, 's]\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2::dim_type)\" and \"y = (toQ (fromQ x))\"\n  shows \"x \\<cong>\\<^sub>Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cong>\\<^sub>Q y", "by (simp add: assms(1) assms(2) coerceQuant_eq_iff2 coerceQuantT_def)"], ["", "text\\<open>This is more general that \\<open>y = x \\<Longrightarrow> x \\<cong>\\<^sub>Q y\\<close>, since x and y may have different type.\\<close>"], ["", "lemma qeq: \n  fixes x :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" fixes y :: \"'a['d\\<^sub>2::dim_type, 's]\"\n  assumes \"x \\<cong>\\<^sub>Q y\"\n  shows \"QD('d\\<^sub>1) = QD('d\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QD('d\\<^sub>1) = QD('d\\<^sub>2)", "by (metis (full_types) qequiv.rep_eq assms fromQ mem_Collect_eq)"], ["", "subsection\\<open> Operators on Typed Quantities \\<close>"], ["", "text \\<open> We define several operators on typed quantities. These variously compose the dimension types\n  as well. Multiplication composes the two dimension types. Inverse constructs and inverted \n  dimension type. Division is defined in terms of multiplication and inverse. \\<close>"], ["", "lift_definition \n  qtimes :: \"('n::comm_ring_1)['a::dim_type, 's::unit_system] \\<Rightarrow> 'n['b::dim_type, 's] \\<Rightarrow> 'n['a \\<cdot>'b, 's]\" (infixl \"\\<^bold>\\<cdot>\" 69) \n  is \"(*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Quantity_ext1 Quantity_ext2.\n       \\<lbrakk>Quantity.dim Quantity_ext1 = QD('a);\n        Quantity.dim Quantity_ext2 = QD('b)\\<rbrakk>\n       \\<Longrightarrow> Quantity.dim\n                          (Quantity_ext1 \\<cdot> Quantity_ext2) =\n                         QD('a \\<cdot> 'b)", "by (simp add: dim_ty_sem_DimTimes_def times_Quantity_ext_def)"], ["", "lift_definition \n  qinverse :: \"('n::field)['a::dim_type, 's::unit_system] \\<Rightarrow> 'n['a\\<^sup>-\\<^sup>1, 's]\" (\"(_\\<^sup>-\\<^sup>\\<one>)\" [999] 999) \n  is \"inverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Quantity_ext.\n       Quantity.dim Quantity_ext = QD('a) \\<Longrightarrow>\n       Quantity.dim (inverse Quantity_ext) = QD('a\\<^sup>-\\<^sup>1)", "by (simp add: inverse_Quantity_ext_def dim_ty_sem_DimInv_def)"], ["", "abbreviation (input)\n  qdivide :: \"('n::field)['a::dim_type, 's::unit_system] \\<Rightarrow> 'n['b::dim_type, 's] \\<Rightarrow> 'n['a/'b, 's]\" (infixl \"\\<^bold>'/\" 70) where\n\"qdivide x y \\<equiv> x \\<^bold>\\<cdot> y\\<^sup>-\\<^sup>\\<one>\""], ["", "text \\<open> We also provide some helpful notations for expressing heterogeneous powers. \\<close>"], ["", "abbreviation qsq         (\"(_)\\<^sup>\\<two>\"  [999] 999) where \"u\\<^sup>\\<two> \\<equiv> u\\<^bold>\\<cdot>u\""], ["", "abbreviation qcube       (\"(_)\\<^sup>\\<three>\"  [999] 999) where \"u\\<^sup>\\<three> \\<equiv> u\\<^bold>\\<cdot>u\\<^bold>\\<cdot>u\""], ["", "abbreviation qquart      (\"(_)\\<^sup>\\<four>\"  [999] 999) where \"u\\<^sup>\\<four> \\<equiv> u\\<^bold>\\<cdot>u\\<^bold>\\<cdot>u\\<^bold>\\<cdot>u\""], ["", "abbreviation qneq_sq     (\"(_)\\<^sup>-\\<^sup>\\<two>\" [999] 999) where \"u\\<^sup>-\\<^sup>\\<two> \\<equiv> (u\\<^sup>\\<two>)\\<^sup>-\\<^sup>\\<one>\""], ["", "abbreviation qneq_cube   (\"(_)\\<^sup>-\\<^sup>\\<three>\" [999] 999) where \"u\\<^sup>-\\<^sup>\\<three> \\<equiv> (u\\<^sup>\\<three>)\\<^sup>-\\<^sup>\\<one>\""], ["", "abbreviation qneq_quart  (\"(_)\\<^sup>-\\<^sup>\\<four>\" [999] 999) where \"u\\<^sup>-\\<^sup>\\<four> \\<equiv> (u\\<^sup>\\<three>)\\<^sup>-\\<^sup>\\<one>\""], ["", "text \\<open> Analogous to the \\<^const>\\<open>scaleR\\<close> operator for vectors, we define the following scalar\n  multiplication that scales an existing quantity by a numeric value. This operator is\n  especially important for the representation of quantity values, which consist of a numeric\n  value and a unit. \\<close>"], ["", "lift_definition scaleQ :: \"'a \\<Rightarrow> 'a::comm_ring_1['d::dim_type, 's::unit_system] \\<Rightarrow> 'a['d, 's]\" (infixr \"*\\<^sub>Q\" 63)\n  is \"\\<lambda> r x. \\<lparr> mag = r * mag x, dim = QD('d), unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Quantity_exta.\n       Quantity.dim Quantity_exta = QD('d) \\<Longrightarrow>\n       Quantity.dim\n        \\<lparr>mag = a \\<cdot> mag Quantity_exta, dim = QD('d),\n           unit_sys = unit\\<rparr> =\n       QD('d)", "by simp"], ["", "text \\<open> Finally, we instantiate the arithmetic types classes where possible. We do not instantiate\n  \\<^class>\\<open>times\\<close> because this results in a nonsensical homogeneous product on quantities. \\<close>"], ["", "instantiation QuantT :: (zero, dim_type, unit_system) zero\nbegin"], ["", "lift_definition zero_QuantT :: \"('a, 'b, 'c) QuantT\" is \"\\<lparr> mag = 0, dim = QD('b), unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim\n     \\<lparr>mag = 0::'a, dim = QD('b), unit_sys = unit\\<rparr> =\n    QD('b)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], zero_class)", ".."], ["", "end"], ["", "instantiation QuantT :: (one, dim_type, unit_system) one\nbegin"], ["", "lift_definition one_QuantT :: \"('a, 'b, 'c) QuantT\" is \"\\<lparr> mag = 1, dim = QD('b), unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quantity.dim\n     \\<lparr>mag = 1::'a, dim = QD('b), unit_sys = unit\\<rparr> =\n    QD('b)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], one_class)", ".."], ["", "end"], ["", "text \\<open> The following specialised one element has both magnitude and dimension 1: it is a \n  dimensionless quantity. \\<close>"], ["", "abbreviation qone :: \"'n::one[\\<one>, 's::unit_system]\" (\"\\<one>\") where \"qone \\<equiv> 1\""], ["", "text \\<open> Unlike for semantic quantities, the plus operator on typed quantities is total, since the\n  type system ensures that the dimensions (and the dimension types) must be the same. \\<close>"], ["", "instantiation QuantT :: (plus, dim_type, unit_system) plus\nbegin"], ["", "lift_definition plus_QuantT :: \"'a['b, 'c] \\<Rightarrow> 'a['b, 'c] \\<Rightarrow> 'a['b, 'c]\"\n  is \"\\<lambda> x y. \\<lparr> mag = mag x + mag y, dim = QD('b), unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Quantity_ext1 Quantity_ext2.\n       \\<lbrakk>Quantity.dim Quantity_ext1 = QD('b);\n        Quantity.dim Quantity_ext2 = QD('b)\\<rbrakk>\n       \\<Longrightarrow> Quantity.dim\n                          \\<lparr>mag =\n                                    mag Quantity_ext1 + mag Quantity_ext2,\n                             dim = QD('b), unit_sys = unit\\<rparr> =\n                         QD('b)", "by (simp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], plus_class)", ".."], ["", "end"], ["", "text \\<open> We can also show that typed quantities are commutative \\<^emph>\\<open>additive\\<close> monoids. Indeed, addition\n  is a much easier operator to deal with in typed quantities, unlike product. \\<close>"], ["", "instance QuantT :: (semigroup_add,dim_type,unit_system) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], semigroup_add_class)", "by (intro_classes, transfer, simp add: add.assoc)"], ["", "instance QuantT :: (ab_semigroup_add,dim_type,unit_system) ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], ab_semigroup_add_class)", "by (intro_classes, transfer, simp add: add.commute)"], ["", "instance QuantT :: (monoid_add,dim_type,unit_system) monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], monoid_add_class)", "by (intro_classes; (transfer, simp add: eq_unit))"], ["", "instance QuantT :: (comm_monoid_add,dim_type,unit_system) comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], comm_monoid_add_class)", "by (intro_classes; transfer, simp)"], ["", "instantiation QuantT :: (uminus,dim_type,unit_system) uminus\nbegin"], ["", "lift_definition uminus_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c]\" \n  is \"\\<lambda> x. \\<lparr> mag = - mag x, dim = dim x, unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Quantity_exta.\n       Quantity.dim Quantity_exta = QD('b) \\<Longrightarrow>\n       Quantity.dim\n        \\<lparr>mag = - mag Quantity_exta, dim = Quantity.dim Quantity_exta,\n           unit_sys = unit\\<rparr> =\n       QD('b)", "by (simp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], uminus_class)", ".."], ["", "end"], ["", "instantiation QuantT :: (minus,dim_type,unit_system) minus\nbegin"], ["", "lift_definition minus_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c] \\<Rightarrow> 'a['b,'c]\"\n  is \"\\<lambda> x y. \\<lparr> mag = mag x - mag y, dim = dim x, unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Quantity_ext1 Quantity_ext2.\n       \\<lbrakk>Quantity.dim Quantity_ext1 = QD('b);\n        Quantity.dim Quantity_ext2 = QD('b)\\<rbrakk>\n       \\<Longrightarrow> Quantity.dim\n                          \\<lparr>mag =\n                                    mag Quantity_ext1 - mag Quantity_ext2,\n                             dim = Quantity.dim Quantity_ext1,\n                             unit_sys = unit\\<rparr> =\n                         QD('b)", "by (simp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], minus_class)", ".."], ["", "end"], ["", "instance QuantT :: (numeral,dim_type,unit_system) numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], numeral_class)", ".."], ["", "text \\<open> Moreover, types quantities also form an additive group. \\<close>"], ["", "instance QuantT :: (ab_group_add,dim_type,unit_system) ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], ab_group_add_class)", "by (intro_classes, (transfer, simp)+)"], ["", "text \\<open> Typed quantities helpfully can be both partially and a linearly ordered. \\<close>"], ["", "instantiation QuantT :: (order,dim_type,unit_system) order\nbegin"], ["", "lift_definition less_eq_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c] \\<Rightarrow> bool\" is \"\\<lambda> x y. mag x \\<le> mag y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c] \\<Rightarrow> bool\" is \"\\<lambda> x y. mag x < mag y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], order_class)", "by (intro_classes, (transfer, simp add: unit_eq less_le_not_le Measurement_System_eq_intro)+)"], ["", "end"], ["", "instance QuantT :: (linorder,dim_type,unit_system) linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], linorder_class)", "by (intro_classes, transfer, auto)"], ["", "instantiation QuantT :: (scaleR,dim_type,unit_system) scaleR\nbegin"], ["", "lift_definition scaleR_QuantT :: \"real \\<Rightarrow> 'a['b,'c] \\<Rightarrow> 'a['b,'c]\"\nis \"\\<lambda> n q. \\<lparr> mag = n *\\<^sub>R mag q, dim = dim q, unit_sys = unit \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real Quantity_exta.\n       Quantity.dim Quantity_exta = QD('b) \\<Longrightarrow>\n       Quantity.dim\n        \\<lparr>mag = real *\\<^sub>R mag Quantity_exta,\n           dim = Quantity.dim Quantity_exta, unit_sys = unit\\<rparr> =\n       QD('b)", "by (simp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], scaleR_class)", ".."], ["", "end"], ["", "instance QuantT :: (real_vector,dim_type,unit_system) real_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], real_vector_class)", "by (intro_classes, (transfer, simp add: eq_unit scaleR_add_left scaleR_add_right)+)"], ["", "instantiation QuantT :: (norm,dim_type,unit_system) norm\nbegin"], ["", "lift_definition norm_QuantT :: \"'a['b,'c] \\<Rightarrow> real\" \nis \"\\<lambda> x. norm (mag x)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], norm_class)", ".."], ["", "end"], ["", "instantiation QuantT :: (sgn_div_norm,dim_type,unit_system) sgn_div_norm\nbegin"], ["", "definition sgn_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c]\" where\n\"sgn_QuantT x = x /\\<^sub>R norm x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], sgn_div_norm_class)", "by (intro_classes, simp add: sgn_QuantT_def)"], ["", "end"], ["", "instantiation QuantT :: (dist_norm,dim_type,unit_system) dist_norm\nbegin"], ["", "definition dist_QuantT :: \"'a['b,'c] \\<Rightarrow> 'a['b,'c] \\<Rightarrow> real\" where\n\"dist_QuantT x y = norm (x - y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], dist_norm_class)", "by (intro_classes, simp add: dist_QuantT_def)"], ["", "end"], ["", "instantiation QuantT :: (\"{uniformity_dist,dist_norm}\",dim_type,unit_system) uniformity_dist\nbegin"], ["", "definition uniformity_QuantT :: \"('a['b,'c] \\<times> 'a['b,'c]) filter\" where\n\"uniformity_QuantT = (INF e\\<in>{0 <..}. principal {(x, y). dist x y < e})\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], uniformity_dist_class)", "by (intro_classes, simp add: uniformity_QuantT_def)"], ["", "end"], ["", "instantiation QuantT :: (\"{dist_norm,open_uniformity,uniformity_dist}\",dim_type,unit_system) \n                        open_uniformity\nbegin"], ["", "definition open_QuantT :: \"('a['b,'c]) set \\<Rightarrow> bool\" where\n\"open_QuantT U = (\\<forall>x\\<in>U. eventually (\\<lambda>(x', y). x' = x \\<longrightarrow> y \\<in> U) uniformity)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], open_uniformity_class)", "by (intro_classes, simp add: open_QuantT_def)"], ["", "end"], ["", "text \\<open> Quantities form a real normed vector space. \\<close>"], ["", "instance QuantT :: (real_normed_vector,dim_type,unit_system) real_normed_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a['b, 'c], real_normed_vector_class)", "by (intro_classes; transfer, auto simp add: eq_unit norm_triangle_ineq)"], ["", "end"]]}