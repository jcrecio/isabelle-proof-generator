{"file_name": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities/ISQ_Proof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Physical_Quantities", "problem_names": ["lemma quant_eq_iff_mag_eq [si_eq]:\n  \"x = y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma quant_eqI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x = y\"", "lemma quant_equiv_iff [si_eq]:\n  fixes x :: \"'a['u\\<^sub>1::dim_type, 's::unit_system]\" and y :: \"'a['u\\<^sub>2::dim_type, 's::unit_system]\"\n  shows \"x \\<cong>\\<^sub>Q y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and> QD('u\\<^sub>1) = QD('u\\<^sub>2)\"", "lemma quant_equivI [si_transfer]:\n  fixes x :: \"'a['u\\<^sub>1::dim_type, 's::unit_system]\" and y :: \"'a['u\\<^sub>2::dim_type, 's::unit_system]\"\n  assumes \"QD('u\\<^sub>1) = QD('u\\<^sub>2)\" \"QD('u\\<^sub>1) = QD('u\\<^sub>2) \\<Longrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"\n  shows \"x \\<cong>\\<^sub>Q y\"", "lemma quant_le_iff_magn_le [si_eq]:\n  \"x \\<le> y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma quant_leI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x \\<le> y\"", "lemma quant_less_iff_magn_less [si_eq]:\n  \"x < y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q < \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma quant_lessI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q < \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x < y\"", "lemma magQ_zero [si_eq]: \"\\<lbrakk>0\\<rbrakk>\\<^sub>Q = 0\"", "lemma magQ_one [si_eq]: \"\\<lbrakk>1\\<rbrakk>\\<^sub>Q = 1\"", "lemma magQ_plus [si_eq]: \"\\<lbrakk>x + y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q + \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma magQ_minus [si_eq]: \"\\<lbrakk>x - y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q - \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma magQ_uminus [si_eq]: \"\\<lbrakk>- x\\<rbrakk>\\<^sub>Q = - \\<lbrakk>x\\<rbrakk>\\<^sub>Q\"", "lemma magQ_scaleQ [si_eq]: \"\\<lbrakk>x *\\<^sub>Q y\\<rbrakk>\\<^sub>Q = x * \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma magQ_qtimes [si_eq]: \"\\<lbrakk>x \\<^bold>\\<cdot> y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<cdot> \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma magQ_qinverse [si_eq]: \"\\<lbrakk>x\\<^sup>-\\<^sup>\\<one>\\<rbrakk>\\<^sub>Q = inverse \\<lbrakk>x\\<rbrakk>\\<^sub>Q\"", "lemma magQ_qdivivide [si_eq]: \"\\<lbrakk>(x::('a::field)[_,_]) \\<^bold>/ y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q / \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"", "lemma magQ_numeral [si_eq]: \"\\<lbrakk>numeral n\\<rbrakk>\\<^sub>Q = numeral n\"", "lemma magQ_coerce [si_eq]: \n  fixes q :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" and t :: \"'d\\<^sub>2::dim_type itself\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2)\"\n  shows \"\\<lbrakk>coerceQuantT t q\\<rbrakk>\\<^sub>Q = \\<lbrakk>q\\<rbrakk>\\<^sub>Q\"", "lemma dimQ [simp]: \"dimQ(x :: 'a['d::dim_type, 's::unit_system]) = QD('d)\"", "lemma \"QD(N \\<cdot> \\<Theta> \\<cdot> N) = QD(\\<Theta> \\<cdot> N\\<^sup>2)\""], "translations": [["", "lemma quant_eq_iff_mag_eq [si_eq]:\n  \"x = y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q)", "by (auto simp add: magQ_def, transfer, simp add: eq_unit)"], ["", "lemma quant_eqI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<rbrakk>\\<^sub>Q =\n    \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow>\n    x = y", "by (simp add: quant_eq_iff_mag_eq)"], ["", "lemma quant_equiv_iff [si_eq]:\n  fixes x :: \"'a['u\\<^sub>1::dim_type, 's::unit_system]\" and y :: \"'a['u\\<^sub>2::dim_type, 's::unit_system]\"\n  shows \"x \\<cong>\\<^sub>Q y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and> QD('u\\<^sub>1) = QD('u\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cong>\\<^sub>Q y) =\n    (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and>\n     QD('u\\<^sub>1) = QD('u\\<^sub>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<cong>\\<^sub>Q y) =\n    (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and>\n     QD('u\\<^sub>1) = QD('u\\<^sub>2))", "have \"\\<forall>t ta. (ta::'a['u\\<^sub>2, 's]) = t \\<or> mag (fromQ ta) \\<noteq> mag (fromQ t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t ta. ta = t \\<or> mag (fromQ ta) \\<noteq> mag (fromQ t)", "by (simp add: magQ_def quant_eq_iff_mag_eq)"], ["proof (state)\nthis:\n  \\<forall>t ta. ta = t \\<or> mag (fromQ ta) \\<noteq> mag (fromQ t)\n\ngoal (1 subgoal):\n 1. (x \\<cong>\\<^sub>Q y) =\n    (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and>\n     QD('u\\<^sub>1) = QD('u\\<^sub>2))", "then"], ["proof (chain)\npicking this:\n  \\<forall>t ta. ta = t \\<or> mag (fromQ ta) \\<noteq> mag (fromQ t)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t ta. ta = t \\<or> mag (fromQ ta) \\<noteq> mag (fromQ t)\n\ngoal (1 subgoal):\n 1. (x \\<cong>\\<^sub>Q y) =\n    (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and>\n     QD('u\\<^sub>1) = QD('u\\<^sub>2))", "by (metis (full_types) qequiv.rep_eq coerceQuant_eq_iff2 qeq magQ_def)"], ["proof (state)\nthis:\n  (x \\<cong>\\<^sub>Q y) =\n  (\\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<and>\n   QD('u\\<^sub>1) = QD('u\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quant_equivI [si_transfer]:\n  fixes x :: \"'a['u\\<^sub>1::dim_type, 's::unit_system]\" and y :: \"'a['u\\<^sub>2::dim_type, 's::unit_system]\"\n  assumes \"QD('u\\<^sub>1) = QD('u\\<^sub>2)\" \"QD('u\\<^sub>1) = QD('u\\<^sub>2) \\<Longrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q\"\n  shows \"x \\<cong>\\<^sub>Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cong>\\<^sub>Q y", "using assms quant_equiv_iff"], ["proof (prove)\nusing this:\n  QD('u\\<^sub>1) = QD('u\\<^sub>2)\n  QD('u\\<^sub>1) = QD('u\\<^sub>2) \\<Longrightarrow>\n  \\<lbrakk>x\\<rbrakk>\\<^sub>Q = \\<lbrakk>y\\<rbrakk>\\<^sub>Q\n  (?x \\<cong>\\<^sub>Q ?y) =\n  (\\<lbrakk>?x\\<rbrakk>\\<^sub>Q = \\<lbrakk>?y\\<rbrakk>\\<^sub>Q \\<and>\n   QD(?'u\\<^sub>1) = QD(?'u\\<^sub>2))\n\ngoal (1 subgoal):\n 1. x \\<cong>\\<^sub>Q y", "by blast"], ["", "lemma quant_le_iff_magn_le [si_eq]:\n  \"x \\<le> y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) =\n    (\\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q)", "by (auto simp add: magQ_def; (transfer, simp))"], ["", "lemma quant_leI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<rbrakk>\\<^sub>Q\n    \\<le> \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow>\n    x \\<le> y", "by (simp add: quant_le_iff_magn_le)"], ["", "lemma quant_less_iff_magn_less [si_eq]:\n  \"x < y \\<longleftrightarrow> \\<lbrakk>x\\<rbrakk>\\<^sub>Q < \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (\\<lbrakk>x\\<rbrakk>\\<^sub>Q < \\<lbrakk>y\\<rbrakk>\\<^sub>Q)", "by (auto simp add: magQ_def; (transfer, simp))"], ["", "lemma quant_lessI [si_transfer]:\n  \"\\<lbrakk>x\\<rbrakk>\\<^sub>Q < \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<rbrakk>\\<^sub>Q\n    < \\<lbrakk>y\\<rbrakk>\\<^sub>Q \\<Longrightarrow>\n    x < y", "by (simp add: quant_less_iff_magn_less)"], ["", "lemma magQ_zero [si_eq]: \"\\<lbrakk>0\\<rbrakk>\\<^sub>Q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0\\<rbrakk>\\<^sub>Q = (0::'a)", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_one [si_eq]: \"\\<lbrakk>1\\<rbrakk>\\<^sub>Q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1\\<rbrakk>\\<^sub>Q = (1::'a)", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_plus [si_eq]: \"\\<lbrakk>x + y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q + \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + y\\<rbrakk>\\<^sub>Q =\n    \\<lbrakk>x\\<rbrakk>\\<^sub>Q + \\<lbrakk>y\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_minus [si_eq]: \"\\<lbrakk>x - y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q - \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x - y\\<rbrakk>\\<^sub>Q =\n    \\<lbrakk>x\\<rbrakk>\\<^sub>Q - \\<lbrakk>y\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_uminus [si_eq]: \"\\<lbrakk>- x\\<rbrakk>\\<^sub>Q = - \\<lbrakk>x\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- x\\<rbrakk>\\<^sub>Q = - \\<lbrakk>x\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_scaleQ [si_eq]: \"\\<lbrakk>x *\\<^sub>Q y\\<rbrakk>\\<^sub>Q = x * \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x *\\<^sub>Q y\\<rbrakk>\\<^sub>Q =\n    x \\<cdot> \\<lbrakk>y\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_qtimes [si_eq]: \"\\<lbrakk>x \\<^bold>\\<cdot> y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<cdot> \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<^bold>\\<cdot> y\\<rbrakk>\\<^sub>Q =\n    \\<lbrakk>x\\<rbrakk>\\<^sub>Q \\<cdot> \\<lbrakk>y\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_qinverse [si_eq]: \"\\<lbrakk>x\\<^sup>-\\<^sup>\\<one>\\<rbrakk>\\<^sub>Q = inverse \\<lbrakk>x\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x\\<^sup>-\\<^sup>\\<one>\\<rbrakk>\\<^sub>Q =\n    inverse \\<lbrakk>x\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp)"], ["", "lemma magQ_qdivivide [si_eq]: \"\\<lbrakk>(x::('a::field)[_,_]) \\<^bold>/ y\\<rbrakk>\\<^sub>Q = \\<lbrakk>x\\<rbrakk>\\<^sub>Q / \\<lbrakk>y\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<^bold>\\<cdot> y\\<^sup>-\\<^sup>\\<one>\\<rbrakk>\\<^sub>Q =\n    \\<lbrakk>x\\<rbrakk>\\<^sub>Q / \\<lbrakk>y\\<rbrakk>\\<^sub>Q", "by (simp add: magQ_def, transfer, simp add: field_class.field_divide_inverse)"], ["", "lemma magQ_numeral [si_eq]: \"\\<lbrakk>numeral n\\<rbrakk>\\<^sub>Q = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>numeral n\\<rbrakk>\\<^sub>Q = numeral n", "apply (induct n, simp_all add: si_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mag (fromQ 1) = (1::'a)\n 2. \\<And>n.\n       mag (fromQ (numeral n)) = numeral n \\<Longrightarrow>\n       mag (fromQ (numeral (num.Bit0 n))) = numeral (num.Bit0 n)\n 3. \\<And>n.\n       mag (fromQ (numeral n)) = numeral n \\<Longrightarrow>\n       mag (fromQ (numeral (num.Bit1 n))) = numeral (num.Bit1 n)", "apply (metis magQ_def magQ_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       mag (fromQ (numeral n)) = numeral n \\<Longrightarrow>\n       mag (fromQ (numeral (num.Bit0 n))) = numeral (num.Bit0 n)\n 2. \\<And>n.\n       mag (fromQ (numeral n)) = numeral n \\<Longrightarrow>\n       mag (fromQ (numeral (num.Bit1 n))) = numeral (num.Bit1 n)", "apply (metis magQ_def magQ_plus numeral_code(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       mag (fromQ (numeral n)) = numeral n \\<Longrightarrow>\n       mag (fromQ (numeral (num.Bit1 n))) = numeral (num.Bit1 n)", "apply (metis magQ_def magQ_one magQ_plus numeral_code(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma magQ_coerce [si_eq]: \n  fixes q :: \"'a['d\\<^sub>1::dim_type, 's::unit_system]\" and t :: \"'d\\<^sub>2::dim_type itself\"\n  assumes \"QD('d\\<^sub>1) = QD('d\\<^sub>2)\"\n  shows \"\\<lbrakk>coerceQuantT t q\\<rbrakk>\\<^sub>Q = \\<lbrakk>q\\<rbrakk>\\<^sub>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coerceQuantT t q\\<rbrakk>\\<^sub>Q = \\<lbrakk>q\\<rbrakk>\\<^sub>Q", "by (simp add: coerceQuantT_def magQ_def assms, metis assms qequiv.rep_eq updown_eq_iff)"], ["", "lemma dimQ [simp]: \"dimQ(x :: 'a['d::dim_type, 's::unit_system]) = QD('d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dimQ x = QD('d)", "by (simp add: dimQ_def, transfer, simp)"], ["", "text \\<open> The following tactic breaks an SI conjecture down to numeric and unit properties \\<close>"], ["", "method si_simp uses add =\n  (rule_tac si_transfer; simp add: add si_eq field_simps)"], ["", "text \\<open> The next tactic additionally compiles the semantics of the underlying units \\<close>"], ["", "method si_calc uses add = \n  (si_simp add: add; simp add: si_def add)"], ["", "lemma \"QD(N \\<cdot> \\<Theta> \\<cdot> N) = QD(\\<Theta> \\<cdot> N\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QD(N \\<cdot> \\<Theta> \\<cdot> N) = QD(\\<Theta> \\<cdot> N\\<^sup>2)", "by (simp add: si_eq si_def)"], ["", "end"]]}