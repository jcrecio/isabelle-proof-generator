{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP/LTL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP", "problem_names": ["lemmas defs =\n  state_prop_def\n  always_def\n  eventually_def\n  next_def\n  release_def\n  unless_def\n  until_def", "lemma suffix_state_prop[simp]:\n  shows \"\\<lceil>P\\<rceil> (\\<sigma> |\\<^sub>s i) = P (\\<sigma> i)\"", "lemma alwaysI[intro]:\n  assumes \"\\<And>i. P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(\\<box>P) \\<sigma>\"", "lemma alwaysD:\n  assumes \"(\\<box>P) \\<sigma>\"\n  shows \"P (\\<sigma> |\\<^sub>s i)\"", "lemma alwaysE: \"\\<lbrakk>(\\<box>P) \\<sigma>; P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma always_induct:\n  assumes \"P \\<sigma>\"\n  assumes \"(\\<box>(P \\<^bold>\\<longrightarrow> \\<circle>P)) \\<sigma>\"\n  shows \"(\\<box>P) \\<sigma>\"", "lemma seq_comp:\n  fixes \\<sigma> :: \"'a seq\"\n  fixes P :: \"'b seq_pred\"\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  shows\n    \"(\\<box>P) (f \\<circ> \\<sigma>) \\<longleftrightarrow> (\\<box>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(\\<diamond>P) (f \\<circ> \\<sigma>) \\<longleftrightarrow> (\\<diamond>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(P \\<U> Q) (f \\<circ> \\<sigma>) \\<longleftrightarrow> ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<U> (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(P \\<W> Q) (f \\<circ> \\<sigma>) \\<longleftrightarrow> ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<W> (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>))) \\<sigma>\"", "lemma nextI[intro]:\n  assumes \"P (\\<sigma> |\\<^sub>s Suc 0)\"\n  shows \"(\\<circle>P) \\<sigma>\"", "lemma untilI[intro]:\n  assumes \"Q (\\<sigma> |\\<^sub>s i)\"\n  assumes \"\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\"\n  shows \"(P \\<U> Q) \\<sigma>\"", "lemma untilE:\n  assumes \"(P \\<U> Q) \\<sigma>\"\n  obtains i where \"Q (\\<sigma> |\\<^sub>s i)\" and \"\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\"", "lemma eventuallyI[intro]:\n  assumes \"P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(\\<diamond>P) \\<sigma>\"", "lemma eventuallyE[elim]:\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  obtains i where \"P (\\<sigma> |\\<^sub>s i)\"", "lemma unless_alwaysI:\n  assumes \"(\\<box> P) \\<sigma>\"\n  shows \"(P \\<W> Q) \\<sigma>\"", "lemma unless_untilI:\n  assumes \"Q (\\<sigma> |\\<^sub>s j)\"\n  assumes \"\\<And>i. i < j \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(P \\<W> Q) \\<sigma>\"", "lemma always_imp_refl[iff]:\n  shows \"(P \\<^bold>\\<hookrightarrow> P) \\<sigma>\"", "lemma always_imp_trans:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<hookrightarrow> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> R) \\<sigma>\"", "lemma always_imp_mp:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"P \\<sigma>\"\n  shows \"Q \\<sigma>\"", "lemma always_imp_mp_suffix:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"P (\\<sigma> |\\<^sub>s i)\"\n  shows \"Q (\\<sigma> |\\<^sub>s i)\"", "lemma necessitation:\n  \"(\\<And>s. P s) \\<Longrightarrow> (\\<box>P) \\<sigma>\"\n  \"(\\<And>s. P s) \\<Longrightarrow> (\\<diamond>P) \\<sigma>\"\n  \"(\\<And>s. P s) \\<Longrightarrow> (P \\<W> Q) \\<sigma>\"\n  \"(\\<And>s. Q s) \\<Longrightarrow> (P \\<U> Q) \\<sigma>\"", "lemma cong:\n  \"(\\<And>s. P s = P' s) \\<Longrightarrow> \\<lceil>P\\<rceil> = \\<lceil>P'\\<rceil>\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<box>P) = (\\<box>P')\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<diamond>P) = (\\<diamond>P')\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<circle>P) = (\\<circle>P')\"\n  \"\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P \\<U> Q) = (P' \\<U> Q')\"\n  \"\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P \\<W> Q) = (P' \\<W> Q')\"", "lemma norm[simp]:\n  \"\\<lceil>\\<langle>False\\<rangle>\\<rceil> = \\<langle>False\\<rangle>\"\n  \"\\<lceil>\\<langle>True\\<rangle>\\<rceil> = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<lceil>p\\<rceil>) = \\<lceil>\\<^bold>\\<not>p\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<and> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<and> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<or> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<or> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<longrightarrow> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<longrightarrow> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<and> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<and> q\\<rceil> \\<sigma>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<or> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<or> q\\<rceil> \\<sigma>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<longrightarrow> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<longrightarrow> q\\<rceil> \\<sigma>\"\n\n  \"(\\<circle>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<circle>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n\n  \"(\\<box>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<box>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<box> P) \\<sigma> = (\\<diamond> (\\<^bold>\\<not> P)) \\<sigma>\"\n  \"(\\<box>\\<box> P) = (\\<box> P)\"\n\n  \"(\\<diamond>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<diamond>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<diamond> P) = (\\<box> (\\<^bold>\\<not> P))\"\n  \"(\\<diamond>\\<diamond> P) = (\\<diamond> P)\"\n\n  \"(P \\<W> \\<langle>False\\<rangle>) = (\\<box> P)\"\n\n  \"(\\<^bold>\\<not>(P \\<U> Q)) \\<sigma> = (\\<^bold>\\<not>P \\<R> \\<^bold>\\<not>Q) \\<sigma>\"\n  \"(\\<langle>False\\<rangle> \\<U> P) = P\"\n  \"(P \\<U> \\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(P \\<U> \\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<langle>True\\<rangle> \\<U> P) = (\\<diamond> P)\"\n  \"(P \\<U> (P \\<U> Q)) = (P \\<U> Q)\"\n\n  \"(\\<^bold>\\<not>(P \\<R> Q)) \\<sigma> = (\\<^bold>\\<not>P \\<U> \\<^bold>\\<not>Q) \\<sigma>\"\n  \"(\\<langle>False\\<rangle> \\<R> P) = (\\<box>P)\"\n  \"(P \\<R> \\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<langle>True\\<rangle> \\<R> P) = P\"\n  \"(P \\<R> \\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"", "lemma always_conj_distrib: \"(\\<box>(P \\<^bold>\\<and> Q)) = (\\<box>P \\<^bold>\\<and> \\<box>Q)\"", "lemma eventually_disj_distrib: \"(\\<diamond>(P \\<^bold>\\<or> Q)) = (\\<diamond>P \\<^bold>\\<or> \\<diamond>Q)\"", "lemma always_eventually[elim!]:\n  assumes \"(\\<box>P) \\<sigma>\"\n  shows \"(\\<diamond>P) \\<sigma>\"", "lemma eventually_imp_conv_disj: \"(\\<diamond>(P \\<^bold>\\<longrightarrow> Q)) = (\\<diamond>(\\<^bold>\\<not>P) \\<^bold>\\<or> \\<diamond>Q)\"", "lemma eventually_imp_distrib:\n  \"(\\<diamond>(P \\<^bold>\\<longrightarrow> Q)) = (\\<box>P \\<^bold>\\<longrightarrow> \\<diamond>Q)\"", "lemma unfold:\n  \"(\\<box> P) \\<sigma> = (P \\<^bold>\\<and> \\<circle>\\<box>P) \\<sigma>\"\n  \"(\\<diamond> P) \\<sigma> = (P \\<^bold>\\<or> \\<circle>\\<diamond>P) \\<sigma>\"\n  \"(P \\<W> Q) \\<sigma> = (Q \\<^bold>\\<or> (P \\<^bold>\\<and> \\<circle>(P \\<W> Q))) \\<sigma>\"\n  \"(P \\<U> Q) \\<sigma> = (Q \\<^bold>\\<or> (P \\<^bold>\\<and> \\<circle>(P \\<U> Q))) \\<sigma>\"\n  \"(P \\<R> Q) \\<sigma> = (Q \\<^bold>\\<and> (P \\<^bold>\\<or> \\<circle>(P \\<R> Q))) \\<sigma>\"", "lemma mono:\n  \"\\<lbrakk>(\\<box>P) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow>  P' \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<box>P') \\<sigma>\"\n  \"\\<lbrakk>(\\<diamond>P) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow>  P' \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<diamond>P') \\<sigma>\"\n  \"\\<lbrakk>(P \\<U> Q) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<U> Q') \\<sigma>\"\n  \"\\<lbrakk>(P \\<W> Q) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<W> Q') \\<sigma>\"", "lemma always_imp_mono:\n  \"\\<lbrakk>(\\<box>P) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<box>P') \\<sigma>\"\n  \"\\<lbrakk>(\\<diamond>P) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<diamond>P') \\<sigma>\"\n  \"\\<lbrakk>(P \\<U> Q) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>; (Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<U> Q') \\<sigma>\"\n  \"\\<lbrakk>(P \\<W> Q) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>; (Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<W> Q') \\<sigma>\"", "lemma next_conj_distrib:\n  \"(\\<circle>(P \\<^bold>\\<and> Q)) = (\\<circle>P \\<^bold>\\<and> \\<circle>Q)\"", "lemma next_disj_distrib:\n  \"(\\<circle>(P \\<^bold>\\<or> Q)) = (\\<circle>P \\<^bold>\\<or> \\<circle>Q)\"", "lemma until_next_distrib:\n  \"(\\<circle>(P \\<U> Q)) = (\\<circle>P \\<U> \\<circle>Q)\"", "lemma until_imp_eventually:\n  \"((P \\<U> Q) \\<^bold>\\<longrightarrow> \\<diamond>Q) \\<sigma>\"", "lemma until_until_disj:\n  assumes \"(P \\<U> Q \\<U> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<U> R) \\<sigma>\"", "lemma unless_unless_disj:\n  assumes \"(P \\<W> Q \\<W> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<W> R) \\<sigma>\"", "lemma until_conj_distrib:\n  \"((P \\<^bold>\\<and> Q) \\<U> R) = ((P \\<U> R) \\<^bold>\\<and> (Q \\<U> R))\"", "lemma until_disj_distrib:\n  \"(P \\<U> (Q \\<^bold>\\<or> R)) = ((P \\<U> Q) \\<^bold>\\<or> (P \\<U> R))\"", "lemma eventually_until:\n  \"(\\<diamond>P) = (\\<^bold>\\<not>P \\<U> P)\"", "lemma eventually_until_eventually:\n  \"(\\<diamond>(P \\<U> Q)) = (\\<diamond>Q)\"", "lemma eventually_unless_until:\n  \"((P \\<W> Q) \\<^bold>\\<and> \\<diamond>Q) = (P \\<U> Q)\"", "lemma eventually_always_imp_always_eventually:\n  assumes \"(\\<diamond>\\<box>P) \\<sigma>\"\n  shows \"(\\<box>\\<diamond>P) \\<sigma>\"", "lemma eventually_always_next_stable:\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>P) \\<sigma>\"\n  shows \"(\\<diamond>\\<box>P) \\<sigma>\"", "lemma next_stable_imp_eventually_always:\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>P) \\<sigma>\"\n  shows \"(\\<diamond>P \\<^bold>\\<longrightarrow> \\<diamond>\\<box>P) \\<sigma>\"", "lemma always_eventually_always:\n  \"\\<diamond>\\<box>\\<diamond>P = \\<box>\\<diamond>P\"", "lemma stable_unless:\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>(P \\<^bold>\\<or> Q)) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> (P \\<W> Q)) \\<sigma>\"", "lemma unless_induct: \\<comment>\\<open> Rule \\texttt{WAIT} from @{cite [cite_macro=citet] \\<open>Fig~3.3\\<close> \"MannaPnueli:1995\"}\\<close>\n  assumes I: \"(I \\<^bold>\\<hookrightarrow> \\<circle>(I \\<^bold>\\<or> R)) \\<sigma>\"\n  assumes P: \"(P \\<^bold>\\<hookrightarrow> I \\<^bold>\\<or> R) \\<sigma>\"\n  assumes Q: \"(I \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> Q \\<W> R) \\<sigma>\"", "lemma leads_to_refl:\n  shows \"(P \\<^bold>\\<leadsto> P) \\<sigma>\"", "lemma leads_to_trans:\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<leadsto> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<leadsto> R) \\<sigma>\"", "lemma leads_to_eventuallyE:\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  shows \"(\\<diamond>Q) \\<sigma>\"", "lemma leads_to_mono:\n  assumes \"(P' \\<^bold>\\<hookrightarrow> P) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\"\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  shows \"(P' \\<^bold>\\<leadsto> Q') \\<sigma>\"", "lemma leads_to_eventually:\n  shows \"(P \\<^bold>\\<leadsto> Q \\<^bold>\\<longrightarrow> \\<diamond>P \\<^bold>\\<longrightarrow> \\<diamond>Q) \\<sigma>\"", "lemma leads_to_disj:\n  assumes \"(P \\<^bold>\\<leadsto> R) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<leadsto> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<^bold>\\<leadsto> R) \\<sigma>\"", "lemma leads_to_leads_to_viaE:\n  shows \"((P \\<^bold>\\<hookrightarrow> P \\<U> Q) \\<^bold>\\<longrightarrow> P \\<^bold>\\<leadsto> Q) \\<sigma>\"", "lemma leads_to_via_concl_weaken:\n  assumes \"(R \\<^bold>\\<hookrightarrow> R') \\<sigma>\"\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R') \\<sigma>\"", "lemma leads_to_via_trans:\n  assumes \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\"\n  assumes \"(C \\<^bold>\\<hookrightarrow> D \\<U> E) \\<sigma>\"\n  shows \"(A \\<^bold>\\<hookrightarrow> (B \\<^bold>\\<or> D) \\<U> E) \\<sigma>\"", "lemma leads_to_via_disj: \\<comment> \\<open> useful for case distinctions \\<close>\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R) \\<sigma>\"\n  assumes \"(P' \\<^bold>\\<hookrightarrow> Q' \\<U> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<or> P' \\<^bold>\\<hookrightarrow> (Q \\<^bold>\\<or> Q') \\<U> R) \\<sigma>\"", "lemma leads_to_via_disj': \\<comment> \\<open> more like a chaining rule \\<close>\n  assumes \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\"\n  assumes \"(C \\<^bold>\\<hookrightarrow> D \\<U> E) \\<sigma>\"\n  shows \"(A \\<^bold>\\<or> C \\<^bold>\\<hookrightarrow> (B \\<^bold>\\<or> D) \\<U> E) \\<sigma>\"", "lemma leads_to_via_stable_augmentation:\n  assumes stable: \"(P \\<^bold>\\<and> Q \\<^bold>\\<hookrightarrow> \\<circle>Q) \\<sigma>\"\n  assumes U: \"(A \\<^bold>\\<hookrightarrow> P \\<U> C) \\<sigma>\"\n  shows \"((A \\<^bold>\\<and> Q) \\<^bold>\\<hookrightarrow> P \\<U> (C \\<^bold>\\<and> Q)) \\<sigma>\"", "lemma leads_to_via_wf:\n  assumes \"wf R\"\n  assumes indhyp: \"\\<And>t. (A \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>= \\<langle>t\\<rangle>\\<rceil> \\<^bold>\\<hookrightarrow> B \\<U> (A \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>\\<otimes> \\<langle>t\\<rangle> \\<^bold>\\<in> \\<langle>R\\<rangle>\\<rceil> \\<^bold>\\<or> C)) \\<sigma>\"\n  shows \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\"", "lemma leads_to_wf:\n  fixes Is :: \"('a seq_pred \\<times> ('a \\<Rightarrow> 'b)) set\"\n  assumes \"wf (R :: 'b rel)\"\n  assumes W1: \"(\\<box>(\\<^bold>\\<exists>\\<phi>. \\<lceil>\\<langle>\\<phi>\\<in>fst ` Is\\<rangle>\\<rceil> \\<^bold>\\<and> (P \\<^bold>\\<longrightarrow> \\<phi>))) \\<sigma>\"\n  assumes W2: \"\\<forall>(\\<phi>, \\<delta>)\\<in>Is. \\<exists>(\\<phi>', \\<delta>')\\<in>insert (Q, \\<delta>0) Is. \\<forall>t. (\\<phi> \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>= \\<langle>t\\<rangle>\\<rceil> \\<^bold>\\<leadsto> \\<phi>' \\<^bold>\\<and> \\<lceil>\\<delta>' \\<^bold>\\<otimes> \\<langle>t\\<rangle> \\<^bold>\\<in> \\<langle>R\\<rangle>\\<rceil>) \\<sigma>\"\n  shows \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"", "lemma weakly_fair_def2:\n  shows \"weakly_fair enabled taken = \\<box>(\\<^bold>\\<not>\\<box>(enabled \\<^bold>\\<and> \\<^bold>\\<not>taken))\"", "lemma weakly_fair_def3:\n  shows \"weakly_fair enabled taken = (\\<diamond>\\<box>enabled \\<^bold>\\<longrightarrow> \\<box>\\<diamond>taken)\"", "lemma weakly_fair_def4:\n  shows \"weakly_fair enabled taken = \\<box>\\<diamond>(enabled \\<^bold>\\<longrightarrow> taken)\"", "lemma mp_weakly_fair:\n  assumes \"weakly_fair enabled taken \\<sigma>\"\n  assumes \"(\\<box>enabled) \\<sigma>\"\n  shows \"(\\<diamond>taken) \\<sigma>\"", "lemma always_weakly_fair:\n  shows \"\\<box>(weakly_fair enabled taken) = weakly_fair enabled taken\"", "lemma eventually_weakly_fair:\n  shows \"\\<diamond>(weakly_fair enabled taken) = weakly_fair enabled taken\"", "lemma weakly_fair_weaken:\n  assumes \"(enabled' \\<^bold>\\<hookrightarrow> enabled) \\<sigma>\"\n  assumes \"(taken \\<^bold>\\<hookrightarrow> taken') \\<sigma>\"\n  shows \"(weakly_fair enabled taken \\<^bold>\\<hookrightarrow>  weakly_fair enabled' taken') \\<sigma>\"", "lemma weakly_fair_unless_until:\n  shows \"(weakly_fair enabled taken \\<^bold>\\<and> (enabled \\<^bold>\\<hookrightarrow> enabled \\<W> taken)) = (enabled \\<^bold>\\<hookrightarrow> enabled \\<U> taken)\"", "lemma stable_leads_to_eventually:\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<hookrightarrow> (\\<box>enabled \\<^bold>\\<or> \\<diamond>taken)) \\<sigma>\"", "lemma weakly_fair_stable_leads_to:\n  assumes \"(weakly_fair enabled taken) \\<sigma>\"\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<leadsto> taken) \\<sigma>\"", "lemma weakly_fair_stable_leads_to_via:\n  assumes \"(weakly_fair enabled taken) \\<sigma>\"\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<hookrightarrow> enabled \\<U> taken) \\<sigma>\"", "lemma strongly_fair_def2:\n  \"strongly_fair enabled taken = \\<box>(\\<^bold>\\<not>\\<box>(\\<diamond>enabled \\<^bold>\\<and> \\<^bold>\\<not>taken))\"", "lemma strongly_fair_def3:\n  \"strongly_fair enabled taken = (\\<box>\\<diamond>enabled \\<^bold>\\<longrightarrow> \\<box>\\<diamond>taken)\"", "lemma always_strongly_fair:\n  \"\\<box>(strongly_fair enabled taken) = strongly_fair enabled taken\"", "lemma eventually_strongly_fair:\n  \"\\<diamond>(strongly_fair enabled taken) = strongly_fair enabled taken\"", "lemma strongly_fair_disj_distrib: \\<comment> \\<open>not true for \\<open>weakly_fair\\<close>\\<close>\n  \"strongly_fair (enabled1 \\<^bold>\\<or> enabled2) taken = (strongly_fair enabled1 taken \\<^bold>\\<and> strongly_fair enabled2 taken)\"", "lemma strongly_fair_imp_weakly_fair:\n  assumes \"strongly_fair enabled taken \\<sigma>\"\n  shows \"weakly_fair enabled taken \\<sigma>\"", "lemma always_enabled_weakly_fair_strongly_fair:\n  assumes \"(\\<box>enabled) \\<sigma>\"\n  shows \"weakly_fair enabled taken \\<sigma> = strongly_fair enabled taken \\<sigma>\"", "lemma safety_state_prop:\n  shows \"safety \\<lceil>P\\<rceil>\"", "lemma safety_Next:\n  assumes \"safety P\"\n  shows \"safety (\\<circle>P)\"", "lemma safety_unless:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<W> Q)\"", "lemma safety_always:\n  assumes \"safety P\"\n  shows \"safety (\\<box>P)\"", "lemma absolute_liveness_eventually:\n  shows \"absolute_liveness P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<diamond>P\"", "lemma stable_always:\n  shows \"stable P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<box>P\"", "lemma fairness_weakly_fair:\n  assumes \"\\<exists>s. taken s\"\n  shows \"fairness (weakly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)\"", "lemma fairness_strongly_fair:\n  assumes \"\\<exists>s. taken s\"\n  shows \"fairness (strongly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)\""], "translations": [["", "lemmas defs =\n  state_prop_def\n  always_def\n  eventually_def\n  next_def\n  release_def\n  unless_def\n  until_def"], ["", "lemma suffix_state_prop[simp]:\n  shows \"\\<lceil>P\\<rceil> (\\<sigma> |\\<^sub>s i) = P (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> (\\<sigma> |\\<^sub>s i) = P (\\<sigma> i)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ((\\<sigma> |\\<^sub>s i) 0) = P (\\<sigma> i)", "by simp"], ["", "lemma alwaysI[intro]:\n  assumes \"\\<And>i. P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(\\<box>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>P) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (\\<sigma> |\\<^sub>s i)", "using assms"], ["proof (prove)\nusing this:\n  P (\\<sigma> |\\<^sub>s ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (\\<sigma> |\\<^sub>s i)", "by blast"], ["", "lemma alwaysD:\n  assumes \"(\\<box>P) \\<sigma>\"\n  shows \"P (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s i)", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s i)", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s i)", "by blast"], ["", "lemma alwaysE: \"\\<lbrakk>(\\<box>P) \\<sigma>; P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>P) \\<sigma>;\n     P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n     P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by blast"], ["", "lemma always_induct:\n  assumes \"P \\<sigma>\"\n  assumes \"(\\<box>(P \\<^bold>\\<longrightarrow> \\<circle>P)) \\<sigma>\"\n  shows \"(\\<box>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>P) \\<sigma>", "proof(rule alwaysI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. P (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. P (\\<sigma> |\\<^sub>s i)", "from assms"], ["proof (chain)\npicking this:\n  P \\<sigma>\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<circle>P) s)) \\<sigma>", "show \"P (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  P \\<sigma>\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<circle>P) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s i)", "unfolding defs"], ["proof (prove)\nusing this:\n  P \\<sigma>\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     P (\\<sigma> |\\<^sub>s i |\\<^sub>s 1)\n\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s i)", "by (induct i) simp_all"], ["proof (state)\nthis:\n  P (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_comp:\n  fixes \\<sigma> :: \"'a seq\"\n  fixes P :: \"'b seq_pred\"\n  fixes f :: \"'a \\<Rightarrow> 'b\"\n  shows\n    \"(\\<box>P) (f \\<circ> \\<sigma>) \\<longleftrightarrow> (\\<box>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(\\<diamond>P) (f \\<circ> \\<sigma>) \\<longleftrightarrow> (\\<diamond>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(P \\<U> Q) (f \\<circ> \\<sigma>) \\<longleftrightarrow> ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<U> (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>))) \\<sigma>\"\n    \"(P \\<W> Q) (f \\<circ> \\<sigma>) \\<longleftrightarrow> ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<W> (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>))) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<box>P) (f \\<circ> \\<sigma>) =\n     (\\<box>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma> &&&\n     (\\<diamond>P) (f \\<circ> \\<sigma>) =\n     (\\<diamond>(\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>))) \\<sigma>) &&&\n    (P \\<U> Q) (f \\<circ> \\<sigma>) =\n    ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<U>\n     (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>)))\n     \\<sigma> &&&\n    (P \\<W> Q) (f \\<circ> \\<sigma>) =\n    ((\\<lambda>\\<sigma>. P (f \\<circ> \\<sigma>)) \\<W>\n     (\\<lambda>\\<sigma>. Q (f \\<circ> \\<sigma>)))\n     \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i. P ((f \\<circ> \\<sigma>) |\\<^sub>s i)) =\n     (\\<forall>i. P (f \\<circ> \\<sigma> |\\<^sub>s i)) &&&\n     (\\<exists>i.\n         P ((f \\<circ> \\<sigma>) |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n     (\\<exists>i.\n         P (f \\<circ> \\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. True))) &&&\n    (\\<exists>i.\n        Q ((f \\<circ> \\<sigma>) |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P ((f \\<circ> \\<sigma>) |\\<^sub>s k))) =\n    (\\<exists>i.\n        Q (f \\<circ> \\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (f \\<circ> \\<sigma> |\\<^sub>s k))) &&&\n    ((\\<exists>i.\n         Q ((f \\<circ> \\<sigma>) |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P ((f \\<circ> \\<sigma>) |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P ((f \\<circ> \\<sigma>) |\\<^sub>s i))) =\n    ((\\<exists>i.\n         Q (f \\<circ> \\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (f \\<circ> \\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (f \\<circ> \\<sigma> |\\<^sub>s i)))", "by simp_all"], ["", "lemma nextI[intro]:\n  assumes \"P (\\<sigma> |\\<^sub>s Suc 0)\"\n  shows \"(\\<circle>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<circle>P) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  P (\\<sigma> |\\<^sub>s Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<circle>P) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  P (\\<sigma> |\\<^sub>s Suc 0)\n\ngoal (1 subgoal):\n 1. P (\\<sigma> |\\<^sub>s 1)", "by simp"], ["", "lemma untilI[intro]:\n  assumes \"Q (\\<sigma> |\\<^sub>s i)\"\n  assumes \"\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\"\n  shows \"(P \\<U> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<U> Q) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))", "using assms"], ["proof (prove)\nusing this:\n  Q (\\<sigma> |\\<^sub>s i)\n  \\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))", "by blast"], ["", "lemma untilE:\n  assumes \"(P \\<U> Q) \\<sigma>\"\n  obtains i where \"Q (\\<sigma> |\\<^sub>s i)\" and \"\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n         \\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (P \\<U> Q) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n         \\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding until_def"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     Q (\\<sigma> |\\<^sub>s i) \\<and>\n     (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n         \\<forall>k<i. P (\\<sigma> |\\<^sub>s k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma eventuallyI[intro]:\n  assumes \"P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(\\<diamond>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>P) \\<sigma>", "unfolding eventually_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<U> P) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<U> P) \\<sigma>", "by blast"], ["", "lemma eventuallyE[elim]:\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  obtains i where \"P (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (\\<diamond>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: untilE)"], ["", "lemma unless_alwaysI:\n  assumes \"(\\<box> P) \\<sigma>\"\n  shows \"(P \\<W> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n    (\\<forall>i. P (\\<sigma> |\\<^sub>s i))", "by blast"], ["", "lemma unless_untilI:\n  assumes \"Q (\\<sigma> |\\<^sub>s j)\"\n  assumes \"\\<And>i. i < j \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\"\n  shows \"(P \\<W> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n    (\\<forall>i. P (\\<sigma> |\\<^sub>s i))", "using assms"], ["proof (prove)\nusing this:\n  Q (\\<sigma> |\\<^sub>s j)\n  ?i < j \\<Longrightarrow> P (\\<sigma> |\\<^sub>s ?i)\n\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n    (\\<forall>i. P (\\<sigma> |\\<^sub>s i))", "by blast"], ["", "lemma always_imp_refl[iff]:\n  shows \"(P \\<^bold>\\<hookrightarrow> P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> P s)) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow> P (\\<sigma> |\\<^sub>s i)", "by blast"], ["", "lemma always_imp_trans:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<hookrightarrow> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> R s)) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> Q s)) \\<sigma>\n  (\\<box>(\\<lambda>s. Q s \\<longrightarrow> R s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> R s)) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n  \\<forall>i.\n     Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow> R (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow> R (\\<sigma> |\\<^sub>s i)", "by blast"], ["", "lemma always_imp_mp:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"P \\<sigma>\"\n  shows \"Q \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> Q s)) \\<sigma>\n  P \\<sigma>\n\ngoal (1 subgoal):\n 1. Q \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n  P \\<sigma>\n\ngoal (1 subgoal):\n 1. Q \\<sigma>", "by (metis suffix_zero)"], ["", "lemma always_imp_mp_suffix:\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  assumes \"P (\\<sigma> |\\<^sub>s i)\"\n  shows \"Q (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (\\<sigma> |\\<^sub>s i)", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> Q s)) \\<sigma>\n  P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. Q (\\<sigma> |\\<^sub>s i)", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n  P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. Q (\\<sigma> |\\<^sub>s i)", "by metis"], ["", "text\\<open>\n\nSome basic facts and equivalences, mostly sanity.\n\n\\<close>"], ["", "lemma necessitation:\n  \"(\\<And>s. P s) \\<Longrightarrow> (\\<box>P) \\<sigma>\"\n  \"(\\<And>s. P s) \\<Longrightarrow> (\\<diamond>P) \\<sigma>\"\n  \"(\\<And>s. P s) \\<Longrightarrow> (P \\<W> Q) \\<sigma>\"\n  \"(\\<And>s. Q s) \\<Longrightarrow> (P \\<U> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>s. P s) \\<Longrightarrow> (\\<box>P) \\<sigma>) &&&\n     ((\\<And>s. P s) \\<Longrightarrow> (\\<diamond>P) \\<sigma>)) &&&\n    ((\\<And>s. P s) \\<Longrightarrow> (P \\<W> Q) \\<sigma>) &&&\n    ((\\<And>s. Q s) \\<Longrightarrow> (P \\<U> Q) \\<sigma>)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>s. P s) \\<Longrightarrow>\n      \\<forall>i. P (\\<sigma> |\\<^sub>s i)) &&&\n     ((\\<And>s. P s) \\<Longrightarrow>\n      \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True))) &&&\n    ((\\<And>s. P s) \\<Longrightarrow>\n     (\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) &&&\n    ((\\<And>s. Q s) \\<Longrightarrow>\n     \\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)))", "by auto"], ["", "lemma cong:\n  \"(\\<And>s. P s = P' s) \\<Longrightarrow> \\<lceil>P\\<rceil> = \\<lceil>P'\\<rceil>\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<box>P) = (\\<box>P')\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<diamond>P) = (\\<diamond>P')\"\n  \"(\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow> (\\<circle>P) = (\\<circle>P')\"\n  \"\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P \\<U> Q) = (P' \\<U> Q')\"\n  \"\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P \\<W> Q) = (P' \\<W> Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>s. P s = P' s) \\<Longrightarrow>\n      \\<lceil>P\\<rceil> = \\<lceil>P'\\<rceil>) &&&\n     ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n      \\<box>P = \\<box>P') &&&\n     ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n      \\<diamond>P = \\<diamond>P')) &&&\n    ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n     \\<circle>P = \\<circle>P') &&&\n    (\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P \\<U> Q) = (P' \\<U> Q')) &&&\n    (\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P \\<W> Q) = (P' \\<W> Q'))", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>s. P s = P' s) \\<Longrightarrow>\n      (\\<lambda>\\<sigma>. P (\\<sigma> 0)) =\n      (\\<lambda>\\<sigma>. P' (\\<sigma> 0))) &&&\n     ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n      (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> |\\<^sub>s i)) =\n      (\\<lambda>\\<sigma>. \\<forall>i. P' (\\<sigma> |\\<^sub>s i))) &&&\n     ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             P' (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))) &&&\n    ((\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>) \\<Longrightarrow>\n     (\\<lambda>\\<sigma>. P (\\<sigma> |\\<^sub>s 1)) =\n     (\\<lambda>\\<sigma>. P' (\\<sigma> |\\<^sub>s 1))) &&&\n    (\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                           \\<exists>i.\n                              Q (\\<sigma> |\\<^sub>s i) \\<and>\n                              (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n                       (\\<lambda>\\<sigma>.\n                           \\<exists>i.\n                              Q' (\\<sigma> |\\<^sub>s i) \\<and>\n                              (\\<forall>k<i.\n                                  P' (\\<sigma> |\\<^sub>s k)))) &&&\n    (\\<lbrakk>\\<And>\\<sigma>. P \\<sigma> = P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> = Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>s.\n                           (\\<exists>i.\n                               Q (s |\\<^sub>s i) \\<and>\n                               (\\<forall>k<i. P (s |\\<^sub>s k))) \\<or>\n                           (\\<forall>i. P (s |\\<^sub>s i))) =\n                       (\\<lambda>s.\n                           (\\<exists>i.\n                               Q' (s |\\<^sub>s i) \\<and>\n                               (\\<forall>k<i. P' (s |\\<^sub>s k))) \\<or>\n                           (\\<forall>i. P' (s |\\<^sub>s i))))", "by auto"], ["", "lemma norm[simp]:\n  \"\\<lceil>\\<langle>False\\<rangle>\\<rceil> = \\<langle>False\\<rangle>\"\n  \"\\<lceil>\\<langle>True\\<rangle>\\<rceil> = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<lceil>p\\<rceil>) = \\<lceil>\\<^bold>\\<not>p\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<and> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<and> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<or> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<or> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<^bold>\\<longrightarrow> \\<lceil>q\\<rceil>) = \\<lceil>p \\<^bold>\\<longrightarrow> q\\<rceil>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<and> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<and> q\\<rceil> \\<sigma>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<or> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<or> q\\<rceil> \\<sigma>\"\n  \"(\\<lceil>p\\<rceil> \\<sigma> \\<longrightarrow> \\<lceil>q\\<rceil> \\<sigma>) = \\<lceil>p \\<^bold>\\<longrightarrow> q\\<rceil> \\<sigma>\"\n\n  \"(\\<circle>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<circle>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n\n  \"(\\<box>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<box>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<box> P) \\<sigma> = (\\<diamond> (\\<^bold>\\<not> P)) \\<sigma>\"\n  \"(\\<box>\\<box> P) = (\\<box> P)\"\n\n  \"(\\<diamond>\\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<diamond>\\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<^bold>\\<not>\\<diamond> P) = (\\<box> (\\<^bold>\\<not> P))\"\n  \"(\\<diamond>\\<diamond> P) = (\\<diamond> P)\"\n\n  \"(P \\<W> \\<langle>False\\<rangle>) = (\\<box> P)\"\n\n  \"(\\<^bold>\\<not>(P \\<U> Q)) \\<sigma> = (\\<^bold>\\<not>P \\<R> \\<^bold>\\<not>Q) \\<sigma>\"\n  \"(\\<langle>False\\<rangle> \\<U> P) = P\"\n  \"(P \\<U> \\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(P \\<U> \\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\"\n  \"(\\<langle>True\\<rangle> \\<U> P) = (\\<diamond> P)\"\n  \"(P \\<U> (P \\<U> Q)) = (P \\<U> Q)\"\n\n  \"(\\<^bold>\\<not>(P \\<R> Q)) \\<sigma> = (\\<^bold>\\<not>P \\<U> \\<^bold>\\<not>Q) \\<sigma>\"\n  \"(\\<langle>False\\<rangle> \\<R> P) = (\\<box>P)\"\n  \"(P \\<R> \\<langle>False\\<rangle>) = \\<langle>False\\<rangle>\"\n  \"(\\<langle>True\\<rangle> \\<R> P) = P\"\n  \"(P \\<R> \\<langle>True\\<rangle>) = \\<langle>True\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lceil>\\<lambda>s. False\\<rceil> = (\\<lambda>s. False) &&&\n       \\<lceil>\\<lambda>s. True\\<rceil> = (\\<lambda>s. True) &&&\n       (\\<lambda>s. \\<not> \\<lceil>p\\<rceil> s) =\n       \\<lceil>\\<lambda>s. \\<not> p s\\<rceil>) &&&\n      ((\\<lambda>s. \\<lceil>p\\<rceil> s \\<and> \\<lceil>q\\<rceil> s) =\n       \\<lceil>\\<lambda>s. p s \\<and> q s\\<rceil> &&&\n       (\\<lambda>s. \\<lceil>p\\<rceil> s \\<or> \\<lceil>q\\<rceil> s) =\n       \\<lceil>\\<lambda>s. p s \\<or> q s\\<rceil>) &&&\n      (\\<lambda>s.\n          \\<lceil>p\\<rceil> s \\<longrightarrow> \\<lceil>q\\<rceil> s) =\n      \\<lceil>\\<lambda>s. p s \\<longrightarrow> q s\\<rceil> &&&\n      (\\<lceil>p\\<rceil> \\<sigma> \\<and> \\<lceil>q\\<rceil> \\<sigma>) =\n      \\<lceil>\\<lambda>s. p s \\<and> q s\\<rceil> \\<sigma>) &&&\n     (((\\<lceil>p\\<rceil> \\<sigma> \\<or> \\<lceil>q\\<rceil> \\<sigma>) =\n       \\<lceil>\\<lambda>s. p s \\<or> q s\\<rceil> \\<sigma> &&&\n       (\\<lceil>p\\<rceil> \\<sigma> \\<longrightarrow>\n        \\<lceil>q\\<rceil> \\<sigma>) =\n       \\<lceil>\\<lambda>s. p s \\<longrightarrow> q s\\<rceil> \\<sigma>) &&&\n      \\<circle>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n      \\<circle>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n     (\\<box>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n      \\<box>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n     (\\<not> (\\<box>P) \\<sigma>) =\n     (\\<diamond>(\\<lambda>s. \\<not> P s)) \\<sigma> &&&\n     \\<box>\\<box>P = \\<box>P) &&&\n    (((\\<diamond>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n       \\<diamond>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n      (\\<lambda>s. \\<not> (\\<diamond>P) s) =\n      \\<box>(\\<lambda>s. \\<not> P s) &&&\n      \\<diamond>\\<diamond>P = \\<diamond>P) &&&\n     ((P \\<W> (\\<lambda>s. False)) = \\<box>P &&&\n      (\\<not> (P \\<U> Q) \\<sigma>) =\n      ((\\<lambda>s. \\<not> P s) \\<R> (\\<lambda>s. \\<not> Q s)) \\<sigma>) &&&\n     ((\\<lambda>s. False) \\<U> P) = P &&&\n     (P \\<U> (\\<lambda>s. False)) = (\\<lambda>s. False)) &&&\n    (((P \\<U> (\\<lambda>s. True)) = (\\<lambda>s. True) &&&\n      ((\\<lambda>s. True) \\<U> P) = \\<diamond>P) &&&\n     (P \\<U> P \\<U> Q) = (P \\<U> Q) &&&\n     (\\<not> (P \\<R> Q) \\<sigma>) =\n     ((\\<lambda>s. \\<not> P s) \\<U> (\\<lambda>s. \\<not> Q s)) \\<sigma>) &&&\n    (((\\<lambda>s. False) \\<R> P) = \\<box>P &&&\n     (P \\<R> (\\<lambda>s. False)) = (\\<lambda>s. False)) &&&\n    ((\\<lambda>s. True) \\<R> P) = P &&&\n    (P \\<R> (\\<lambda>s. True)) = (\\<lambda>s. True)", "(*\n  \"(P \\<U> (P \\<U> Q)) \\<sigma> = (P \\<U> Q) \\<sigma>\" FIXME for Release\n*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lceil>\\<lambda>s. False\\<rceil> = (\\<lambda>s. False) &&&\n       \\<lceil>\\<lambda>s. True\\<rceil> = (\\<lambda>s. True) &&&\n       (\\<lambda>s. \\<not> \\<lceil>p\\<rceil> s) =\n       \\<lceil>\\<lambda>s. \\<not> p s\\<rceil>) &&&\n      ((\\<lambda>s. \\<lceil>p\\<rceil> s \\<and> \\<lceil>q\\<rceil> s) =\n       \\<lceil>\\<lambda>s. p s \\<and> q s\\<rceil> &&&\n       (\\<lambda>s. \\<lceil>p\\<rceil> s \\<or> \\<lceil>q\\<rceil> s) =\n       \\<lceil>\\<lambda>s. p s \\<or> q s\\<rceil>) &&&\n      (\\<lambda>s.\n          \\<lceil>p\\<rceil> s \\<longrightarrow> \\<lceil>q\\<rceil> s) =\n      \\<lceil>\\<lambda>s. p s \\<longrightarrow> q s\\<rceil> &&&\n      (\\<lceil>p\\<rceil> \\<sigma> \\<and> \\<lceil>q\\<rceil> \\<sigma>) =\n      \\<lceil>\\<lambda>s. p s \\<and> q s\\<rceil> \\<sigma>) &&&\n     (((\\<lceil>p\\<rceil> \\<sigma> \\<or> \\<lceil>q\\<rceil> \\<sigma>) =\n       \\<lceil>\\<lambda>s. p s \\<or> q s\\<rceil> \\<sigma> &&&\n       (\\<lceil>p\\<rceil> \\<sigma> \\<longrightarrow>\n        \\<lceil>q\\<rceil> \\<sigma>) =\n       \\<lceil>\\<lambda>s. p s \\<longrightarrow> q s\\<rceil> \\<sigma>) &&&\n      \\<circle>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n      \\<circle>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n     (\\<box>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n      \\<box>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n     (\\<not> (\\<box>P) \\<sigma>) =\n     (\\<diamond>(\\<lambda>s. \\<not> P s)) \\<sigma> &&&\n     \\<box>\\<box>P = \\<box>P) &&&\n    (((\\<diamond>(\\<lambda>s. False) = (\\<lambda>s. False) &&&\n       \\<diamond>(\\<lambda>s. True) = (\\<lambda>s. True)) &&&\n      (\\<lambda>s. \\<not> (\\<diamond>P) s) =\n      \\<box>(\\<lambda>s. \\<not> P s) &&&\n      \\<diamond>\\<diamond>P = \\<diamond>P) &&&\n     ((P \\<W> (\\<lambda>s. False)) = \\<box>P &&&\n      (\\<not> (P \\<U> Q) \\<sigma>) =\n      ((\\<lambda>s. \\<not> P s) \\<R> (\\<lambda>s. \\<not> Q s)) \\<sigma>) &&&\n     ((\\<lambda>s. False) \\<U> P) = P &&&\n     (P \\<U> (\\<lambda>s. False)) = (\\<lambda>s. False)) &&&\n    (((P \\<U> (\\<lambda>s. True)) = (\\<lambda>s. True) &&&\n      ((\\<lambda>s. True) \\<U> P) = \\<diamond>P) &&&\n     (P \\<U> P \\<U> Q) = (P \\<U> Q) &&&\n     (\\<not> (P \\<R> Q) \\<sigma>) =\n     ((\\<lambda>s. \\<not> P s) \\<U> (\\<lambda>s. \\<not> Q s)) \\<sigma>) &&&\n    (((\\<lambda>s. False) \\<R> P) = \\<box>P &&&\n     (P \\<R> (\\<lambda>s. False)) = (\\<lambda>s. False)) &&&\n    ((\\<lambda>s. True) \\<R> P) = P &&&\n    (P \\<R> (\\<lambda>s. True)) = (\\<lambda>s. True)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<lambda>\\<sigma>. False) = (\\<lambda>s. False) &&&\n       (\\<lambda>\\<sigma>. True) = (\\<lambda>s. True) &&&\n       (\\<lambda>s. \\<not> p (s 0)) =\n       (\\<lambda>\\<sigma>. \\<not> p (\\<sigma> 0))) &&&\n      ((\\<lambda>s. p (s 0) \\<and> q (s 0)) =\n       (\\<lambda>\\<sigma>. p (\\<sigma> 0) \\<and> q (\\<sigma> 0)) &&&\n       (\\<lambda>s. p (s 0) \\<or> q (s 0)) =\n       (\\<lambda>\\<sigma>. p (\\<sigma> 0) \\<or> q (\\<sigma> 0))) &&&\n      (\\<lambda>s. p (s 0) \\<longrightarrow> q (s 0)) =\n      (\\<lambda>\\<sigma>.\n          p (\\<sigma> 0) \\<longrightarrow> q (\\<sigma> 0)) &&&\n      (p (\\<sigma> 0) \\<and> q (\\<sigma> 0)) =\n      (p (\\<sigma> 0) \\<and> q (\\<sigma> 0))) &&&\n     (((p (\\<sigma> 0) \\<or> q (\\<sigma> 0)) =\n       (p (\\<sigma> 0) \\<or> q (\\<sigma> 0)) &&&\n       (p (\\<sigma> 0) \\<longrightarrow> q (\\<sigma> 0)) =\n       (p (\\<sigma> 0) \\<longrightarrow> q (\\<sigma> 0))) &&&\n      (\\<lambda>\\<sigma>. False) = (\\<lambda>s. False) &&&\n      (\\<lambda>\\<sigma>. True) = (\\<lambda>s. True)) &&&\n     ((\\<lambda>\\<sigma>. \\<forall>i. False) = (\\<lambda>s. False) &&&\n      (\\<lambda>\\<sigma>. \\<forall>i. True) = (\\<lambda>s. True)) &&&\n     (\\<not> (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) =\n     (\\<exists>i.\n         \\<not> P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) &&&\n     (\\<lambda>\\<sigma>.\n         \\<forall>i ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) =\n     (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> |\\<^sub>s i))) &&&\n    ((((\\<lambda>\\<sigma>. \\<exists>i. False \\<and> (\\<forall>k<i. True)) =\n       (\\<lambda>s. False) &&&\n       (\\<lambda>\\<sigma>. \\<exists>i. True \\<and> (\\<forall>k<i. True)) =\n       (\\<lambda>s. True)) &&&\n      (\\<lambda>s.\n          \\<nexists>i. P (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n      (\\<lambda>\\<sigma>. \\<forall>i. \\<not> P (\\<sigma> |\\<^sub>s i)) &&&\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             (\\<exists>ia.\n                 P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                 (\\<forall>k<ia. True)) \\<and>\n             (\\<forall>k<i. True)) =\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True))) &&&\n     ((\\<lambda>s.\n          (\\<exists>i. False \\<and> (\\<forall>k<i. P (s |\\<^sub>s k))) \\<or>\n          (\\<forall>i. P (s |\\<^sub>s i))) =\n      (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> |\\<^sub>s i)) &&&\n      (\\<nexists>i.\n          Q (\\<sigma> |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n      (\\<nexists>i.\n          \\<not> \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. \\<not> \\<not> P (\\<sigma> |\\<^sub>s k)))) &&&\n     (\\<lambda>\\<sigma>.\n         \\<exists>i.\n            P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. False)) =\n     P &&&\n     (\\<lambda>\\<sigma>.\n         \\<exists>i.\n            False \\<and> (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n     (\\<lambda>s. False)) &&&\n    (((\\<lambda>\\<sigma>.\n          \\<exists>i.\n             True \\<and> (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n      (\\<lambda>s. True) &&&\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n      (\\<lambda>\\<sigma>.\n          \\<exists>i.\n             P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True))) &&&\n     (\\<lambda>\\<sigma>.\n         \\<exists>i.\n            (\\<exists>ia.\n                Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                (\\<forall>k<ia.\n                    P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<and>\n            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n     (\\<lambda>\\<sigma>.\n         \\<exists>i.\n            Q (\\<sigma> |\\<^sub>s i) \\<and>\n            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) &&&\n     (\\<not> (\\<nexists>i.\n                 \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n                 (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k)))) =\n     (\\<exists>i.\n         \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k)))) &&&\n    ((\\<lambda>s.\n         \\<nexists>i.\n            \\<not> P (s |\\<^sub>s i) \\<and> (\\<forall>k<i. \\<not> False)) =\n     (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> |\\<^sub>s i)) &&&\n     (\\<lambda>s.\n         \\<nexists>i.\n            \\<not> False \\<and> (\\<forall>k<i. \\<not> P (s |\\<^sub>s k))) =\n     (\\<lambda>s. False)) &&&\n    (\\<lambda>s.\n        \\<nexists>i.\n           \\<not> P (s |\\<^sub>s i) \\<and> (\\<forall>k<i. \\<not> True)) =\n    P &&&\n    (\\<lambda>s.\n        \\<nexists>i.\n           \\<not> True \\<and> (\\<forall>k<i. \\<not> P (s |\\<^sub>s k))) =\n    (\\<lambda>s. True)", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x i.\n       \\<forall>i ia. P (x |\\<^sub>s i + ia) \\<Longrightarrow>\n       P (x |\\<^sub>s i)\n 2. \\<And>x i.\n       P (x |\\<^sub>s i) \\<Longrightarrow>\n       \\<exists>i ia. P (x |\\<^sub>s i + ia)\n 3. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P x\n 4. \\<And>x.\n       P x \\<Longrightarrow>\n       \\<exists>i. P (x |\\<^sub>s i) \\<and> (\\<forall>k. \\<not> k < i)\n 5. \\<And>x i ia.\n       \\<lbrakk>\\<forall>k<i. P (x |\\<^sub>s k); Q (x |\\<^sub>s i + ia);\n        \\<forall>k<ia. P (x |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 6. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 7. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 8. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply (metis suffix_plus suffix_zero)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x i.\n       P (x |\\<^sub>s i) \\<Longrightarrow>\n       \\<exists>i ia. P (x |\\<^sub>s i + ia)\n 2. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P x\n 3. \\<And>x.\n       P x \\<Longrightarrow>\n       \\<exists>i. P (x |\\<^sub>s i) \\<and> (\\<forall>k. \\<not> k < i)\n 4. \\<And>x i ia.\n       \\<lbrakk>\\<forall>k<i. P (x |\\<^sub>s k); Q (x |\\<^sub>s i + ia);\n        \\<forall>k<ia. P (x |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 5. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 6. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 7. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply (metis suffix_plus suffix_zero)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<And>x.\n       P x \\<Longrightarrow>\n       \\<exists>i. P (x |\\<^sub>s i) \\<and> (\\<forall>k. \\<not> k < i)\n 3. \\<And>x i ia.\n       \\<lbrakk>\\<forall>k<i. P (x |\\<^sub>s k); Q (x |\\<^sub>s i + ia);\n        \\<forall>k<ia. P (x |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 4. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 5. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 6. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       P x \\<Longrightarrow>\n       \\<exists>i. P (x |\\<^sub>s i) \\<and> (\\<forall>k. \\<not> k < i)\n 2. \\<And>x i ia.\n       \\<lbrakk>\\<forall>k<i. P (x |\\<^sub>s k); Q (x |\\<^sub>s i + ia);\n        \\<forall>k<ia. P (x |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 3. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 4. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 5. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x i ia.\n       \\<lbrakk>\\<forall>k<i. P (x |\\<^sub>s k); Q (x |\\<^sub>s i + ia);\n        \\<forall>k<ia. P (x |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 2. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 3. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 4. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply (metis add.commute add_diff_inverse_nat less_diff_conv2 not_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>Q (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (\\<exists>ia.\n                                Q (x |\\<^sub>s i + ia) \\<and>\n                                (\\<forall>k<ia.\n                                    P (x |\\<^sub>s i + k))) \\<and>\n                            (\\<forall>k<i. P (x |\\<^sub>s k))\n 2. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 3. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply (metis add.right_neutral not_less0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>i.\n          P (x |\\<^sub>s i) \\<or> (\\<exists>k. k < i) \\<Longrightarrow>\n       P x\n 2. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>P x; \\<forall>k. \\<not> k < i\\<rbrakk>\n       \\<Longrightarrow> P (x |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma always_conj_distrib: \"(\\<box>(P \\<^bold>\\<and> Q)) = (\\<box>P \\<^bold>\\<and> \\<box>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>(\\<lambda>s. P s \\<and> Q s) =\n    (\\<lambda>s. (\\<box>P) s \\<and> (\\<box>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<forall>i.\n           P (\\<sigma> |\\<^sub>s i) \\<and> Q (\\<sigma> |\\<^sub>s i)) =\n    (\\<lambda>s.\n        (\\<forall>i. P (s |\\<^sub>s i)) \\<and>\n        (\\<forall>i. Q (s |\\<^sub>s i)))", "by auto"], ["", "lemma eventually_disj_distrib: \"(\\<diamond>(P \\<^bold>\\<or> Q)) = (\\<diamond>P \\<^bold>\\<or> \\<diamond>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>(\\<lambda>s. P s \\<or> Q s) =\n    (\\<lambda>s. (\\<diamond>P) s \\<or> (\\<diamond>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (P (\\<sigma> |\\<^sub>s i) \\<or> Q (\\<sigma> |\\<^sub>s i)) \\<and>\n           (\\<forall>k<i. True)) =\n    (\\<lambda>s.\n        (\\<exists>i. P (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) \\<or>\n        (\\<exists>i. Q (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))", "by auto"], ["", "lemma always_eventually[elim!]:\n  assumes \"(\\<box>P) \\<sigma>\"\n  shows \"(\\<diamond>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>P) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>P) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)", "by auto"], ["", "lemma eventually_imp_conv_disj: \"(\\<diamond>(P \\<^bold>\\<longrightarrow> Q)) = (\\<diamond>(\\<^bold>\\<not>P) \\<^bold>\\<or> \\<diamond>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>(\\<lambda>s. P s \\<longrightarrow> Q s) =\n    (\\<lambda>s.\n        (\\<diamond>(\\<lambda>s. \\<not> P s)) s \\<or> (\\<diamond>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n            Q (\\<sigma> |\\<^sub>s i)) \\<and>\n           (\\<forall>k<i. True)) =\n    (\\<lambda>s.\n        (\\<exists>i.\n            \\<not> P (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) \\<or>\n        (\\<exists>i. Q (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))", "by auto"], ["", "lemma eventually_imp_distrib:\n  \"(\\<diamond>(P \\<^bold>\\<longrightarrow> Q)) = (\\<box>P \\<^bold>\\<longrightarrow> \\<diamond>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>(\\<lambda>s. P s \\<longrightarrow> Q s) =\n    (\\<lambda>s. (\\<box>P) s \\<longrightarrow> (\\<diamond>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n            Q (\\<sigma> |\\<^sub>s i)) \\<and>\n           (\\<forall>k<i. True)) =\n    (\\<lambda>s.\n        (\\<forall>i. P (s |\\<^sub>s i)) \\<longrightarrow>\n        (\\<exists>i. Q (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))", "by auto"], ["", "lemma unfold:\n  \"(\\<box> P) \\<sigma> = (P \\<^bold>\\<and> \\<circle>\\<box>P) \\<sigma>\"\n  \"(\\<diamond> P) \\<sigma> = (P \\<^bold>\\<or> \\<circle>\\<diamond>P) \\<sigma>\"\n  \"(P \\<W> Q) \\<sigma> = (Q \\<^bold>\\<or> (P \\<^bold>\\<and> \\<circle>(P \\<W> Q))) \\<sigma>\"\n  \"(P \\<U> Q) \\<sigma> = (Q \\<^bold>\\<or> (P \\<^bold>\\<and> \\<circle>(P \\<U> Q))) \\<sigma>\"\n  \"(P \\<R> Q) \\<sigma> = (Q \\<^bold>\\<and> (P \\<^bold>\\<or> \\<circle>(P \\<R> Q))) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<box>P) \\<sigma> =\n     (P \\<sigma> \\<and> (\\<circle>\\<box>P) \\<sigma>) &&&\n     (\\<diamond>P) \\<sigma> =\n     (P \\<sigma> \\<or> (\\<circle>\\<diamond>P) \\<sigma>)) &&&\n    (P \\<W> Q) \\<sigma> =\n    (Q \\<sigma> \\<or> P \\<sigma> \\<and> (\\<circle>(P \\<W> Q)) \\<sigma>) &&&\n    (P \\<U> Q) \\<sigma> =\n    (Q \\<sigma> \\<or> P \\<sigma> \\<and> (\\<circle>(P \\<U> Q)) \\<sigma>) &&&\n    (P \\<R> Q) \\<sigma> =\n    (Q \\<sigma> \\<and> (P \\<sigma> \\<or> (\\<circle>(P \\<R> Q)) \\<sigma>))", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i. P (\\<sigma> |\\<^sub>s i)) =\n     (P \\<sigma> \\<and>\n      (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i))) &&&\n     (\\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n     (P \\<sigma> \\<or>\n      (\\<exists>i.\n          P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. True)))) &&&\n    ((\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     ((\\<exists>i.\n          Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))) \\<or>\n      (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i)))) &&&\n    (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     (\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k)))) &&&\n    (\\<nexists>i.\n        \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<and>\n     (P \\<sigma> \\<or>\n      (\\<nexists>i.\n          \\<not> Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k)))))", "apply -"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<forall>i. P (\\<sigma> |\\<^sub>s i)) =\n    (P \\<sigma> \\<and> (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i)))\n 2. (\\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n    (P \\<sigma> \\<or>\n     (\\<exists>i.\n         P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))\n 3. ((\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     ((\\<exists>i.\n          Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))) \\<or>\n      (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i))))\n 4. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     (\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))))\n 5. (\\<nexists>i.\n        \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<and>\n     (P \\<sigma> \\<or>\n      (\\<nexists>i.\n          \\<not> Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k)))))", "apply (metis (full_types) add.commute add_diff_inverse_nat less_one suffix_plus suffix_zero)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n    (P \\<sigma> \\<or>\n     (\\<exists>i.\n         P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))\n 2. ((\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     ((\\<exists>i.\n          Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))) \\<or>\n      (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i))))\n 3. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     (\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))))\n 4. (\\<nexists>i.\n        \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<and>\n     (P \\<sigma> \\<or>\n      (\\<nexists>i.\n          \\<not> Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k)))))", "apply (metis (full_types) One_nat_def add.right_neutral add_Suc_right lessI less_Suc_eq_0_disj suffix_plus suffix_zero)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n     (\\<forall>i. P (\\<sigma> |\\<^sub>s i))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     ((\\<exists>i.\n          Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))) \\<or>\n      (\\<forall>i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i))))\n 2. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<or>\n     P \\<sigma> \\<and>\n     (\\<exists>i.\n         Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n         (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))))\n 3. (\\<nexists>i.\n        \\<not> Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k))) =\n    (Q \\<sigma> \\<and>\n     (P \\<sigma> \\<or>\n      (\\<nexists>i.\n          \\<not> Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n          (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k)))))", "apply auto"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>i ia.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>;\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<longrightarrow>\n           (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s Suc ia)\n 3. \\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n     \\<not> Q \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>\n 4. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 5. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 6. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 7. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 8. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 9. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 10. \\<And>i.\n        \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n         \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>i.\n                             Q (\\<sigma> |\\<^sub>s i) \\<and>\n                             (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\nA total of 14 subgoals...", "apply fastforce"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>;\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<longrightarrow>\n           (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s Suc ia)\n 2. \\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n     \\<not> Q \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 4. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 5. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 6. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 7. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 8. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 9. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 10. \\<forall>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<or>\n        (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n     Q \\<sigma>\nA total of 13 subgoals...", "apply (metis gr0_conv_Suc nat_neq_iff not_less_eq suffix_zero)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n     \\<not> Q \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 4. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 5. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 6. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 7. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 8. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 9. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 10. \\<And>i.\n        \\<lbrakk>\\<forall>i.\n                    Q (\\<sigma> |\\<^sub>s i) \\<or>\n                    (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n         \\<not> P \\<sigma>;\n         \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n        \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\nA total of 12 subgoals...", "apply (metis suffix_zero)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 4. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 6. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 7. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 8. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 9. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 10. \\<And>i.\n        \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n         P \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\nA total of 11 subgoals...", "apply force"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 4. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 5. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 6. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 7. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 8. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 9. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 10. \\<And>i.\n        \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n         \\<forall>i.\n            Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n            (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n        \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (10 subgoals):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc ia);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 4. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 5. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 6. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 7. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 8. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 9. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 10. \\<And>i.\n        \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n         \\<forall>i.\n            Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n            (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n        \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i. \\<not> P (\\<sigma> |\\<^sub>s k));\n        P \\<sigma>; \\<forall>i. P (\\<sigma> |\\<^sub>s Suc i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 3. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 4. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 5. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 6. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 7. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 8. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 9. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply (metis gr0_conv_Suc nat_neq_iff not_less0 suffix_zero)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 3. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 4. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 5. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 6. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 7. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 8. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s k); \\<not> Q \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s Suc i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k))\n 2. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 3. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 4. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 5. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 6. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 7. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply (case_tac i; auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. Q \\<sigma> \\<Longrightarrow>\n    \\<exists>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 2. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 3. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 4. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 5. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 6. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply force"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 2. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 4. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 5. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (5 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>P \\<sigma>; Q (\\<sigma> |\\<^sub>s Suc i);\n        \\<forall>k<i. P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            Q (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n 2. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 4. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 5. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i.\n       Q (\\<sigma> |\\<^sub>s i) \\<or>\n       (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k)) \\<Longrightarrow>\n    Q \\<sigma>\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 3. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 4. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 2. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   Q (\\<sigma> |\\<^sub>s i) \\<or>\n                   (\\<exists>k<i. P (\\<sigma> |\\<^sub>s k));\n        \\<not> P \\<sigma>;\n        \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s Suc i)\n 2. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>Q \\<sigma>; \\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i.\n           Q (\\<sigma> |\\<^sub>s Suc i) \\<or>\n           (\\<exists>k<i. P (\\<sigma> |\\<^sub>s Suc k))\\<rbrakk>\n       \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s i)", "apply (case_tac i; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mono:\n  \"\\<lbrakk>(\\<box>P) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow>  P' \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<box>P') \\<sigma>\"\n  \"\\<lbrakk>(\\<diamond>P) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow>  P' \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<diamond>P') \\<sigma>\"\n  \"\\<lbrakk>(P \\<U> Q) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<U> Q') \\<sigma>\"\n  \"\\<lbrakk>(P \\<W> Q) \\<sigma>; \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>; \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<W> Q') \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>(\\<box>P) \\<sigma>;\n       \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> (\\<box>P') \\<sigma>) &&&\n     (\\<lbrakk>(\\<diamond>P) \\<sigma>;\n       \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> (\\<diamond>P') \\<sigma>)) &&&\n    (\\<lbrakk>(P \\<U> Q) \\<sigma>;\n      \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P' \\<U> Q') \\<sigma>) &&&\n    (\\<lbrakk>(P \\<W> Q) \\<sigma>;\n      \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P' \\<W> Q') \\<sigma>)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n       \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> \\<forall>i. P' (\\<sigma> |\\<^sub>s i)) &&&\n     (\\<lbrakk>\\<exists>i.\n                  P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True);\n       \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> \\<exists>i.\n                           P' (\\<sigma> |\\<^sub>s i) \\<and>\n                           (\\<forall>k<i. True))) &&&\n    (\\<lbrakk>\\<exists>i.\n                 Q (\\<sigma> |\\<^sub>s i) \\<and>\n                 (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k));\n      \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>i.\n                          Q' (\\<sigma> |\\<^sub>s i) \\<and>\n                          (\\<forall>k<i. P' (\\<sigma> |\\<^sub>s k))) &&&\n    (\\<lbrakk>(\\<exists>i.\n                  Q (\\<sigma> |\\<^sub>s i) \\<and>\n                  (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n              (\\<forall>i. P (\\<sigma> |\\<^sub>s i));\n      \\<And>\\<sigma>. P \\<sigma> \\<Longrightarrow> P' \\<sigma>;\n      \\<And>\\<sigma>. Q \\<sigma> \\<Longrightarrow> Q' \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>i.\n                           Q' (\\<sigma> |\\<^sub>s i) \\<and>\n                           (\\<forall>k<i. P' (\\<sigma> |\\<^sub>s k))) \\<or>\n                       (\\<forall>i. P' (\\<sigma> |\\<^sub>s i)))", "by force+"], ["", "lemma always_imp_mono:\n  \"\\<lbrakk>(\\<box>P) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<box>P') \\<sigma>\"\n  \"\\<lbrakk>(\\<diamond>P) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>\\<rbrakk> \\<Longrightarrow> (\\<diamond>P') \\<sigma>\"\n  \"\\<lbrakk>(P \\<U> Q) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>; (Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<U> Q') \\<sigma>\"\n  \"\\<lbrakk>(P \\<W> Q) \\<sigma>; (P \\<^bold>\\<hookrightarrow> P') \\<sigma>; (Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\\<rbrakk> \\<Longrightarrow> (P' \\<W> Q') \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>(\\<box>P) \\<sigma>;\n       (\\<box>(\\<lambda>s. P s \\<longrightarrow> P' s)) \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> (\\<box>P') \\<sigma>) &&&\n     (\\<lbrakk>(\\<diamond>P) \\<sigma>;\n       (\\<box>(\\<lambda>s. P s \\<longrightarrow> P' s)) \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> (\\<diamond>P') \\<sigma>)) &&&\n    (\\<lbrakk>(P \\<U> Q) \\<sigma>;\n      (\\<box>(\\<lambda>s. P s \\<longrightarrow> P' s)) \\<sigma>;\n      (\\<box>(\\<lambda>s. Q s \\<longrightarrow> Q' s)) \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P' \\<U> Q') \\<sigma>) &&&\n    (\\<lbrakk>(P \\<W> Q) \\<sigma>;\n      (\\<box>(\\<lambda>s. P s \\<longrightarrow> P' s)) \\<sigma>;\n      (\\<box>(\\<lambda>s. Q s \\<longrightarrow> Q' s)) \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> (P' \\<W> Q') \\<sigma>)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<forall>i. P (\\<sigma> |\\<^sub>s i);\n       \\<forall>i.\n          P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n          P' (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>i. P' (\\<sigma> |\\<^sub>s i)) &&&\n     (\\<lbrakk>\\<exists>i.\n                  P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True);\n       \\<forall>i.\n          P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n          P' (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n      \\<Longrightarrow> \\<exists>i.\n                           P' (\\<sigma> |\\<^sub>s i) \\<and>\n                           (\\<forall>k<i. True))) &&&\n    (\\<lbrakk>\\<exists>i.\n                 Q (\\<sigma> |\\<^sub>s i) \\<and>\n                 (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k));\n      \\<forall>i.\n         P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n         P' (\\<sigma> |\\<^sub>s i);\n      \\<forall>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n         Q' (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>i.\n                          Q' (\\<sigma> |\\<^sub>s i) \\<and>\n                          (\\<forall>k<i. P' (\\<sigma> |\\<^sub>s k))) &&&\n    (\\<lbrakk>(\\<exists>i.\n                  Q (\\<sigma> |\\<^sub>s i) \\<and>\n                  (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n              (\\<forall>i. P (\\<sigma> |\\<^sub>s i));\n      \\<forall>i.\n         P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n         P' (\\<sigma> |\\<^sub>s i);\n      \\<forall>i.\n         Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n         Q' (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>i.\n                           Q' (\\<sigma> |\\<^sub>s i) \\<and>\n                           (\\<forall>k<i. P' (\\<sigma> |\\<^sub>s k))) \\<or>\n                       (\\<forall>i. P' (\\<sigma> |\\<^sub>s i)))", "by force+"], ["", "lemma next_conj_distrib:\n  \"(\\<circle>(P \\<^bold>\\<and> Q)) = (\\<circle>P \\<^bold>\\<and> \\<circle>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<circle>(\\<lambda>s. P s \\<and> Q s) =\n    (\\<lambda>s. (\\<circle>P) s \\<and> (\\<circle>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        P (\\<sigma> |\\<^sub>s 1) \\<and> Q (\\<sigma> |\\<^sub>s 1)) =\n    (\\<lambda>s. P (s |\\<^sub>s 1) \\<and> Q (s |\\<^sub>s 1))", "by auto"], ["", "lemma next_disj_distrib:\n  \"(\\<circle>(P \\<^bold>\\<or> Q)) = (\\<circle>P \\<^bold>\\<or> \\<circle>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<circle>(\\<lambda>s. P s \\<or> Q s) =\n    (\\<lambda>s. (\\<circle>P) s \\<or> (\\<circle>Q) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        P (\\<sigma> |\\<^sub>s 1) \\<or> Q (\\<sigma> |\\<^sub>s 1)) =\n    (\\<lambda>s. P (s |\\<^sub>s 1) \\<or> Q (s |\\<^sub>s 1))", "by auto"], ["", "lemma until_next_distrib:\n  \"(\\<circle>(P \\<U> Q)) = (\\<circle>P \\<U> \\<circle>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<circle>(P \\<U> Q) = (\\<circle>P \\<U> \\<circle>Q)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           Q (\\<sigma> |\\<^sub>s 1 |\\<^sub>s i) \\<and>\n           (\\<forall>k<i. P (\\<sigma> |\\<^sub>s 1 |\\<^sub>s k))) =\n    (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           Q (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<and>\n           (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k |\\<^sub>s 1)))", "by (auto simp: fun_eq_iff)"], ["", "lemma until_imp_eventually:\n  \"((P \\<U> Q) \\<^bold>\\<longrightarrow> \\<diamond>Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<U> Q) \\<sigma> \\<longrightarrow> (\\<diamond>Q) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<longrightarrow>\n    (\\<exists>i. Q (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True))", "by auto"], ["", "lemma until_until_disj:\n  assumes \"(P \\<U> Q \\<U> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<U> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<or> Q s) \\<U> R) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (P \\<U> Q \\<U> R) \\<sigma>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<or> Q s) \\<U> R) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<and>\n     (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       R (\\<sigma> |\\<^sub>s i) \\<and>\n       (\\<forall>k<i.\n           P (\\<sigma> |\\<^sub>s k) \\<or> Q (\\<sigma> |\\<^sub>s k))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>k<i. P (\\<sigma> |\\<^sub>s k);\n        R (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            R (\\<sigma> |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i.\n                                P (\\<sigma> |\\<^sub>s k) \\<or>\n                                Q (\\<sigma> |\\<^sub>s k))", "apply (metis (full_types) add_diff_inverse_nat nat_add_left_cancel_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unless_unless_disj:\n  assumes \"(P \\<W> Q \\<W> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<W> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<or> Q s) \\<W> R) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (P \\<W> Q \\<W> R) \\<sigma>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<or> Q s) \\<W> R) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  (\\<exists>i.\n      ((\\<exists>ia.\n           R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<or>\n       (\\<forall>ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia))) \\<and>\n      (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n  (\\<forall>i. P (\\<sigma> |\\<^sub>s i))\n\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        R (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i.\n            P (\\<sigma> |\\<^sub>s k) \\<or> Q (\\<sigma> |\\<^sub>s k))) \\<or>\n    (\\<forall>i. P (\\<sigma> |\\<^sub>s i) \\<or> Q (\\<sigma> |\\<^sub>s i))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i ia ib.\n       \\<lbrakk>\\<forall>i.\n                   R (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i.\n                       \\<not> P (\\<sigma> |\\<^sub>s k) \\<and>\n                       \\<not> Q (\\<sigma> |\\<^sub>s k));\n        \\<not> Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s k);\n        R (\\<sigma> |\\<^sub>s ia + ib);\n        \\<forall>k<ib. Q (\\<sigma> |\\<^sub>s ia + k)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   R (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i.\n                       \\<not> P (\\<sigma> |\\<^sub>s k) \\<and>\n                       \\<not> Q (\\<sigma> |\\<^sub>s k));\n        \\<not> Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i. Q (\\<sigma> |\\<^sub>s ia + i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)", "apply (metis add.commute add_diff_inverse_nat leI less_diff_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   R (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>k<i.\n                       \\<not> P (\\<sigma> |\\<^sub>s k) \\<and>\n                       \\<not> Q (\\<sigma> |\\<^sub>s k));\n        \\<not> Q (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<ia. P (\\<sigma> |\\<^sub>s k);\n        \\<forall>i. Q (\\<sigma> |\\<^sub>s ia + i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i)", "apply (metis add_diff_inverse_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma until_conj_distrib:\n  \"((P \\<^bold>\\<and> Q) \\<U> R) = ((P \\<U> R) \\<^bold>\\<and> (Q \\<U> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<and> Q s) \\<U> R) =\n    (\\<lambda>s. (P \\<U> R) s \\<and> (Q \\<U> R) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           R (\\<sigma> |\\<^sub>s i) \\<and>\n           (\\<forall>k<i.\n               P (\\<sigma> |\\<^sub>s k) \\<and> Q (\\<sigma> |\\<^sub>s k))) =\n    (\\<lambda>s.\n        (\\<exists>i.\n            R (s |\\<^sub>s i) \\<and>\n            (\\<forall>k<i. P (s |\\<^sub>s k))) \\<and>\n        (\\<exists>i.\n            R (s |\\<^sub>s i) \\<and> (\\<forall>k<i. Q (s |\\<^sub>s k))))", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i ia.\n       \\<lbrakk>R (x |\\<^sub>s i); \\<forall>k<i. P (x |\\<^sub>s k);\n        R (x |\\<^sub>s ia); \\<forall>k<ia. Q (x |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            R (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i.\n                                P (x |\\<^sub>s k) \\<and> Q (x |\\<^sub>s k))", "apply (metis dual_order.strict_trans nat_neq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma until_disj_distrib:\n  \"(P \\<U> (Q \\<^bold>\\<or> R)) = ((P \\<U> Q) \\<^bold>\\<or> (P \\<U> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<U> (\\<lambda>s. Q s \\<or> R s)) =\n    (\\<lambda>s. (P \\<U> Q) s \\<or> (P \\<U> R) s)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (Q (\\<sigma> |\\<^sub>s i) \\<or> R (\\<sigma> |\\<^sub>s i)) \\<and>\n           (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) =\n    (\\<lambda>s.\n        (\\<exists>i.\n            Q (s |\\<^sub>s i) \\<and>\n            (\\<forall>k<i. P (s |\\<^sub>s k))) \\<or>\n        (\\<exists>i.\n            R (s |\\<^sub>s i) \\<and> (\\<forall>k<i. P (s |\\<^sub>s k))))", "by (auto simp: fun_eq_iff)"], ["", "lemma eventually_until:\n  \"(\\<diamond>P) = (\\<^bold>\\<not>P \\<U> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>P = ((\\<lambda>s. \\<not> P s) \\<U> P)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)) =\n    (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           P (\\<sigma> |\\<^sub>s i) \\<and>\n           (\\<forall>k<i. \\<not> P (\\<sigma> |\\<^sub>s k)))", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       P (x |\\<^sub>s i) \\<Longrightarrow>\n       \\<exists>i.\n          P (x |\\<^sub>s i) \\<and> (\\<forall>k<i. \\<not> P (x |\\<^sub>s k))", "apply (case_tac \"P (x |\\<^sub>s 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); P (x |\\<^sub>s 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            P (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. \\<not> P (x |\\<^sub>s k))\n 2. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); \\<not> P (x |\\<^sub>s 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            P (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. \\<not> P (x |\\<^sub>s k))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>P (x |\\<^sub>s i); \\<not> P (x |\\<^sub>s 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            P (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. \\<not> P (x |\\<^sub>s k))", "apply (drule (1) ex_least_nat_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<not> P (x |\\<^sub>s 0);\n        \\<exists>k<i.\n           (\\<forall>i\\<le>k. \\<not> P (x |\\<^sub>s i)) \\<and>\n           P (x |\\<^sub>s Suc k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            P (x |\\<^sub>s i) \\<and>\n                            (\\<forall>k<i. \\<not> P (x |\\<^sub>s k))", "apply (metis le_simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eventually_until_eventually:\n  \"(\\<diamond>(P \\<U> Q)) = (\\<diamond>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>(P \\<U> Q) = \\<diamond>Q", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (\\<exists>ia.\n               Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n               (\\<forall>k<ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<and>\n           (\\<forall>k<i. True)) =\n    (\\<lambda>\\<sigma>.\n        \\<exists>i. Q (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True))", "by force"], ["", "lemma eventually_unless_until:\n  \"((P \\<W> Q) \\<^bold>\\<and> \\<diamond>Q) = (P \\<U> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. (P \\<W> Q) s \\<and> (\\<diamond>Q) s) = (P \\<U> Q)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        ((\\<exists>i.\n             Q (s |\\<^sub>s i) \\<and>\n             (\\<forall>k<i. P (s |\\<^sub>s k))) \\<or>\n         (\\<forall>i. P (s |\\<^sub>s i))) \\<and>\n        (\\<exists>i. Q (s |\\<^sub>s i) \\<and> (\\<forall>k<i. True))) =\n    (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           Q (\\<sigma> |\\<^sub>s i) \\<and>\n           (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k)))", "by force"], ["", "lemma eventually_always_imp_always_eventually:\n  assumes \"(\\<diamond>\\<box>P) \\<sigma>\"\n  shows \"(\\<box>\\<diamond>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>\\<diamond>P) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<diamond>\\<box>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>\\<diamond>P) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     (\\<forall>ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n     (\\<forall>k<i. True)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>ia.\n          P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True)", "by (metis suffix_commute)"], ["", "lemma eventually_always_next_stable:\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>P) \\<sigma>\"\n  shows \"(\\<diamond>\\<box>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>\\<box>P) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<diamond>P) \\<sigma>\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<circle>P) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>\\<box>P) \\<sigma>", "by (metis (no_types) eventuallyI alwaysD always_induct eventuallyE norm(15))"], ["", "lemma next_stable_imp_eventually_always:\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>P) \\<sigma>\"\n  shows \"(\\<diamond>P \\<^bold>\\<longrightarrow> \\<diamond>\\<box>P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>P) \\<sigma> \\<longrightarrow> (\\<diamond>\\<box>P) \\<sigma>", "using assms eventually_always_next_stable"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<circle>P) s)) \\<sigma>\n  \\<lbrakk>(\\<diamond>?P) ?\\<sigma>;\n   (\\<box>(\\<lambda>s. ?P s \\<longrightarrow> (\\<circle>?P) s))\n    ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> (\\<diamond>\\<box>?P) ?\\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>P) \\<sigma> \\<longrightarrow> (\\<diamond>\\<box>P) \\<sigma>", "by blast"], ["", "lemma always_eventually_always:\n  \"\\<diamond>\\<box>\\<diamond>P = \\<box>\\<diamond>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>\\<box>\\<diamond>P = \\<box>\\<diamond>P", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<exists>i.\n           (\\<forall>ia.\n               \\<exists>ib.\n                  P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<and>\n                  (\\<forall>k<ib. True)) \\<and>\n           (\\<forall>k<i. True)) =\n    (\\<lambda>\\<sigma>.\n        \\<forall>i.\n           \\<exists>ia.\n              P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n              (\\<forall>k<ia. True))", "by (clarsimp simp: fun_eq_iff) (metis add.left_commute semiring_normalization_rules(25))"], ["", "(* FIXME define \"stable\", develop more rules for it *)"], ["", "lemma stable_unless:\n  assumes \"(P \\<^bold>\\<hookrightarrow> \\<circle>(P \\<^bold>\\<or> Q)) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> (P \\<W> Q)) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (P \\<W> Q) s)) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             P s \\<longrightarrow>\n             (\\<circle>(\\<lambda>s. P s \\<or> Q s)) s))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (P \\<W> Q) s)) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     P (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n     Q (\\<sigma> |\\<^sub>s i |\\<^sub>s 1)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<or>\n       (\\<forall>ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       P (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n       Q (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<Longrightarrow>\n    \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<or>\n       (\\<forall>ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia))", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                P (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n                Q (\\<sigma> |\\<^sub>s i |\\<^sub>s 1);\n     \\<not> (\\<forall>i.\n                P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                (\\<exists>ia.\n                    Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                    (\\<forall>k<ia.\n                        P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))) \\<or>\n                (\\<forall>ia.\n                    P (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   P (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   Q (\\<sigma> |\\<^sub>s Suc i);\n        P (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia.\n           Q (\\<sigma> |\\<^sub>s i + ia) \\<longrightarrow>\n           (\\<exists>k<ia. \\<not> P (\\<sigma> |\\<^sub>s i + k));\n        \\<not> P (\\<sigma> |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) ex_least_nat_less[where P=\"\\<lambda>j. \\<not>P (\\<sigma> |\\<^sub>s i + j)\" for i, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   P (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   Q (\\<sigma> |\\<^sub>s Suc i);\n        P (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia.\n           Q (\\<sigma> |\\<^sub>s i + ia) \\<longrightarrow>\n           (\\<exists>k<ia. \\<not> P (\\<sigma> |\\<^sub>s i + k));\n        \\<exists>k<ia.\n           (\\<forall>ia\\<le>k. P (\\<sigma> |\\<^sub>s i + ia)) \\<and>\n           \\<not> P (\\<sigma> |\\<^sub>s Suc (i + k))\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia k.\n       \\<lbrakk>\\<forall>i.\n                   P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   P (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   Q (\\<sigma> |\\<^sub>s Suc i);\n        P (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia.\n           Q (\\<sigma> |\\<^sub>s i + ia) \\<longrightarrow>\n           (\\<exists>k<ia. \\<not> P (\\<sigma> |\\<^sub>s i + k));\n        k < ia; \\<forall>ia\\<le>k. P (\\<sigma> |\\<^sub>s i + ia);\n        \\<not> P (\\<sigma> |\\<^sub>s Suc (i + k))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis add_Suc_right le_less less_Suc_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unless_induct: \\<comment>\\<open> Rule \\texttt{WAIT} from @{cite [cite_macro=citet] \\<open>Fig~3.3\\<close> \"MannaPnueli:1995\"}\\<close>\n  assumes I: \"(I \\<^bold>\\<hookrightarrow> \\<circle>(I \\<^bold>\\<or> R)) \\<sigma>\"\n  assumes P: \"(P \\<^bold>\\<hookrightarrow> I \\<^bold>\\<or> R) \\<sigma>\"\n  assumes Q: \"(I \\<^bold>\\<hookrightarrow> Q) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> Q \\<W> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (Q \\<W> R) s)) \\<sigma>", "apply (intro alwaysI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       P (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (erule impE[OF alwaysD[OF P]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<or>\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (rule always_imp_mono(4)[where P=I and Q=R])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (I \\<W> R) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (\\<box>(\\<lambda>s. I s \\<longrightarrow> Q s))\n        (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (\\<box>(\\<lambda>s. R s \\<longrightarrow> R s))\n        (\\<sigma> |\\<^sub>s i)\n 4. \\<And>i.\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (erule mp[OF alwaysD[OF stable_unless[OF I]]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (\\<box>(\\<lambda>s. I s \\<longrightarrow> Q s))\n        (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (\\<box>(\\<lambda>s. R s \\<longrightarrow> R s))\n        (\\<sigma> |\\<^sub>s i)\n 3. \\<And>i.\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (simp add: Q alwaysD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       I (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (\\<box>(\\<lambda>s. R s \\<longrightarrow> R s))\n        (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       R (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (Q \\<W> R) (\\<sigma> |\\<^sub>s i)", "apply (simp add: unfold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> Leads-to and leads-to-via \\label{sec:leads-to} \\<close>"], ["", "text\\<open>\n\nMost of our assertions will be of the form @{term \"A \\<^bold>\\<longrightarrow> \\<diamond>C\"} (pronounced ``\\<open>A\\<close> leads to \\<open>C\\<close>'')\nor @{term \"A \\<^bold>\\<longrightarrow> B \\<U> C\"} (``\\<open>A\\<close> leads to \\<open>C\\<close> via \\<open>B\\<close>'').\n\nMost of these rules are due to @{cite [cite_macro=citet]\n\"Jackson:1998\"} who used leads-to-via in a sequential setting. Others\nare due to @{cite [cite_macro=citet] \"MannaPnueli:1991\"}.\n\nThe leads-to-via connective is similar to the ``ensures'' modality of @{cite [cite_macro=citet] \\<open>\\S3.4.4\\<close> \"ChandyMisra:1989\"}.\n\n\\<close>"], ["", "abbreviation (input)\n  leads_to :: \"'a seq_pred \\<Rightarrow> 'a seq_pred \\<Rightarrow> 'a seq_pred\" (infixr \"\\<^bold>\\<leadsto>\" 25) where (* FIXME priority *)\n  \"P \\<^bold>\\<leadsto> Q \\<equiv> P \\<^bold>\\<hookrightarrow> \\<diamond>Q\""], ["", "lemma leads_to_refl:\n  shows \"(P \\<^bold>\\<leadsto> P) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>P) s)) \\<sigma>", "by (metis (no_types, lifting) necessitation(1) unfold(2))"], ["", "lemma leads_to_trans:\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<leadsto> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<leadsto> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>R) s)) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. Q s \\<longrightarrow> (\\<diamond>R) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>R) s)) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n  \\<forall>i.\n     Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "by clarsimp (metis semiring_normalization_rules(25))"], ["", "lemma leads_to_eventuallyE:\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  assumes \"(\\<diamond>P) \\<sigma>\"\n  shows \"(\\<diamond>Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>Q) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>\n  (\\<diamond>P) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>Q) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n  \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)\n\ngoal (1 subgoal):\n 1. \\<exists>i. Q (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)", "by auto"], ["", "lemma leads_to_mono:\n  assumes \"(P' \\<^bold>\\<hookrightarrow> P) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<hookrightarrow> Q') \\<sigma>\"\n  assumes \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\"\n  shows \"(P' \\<^bold>\\<leadsto> Q') \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P' s \\<longrightarrow> (\\<diamond>Q') s)) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P' s \\<longrightarrow> P s)) \\<sigma>\n  (\\<box>(\\<lambda>s. Q s \\<longrightarrow> Q' s)) \\<sigma>\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P' s \\<longrightarrow> (\\<diamond>Q') s)) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P' (\\<sigma> |\\<^sub>s i) \\<longrightarrow> P (\\<sigma> |\\<^sub>s i)\n  \\<forall>i.\n     Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow> Q' (\\<sigma> |\\<^sub>s i)\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P' (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           Q' (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "by clarsimp blast"], ["", "lemma leads_to_eventually:\n  shows \"(P \\<^bold>\\<leadsto> Q \\<^bold>\\<longrightarrow> \\<diamond>P \\<^bold>\\<longrightarrow> \\<diamond>Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               P s \\<longrightarrow>\n               (\\<diamond>(\\<lambda>s.\n                              Q s \\<longrightarrow>\n                              (\\<diamond>P) s \\<longrightarrow>\n                              (\\<diamond>Q) s))\n                s))\n     \\<sigma>", "by (metis (no_types, lifting) alwaysI unfold(2))"], ["", "lemma leads_to_disj:\n  assumes \"(P \\<^bold>\\<leadsto> R) \\<sigma>\"\n  assumes \"(Q \\<^bold>\\<leadsto> R) \\<sigma>\"\n  shows \"((P \\<^bold>\\<or> Q) \\<^bold>\\<leadsto> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<or> Q s \\<longrightarrow> (\\<diamond>R) s))\n     \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>R) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. Q s \\<longrightarrow> (\\<diamond>R) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<or> Q s \\<longrightarrow> (\\<diamond>R) s))\n     \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n  \\<forall>i.\n     Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<or>\n       Q (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "by simp"], ["", "lemma leads_to_leads_to_viaE:\n  shows \"((P \\<^bold>\\<hookrightarrow> P \\<U> Q) \\<^bold>\\<longrightarrow> P \\<^bold>\\<leadsto> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (P \\<U> Q) s))\n     \\<sigma> \\<longrightarrow>\n    (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n        (\\<exists>ia.\n            Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n            (\\<forall>k<ia.\n                P (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))) \\<longrightarrow>\n    (\\<forall>i.\n        P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n        (\\<exists>ia.\n            Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n            (\\<forall>k<ia. True)))", "by clarsimp blast"], ["", "lemma leads_to_via_concl_weaken:\n  assumes \"(R \\<^bold>\\<hookrightarrow> R') \\<sigma>\"\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R') \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (Q \\<U> R') s)) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. R s \\<longrightarrow> R' s)) \\<sigma>\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (Q \\<U> R) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (Q \\<U> R') s)) \\<sigma>", "unfolding LTL.defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     R (\\<sigma> |\\<^sub>s i) \\<longrightarrow> R' (\\<sigma> |\\<^sub>s i)\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           R' (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))", "by force"], ["", "lemma leads_to_via_trans:\n  assumes \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\"\n  assumes \"(C \\<^bold>\\<hookrightarrow> D \\<U> E) \\<sigma>\"\n  shows \"(A \\<^bold>\\<hookrightarrow> (B \\<^bold>\\<or> D) \\<U> E) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               A s \\<longrightarrow>\n               ((\\<lambda>s. B s \\<or> D s) \\<U> E) s))\n     \\<sigma>", "proof(rule alwaysI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "assume \"A (\\<sigma> |\\<^sub>s i)\""], ["proof (state)\nthis:\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "with assms"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)", "show \"((B \\<^bold>\\<or> D) \\<U> E) (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s))\n              \\<sigma>;\n     (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (erule alwaysE[where i=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n              \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (B \\<U> C) (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n              \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i); (B \\<U> C) (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (erule untilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i |\\<^sub>s ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "(* suffix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (drule (1) always_imp_mp_suffix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        (D \\<U> E) (\\<sigma> |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (erule untilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia |\\<^sub>s iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia + iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "(* suffix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia + iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (rule_tac i=\"ia + iaa\" in untilI; simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s ia + i);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s k + i);\n        E (\\<sigma> |\\<^sub>s ia + (iaa + i));\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s ia + (k + i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<ia + iaa.\n                            B (\\<sigma> |\\<^sub>s k + i) \\<or>\n                            D (\\<sigma> |\\<^sub>s k + i)", "apply (metis (full_types) add.assoc leI le_Suc_ex nat_add_left_cancel_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* arithmetic *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leads_to_via_disj: \\<comment> \\<open> useful for case distinctions \\<close>\n  assumes \"(P \\<^bold>\\<hookrightarrow> Q \\<U> R) \\<sigma>\"\n  assumes \"(P' \\<^bold>\\<hookrightarrow> Q' \\<U> R) \\<sigma>\"\n  shows \"(P \\<^bold>\\<or> P' \\<^bold>\\<hookrightarrow> (Q \\<^bold>\\<or> Q') \\<U> R) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               P s \\<or> P' s \\<longrightarrow>\n               ((\\<lambda>s. Q s \\<or> Q' s) \\<U> R) s))\n     \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (Q \\<U> R) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. P' s \\<longrightarrow> (Q' \\<U> R) s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               P s \\<or> P' s \\<longrightarrow>\n               ((\\<lambda>s. Q s \\<or> Q' s) \\<U> R) s))\n     \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))\n  \\<forall>i.\n     P' (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. Q' (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (\\<sigma> |\\<^sub>s i) \\<or>\n       P' (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           R (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia.\n               Q (\\<sigma> |\\<^sub>s i |\\<^sub>s k) \\<or>\n               Q' (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))", "by (auto 10 0)"], ["", "lemma leads_to_via_disj': \\<comment> \\<open> more like a chaining rule \\<close>\n  assumes \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\"\n  assumes \"(C \\<^bold>\\<hookrightarrow> D \\<U> E) \\<sigma>\"\n  shows \"(A \\<^bold>\\<or> C \\<^bold>\\<hookrightarrow> (B \\<^bold>\\<or> D) \\<U> E) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               A s \\<or> C s \\<longrightarrow>\n               ((\\<lambda>s. B s \\<or> D s) \\<U> E) s))\n     \\<sigma>", "proof(rule alwaysI, rule impI, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "assume \"A (\\<sigma> |\\<^sub>s i)\""], ["proof (state)\nthis:\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "with assms"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)", "show \"((B \\<^bold>\\<or> D) \\<U> E) (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s)) \\<sigma>\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s))\n              \\<sigma>;\n     (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (erule alwaysE[where i=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n              \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (B \\<U> C) (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n              \\<sigma>;\n     A (\\<sigma> |\\<^sub>s i); (B \\<U> C) (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (erule untilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i |\\<^sub>s ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "(* suffix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n                 \\<sigma>;\n        A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (drule (1) always_imp_mp_suffix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        (D \\<U> E) (\\<sigma> |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (erule untilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia |\\<^sub>s iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia + iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "(* suffix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s i + ia);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s i + k);\n        E (\\<sigma> |\\<^sub>s i + ia + iaa);\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s i + ia + k)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                          (\\<sigma> |\\<^sub>s i)", "apply (rule_tac i=\"ia + iaa\" in untilI; simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); C (\\<sigma> |\\<^sub>s ia + i);\n        \\<forall>k<ia. B (\\<sigma> |\\<^sub>s k + i);\n        E (\\<sigma> |\\<^sub>s ia + (iaa + i));\n        \\<forall>k<iaa. D (\\<sigma> |\\<^sub>s ia + (k + i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<ia + iaa.\n                            B (\\<sigma> |\\<^sub>s k + i) \\<or>\n                            D (\\<sigma> |\\<^sub>s k + i)", "apply (metis (full_types) add.assoc leI le_Suc_ex nat_add_left_cancel_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* arithmetic *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "assume \"C (\\<sigma> |\\<^sub>s i)\""], ["proof (state)\nthis:\n  C (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       C (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "with assms(2)"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  C (\\<sigma> |\\<^sub>s i)", "show \"((B \\<^bold>\\<or> D) \\<U> E) (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s)) \\<sigma>\n  C (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s. C s \\<longrightarrow> (D \\<U> E) s))\n              \\<sigma>;\n     C (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (erule alwaysE[where i=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C (\\<sigma> |\\<^sub>s i);\n     C (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (D \\<U> E) (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. B s \\<or> D s) \\<U> E)\n                       (\\<sigma> |\\<^sub>s i)", "apply (simp add: mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>s. B s \\<or> D s) \\<U> E) (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leads_to_via_stable_augmentation:\n  assumes stable: \"(P \\<^bold>\\<and> Q \\<^bold>\\<hookrightarrow> \\<circle>Q) \\<sigma>\"\n  assumes U: \"(A \\<^bold>\\<hookrightarrow> P \\<U> C) \\<sigma>\"\n  shows \"((A \\<^bold>\\<and> Q) \\<^bold>\\<hookrightarrow> P \\<U> (C \\<^bold>\\<and> Q)) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               A s \\<and> Q s \\<longrightarrow>\n               (P \\<U> (\\<lambda>s. C s \\<and> Q s)) s))\n     \\<sigma>", "proof(intro alwaysI impI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); Q (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (P \\<U> (\\<lambda>s. C s \\<and> Q s))\n                          (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); Q (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (P \\<U> (\\<lambda>s. C s \\<and> Q s))\n                          (\\<sigma> |\\<^sub>s i)", "assume AP: \"A (\\<sigma> |\\<^sub>s i)\" \"Q (\\<sigma> |\\<^sub>s i)\""], ["proof (state)\nthis:\n  A (\\<sigma> |\\<^sub>s i)\n  Q (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); Q (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (P \\<U> (\\<lambda>s. C s \\<and> Q s))\n                          (\\<sigma> |\\<^sub>s i)", "have \"Q (\\<sigma> |\\<^sub>s (j + i))\" if \"Q (\\<sigma> |\\<^sub>s i)\" and \"\\<forall>k<j. P (\\<sigma> |\\<^sub>s (k + i))\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (\\<sigma> |\\<^sub>s j + i)", "using that stable"], ["proof (prove)\nusing this:\n  Q (\\<sigma> |\\<^sub>s i)\n  \\<forall>k<j. P (\\<sigma> |\\<^sub>s k + i)\n  (\\<box>(\\<lambda>s. P s \\<and> Q s \\<longrightarrow> (\\<circle>Q) s))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. Q (\\<sigma> |\\<^sub>s j + i)", "by (induct j; force simp: defs)"], ["proof (state)\nthis:\n  \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n   \\<forall>k<?j. P (\\<sigma> |\\<^sub>s k + i)\\<rbrakk>\n  \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s ?j + i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i); Q (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (P \\<U> (\\<lambda>s. C s \\<and> Q s))\n                          (\\<sigma> |\\<^sub>s i)", "with U AP"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (P \\<U> C) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)\n  Q (\\<sigma> |\\<^sub>s i)\n  \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n   \\<forall>k<?j. P (\\<sigma> |\\<^sub>s k + i)\\<rbrakk>\n  \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s ?j + i)", "show \"(P \\<U> (\\<lambda>\\<sigma>. C \\<sigma> \\<and> Q \\<sigma>)) (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. A s \\<longrightarrow> (P \\<U> C) s)) \\<sigma>\n  A (\\<sigma> |\\<^sub>s i)\n  Q (\\<sigma> |\\<^sub>s i)\n  \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n   \\<forall>k<?j. P (\\<sigma> |\\<^sub>s k + i)\\<rbrakk>\n  \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s ?j + i)\n\ngoal (1 subgoal):\n 1. (P \\<U> (\\<lambda>\\<sigma>. C \\<sigma> \\<and> Q \\<sigma>))\n     (\\<sigma> |\\<^sub>s i)", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     A (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<exists>ia.\n         C (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s k)))\n  A (\\<sigma> |\\<^sub>s i)\n  Q (\\<sigma> |\\<^sub>s i)\n  \\<lbrakk>Q (\\<sigma> |\\<^sub>s i);\n   \\<forall>k<?j. P (\\<sigma> |\\<^sub>s k + i)\\<rbrakk>\n  \\<Longrightarrow> Q (\\<sigma> |\\<^sub>s ?j + i)\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       (C (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n        Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n       (\\<forall>k<ia. P (\\<sigma> |\\<^sub>s i |\\<^sub>s k))", "by clarsimp (metis (full_types) add.commute)"], ["proof (state)\nthis:\n  (P \\<U> (\\<lambda>\\<sigma>. C \\<sigma> \\<and> Q \\<sigma>))\n   (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leads_to_via_wf:\n  assumes \"wf R\"\n  assumes indhyp: \"\\<And>t. (A \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>= \\<langle>t\\<rangle>\\<rceil> \\<^bold>\\<hookrightarrow> B \\<U> (A \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>\\<otimes> \\<langle>t\\<rangle> \\<^bold>\\<in> \\<langle>R\\<rangle>\\<rceil> \\<^bold>\\<or> C)) \\<sigma>\"\n  shows \"(A \\<^bold>\\<hookrightarrow> B \\<U> C) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. A s \\<longrightarrow> (B \\<U> C) s)) \\<sigma>", "proof(intro alwaysI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "assume \"A (\\<sigma> |\\<^sub>s i)\""], ["proof (state)\nthis:\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A (\\<sigma> |\\<^sub>s i) \\<Longrightarrow>\n       (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "with \\<open>wf R\\<close>"], ["proof (chain)\npicking this:\n  wf R\n  A (\\<sigma> |\\<^sub>s i)", "show \"(B \\<U> C) (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  wf R\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "proof(induct \"\\<delta> (\\<sigma> i)\" arbitrary: i)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>(\\<delta> (\\<sigma> ia), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s ia)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s ia);\n        A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<delta> (\\<sigma> ?i), \\<delta> (\\<sigma> i)) \\<in> R;\n   A (\\<sigma> |\\<^sub>s ?i)\\<rbrakk>\n  \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s ?i)\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>ia.\n                   \\<lbrakk>(\\<delta> (\\<sigma> ia), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s ia)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s ia);\n        A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "with indhyp[where t=\"\\<delta> (\\<sigma> i)\"]"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s.\n             A s \\<and>\n             \\<lceil>\\<lambda>s. \\<delta> s = \\<delta> (\\<sigma> i)\\<rceil>\n              s \\<longrightarrow>\n             (B \\<U>\n              (\\<lambda>s.\n                  A s \\<and>\n                  \\<lceil>\\<lambda>s.\n                             (\\<delta> s, \\<delta> (\\<sigma> i))\n                             \\<in> R\\<rceil>\n                   s \\<or>\n                  C s))\n              s))\n   \\<sigma>\n  \\<lbrakk>(\\<delta> (\\<sigma> ?i), \\<delta> (\\<sigma> i)) \\<in> R;\n   A (\\<sigma> |\\<^sub>s ?i)\\<rbrakk>\n  \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s ?i)\n  A (\\<sigma> |\\<^sub>s i)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             A s \\<and>\n             \\<lceil>\\<lambda>s. \\<delta> s = \\<delta> (\\<sigma> i)\\<rceil>\n              s \\<longrightarrow>\n             (B \\<U>\n              (\\<lambda>s.\n                  A s \\<and>\n                  \\<lceil>\\<lambda>s.\n                             (\\<delta> s, \\<delta> (\\<sigma> i))\n                             \\<in> R\\<rceil>\n                   s \\<or>\n                  C s))\n              s))\n   \\<sigma>\n  \\<lbrakk>(\\<delta> (\\<sigma> ?i), \\<delta> (\\<sigma> i)) \\<in> R;\n   A (\\<sigma> |\\<^sub>s ?i)\\<rbrakk>\n  \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s ?i)\n  A (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s.\n                        A s \\<and>\n                        \\<lceil>\\<lambda>s.\n                                   \\<delta> s =\n                                   \\<delta> (\\<sigma> i)\\<rceil>\n                         s \\<longrightarrow>\n                        (B \\<U>\n                         (\\<lambda>s.\n                             A s \\<and>\n                             \\<lceil>\\<lambda>s.\n  (\\<delta> s, \\<delta> (\\<sigma> i)) \\<in> R\\<rceil>\n                              s \\<or>\n                             C s))\n                         s))\n              \\<sigma>;\n     \\<And>i.\n        \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i)) \\<in> R;\n         A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n        \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (drule alwaysD[where i=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                         \\<in> R;\n                 A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i) \\<and>\n     \\<lceil>\\<lambda>s. \\<delta> s = \\<delta> (\\<sigma> i)\\<rceil>\n      (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (B \\<U>\n      (\\<lambda>s.\n          A s \\<and>\n          \\<lceil>\\<lambda>s.\n                     (\\<delta> s, \\<delta> (\\<sigma> i)) \\<in> R\\<rceil>\n           s \\<or>\n          C s))\n      (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                         \\<in> R;\n                 A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n     A (\\<sigma> |\\<^sub>s i);\n     (B \\<U>\n      (\\<lambda>s.\n          A s \\<and>\n          \\<lceil>\\<lambda>s.\n                     (\\<delta> s, \\<delta> (\\<sigma> i)) \\<in> R\\<rceil>\n           s \\<or>\n          C s))\n      (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n    \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (erule untilE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i |\\<^sub>s i) \\<and>\n        \\<lceil>\\<lambda>s.\n                   (\\<delta> s, \\<delta> (\\<sigma> i)) \\<in> R\\<rceil>\n         (\\<sigma> |\\<^sub>s i |\\<^sub>s i) \\<or>\n        C (\\<sigma> |\\<^sub>s i |\\<^sub>s i);\n        \\<forall>k<i. B (\\<sigma> |\\<^sub>s i |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (rename_tac j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i |\\<^sub>s j) \\<and>\n        \\<lceil>\\<lambda>s.\n                   (\\<delta> s, \\<delta> (\\<sigma> i)) \\<in> R\\<rceil>\n         (\\<sigma> |\\<^sub>s i |\\<^sub>s j) \\<or>\n        C (\\<sigma> |\\<^sub>s i |\\<^sub>s j);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i |\\<^sub>s k)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (erule disjE; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i))\n        \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (drule_tac x=\"i + j\" in meta_spec; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        (B \\<U> C) (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (erule untilE; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j i.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + i);\n        \\<forall>k<i. B (\\<sigma> |\\<^sub>s i + j + k)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (rename_tac j k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j k.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + k);\n        \\<forall>ka<k. B (\\<sigma> |\\<^sub>s i + j + ka)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (rule_tac i=\"j + k\" in untilI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>j k.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + k);\n        \\<forall>ka<k. B (\\<sigma> |\\<^sub>s i + j + ka)\\<rbrakk>\n       \\<Longrightarrow> C (\\<sigma> |\\<^sub>s i |\\<^sub>s j + k)\n 2. \\<And>j k.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + k);\n        \\<forall>ka<k. B (\\<sigma> |\\<^sub>s i + j + ka)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ka<j + k.\n                            B (\\<sigma> |\\<^sub>s i |\\<^sub>s ka)\n 3. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (simp add: add.assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j k.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + k);\n        \\<forall>ka<k. B (\\<sigma> |\\<^sub>s i + j + ka)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ka<j + k.\n                            B (\\<sigma> |\\<^sub>s i |\\<^sub>s ka)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j k ka.\n       \\<lbrakk>A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        A (\\<sigma> |\\<^sub>s i + j);\n        (\\<delta> (\\<sigma> (i + j)), \\<delta> (\\<sigma> i)) \\<in> R;\n        C (\\<sigma> |\\<^sub>s i + j + k);\n        \\<forall>ka<k. B (\\<sigma> |\\<^sub>s i + j + ka);\n        ka < j + k\\<rbrakk>\n       \\<Longrightarrow> B (\\<sigma> |\\<^sub>s i + ka)\n 2. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply (metis add.assoc add.commute add_diff_inverse_nat less_diff_conv2 not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>(\\<delta> (\\<sigma> i), \\<delta> (\\<sigma> i))\n                            \\<in> R;\n                    A (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n                   \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i);\n        A (\\<sigma> |\\<^sub>s i);\n        \\<forall>k<j. B (\\<sigma> |\\<^sub>s i + k);\n        C (\\<sigma> |\\<^sub>s i + j)\\<rbrakk>\n       \\<Longrightarrow> (B \\<U> C) (\\<sigma> |\\<^sub>s i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (B \\<U> C) (\\<sigma> |\\<^sub>s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe well-founded response rule due to @{cite [cite_macro=citet] \\<open>Fig~1.23: \\texttt{WELL} (well-founded response)\\<close>\"MannaPnueli:2010\"},\ngeneralised to an arbitrary set of assertions and sequence predicates.\n\\<^item> \\<open>W1\\<close> generalised to be contingent.\n\\<^item> \\<open>W2\\<close> is a well-founded set of assertions that by \\<open>W1\\<close> includes \\<open>P\\<close>\n\n\\<close>"], ["", "(* FIXME: Does \\<open>Is\\<close> need to be consistent? *)"], ["", "lemma leads_to_wf:\n  fixes Is :: \"('a seq_pred \\<times> ('a \\<Rightarrow> 'b)) set\"\n  assumes \"wf (R :: 'b rel)\"\n  assumes W1: \"(\\<box>(\\<^bold>\\<exists>\\<phi>. \\<lceil>\\<langle>\\<phi>\\<in>fst ` Is\\<rangle>\\<rceil> \\<^bold>\\<and> (P \\<^bold>\\<longrightarrow> \\<phi>))) \\<sigma>\"\n  assumes W2: \"\\<forall>(\\<phi>, \\<delta>)\\<in>Is. \\<exists>(\\<phi>', \\<delta>')\\<in>insert (Q, \\<delta>0) Is. \\<forall>t. (\\<phi> \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>= \\<langle>t\\<rangle>\\<rceil> \\<^bold>\\<leadsto> \\<phi>' \\<^bold>\\<and> \\<lceil>\\<delta>' \\<^bold>\\<otimes> \\<langle>t\\<rangle> \\<^bold>\\<in> \\<langle>R\\<rangle>\\<rceil>) \\<sigma>\"\n  shows \"(P \\<^bold>\\<leadsto> Q) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>", "have \"(\\<phi> \\<^bold>\\<and> \\<lceil>\\<delta> \\<^bold>= \\<langle>t\\<rangle>\\<rceil> \\<^bold>\\<leadsto> Q) \\<sigma>\" if \"(\\<phi>, \\<delta>) \\<in> Is\" for \\<phi> \\<delta> t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               \\<phi> s \\<and>\n               \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                s \\<longrightarrow>\n               (\\<diamond>Q) s))\n     \\<sigma>", "using \\<open>wf R\\<close> that W2"], ["proof (prove)\nusing this:\n  wf R\n  (\\<phi>, \\<delta>) \\<in> Is\n  \\<forall>(\\<phi>, \\<delta>)\\<in>Is.\n     \\<exists>(\\<phi>', \\<delta>')\\<in>insert (Q, \\<delta>0) Is.\n        \\<forall>t.\n           (\\<box>(\\<lambda>s.\n                      \\<phi> s \\<and>\n                      \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                       s \\<longrightarrow>\n                      (\\<diamond>(\\<lambda>s.\n                                     \\<phi>' s \\<and>\n                                     \\<lceil>\\<lambda>s.\n          (\\<delta>' s, t) \\<in> R\\<rceil>\ns))\n                       s))\n            \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               \\<phi> s \\<and>\n               \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                s \\<longrightarrow>\n               (\\<diamond>Q) s))\n     \\<sigma>", "apply (induct t arbitrary: \\<phi> \\<delta>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi> \\<delta>.\n       \\<lbrakk>\\<And>y \\<phi> \\<delta>.\n                   \\<lbrakk>(y, x) \\<in> R; (\\<phi>, \\<delta>) \\<in> Is;\n                    \\<forall>(\\<phi>, \\<delta>)\\<in>Is.\n                       \\<exists>(\\<phi>', \\<delta>')\n                                \\<in>insert (Q, \\<delta>0) Is.\n                          \\<forall>t.\n                             (\\<box>(\\<lambda>s.\n  \\<phi> s \\<and>\n  \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil> s \\<longrightarrow>\n  (\\<diamond>(\\<lambda>s.\n                 \\<phi>' s \\<and>\n                 \\<lceil>\\<lambda>s. (\\<delta>' s, t) \\<in> R\\<rceil> s))\n   s))\n                              \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> (\\<box>(\\<lambda>s.\n          \\<phi> s \\<and>\n          \\<lceil>\\<lambda>s. \\<delta> s = y\\<rceil> s \\<longrightarrow>\n          (\\<diamond>Q) s))\n\\<sigma>;\n        (\\<phi>, \\<delta>) \\<in> Is;\n        \\<forall>(\\<phi>, \\<delta>)\\<in>Is.\n           \\<exists>(\\<phi>', \\<delta>')\\<in>insert (Q, \\<delta>0) Is.\n              \\<forall>t.\n                 (\\<box>(\\<lambda>s.\n                            \\<phi> s \\<and>\n                            \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                             s \\<longrightarrow>\n                            (\\<diamond>(\\<lambda>s.\n     \\<phi>' s \\<and>\n     \\<lceil>\\<lambda>s. (\\<delta>' s, t) \\<in> R\\<rceil> s))\n                             s))\n                  \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    \\<phi> s \\<and>\n                                    \\<lceil>\\<lambda>s.\n         \\<delta> s = x\\<rceil>\n                                     s \\<longrightarrow>\n                                    (\\<diamond>Q) s))\n                          \\<sigma>", "unfolding LTL.defs split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<phi> \\<delta>.\n       \\<lbrakk>\\<And>y \\<phi> \\<delta>.\n                   \\<lbrakk>(y, x) \\<in> R; (\\<phi>, \\<delta>) \\<in> Is;\n                    \\<forall>p\\<in>Is.\n                       \\<exists>pa\\<in>insert (Q, \\<delta>0) Is.\n                          \\<forall>t i.\n                             fst p (\\<sigma> |\\<^sub>s i) \\<and>\n                             snd p ((\\<sigma> |\\<^sub>s i) 0) =\n                             t \\<longrightarrow>\n                             (\\<exists>ia.\n                                 (fst pa\n                                   (\\<sigma> |\\<^sub>s i |\\<^sub>s\n                                    ia) \\<and>\n                                  (snd pa\n                                    ((\\<sigma> |\\<^sub>s i |\\<^sub>s ia) 0),\n                                   t)\n                                  \\<in> R) \\<and>\n                                 (\\<forall>k<ia. True))\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i.\n  \\<phi> (\\<sigma> |\\<^sub>s i) \\<and>\n  \\<delta> ((\\<sigma> |\\<^sub>s i) 0) = y \\<longrightarrow>\n  (\\<exists>ia.\n      Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and> (\\<forall>k<ia. True));\n        (\\<phi>, \\<delta>) \\<in> Is;\n        \\<forall>p\\<in>Is.\n           \\<exists>pa\\<in>insert (Q, \\<delta>0) Is.\n              \\<forall>t i.\n                 fst p (\\<sigma> |\\<^sub>s i) \\<and>\n                 snd p ((\\<sigma> |\\<^sub>s i) 0) = t \\<longrightarrow>\n                 (\\<exists>ia.\n                     (fst pa (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                      (snd pa ((\\<sigma> |\\<^sub>s i |\\<^sub>s ia) 0), t)\n                      \\<in> R) \\<and>\n                     (\\<forall>k<ia. True))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            \\<phi> (\\<sigma> |\\<^sub>s i) \\<and>\n                            \\<delta> ((\\<sigma> |\\<^sub>s i) 0) =\n                            x \\<longrightarrow>\n                            (\\<exists>ia.\n                                Q (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                                (\\<forall>k<ia. True))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<delta> i.\n       \\<lbrakk>\\<And>y \\<phi> \\<delta>'.\n                   \\<lbrakk>(y, \\<delta> (\\<sigma> i)) \\<in> R;\n                    (\\<phi>, \\<delta>') \\<in> Is\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i.\n  \\<phi> (\\<sigma> |\\<^sub>s i) \\<and>\n  \\<delta>' (\\<sigma> i) = y \\<longrightarrow>\n  (\\<exists>ia. Q (\\<sigma> |\\<^sub>s i + ia));\n        (\\<phi>, \\<delta>) \\<in> Is;\n        \\<forall>p\\<in>Is.\n           (\\<forall>i.\n               fst p (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n               (\\<exists>ia.\n                   Q (\\<sigma> |\\<^sub>s i + ia) \\<and>\n                   (\\<delta>0 (\\<sigma> (i + ia)), snd p (\\<sigma> i))\n                   \\<in> R)) \\<or>\n           (\\<exists>pa\\<in>Is.\n               \\<forall>i.\n                  fst p (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                  (\\<exists>ia.\n                      fst pa (\\<sigma> |\\<^sub>s i + ia) \\<and>\n                      (snd pa (\\<sigma> (i + ia)), snd p (\\<sigma> i))\n                      \\<in> R));\n        \\<phi> (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. Q (\\<sigma> |\\<^sub>s i + ia)", "apply (metis (no_types, hide_lams) ab_semigroup_add_class.add_ac(1) fst_eqD snd_conv surjective_pairing)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (?\\<phi>, ?\\<delta>) \\<in> Is \\<Longrightarrow>\n  (\\<box>(\\<lambda>s.\n             ?\\<phi> s \\<and>\n             \\<lceil>\\<lambda>s. ?\\<delta> s = ?t\\<rceil>\n              s \\<longrightarrow>\n             (\\<diamond>Q) s))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>", "with W1"], ["proof (chain)\npicking this:\n  (\\<box>(\\<lambda>s.\n             \\<exists>x.\n                \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil> s \\<and>\n                (P s \\<longrightarrow> x s)))\n   \\<sigma>\n  (?\\<phi>, ?\\<delta>) \\<in> Is \\<Longrightarrow>\n  (\\<box>(\\<lambda>s.\n             ?\\<phi> s \\<and>\n             \\<lceil>\\<lambda>s. ?\\<delta> s = ?t\\<rceil>\n              s \\<longrightarrow>\n             (\\<diamond>Q) s))\n   \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             \\<exists>x.\n                \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil> s \\<and>\n                (P s \\<longrightarrow> x s)))\n   \\<sigma>\n  (?\\<phi>, ?\\<delta>) \\<in> Is \\<Longrightarrow>\n  (\\<box>(\\<lambda>s.\n             ?\\<phi> s \\<and>\n             \\<lceil>\\<lambda>s. ?\\<delta> s = ?t\\<rceil>\n              s \\<longrightarrow>\n             (\\<diamond>Q) s))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<box>(\\<lambda>s.\n                        \\<exists>x.\n                           \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil>\n                            s \\<and>\n                           (P s \\<longrightarrow> x s)))\n              \\<sigma>;\n     \\<And>\\<phi> \\<delta> t.\n        (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n        (\\<box>(\\<lambda>s.\n                   \\<phi> s \\<and>\n                   \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                    s \\<longrightarrow>\n                   (\\<diamond>Q) s))\n         \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                 P s \\<longrightarrow> (\\<diamond>Q) s))\n                       \\<sigma>", "apply (rule alwaysI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>(\\<box>(\\<lambda>s.\n                           \\<exists>x.\n                              \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil>\n                               s \\<and>\n                              (P s \\<longrightarrow> x s)))\n                 \\<sigma>;\n        \\<And>\\<phi> \\<delta> t.\n           (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n           (\\<box>(\\<lambda>s.\n                      \\<phi> s \\<and>\n                      \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                       s \\<longrightarrow>\n                      (\\<diamond>Q) s))\n            \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                         (\\<diamond>Q) (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>(\\<box>(\\<lambda>s.\n                           \\<exists>x.\n                              \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil>\n                               s \\<and>\n                              (P s \\<longrightarrow> x s)))\n                 \\<sigma>;\n        \\<And>\\<phi> \\<delta> t.\n           (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n           (\\<box>(\\<lambda>s.\n                      \\<phi> s \\<and>\n                      \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                       s \\<longrightarrow>\n                      (\\<diamond>Q) s))\n            \\<sigma>;\n        P (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (\\<diamond>Q) (\\<sigma> |\\<^sub>s i)", "apply (erule_tac i=i in alwaysE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>\\<phi> \\<delta> t.\n                   (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n                   (\\<box>(\\<lambda>s.\n                              \\<phi> s \\<and>\n                              \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                               s \\<longrightarrow>\n                              (\\<diamond>Q) s))\n                    \\<sigma>;\n        P (\\<sigma> |\\<^sub>s i);\n        \\<exists>x.\n           \\<lceil>\\<lambda>s. x \\<in> fst ` Is\\<rceil>\n            (\\<sigma> |\\<^sub>s i) \\<and>\n           (P (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n            x (\\<sigma> |\\<^sub>s i))\\<rbrakk>\n       \\<Longrightarrow> (\\<diamond>Q) (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i a b.\n       \\<lbrakk>\\<And>\\<phi> \\<delta> t.\n                   (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n                   (\\<box>(\\<lambda>s.\n                              \\<phi> s \\<and>\n                              \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                               s \\<longrightarrow>\n                              (\\<diamond>Q) s))\n                    \\<sigma>;\n        P (\\<sigma> |\\<^sub>s i); (a, b) \\<in> Is;\n        a (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (\\<diamond>Q) (\\<sigma> |\\<^sub>s i)", "using alwaysD suffix_state_prop"], ["proof (prove)\nusing this:\n  (\\<box>?P) ?\\<sigma> \\<Longrightarrow> ?P (?\\<sigma> |\\<^sub>s ?i)\n  \\<lceil>?P\\<rceil> (?\\<sigma> |\\<^sub>s ?i) = ?P (?\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i a b.\n       \\<lbrakk>\\<And>\\<phi> \\<delta> t.\n                   (\\<phi>, \\<delta>) \\<in> Is \\<Longrightarrow>\n                   (\\<box>(\\<lambda>s.\n                              \\<phi> s \\<and>\n                              \\<lceil>\\<lambda>s. \\<delta> s = t\\<rceil>\n                               s \\<longrightarrow>\n                              (\\<diamond>Q) s))\n                    \\<sigma>;\n        P (\\<sigma> |\\<^sub>s i); (a, b) \\<in> Is;\n        a (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> (\\<diamond>Q) (\\<sigma> |\\<^sub>s i)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<box>(\\<lambda>s. P s \\<longrightarrow> (\\<diamond>Q) s)) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Fairness\\<close>"], ["", "text\\<open>\n\nA few renderings of weak fairness. @{cite [cite_macro=citet] \"vanGlabbeekHofner:2019\"} call this\n\"response to insistence\" as a generalisation of weak fairness.\n\n\\<close>"], ["", "definition weakly_fair :: \"'a seq_pred \\<Rightarrow> 'a seq_pred \\<Rightarrow> 'a seq_pred\" where\n  \"weakly_fair enabled taken = (\\<box>enabled \\<^bold>\\<hookrightarrow> \\<diamond>taken)\""], ["", "lemma weakly_fair_def2:\n  shows \"weakly_fair enabled taken = \\<box>(\\<^bold>\\<not>\\<box>(enabled \\<^bold>\\<and> \\<^bold>\\<not>taken))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_fair enabled taken =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s. enabled s \\<and> \\<not> taken s))\n                      s)", "unfolding weakly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>(\\<lambda>s.\n              (\\<box>enabled) s \\<longrightarrow> (\\<diamond>taken) s) =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s. enabled s \\<and> \\<not> taken s))\n                      s)", "by (metis (full_types) always_conj_distrib norm(18))"], ["", "lemma weakly_fair_def3:\n  shows \"weakly_fair enabled taken = (\\<diamond>\\<box>enabled \\<^bold>\\<longrightarrow> \\<box>\\<diamond>taken)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_fair enabled taken =\n    (\\<lambda>s.\n        (\\<diamond>\\<box>enabled) s \\<longrightarrow>\n        (\\<box>\\<diamond>taken) s)", "unfolding weakly_fair_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s. enabled s \\<and> \\<not> taken s))\n                      s) =\n    (\\<lambda>s.\n        (\\<diamond>\\<box>enabled) s \\<longrightarrow>\n        (\\<box>\\<diamond>taken) s)", "apply (clarsimp simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<box>\\<diamond>(\\<lambda>s. enabled s \\<longrightarrow> taken s))\n        x =\n       ((\\<diamond>\\<box>enabled) x \\<longrightarrow>\n        (\\<box>\\<diamond>taken) x)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>i.\n           \\<exists>ia.\n              (enabled (x |\\<^sub>s i |\\<^sub>s ia) \\<longrightarrow>\n               taken (x |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n              (\\<forall>k<ia. True)) =\n       ((\\<exists>i.\n            (\\<forall>ia. enabled (x |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n            (\\<forall>k<i. True)) \\<longrightarrow>\n        (\\<forall>i.\n            \\<exists>ia.\n               taken (x |\\<^sub>s i |\\<^sub>s ia) \\<and>\n               (\\<forall>k<ia. True)))", "(* True, but can we get there deductively? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>i.\n           \\<exists>ia.\n              (enabled (x |\\<^sub>s i |\\<^sub>s ia) \\<longrightarrow>\n               taken (x |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n              (\\<forall>k<ia. True)) =\n       ((\\<exists>i.\n            (\\<forall>ia. enabled (x |\\<^sub>s i |\\<^sub>s ia)) \\<and>\n            (\\<forall>k<i. True)) \\<longrightarrow>\n        (\\<forall>i.\n            \\<exists>ia.\n               taken (x |\\<^sub>s i |\\<^sub>s ia) \\<and>\n               (\\<forall>k<ia. True)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i ia.\n       \\<lbrakk>\\<forall>i.\n                   \\<exists>ia.\n                      enabled (x |\\<^sub>s i + ia) \\<longrightarrow>\n                      taken (x |\\<^sub>s i + ia);\n        \\<forall>ia. enabled (x |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. taken (x |\\<^sub>s ia + i)", "apply (metis (full_types) add.left_commute semiring_normalization_rules(25))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma weakly_fair_def4:\n  shows \"weakly_fair enabled taken = \\<box>\\<diamond>(enabled \\<^bold>\\<longrightarrow> taken)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_fair enabled taken =\n    \\<box>\\<diamond>(\\<lambda>s. enabled s \\<longrightarrow> taken s)", "using weakly_fair_def2"], ["proof (prove)\nusing this:\n  weakly_fair ?enabled ?taken =\n  \\<box>(\\<lambda>s.\n            \\<not> (\\<box>(\\<lambda>s. ?enabled s \\<and> \\<not> ?taken s))\n                    s)\n\ngoal (1 subgoal):\n 1. weakly_fair enabled taken =\n    \\<box>\\<diamond>(\\<lambda>s. enabled s \\<longrightarrow> taken s)", "by force"], ["", "lemma mp_weakly_fair:\n  assumes \"weakly_fair enabled taken \\<sigma>\"\n  assumes \"(\\<box>enabled) \\<sigma>\"\n  shows \"(\\<diamond>taken) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<diamond>taken) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  weakly_fair enabled taken \\<sigma>\n  (\\<box>enabled) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>taken) \\<sigma>", "unfolding weakly_fair_def"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             (\\<box>enabled) s \\<longrightarrow> (\\<diamond>taken) s))\n   \\<sigma>\n  (\\<box>enabled) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>taken) \\<sigma>", "using always_imp_mp"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             (\\<box>enabled) s \\<longrightarrow> (\\<diamond>taken) s))\n   \\<sigma>\n  (\\<box>enabled) \\<sigma>\n  \\<lbrakk>(\\<box>(\\<lambda>s. ?P s \\<longrightarrow> ?Q s)) ?\\<sigma>;\n   ?P ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?Q ?\\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>taken) \\<sigma>", "by blast"], ["", "lemma always_weakly_fair:\n  shows \"\\<box>(weakly_fair enabled taken) = weakly_fair enabled taken\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>weakly_fair enabled taken = weakly_fair enabled taken", "unfolding weakly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>\\<box>(\\<lambda>s.\n                    (\\<box>enabled) s \\<longrightarrow>\n                    (\\<diamond>taken) s) =\n    \\<box>(\\<lambda>s.\n              (\\<box>enabled) s \\<longrightarrow> (\\<diamond>taken) s)", "by simp"], ["", "lemma eventually_weakly_fair:\n  shows \"\\<diamond>(weakly_fair enabled taken) = weakly_fair enabled taken\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>weakly_fair enabled taken = weakly_fair enabled taken", "unfolding weakly_fair_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>\\<box>(\\<lambda>s.\n                        \\<not> (\\<box>(\\<lambda>s.\n    enabled s \\<and> \\<not> taken s))\n                                s) =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s. enabled s \\<and> \\<not> taken s))\n                      s)", "by (simp add: always_eventually_always)"], ["", "lemma weakly_fair_weaken:\n  assumes \"(enabled' \\<^bold>\\<hookrightarrow> enabled) \\<sigma>\"\n  assumes \"(taken \\<^bold>\\<hookrightarrow> taken') \\<sigma>\"\n  shows \"(weakly_fair enabled taken \\<^bold>\\<hookrightarrow>  weakly_fair enabled' taken') \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               weakly_fair enabled taken s \\<longrightarrow>\n               weakly_fair enabled' taken' s))\n     \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. enabled' s \\<longrightarrow> enabled s)) \\<sigma>\n  (\\<box>(\\<lambda>s. taken s \\<longrightarrow> taken' s)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               weakly_fair enabled taken s \\<longrightarrow>\n               weakly_fair enabled' taken' s))\n     \\<sigma>", "unfolding weakly_fair_def defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     enabled' (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     enabled (\\<sigma> |\\<^sub>s i)\n  \\<forall>i.\n     taken (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     taken' (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<forall>ia.\n           (\\<forall>ib.\n               enabled\n                (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s\n                 ib)) \\<longrightarrow>\n           (\\<exists>ib.\n               taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<and>\n               (\\<forall>k<ib. True))) \\<longrightarrow>\n       (\\<forall>ia.\n           (\\<forall>ib.\n               enabled'\n                (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s\n                 ib)) \\<longrightarrow>\n           (\\<exists>ib.\n               taken'\n                (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<and>\n               (\\<forall>k<ib. True)))", "by simp blast"], ["", "lemma weakly_fair_unless_until:\n  shows \"(weakly_fair enabled taken \\<^bold>\\<and> (enabled \\<^bold>\\<hookrightarrow> enabled \\<W> taken)) = (enabled \\<^bold>\\<hookrightarrow> enabled \\<U> taken)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        weakly_fair enabled taken s \\<and>\n        (\\<box>(\\<lambda>s.\n                   enabled s \\<longrightarrow> (enabled \\<W> taken) s))\n         s) =\n    \\<box>(\\<lambda>s. enabled s \\<longrightarrow> (enabled \\<U> taken) s)", "unfolding defs weakly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        (\\<forall>i.\n            (\\<forall>ia.\n                enabled (s |\\<^sub>s i |\\<^sub>s ia)) \\<longrightarrow>\n            (\\<exists>ia.\n                taken (s |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                (\\<forall>k<ia. True))) \\<and>\n        (\\<forall>i.\n            enabled (s |\\<^sub>s i) \\<longrightarrow>\n            (\\<exists>ia.\n                taken (s |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                (\\<forall>k<ia. enabled (s |\\<^sub>s i |\\<^sub>s k))) \\<or>\n            (\\<forall>ia. enabled (s |\\<^sub>s i |\\<^sub>s ia)))) =\n    (\\<lambda>\\<sigma>.\n        \\<forall>i.\n           enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n           (\\<exists>ia.\n               taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n               (\\<forall>k<ia. enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s k))))", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   enabled (x |\\<^sub>s i) \\<longrightarrow>\n                   (\\<exists>ia.\n                       taken (x |\\<^sub>s i + ia) \\<and>\n                       (\\<forall>k<ia. enabled (x |\\<^sub>s i + k)));\n        \\<forall>ia. enabled (x |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)", "apply (metis add.right_neutral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stable_leads_to_eventually:\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<hookrightarrow> (\\<box>enabled \\<^bold>\\<or> \\<diamond>taken)) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               enabled s \\<longrightarrow>\n               (\\<box>enabled) s \\<or> (\\<diamond>taken) s))\n     \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             enabled s \\<longrightarrow>\n             (\\<circle>(\\<lambda>s. enabled s \\<or> taken s)) s))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               enabled s \\<longrightarrow>\n               (\\<box>enabled) s \\<or> (\\<diamond>taken) s))\n     \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n     taken (\\<sigma> |\\<^sub>s i |\\<^sub>s 1)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<forall>ia. enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<or>\n       (\\<exists>ia.\n           taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n       taken (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<Longrightarrow>\n    \\<forall>i.\n       enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<forall>ia. enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<or>\n       (\\<exists>ia.\n           taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s 1) \\<or>\n                taken (\\<sigma> |\\<^sub>s i |\\<^sub>s 1);\n     \\<not> (\\<forall>i.\n                enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                (\\<forall>ia.\n                    enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<or>\n                (\\<exists>ia.\n                    taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                    (\\<forall>k<ia. True)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   enabled (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   taken (\\<sigma> |\\<^sub>s Suc i);\n        enabled (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia. \\<not> taken (\\<sigma> |\\<^sub>s i + ia);\n        \\<not> enabled (\\<sigma> |\\<^sub>s i + ia)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) ex_least_nat_less[where P=\"\\<lambda>j. \\<not> enabled (\\<sigma> |\\<^sub>s i + j)\" for i, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>\\<forall>i.\n                   enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   enabled (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   taken (\\<sigma> |\\<^sub>s Suc i);\n        enabled (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia. \\<not> taken (\\<sigma> |\\<^sub>s i + ia);\n        \\<exists>k<ia.\n           (\\<forall>ia\\<le>k. enabled (\\<sigma> |\\<^sub>s i + ia)) \\<and>\n           \\<not> enabled (\\<sigma> |\\<^sub>s Suc (i + k))\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i ia k.\n       \\<lbrakk>\\<forall>i.\n                   enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n                   enabled (\\<sigma> |\\<^sub>s Suc i) \\<or>\n                   taken (\\<sigma> |\\<^sub>s Suc i);\n        enabled (\\<sigma> |\\<^sub>s i);\n        \\<forall>ia. \\<not> taken (\\<sigma> |\\<^sub>s i + ia); k < ia;\n        \\<forall>ia\\<le>k. enabled (\\<sigma> |\\<^sub>s i + ia);\n        \\<not> enabled (\\<sigma> |\\<^sub>s Suc (i + k))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis add_Suc_right leI less_irrefl_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma weakly_fair_stable_leads_to:\n  assumes \"(weakly_fair enabled taken) \\<sigma>\"\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<leadsto> taken) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. enabled s \\<longrightarrow> (\\<diamond>taken) s))\n     \\<sigma>", "using stable_leads_to_eventually[OF assms(2)] assms(1)"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s.\n             enabled s \\<longrightarrow>\n             (\\<box>enabled) s \\<or> (\\<diamond>taken) s))\n   \\<sigma>\n  weakly_fair enabled taken \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. enabled s \\<longrightarrow> (\\<diamond>taken) s))\n     \\<sigma>", "unfolding defs weakly_fair_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n     (\\<forall>ia. enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<or>\n     (\\<exists>ia.\n         taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. True))\n  \\<forall>i.\n     (\\<forall>ia.\n         enabled (\\<sigma> |\\<^sub>s i |\\<^sub>s ia)) \\<longrightarrow>\n     (\\<exists>ia.\n         taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n         (\\<forall>k<ia. True))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       enabled (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<exists>ia.\n           taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n           (\\<forall>k<ia. True))", "by (auto simp: fun_eq_iff)"], ["", "lemma weakly_fair_stable_leads_to_via:\n  assumes \"(weakly_fair enabled taken) \\<sigma>\"\n  assumes \"(enabled \\<^bold>\\<hookrightarrow> \\<circle>(enabled \\<^bold>\\<or> taken)) \\<sigma>\"\n  shows \"(enabled \\<^bold>\\<hookrightarrow> enabled \\<U> taken) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. enabled s \\<longrightarrow> (enabled \\<U> taken) s))\n     \\<sigma>", "using stable_unless[OF assms(2)] assms(1)"], ["proof (prove)\nusing this:\n  (\\<box>(\\<lambda>s. enabled s \\<longrightarrow> (enabled \\<W> taken) s))\n   \\<sigma>\n  weakly_fair enabled taken \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s. enabled s \\<longrightarrow> (enabled \\<U> taken) s))\n     \\<sigma>", "by (metis (mono_tags) weakly_fair_unless_until)"], ["", "text\\<open>\n\nSimilarly for strong fairness. @{cite [cite_macro=citet] \"vanGlabbeekHofner:2019\"} call this\n\"response to persistence\" as a generalisation of strong fairness.\n\n\\<close>"], ["", "definition strongly_fair :: \"'a seq_pred \\<Rightarrow> 'a seq_pred \\<Rightarrow> 'a seq_pred\" where\n  \"strongly_fair enabled taken = (\\<box>\\<diamond>enabled \\<^bold>\\<hookrightarrow> \\<diamond>taken)\""], ["", "lemma strongly_fair_def2:\n  \"strongly_fair enabled taken = \\<box>(\\<^bold>\\<not>\\<box>(\\<diamond>enabled \\<^bold>\\<and> \\<^bold>\\<not>taken))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strongly_fair enabled taken =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s.\n                                (\\<diamond>enabled) s \\<and>\n                                \\<not> taken s))\n                      s)", "unfolding strongly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>(\\<lambda>s.\n              (\\<box>\\<diamond>enabled) s \\<longrightarrow>\n              (\\<diamond>taken) s) =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s.\n                                (\\<diamond>enabled) s \\<and>\n                                \\<not> taken s))\n                      s)", "by (metis weakly_fair_def weakly_fair_def2)"], ["", "lemma strongly_fair_def3:\n  \"strongly_fair enabled taken = (\\<box>\\<diamond>enabled \\<^bold>\\<longrightarrow> \\<box>\\<diamond>taken)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strongly_fair enabled taken =\n    (\\<lambda>s.\n        (\\<box>\\<diamond>enabled) s \\<longrightarrow>\n        (\\<box>\\<diamond>taken) s)", "unfolding strongly_fair_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s.\n                                (\\<diamond>enabled) s \\<and>\n                                \\<not> taken s))\n                      s) =\n    (\\<lambda>s.\n        (\\<box>\\<diamond>enabled) s \\<longrightarrow>\n        (\\<box>\\<diamond>taken) s)", "by (metis (full_types) always_eventually_always weakly_fair_def2 weakly_fair_def3)"], ["", "lemma always_strongly_fair:\n  \"\\<box>(strongly_fair enabled taken) = strongly_fair enabled taken\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>strongly_fair enabled taken = strongly_fair enabled taken", "unfolding strongly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box>\\<box>(\\<lambda>s.\n                    (\\<box>\\<diamond>enabled) s \\<longrightarrow>\n                    (\\<diamond>taken) s) =\n    \\<box>(\\<lambda>s.\n              (\\<box>\\<diamond>enabled) s \\<longrightarrow>\n              (\\<diamond>taken) s)", "by simp"], ["", "lemma eventually_strongly_fair:\n  \"\\<diamond>(strongly_fair enabled taken) = strongly_fair enabled taken\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>strongly_fair enabled taken = strongly_fair enabled taken", "unfolding strongly_fair_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond>\\<box>(\\<lambda>s.\n                        \\<not> (\\<box>(\\<lambda>s.\n    (\\<diamond>enabled) s \\<and> \\<not> taken s))\n                                s) =\n    \\<box>(\\<lambda>s.\n              \\<not> (\\<box>(\\<lambda>s.\n                                (\\<diamond>enabled) s \\<and>\n                                \\<not> taken s))\n                      s)", "by (simp add: always_eventually_always)"], ["", "lemma strongly_fair_disj_distrib: \\<comment> \\<open>not true for \\<open>weakly_fair\\<close>\\<close>\n  \"strongly_fair (enabled1 \\<^bold>\\<or> enabled2) taken = (strongly_fair enabled1 taken \\<^bold>\\<and> strongly_fair enabled2 taken)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strongly_fair (\\<lambda>s. enabled1 s \\<or> enabled2 s) taken =\n    (\\<lambda>s.\n        strongly_fair enabled1 taken s \\<and>\n        strongly_fair enabled2 taken s)", "unfolding strongly_fair_def defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        \\<forall>i.\n           (\\<forall>ia.\n               \\<exists>ib.\n                  (enabled1\n                    (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<or>\n                   enabled2\n                    (\\<sigma> |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib)) \\<and>\n                  (\\<forall>k<ib. True)) \\<longrightarrow>\n           (\\<exists>ia.\n               taken (\\<sigma> |\\<^sub>s i |\\<^sub>s ia) \\<and>\n               (\\<forall>k<ia. True))) =\n    (\\<lambda>s.\n        (\\<forall>i.\n            (\\<forall>ia.\n                \\<exists>ib.\n                   enabled1 (s |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<and>\n                   (\\<forall>k<ib. True)) \\<longrightarrow>\n            (\\<exists>ia.\n                taken (s |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                (\\<forall>k<ia. True))) \\<and>\n        (\\<forall>i.\n            (\\<forall>ia.\n                \\<exists>ib.\n                   enabled2 (s |\\<^sub>s i |\\<^sub>s ia |\\<^sub>s ib) \\<and>\n                   (\\<forall>k<ib. True)) \\<longrightarrow>\n            (\\<exists>ia.\n                taken (s |\\<^sub>s i |\\<^sub>s ia) \\<and>\n                (\\<forall>k<ia. True))))", "apply (auto simp: fun_eq_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n                          enabled2\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib. enabled1 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)\n 2. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n                          enabled2\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib. enabled2 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)\n 3. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>i.\n           (\\<forall>ia.\n               \\<exists>ib.\n                  enabled2 (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n           (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib.\n              enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n              enabled2 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n                          enabled2\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib. enabled2 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)\n 2. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>i.\n           (\\<forall>ia.\n               \\<exists>ib.\n                  enabled2 (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n           (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib.\n              enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n              enabled2 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<forall>i.\n                   (\\<forall>ia.\n                       \\<exists>ib.\n                          enabled1\n                           (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n                   (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>i.\n           (\\<forall>ia.\n               \\<exists>ib.\n                  enabled2 (x |\\<^sub>s i + ia + ib)) \\<longrightarrow>\n           (\\<exists>ia. taken (x |\\<^sub>s i + ia));\n        \\<forall>ia.\n           \\<exists>ib.\n              enabled1 (x |\\<^sub>s i + ia + ib) \\<or>\n              enabled2 (x |\\<^sub>s i + ia + ib)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia. taken (x |\\<^sub>s i + ia)", "apply (metis (full_types) semiring_normalization_rules(25))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strongly_fair_imp_weakly_fair:\n  assumes \"strongly_fair enabled taken \\<sigma>\"\n  shows \"weakly_fair enabled taken \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_fair enabled taken \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  strongly_fair enabled taken \\<sigma>\n\ngoal (1 subgoal):\n 1. weakly_fair enabled taken \\<sigma>", "unfolding strongly_fair_def3 weakly_fair_def3"], ["proof (prove)\nusing this:\n  (\\<box>\\<diamond>enabled) \\<sigma> \\<longrightarrow>\n  (\\<box>\\<diamond>taken) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<diamond>\\<box>enabled) \\<sigma> \\<longrightarrow>\n    (\\<box>\\<diamond>taken) \\<sigma>", "by (simp add: eventually_always_imp_always_eventually)"], ["", "lemma always_enabled_weakly_fair_strongly_fair:\n  assumes \"(\\<box>enabled) \\<sigma>\"\n  shows \"weakly_fair enabled taken \\<sigma> = strongly_fair enabled taken \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weakly_fair enabled taken \\<sigma> =\n    strongly_fair enabled taken \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  (\\<box>enabled) \\<sigma>\n\ngoal (1 subgoal):\n 1. weakly_fair enabled taken \\<sigma> =\n    strongly_fair enabled taken \\<sigma>", "by (metis strongly_fair_def3 strongly_fair_imp_weakly_fair unfold(2) weakly_fair_def3)"], ["", "subsection\\<open>Safety and liveness \\label{sec:ltl-safety-liveness}\\<close>"], ["", "text\\<open>\n\n@{cite [cite_macro=citet] \"Sistla:1994\"} shows some characterisations\nof LTL formulas in terms of safety and liveness. Note his @{term\n\"(\\<U>)\"} is actually @{term \"(\\<W>)\"}.\n\nSee also @{cite [cite_macro=citet] \"ChangMannaPnueli:1992\"}.\n\n\\<close>"], ["", "lemma safety_state_prop:\n  shows \"safety \\<lceil>P\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety \\<lceil>P\\<rceil>", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>\\<sigma>. P (\\<sigma> 0))", "by (rule safety_state_prop)"], ["", "lemma safety_Next:\n  assumes \"safety P\"\n  shows \"safety (\\<circle>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<circle>P)", "using assms"], ["proof (prove)\nusing this:\n  safety P\n\ngoal (1 subgoal):\n 1. safety (\\<circle>P)", "unfolding defs safety_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     \\<not> P \\<sigma> \\<longrightarrow>\n     (\\<exists>i. \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> P (\\<sigma> |\\<^sub>s 1) \\<longrightarrow>\n       (\\<exists>i.\n           \\<forall>\\<beta>.\n              \\<not> P (stake i \\<sigma> @- \\<beta> |\\<^sub>s 1))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<forall>\\<sigma>.\n                   \\<not> P \\<sigma> \\<longrightarrow>\n                   (\\<exists>i.\n                       \\<forall>\\<beta>.\n                          \\<not> P (stake i \\<sigma> @- \\<beta>));\n        \\<not> P (\\<sigma> |\\<^sub>s Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<forall>\\<beta>.\n                               (i = 0 \\<longrightarrow>\n                                \\<not> P (\\<beta> |\\<^sub>s Suc 0)) \\<and>\n                               (0 < i \\<longrightarrow>\n                                \\<not> P (tl (stake i \\<sigma>) @- \\<beta>))", "apply (metis (mono_tags) One_nat_def list.sel(3) nat.simps(3) stake.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safety_unless:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<W> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (P \\<W> Q)", "proof(rule safetyI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (\\<And>i.\n           \\<exists>\\<beta>.\n              (P \\<W> Q) (stake i \\<sigma> @- \\<beta>)) \\<Longrightarrow>\n       (P \\<W> Q) \\<sigma>", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (\\<And>i.\n           \\<exists>\\<beta>.\n              (P \\<W> Q) (stake i \\<sigma> @- \\<beta>)) \\<Longrightarrow>\n       (P \\<W> Q) \\<sigma>", "assume X: \"\\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>)\" for i"], ["proof (state)\nthis:\n  \\<exists>\\<beta>. (P \\<W> Q) (stake ?i \\<sigma> @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (\\<And>i.\n           \\<exists>\\<beta>.\n              (P \\<W> Q) (stake i \\<sigma> @- \\<beta>)) \\<Longrightarrow>\n       (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>. (P \\<W> Q) (stake ?i \\<sigma> @- \\<beta>)", "show \"(P \\<W> Q) \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>. (P \\<W> Q) (stake ?i \\<sigma> @- \\<beta>)\n\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "proof(cases \"\\<forall>i j. \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<forall>i j.\n        \\<exists>\\<beta>.\n           P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>\n 2. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "case True"], ["proof (state)\nthis:\n  \\<forall>i j. \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<forall>i j.\n        \\<exists>\\<beta>.\n           P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>\n 2. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "with \\<open>safety P\\<close>"], ["proof (chain)\npicking this:\n  safety P\n  \\<forall>i j. \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)", "have \"\\<forall>i. P (\\<sigma> |\\<^sub>s i)\""], ["proof (prove)\nusing this:\n  safety P\n  \\<forall>i j. \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (\\<sigma> |\\<^sub>s i)", "unfolding safety_def2"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     (\\<forall>i.\n         \\<exists>\\<beta>.\n            P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n     P \\<sigma>\n  \\<forall>i j. \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (\\<sigma> |\\<^sub>s i)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<forall>i j.\n        \\<exists>\\<beta>.\n           P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>\n 2. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. P (\\<sigma> |\\<^sub>s i)\n\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "by (blast intro: unless_alwaysI)"], ["proof (state)\nthis:\n  (P \\<W> Q) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i j.\n             \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i j.\n             \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))", "obtain k k' where \"\\<forall>\\<beta>. \\<not> P (\\<sigma>(k \\<rightarrow> k') @- \\<beta>)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i j.\n             \\<exists>\\<beta>. P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\n\ngoal (1 subgoal):\n 1. (\\<And>k' k.\n        \\<forall>\\<beta>.\n           \\<not> P (\\<sigma>(k \\<rightarrow> k') @-\n                     \\<beta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>\\<beta>. \\<not> P (\\<sigma>(k \\<rightarrow> k') @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<beta>. \\<not> P (\\<sigma>(k \\<rightarrow> k') @- \\<beta>)", "have \"\\<forall>i u. k + k' \\<le> i \\<longrightarrow> \\<not>P ((stake i \\<sigma> @- u) |\\<^sub>s k)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<beta>. \\<not> P (\\<sigma>(k \\<rightarrow> k') @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<forall>i u.\n       k + k' \\<le> i \\<longrightarrow>\n       \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)", "by (metis add.commute diff_add stake_shift_stake_shift stake_suffix_drop suffix_shift)"], ["proof (state)\nthis:\n  \\<forall>i u.\n     k + k' \\<le> i \\<longrightarrow>\n     \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<longrightarrow>\n     \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)", "have \"\\<forall>i u. k + k' \\<le> i \\<and> (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow> (\\<exists>m\\<le>k. Q ((stake i \\<sigma> @- u) |\\<^sub>s m) \\<and> (\\<forall>p<m. P ((stake i \\<sigma> @- u) |\\<^sub>s p)))\""], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<longrightarrow>\n     \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)\n\ngoal (1 subgoal):\n 1. \\<forall>i u.\n       k + k' \\<le> i \\<and>\n       (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n       (\\<exists>m\\<le>k.\n           Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n           (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))", "unfolding defs"], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<longrightarrow>\n     \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)\n\ngoal (1 subgoal):\n 1. \\<forall>i u.\n       k + k' \\<le> i \\<and>\n       ((\\<exists>ia.\n            Q (stake i \\<sigma> @- u |\\<^sub>s ia) \\<and>\n            (\\<forall>k<ia. P (stake i \\<sigma> @- u |\\<^sub>s k))) \\<or>\n        (\\<forall>ia.\n            P (stake i \\<sigma> @- u |\\<^sub>s ia))) \\<longrightarrow>\n       (\\<exists>m\\<le>k.\n           Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n           (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))", "using leI"], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<longrightarrow>\n     \\<not> P (stake i \\<sigma> @- u |\\<^sub>s k)\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>i u.\n       k + k' \\<le> i \\<and>\n       ((\\<exists>ia.\n            Q (stake i \\<sigma> @- u |\\<^sub>s ia) \\<and>\n            (\\<forall>k<ia. P (stake i \\<sigma> @- u |\\<^sub>s k))) \\<or>\n        (\\<forall>ia.\n            P (stake i \\<sigma> @- u |\\<^sub>s ia))) \\<longrightarrow>\n       (\\<exists>m\\<le>k.\n           Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n           (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))", "by blast"], ["proof (state)\nthis:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n         (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n         (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))", "have \"\\<forall>i u. k + k' \\<le> i \\<and> (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow> (\\<exists>m\\<le>k. Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and> (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))\""], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (stake i \\<sigma> @- u |\\<^sub>s m) \\<and>\n         (\\<forall>p<m. P (stake i \\<sigma> @- u |\\<^sub>s p)))\n\ngoal (1 subgoal):\n 1. \\<forall>i u.\n       k + k' \\<le> i \\<and>\n       (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n       (\\<exists>m\\<le>k.\n           Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and>\n           (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))", "by (metis stake_suffix add_leE nat_less_le order_trans)"], ["proof (state)\nthis:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and>\n         (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and>\n         (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))", "have \"\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. \\<exists>u. Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and> (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\""], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and>\n         (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>n\\<ge>i.\n          \\<exists>m\\<le>k.\n             \\<exists>u.\n                Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n                (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))", "using X"], ["proof (prove)\nusing this:\n  \\<forall>i u.\n     k + k' \\<le> i \\<and>\n     (P \\<W> Q) (stake i \\<sigma> @- u) \\<longrightarrow>\n     (\\<exists>m\\<le>k.\n         Q (\\<sigma>(m \\<rightarrow> i - m) @- u) \\<and>\n         (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> i - p) @- u)))\n  \\<exists>\\<beta>. (P \\<W> Q) (stake ?i \\<sigma> @- \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>n\\<ge>i.\n          \\<exists>m\\<le>k.\n             \\<exists>u.\n                Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n                (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))", "by (metis add.commute le_add1)"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>n\\<ge>i.\n        \\<exists>m\\<le>k.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     \\<exists>n\\<ge>i.\n        \\<exists>m\\<le>k.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))", "have \"\\<exists>m\\<le>k. \\<forall>i. \\<exists>n\\<ge>i. \\<exists>u. Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and> (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>n\\<ge>i.\n        \\<exists>m\\<le>k.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>k.\n       \\<forall>i.\n          \\<exists>n\\<ge>i.\n             \\<exists>u.\n                Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n                (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))", "by (simp add: always_eventually_pigeonhole)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>k.\n     \\<forall>i.\n        \\<exists>n\\<ge>i.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<exists>\\<beta>. (P \\<W> Q) (stake i \\<sigma> @- \\<beta>);\n     \\<not> (\\<forall>i j.\n                \\<exists>\\<beta>.\n                   P (\\<sigma>(i \\<rightarrow> j) @- \\<beta>))\\<rbrakk>\n    \\<Longrightarrow> (P \\<W> Q) \\<sigma>", "with \\<open>safety P\\<close> \\<open>safety Q\\<close>"], ["proof (chain)\npicking this:\n  safety P\n  safety Q\n  \\<exists>m\\<le>k.\n     \\<forall>i.\n        \\<exists>n\\<ge>i.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))", "show \"(P \\<W> Q) \\<sigma>\""], ["proof (prove)\nusing this:\n  safety P\n  safety Q\n  \\<exists>m\\<le>k.\n     \\<forall>i.\n        \\<exists>n\\<ge>i.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\n\ngoal (1 subgoal):\n 1. (P \\<W> Q) \\<sigma>", "unfolding defs"], ["proof (prove)\nusing this:\n  safety P\n  safety Q\n  \\<exists>m\\<le>k.\n     \\<forall>i.\n        \\<exists>n\\<ge>i.\n           \\<exists>u.\n              Q (\\<sigma>(m \\<rightarrow> n - m) @- u) \\<and>\n              (\\<forall>p<m. P (\\<sigma>(p \\<rightarrow> n - p) @- u))\n\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        Q (\\<sigma> |\\<^sub>s i) \\<and>\n        (\\<forall>k<i. P (\\<sigma> |\\<^sub>s k))) \\<or>\n    (\\<forall>i. P (\\<sigma> |\\<^sub>s i))", "by (metis Nat.le_diff_conv2 add_leE safety_always_eventually)"], ["proof (state)\nthis:\n  (P \\<W> Q) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P \\<W> Q) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma safety_always:\n  assumes \"safety P\"\n  shows \"safety (\\<box>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<box>P)", "using assms"], ["proof (prove)\nusing this:\n  safety P\n\ngoal (1 subgoal):\n 1. safety (\\<box>P)", "by (metis norm(20) safety_def safety_unless)"], ["", "lemma absolute_liveness_eventually:\n  shows \"absolute_liveness P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<diamond>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absolute_liveness P =\n    ((\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<diamond>P)", "unfolding absolute_liveness_def defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ex P \\<and>\n     (\\<forall>\\<sigma> \\<alpha>.\n         P \\<sigma> \\<longrightarrow> P (\\<alpha> @- \\<sigma>))) =\n    ((\\<exists>\\<sigma>. P \\<sigma>) \\<and>\n     P =\n     (\\<lambda>\\<sigma>.\n         \\<exists>i. P (\\<sigma> |\\<^sub>s i) \\<and> (\\<forall>k<i. True)))", "by (metis cancel_comm_monoid_add_class.diff_cancel drop_eq_Nil order_refl shift.simps(1) stake_suffix_id suffix_shift suffix_zero)"], ["", "lemma stable_always:\n  shows \"stable P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<box>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable P = ((\\<exists>\\<sigma>. P \\<sigma>) \\<and> P = \\<box>P)", "unfolding stable_def defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ex P \\<and>\n     (\\<forall>\\<sigma> i.\n         P \\<sigma> \\<longrightarrow> P (\\<sigma> |\\<^sub>s i))) =\n    ((\\<exists>\\<sigma>. P \\<sigma>) \\<and>\n     P = (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> |\\<^sub>s i)))", "by (metis suffix_zero)"], ["", "(* FIXME Sistla's examples of stable properties are boring and follow directly from this lemma.\n   FIXME the fairness \"type of formulas\" follow from the above and the fairness def. *)"], ["", "text\\<open>\n\nTo show that @{const \\<open>weakly_fair\\<close>} is a @{const \\<open>fairness\\<close>} property requires some constraints on \\<open>enabled\\<close> and \\<open>taken\\<close>:\n\\<^item> it is reasonable to assume they are state formulas\n\\<^item> \\<open>taken\\<close> must be satisfiable\n\n\\<close>"], ["", "lemma fairness_weakly_fair:\n  assumes \"\\<exists>s. taken s\"\n  shows \"fairness (weakly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fairness (weakly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)", "unfolding fairness_def stable_def absolute_liveness_def weakly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ex (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n     (\\<forall>\\<sigma> i.\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          \\<sigma> \\<longrightarrow>\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          (\\<sigma> |\\<^sub>s i))) \\<and>\n    Ex (\\<box>(\\<lambda>s.\n                  (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n    (\\<forall>\\<sigma> \\<alpha>.\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma> \\<longrightarrow>\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         (\\<alpha> @- \\<sigma>))", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>s. taken s\n\ngoal (1 subgoal):\n 1. (Ex (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n     (\\<forall>\\<sigma> i.\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          \\<sigma> \\<longrightarrow>\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          (\\<sigma> |\\<^sub>s i))) \\<and>\n    Ex (\\<box>(\\<lambda>s.\n                  (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n    (\\<forall>\\<sigma> \\<alpha>.\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma> \\<longrightarrow>\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         (\\<alpha> @- \\<sigma>))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 2. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 3. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 4. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (rule_tac x=\"\\<lambda>_ .s\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s))\n        (\\<lambda>_. s)\n 2. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 3. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 4. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 2. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 3. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (simp add: alwaysD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 2. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (rule_tac x=\"\\<lambda>_ .s\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s))\n        (\\<lambda>_. s)\n 2. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<lceil>enabled\\<rceil>) s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (metis (full_types) absolute_liveness_def absolute_liveness_eventually eventually_weakly_fair weakly_fair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fairness_strongly_fair:\n  assumes \"\\<exists>s. taken s\"\n  shows \"fairness (strongly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fairness (strongly_fair \\<lceil>enabled\\<rceil> \\<lceil>taken\\<rceil>)", "unfolding fairness_def stable_def absolute_liveness_def strongly_fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ex (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n     (\\<forall>\\<sigma> i.\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                     s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          \\<sigma> \\<longrightarrow>\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                     s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          (\\<sigma> |\\<^sub>s i))) \\<and>\n    Ex (\\<box>(\\<lambda>s.\n                  (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                   s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n    (\\<forall>\\<sigma> \\<alpha>.\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma> \\<longrightarrow>\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         (\\<alpha> @- \\<sigma>))", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>s. taken s\n\ngoal (1 subgoal):\n 1. (Ex (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n     (\\<forall>\\<sigma> i.\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                     s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          \\<sigma> \\<longrightarrow>\n         (\\<box>(\\<lambda>s.\n                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                     s \\<longrightarrow>\n                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n          (\\<sigma> |\\<^sub>s i))) \\<and>\n    Ex (\\<box>(\\<lambda>s.\n                  (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                   s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s)) \\<and>\n    (\\<forall>\\<sigma> \\<alpha>.\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma> \\<longrightarrow>\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         (\\<alpha> @- \\<sigma>))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                      s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 2. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 3. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                      s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 4. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (rule_tac x=\"\\<lambda>_ .s\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                   s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s))\n        (\\<lambda>_. s)\n 2. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 3. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                      s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 4. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s \\<sigma> i.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<sigma> |\\<^sub>s i)\n 2. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                      s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 3. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (simp add: alwaysD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       Ex (\\<box>(\\<lambda>s.\n                     (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                      s \\<longrightarrow>\n                     (\\<diamond>\\<lceil>taken\\<rceil>) s))\n 2. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (rule_tac x=\"\\<lambda>_ .s\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       taken s \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                   s \\<longrightarrow>\n                  (\\<diamond>\\<lceil>taken\\<rceil>) s))\n        (\\<lambda>_. s)\n 2. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s \\<sigma> \\<alpha>.\n       \\<lbrakk>taken s;\n        (\\<box>(\\<lambda>s.\n                   (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                    s \\<longrightarrow>\n                   (\\<diamond>\\<lceil>taken\\<rceil>) s))\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>(\\<lambda>s.\n                                    (\\<box>\\<diamond>\\<lceil>enabled\\<rceil>)\n                                     s \\<longrightarrow>\n                                    (\\<diamond>\\<lceil>taken\\<rceil>) s))\n                          (\\<alpha> @- \\<sigma>)", "apply (metis (full_types) absolute_liveness_def absolute_liveness_eventually eventually_weakly_fair weakly_fair_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}