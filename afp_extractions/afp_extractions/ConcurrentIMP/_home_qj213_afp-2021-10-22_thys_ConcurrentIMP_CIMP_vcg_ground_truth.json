{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP/CIMP_vcg.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP", "problem_names": ["lemma small_step_stuck:\n  \"\\<not> ([], s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> c'\"", "lemma atS_state_weak_cong[cong]:\n  \"AT s p = AT s' p \\<Longrightarrow> atS p ls s \\<longleftrightarrow> atS p ls s'\"", "lemma atS_simps:\n  \"\\<not>atS p {} s\"\n  \"atS p {l} s \\<longleftrightarrow> at p l s\"\n  \"\\<lbrakk>at p l s; l \\<in> ls\\<rbrakk> \\<Longrightarrow> atS p ls s\"\n  \"(\\<forall>l. at p l s \\<longrightarrow> l \\<notin> ls) \\<Longrightarrow> \\<not>atS p ls s\"", "lemma atS_mono:\n  \"\\<lbrakk>atS p ls s; ls \\<subseteq> ls'\\<rbrakk> \\<Longrightarrow> atS p ls' s\"", "lemma atS_un:\n  \"atS p (l \\<union> l') s \\<longleftrightarrow> atS p l s \\<or> atS p l' s\"", "lemma atLs_disj_union[simp]:\n  \"(atLs p label0 \\<^bold>\\<or> atLs p label1) = atLs p (label0 \\<union> label1)\"", "lemma atLs_insert_disj:\n  \"atLs p (insert l label0) = (atL p l \\<^bold>\\<or> atLs p label0)\"", "lemma small_step_terminated:\n  \"s \\<rightarrow>\\<^bsub>x\\<^esub> s' \\<Longrightarrow> atCs (fst s) = {} \\<Longrightarrow> atCs (fst s') = {}\"", "lemma atC_not_empty:\n  \"atC c \\<noteq> {}\"", "lemma atCs_empty:\n  \"atCs cs = {} \\<longleftrightarrow> cs = []\"", "lemma terminated_no_commands:\n  assumes \"terminated p sh\"\n  shows \"\\<exists>s. GST sh p = ([], s)\"", "lemma terminated_GST_stable:\n  assumes \"system_step q sh' sh\"\n  assumes \"terminated p sh\"\n  shows \"GST sh p = GST sh' p\"", "lemma terminated_stable:\n  assumes \"system_step q sh' sh\"\n  assumes \"terminated p sh\"\n  shows \"terminated p sh'\"", "lemma system_step_pls_nonempty:\n  assumes \"system_step pls sh' sh\"\n  shows \"pls \\<noteq> {}\"", "lemma system_step_no_change:\n  assumes \"system_step ps sh' sh\"\n  assumes \"p \\<notin> ps\"\n  shows \"GST sh' p = GST sh p\"", "lemma initial_stateD:\n  assumes \"initial_state sys s\"\n  shows \"AT (\\<lparr>GST = s, HST = []\\<rparr>) = atC \\<circ> PGMs sys \\<and> INIT sys (\\<lparr>GST = s, HST = []\\<rparr>)\\<down> \\<and> (\\<forall>p l. \\<not>taken p l \\<lparr>GST = s, HST = []\\<rparr>)\"", "lemma initial_states_initial[iff]:\n  assumes \"initial_state sys s\"\n  shows \"at p l (\\<lparr>GST = s, HST = []\\<rparr>) \\<longleftrightarrow> l \\<in> atC (PGMs sys p)\"", "lemma reachable_stateE:\n  assumes \"reachable_state sys sh\"\n  assumes \"\\<And>\\<sigma> i. prerun sys \\<sigma> \\<Longrightarrow> P (\\<sigma> i)\"\n  shows \"P sh\"", "lemma prerun_reachable_state:\n  assumes \"prerun sys \\<sigma>\"\n  shows \"reachable_state sys (\\<sigma> i)\"", "lemma reachable_state_induct[consumes 1, case_names init LocalStep CommunicationStep, induct set: reachable_state]:\n  assumes r: \"reachable_state sys sh\"\n  assumes i: \"\\<And>s. initial_state sys s \\<Longrightarrow> P \\<lparr>GST = s, HST = []\\<rparr>\"\n  assumes l: \"\\<And>sh ls' p. \\<lbrakk>reachable_state sys sh; P sh; GST sh p \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'\\<rbrakk> \\<Longrightarrow> P \\<lparr>GST = (GST sh)(p := ls'), HST = HST sh\\<rparr>\"\n  assumes c: \"\\<And>sh ls1' ls2' p1 p2 \\<alpha> \\<beta>.\n                 \\<lbrakk>reachable_state sys sh; P sh;\n                 GST sh p1 \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1'; GST sh p2 \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2'; p1 \\<noteq> p2 \\<rbrakk>\n                    \\<Longrightarrow> P \\<lparr>GST = (GST sh)(p1 := ls1', p2 := ls2'), HST = HST sh @ [(\\<alpha>, \\<beta>)]\\<rparr>\"\n  shows \"P sh\"", "lemma prerun_valid_TrueI:\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> \\<langle>True\\<rangle>\"", "lemma prerun_valid_conjI:\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> P\"\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> Q\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> P \\<^bold>\\<and> Q\"", "lemma valid_prerun_lift:\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"\n  shows \"sys \\<Turnstile> \\<box>\\<lceil>I\\<rceil>\"", "lemma prerun_valid_induct:\n  assumes \"\\<And>\\<sigma>. prerun sys \\<sigma> \\<Longrightarrow> \\<lceil>I\\<rceil> \\<sigma>\"\n  assumes \"\\<And>\\<sigma>. prerun sys \\<sigma> \\<Longrightarrow> (\\<lceil>I\\<rceil> \\<^bold>\\<hookrightarrow> (\\<circle>\\<lceil>I\\<rceil>)) \\<sigma>\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"", "lemma prerun_validI:\n  assumes \"\\<And>s. reachable_state sys s \\<Longrightarrow> I s\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"", "lemma prerun_validE:\n  assumes \"reachable_state sys s\"\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"\n  shows \"I s\"", "lemma lcond_split:\n  \"Q (lcond lp lp' b s) \\<longleftrightarrow> (b s \\<longrightarrow> Q lp) \\<and> (\\<not>b s \\<longrightarrow> Q lp')\"", "lemma lcond_split_asm:\n  \"Q (lcond lp lp' b s) \\<longleftrightarrow> \\<not> ((b s \\<and> \\<not>Q lp) \\<or> (\\<not>b s \\<and> \\<not> Q lp'))\"", "lemmas lcond_splits = lcond_split lcond_split_asm", "lemma small_step_fragmentsLS:\n  assumes \"s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\"\n  shows \"fragmentsLS s' \\<subseteq> fragmentsLS s\"", "lemma reachable_state_fragmentsLS:\n  assumes \"reachable_state sys sh\"\n  shows \"fragmentsLS (GST sh p) \\<subseteq> fragments (PGMs sys p) {}\"", "lemma fragments_basic_com:\n  assumes \"(c', aft') \\<in> fragments c aft\"\n  shows \"basic_com c'\"", "lemma fragmentsL_basic_com:\n  assumes \"(c', aft') \\<in> fragmentsL cs\"\n  shows \"basic_com c'\"", "lemma ctxt_inj:\n  assumes \"(E, fctxt) \\<in> ctxt\"\n  assumes \"E x = E y\"\n  shows \"x = y\"", "lemma decompose_com_non_empty: \"decompose_com c \\<noteq> {}\"", "lemma decompose_com_basic_com:\n  assumes \"(c', ctxts) \\<in> decompose_com c\"\n  shows \"basic_com c'\"", "lemma decomposeLS_basic_com:\n  assumes \"(c', ctxts) \\<in> decomposeLS s\"\n  shows \"basic_com c'\"", "lemma decompose_com_ctxt:\n  assumes \"(c', ctxts) \\<in> decompose_com c\"\n  shows \"ctxts \\<in> ctxt\"", "lemma decompose_com_ictxt:\n  assumes \"(c', ictxt, fctxt) \\<in> decompose_com c\"\n  shows \"ictxt c' = c\"", "lemma decompose_com_small_step:\n  assumes as: \"(c' # fctxt c' @ cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\"\n  assumes ds: \"(c', ictxt, fctxt) \\<in> decompose_com c\"\n  shows \"(c # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\"", "theorem context_decompose:\n  \"s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<longleftrightarrow> (\\<exists>(c, ictxt, fctxt) \\<in> decomposeLS s.\n                     cPGM s = ictxt c # tl (cPGM s)\n                   \\<and> (c # fctxt c @ tl (cPGM s), cTKN s, cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n                   \\<and> (\\<forall>l\\<in>atC c. cTKN s' = Some l))\" (is \"?lhs = ?rhs\")", "lemma decompose_fragments:\n  assumes \"(c, ictxt, fctxt) \\<in> decompose_com c0\"\n  shows \"(c, loc_compC c (fctxt c @ cs)) \\<in> fragments c0 (atCs cs)\"", "lemma at_decompose:\n  assumes \"(c, ictxt, fctxt) \\<in> decompose_com c0\"\n  shows \"atC c \\<subseteq> atC c0\"", "lemma at_decomposeLS:\n  assumes \"(c, ictxt, fctxt) \\<in> decomposeLS s\"\n  shows \"atC c \\<subseteq> atCs (cPGM s)\"", "lemma decomposeLS_fragmentsLS:\n  assumes \"(c, ictxt, fctxt) \\<in> decomposeLS s\"\n  shows \"(c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s\"", "lemma small_step_loc_compC:\n  assumes \"basic_com c\"\n  assumes \"(c # cs, ls) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ls'\"\n  shows \"loc_compC c cs (snd ls) = atCs (cPGM ls')\"", "theorem decompose_small_step:\n  assumes \"GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps'\"\n  assumes \"reachable_state sys sh\"\n  obtains c cs aft\n    where \"(c, aft) \\<in> fragments (PGMs sys p) {}\"\n      and \"atC c \\<subseteq> atCs (cPGM (GST sh p))\"\n      and \"aft (cLST (GST sh p)) = atCs (cPGM ps')\"\n      and \"(c # cs, cTKN (GST sh p), cLST (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps'\"\n      and \"\\<forall>l\\<in>atC c. cTKN ps' = Some l\"", "lemma fragments_vcg_fragments':\n  \"\\<lbrakk> (c, aft) \\<in> fragments c' aft'; \\<not>isResponse c \\<rbrakk> \\<Longrightarrow> (c, aft) \\<in> vcg_fragments' c' aft'\"", "lemma vcg_fragments'_fragments:\n  \"vcg_fragments' c' aft' \\<subseteq> fragments c' aft'\"", "lemma VCG_step:\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> c \\<lbrace>post\\<rbrace>\"\n  assumes S: \"system_step p sh' sh\"\n  assumes R: \"reachable_state sys sh\"\n  assumes P: \"pre sh\"\n  shows \"post sh'\"", "lemma VCG_step_inv_stable:\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c\"\n  assumes \"prerun sys \\<sigma>\"\n  shows \"(\\<lceil>I\\<rceil> \\<^bold>\\<hookrightarrow> \\<circle>\\<lceil>I\\<rceil>) \\<sigma>\"", "lemma VCG:\n  assumes I: \"\\<forall>s. initial_state sys s \\<longrightarrow> I (\\<lparr>GST = s, HST = []\\<rparr>)\"\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"", "lemmas VCG_valid = valid_prerun_lift[OF VCG, of sys I] for sys I"], "translations": [["", "lemma small_step_stuck:\n  \"\\<not> ([], s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ([], s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> c'", "by (auto elim: small_step.cases)"], ["", "declare system_step.intros[intro]"], ["", "text\\<open>\n\nBy default we ask the simplifier to rewrite @{const \"atS\"} using\nambient @{const \"AT\"} information.\n\n\\<close>"], ["", "lemma atS_state_weak_cong[cong]:\n  \"AT s p = AT s' p \\<Longrightarrow> atS p ls s \\<longleftrightarrow> atS p ls s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT s p = AT s' p \\<Longrightarrow> atS p ls s = atS p ls s'", "by (auto simp: atS_def)"], ["", "text\\<open>\n\nWe provide an incomplete set of basic rules for label sets.\n\n\\<close>"], ["", "lemma atS_simps:\n  \"\\<not>atS p {} s\"\n  \"atS p {l} s \\<longleftrightarrow> at p l s\"\n  \"\\<lbrakk>at p l s; l \\<in> ls\\<rbrakk> \\<Longrightarrow> atS p ls s\"\n  \"(\\<forall>l. at p l s \\<longrightarrow> l \\<notin> ls) \\<Longrightarrow> \\<not>atS p ls s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> atS p {} s &&& atS p {l} s = at p l s) &&&\n    (\\<lbrakk>at p l s; l \\<in> ls\\<rbrakk>\n     \\<Longrightarrow> atS p ls s) &&&\n    (\\<forall>l. at p l s \\<longrightarrow> l \\<notin> ls \\<Longrightarrow>\n     \\<not> atS p ls s)", "by (auto simp: atS_def)"], ["", "lemma atS_mono:\n  \"\\<lbrakk>atS p ls s; ls \\<subseteq> ls'\\<rbrakk> \\<Longrightarrow> atS p ls' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atS p ls s; ls \\<subseteq> ls'\\<rbrakk>\n    \\<Longrightarrow> atS p ls' s", "by (auto simp: atS_def)"], ["", "lemma atS_un:\n  \"atS p (l \\<union> l') s \\<longleftrightarrow> atS p l s \\<or> atS p l' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atS p (l \\<union> l') s = (atS p l s \\<or> atS p l' s)", "by (auto simp: atS_def)"], ["", "lemma atLs_disj_union[simp]:\n  \"(atLs p label0 \\<^bold>\\<or> atLs p label1) = atLs p (label0 \\<union> label1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. atLs p label0 s \\<or> atLs p label1 s) =\n    atLs p (label0 \\<union> label1)", "unfolding atLs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. AT s p \\<in> label0 \\<or> AT s p \\<in> label1) =\n    (\\<lambda>s. AT s p \\<in> label0 \\<union> label1)", "by simp"], ["", "lemma atLs_insert_disj:\n  \"atLs p (insert l label0) = (atL p l \\<^bold>\\<or> atLs p label0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atLs p (insert l label0) =\n    (\\<lambda>s. atLs p {l} s \\<or> atLs p label0 s)", "by simp"], ["", "lemma small_step_terminated:\n  \"s \\<rightarrow>\\<^bsub>x\\<^esub> s' \\<Longrightarrow> atCs (fst s) = {} \\<Longrightarrow> atCs (fst s') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<rightarrow>\\<^bsub>x\\<^esub> s';\n     atCs (cPGM s) = {}\\<rbrakk>\n    \\<Longrightarrow> atCs (cPGM s') = {}", "by (induct pred: small_step) auto"], ["", "lemma atC_not_empty:\n  \"atC c \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atC c \\<noteq> {}", "by (induct c) auto"], ["", "lemma atCs_empty:\n  \"atCs cs = {} \\<longleftrightarrow> cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atCs cs = {}) = (cs = [])", "by (induct cs) (auto simp: atC_not_empty)"], ["", "lemma terminated_no_commands:\n  assumes \"terminated p sh\"\n  shows \"\\<exists>s. GST sh p = ([], s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. GST sh p = ([], s)", "using assms"], ["proof (prove)\nusing this:\n  atLs p {{}} sh\n\ngoal (1 subgoal):\n 1. \\<exists>s. GST sh p = ([], s)", "unfolding atLs_def AT_def"], ["proof (prove)\nusing this:\n  atCs (cPGM (GST sh p)) \\<in> {{}}\n\ngoal (1 subgoal):\n 1. \\<exists>s. GST sh p = ([], s)", "by (metis atCs_empty prod.collapse singletonD)"], ["", "lemma terminated_GST_stable:\n  assumes \"system_step q sh' sh\"\n  assumes \"terminated p sh\"\n  shows \"GST sh p = GST sh' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GST sh p = GST sh' p", "using assms"], ["proof (prove)\nusing this:\n  system_step q sh' sh\n  atLs p {{}} sh\n\ngoal (1 subgoal):\n 1. GST sh p = GST sh' p", "by (auto dest!: terminated_no_commands simp: small_step_stuck elim!: system_step.cases)"], ["", "lemma terminated_stable:\n  assumes \"system_step q sh' sh\"\n  assumes \"terminated p sh\"\n  shows \"terminated p sh'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atLs p {{}} sh'", "using assms"], ["proof (prove)\nusing this:\n  system_step q sh' sh\n  atLs p {{}} sh\n\ngoal (1 subgoal):\n 1. atLs p {{}} sh'", "unfolding atLs_def AT_def"], ["proof (prove)\nusing this:\n  system_step q sh' sh\n  atCs (cPGM (GST sh p)) \\<in> {{}}\n\ngoal (1 subgoal):\n 1. atCs (cPGM (GST sh' p)) \\<in> {{}}", "by (fastforce split: if_splits prod.splits\n               dest: small_step_terminated\n              elim!: system_step.cases)"], ["", "lemma system_step_pls_nonempty:\n  assumes \"system_step pls sh' sh\"\n  shows \"pls \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pls \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  system_step pls sh' sh\n\ngoal (1 subgoal):\n 1. pls \\<noteq> {}", "by cases simp_all"], ["", "lemma system_step_no_change:\n  assumes \"system_step ps sh' sh\"\n  assumes \"p \\<notin> ps\"\n  shows \"GST sh' p = GST sh p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GST sh' p = GST sh p", "using assms"], ["proof (prove)\nusing this:\n  system_step ps sh' sh\n  p \\<notin> ps\n\ngoal (1 subgoal):\n 1. GST sh' p = GST sh p", "by cases simp_all"], ["", "lemma initial_stateD:\n  assumes \"initial_state sys s\"\n  shows \"AT (\\<lparr>GST = s, HST = []\\<rparr>) = atC \\<circ> PGMs sys \\<and> INIT sys (\\<lparr>GST = s, HST = []\\<rparr>)\\<down> \\<and> (\\<forall>p l. \\<not>taken p l \\<lparr>GST = s, HST = []\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AT \\<lparr>GST = s, HST = []\\<rparr> = atC \\<circ> PGMs sys \\<and>\n    INIT sys \\<lparr>GST = s, HST = []\\<rparr>\\<down> \\<and>\n    (\\<forall>p l. \\<not> taken p l \\<lparr>GST = s, HST = []\\<rparr>)", "using assms"], ["proof (prove)\nusing this:\n  initial_state sys s\n\ngoal (1 subgoal):\n 1. AT \\<lparr>GST = s, HST = []\\<rparr> = atC \\<circ> PGMs sys \\<and>\n    INIT sys \\<lparr>GST = s, HST = []\\<rparr>\\<down> \\<and>\n    (\\<forall>p l. \\<not> taken p l \\<lparr>GST = s, HST = []\\<rparr>)", "unfolding initial_state_def split_def o_def LST_def AT_def taken_def"], ["proof (prove)\nusing this:\n  (\\<forall>p. cPGM (s p) = [PGMs sys p] \\<and> cTKN (s p) = None) \\<and>\n  INIT sys (\\<lambda>x. cLST (s x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. atCs (cPGM (GST \\<lparr>GST = s, HST = []\\<rparr> p))) =\n    (\\<lambda>x. atC (PGMs sys x)) \\<and>\n    INIT sys\n     (\\<lambda>x. cLST (GST \\<lparr>GST = s, HST = []\\<rparr> x)) \\<and>\n    (\\<forall>p l.\n        cTKN (GST \\<lparr>GST = s, HST = []\\<rparr> p) \\<noteq> Some l)", "by simp"], ["", "lemma initial_states_initial[iff]:\n  assumes \"initial_state sys s\"\n  shows \"at p l (\\<lparr>GST = s, HST = []\\<rparr>) \\<longleftrightarrow> l \\<in> atC (PGMs sys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at p l \\<lparr>GST = s, HST = []\\<rparr> = (l \\<in> atC (PGMs sys p))", "using assms"], ["proof (prove)\nusing this:\n  initial_state sys s\n\ngoal (1 subgoal):\n 1. at p l \\<lparr>GST = s, HST = []\\<rparr> = (l \\<in> atC (PGMs sys p))", "unfolding initial_state_def split_def AT_def"], ["proof (prove)\nusing this:\n  (\\<forall>p. cPGM (s p) = [PGMs sys p] \\<and> cTKN (s p) = None) \\<and>\n  INIT sys (cLST \\<circ> s)\n\ngoal (1 subgoal):\n 1. (l \\<in> atCs (cPGM (GST \\<lparr>GST = s, HST = []\\<rparr> p))) =\n    (l \\<in> atC (PGMs sys p))", "by simp"], ["", "definition\n  reachable_state :: \"('answer, 'location, 'proc, 'question, 'state, 'ext) pre_system_ext\n                    \\<Rightarrow> ('answer, 'location, 'proc, 'question, 'state) state_pred\"\nwhere\n  \"reachable_state sys s \\<longleftrightarrow> (\\<exists>\\<sigma> i. prerun sys \\<sigma> \\<and> \\<sigma> i = s)\""], ["", "lemma reachable_stateE:\n  assumes \"reachable_state sys sh\"\n  assumes \"\\<And>\\<sigma> i. prerun sys \\<sigma> \\<Longrightarrow> P (\\<sigma> i)\"\n  shows \"P sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P sh", "using assms"], ["proof (prove)\nusing this:\n  reachable_state sys sh\n  prerun sys ?\\<sigma> \\<Longrightarrow> P (?\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. P sh", "unfolding reachable_state_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma> i. prerun sys \\<sigma> \\<and> \\<sigma> i = sh\n  prerun sys ?\\<sigma> \\<Longrightarrow> P (?\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. P sh", "by blast"], ["", "lemma prerun_reachable_state:\n  assumes \"prerun sys \\<sigma>\"\n  shows \"reachable_state sys (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_state sys (\\<sigma> i)", "using assms"], ["proof (prove)\nusing this:\n  prerun sys \\<sigma>\n\ngoal (1 subgoal):\n 1. reachable_state sys (\\<sigma> i)", "unfolding prerun_def LTL.defs system_step_reflclp_def reachable_state_def"], ["proof (prove)\nusing this:\n  (initial_state sys (GST (\\<sigma> 0)) \\<and> HST (\\<sigma> 0) = []) \\<and>\n  (\\<forall>i.\n      (\\<lambda>sh sh'.\n          \\<exists>pls. system_step pls sh' sh)\\<^sup>=\\<^sup>=\n       ((\\<sigma> |\\<^sub>s i) 0) ((\\<sigma> |\\<^sub>s i) 1))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' ia.\n       ((initial_state sys (GST (\\<sigma>' 0)) \\<and>\n         HST (\\<sigma>' 0) = []) \\<and>\n        (\\<forall>i.\n            (\\<lambda>sh sh'.\n                \\<exists>pls. system_step pls sh' sh)\\<^sup>=\\<^sup>=\n             ((\\<sigma>' |\\<^sub>s i) 0)\n             ((\\<sigma>' |\\<^sub>s i) 1))) \\<and>\n       \\<sigma>' ia = \\<sigma> i", "by auto"], ["", "lemma reachable_state_induct[consumes 1, case_names init LocalStep CommunicationStep, induct set: reachable_state]:\n  assumes r: \"reachable_state sys sh\"\n  assumes i: \"\\<And>s. initial_state sys s \\<Longrightarrow> P \\<lparr>GST = s, HST = []\\<rparr>\"\n  assumes l: \"\\<And>sh ls' p. \\<lbrakk>reachable_state sys sh; P sh; GST sh p \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'\\<rbrakk> \\<Longrightarrow> P \\<lparr>GST = (GST sh)(p := ls'), HST = HST sh\\<rparr>\"\n  assumes c: \"\\<And>sh ls1' ls2' p1 p2 \\<alpha> \\<beta>.\n                 \\<lbrakk>reachable_state sys sh; P sh;\n                 GST sh p1 \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1'; GST sh p2 \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2'; p1 \\<noteq> p2 \\<rbrakk>\n                    \\<Longrightarrow> P \\<lparr>GST = (GST sh)(p1 := ls1', p2 := ls2'), HST = HST sh @ [(\\<alpha>, \\<beta>)]\\<rparr>\"\n  shows \"P sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P sh", "using r"], ["proof (prove)\nusing this:\n  reachable_state sys sh\n\ngoal (1 subgoal):\n 1. P sh", "proof(rule reachable_stateE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i. prerun sys \\<sigma> \\<Longrightarrow> P (\\<sigma> i)", "fix \\<sigma> i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i. prerun sys \\<sigma> \\<Longrightarrow> P (\\<sigma> i)", "assume \"prerun sys \\<sigma>\""], ["proof (state)\nthis:\n  prerun sys \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i. prerun sys \\<sigma> \\<Longrightarrow> P (\\<sigma> i)", "show \"P (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (\\<sigma> i)", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. P (\\<sigma> 0)\n 2. \\<And>i. P (\\<sigma> i) \\<Longrightarrow> P (\\<sigma> (Suc i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P (\\<sigma> 0)\n 2. \\<And>i. P (\\<sigma> i) \\<Longrightarrow> P (\\<sigma> (Suc i))", "from \\<open>prerun sys \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  prerun sys \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  prerun sys \\<sigma>\n\ngoal (1 subgoal):\n 1. P (\\<sigma> 0)", "unfolding prerun_def"], ["proof (prove)\nusing this:\n  (initial_state sys (GST (\\<sigma> 0)) \\<and> HST (\\<sigma> 0) = []) \\<and>\n  (\\<box>system_step_reflclp) \\<sigma>\n\ngoal (1 subgoal):\n 1. P (\\<sigma> 0)", "by (metis (full_types) i old.unit.exhaust system_state.surjective)"], ["proof (state)\nthis:\n  P (\\<sigma> 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. P (\\<sigma> i) \\<Longrightarrow> P (\\<sigma> (Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. P (\\<sigma> i) \\<Longrightarrow> P (\\<sigma> (Suc i))", "case (Suc i)"], ["proof (state)\nthis:\n  P (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. \\<And>i. P (\\<sigma> i) \\<Longrightarrow> P (\\<sigma> (Suc i))", "with \\<open>prerun sys \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  prerun sys \\<sigma>\n  P (\\<sigma> i)", "show ?case"], ["proof (prove)\nusing this:\n  prerun sys \\<sigma>\n  P (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. P (\\<sigma> (Suc i))", "unfolding prerun_def LTL.defs system_step_reflclp_def reachable_state_def"], ["proof (prove)\nusing this:\n  (initial_state sys (GST (\\<sigma> 0)) \\<and> HST (\\<sigma> 0) = []) \\<and>\n  (\\<forall>i.\n      (\\<lambda>sh sh'.\n          \\<exists>pls. system_step pls sh' sh)\\<^sup>=\\<^sup>=\n       ((\\<sigma> |\\<^sub>s i) 0) ((\\<sigma> |\\<^sub>s i) 1))\n  P (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. P (\\<sigma> (Suc i))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n     HST (\\<sigma> 0) = [];\n     \\<forall>i.\n        (\\<exists>pls.\n            system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)) \\<or>\n        \\<sigma> i = \\<sigma> (Suc i)\\<rbrakk>\n    \\<Longrightarrow> P (\\<sigma> (Suc i))", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n     HST (\\<sigma> 0) = [];\n     (\\<exists>pls. system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)) \\<or>\n     \\<sigma> i = \\<sigma> (Suc i)\\<rbrakk>\n    \\<Longrightarrow> P (\\<sigma> (Suc i))", "apply (erule disjE; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pls.\n       \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> (Suc i))", "apply (erule system_step.cases; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p a aa b.\n       \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        GST (\\<sigma> i) p \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (a, aa, b);\n        GST (\\<sigma> (Suc i)) = (GST (\\<sigma> i))(p := (a, aa, b));\n        HST (\\<sigma> (Suc i)) = HST (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> (Suc i))\n 2. \\<And>p \\<alpha> \\<beta> a aa b q ab ac ba.\n       \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        GST (\\<sigma> i)\n         p \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (a,\n                aa, b);\n        GST (\\<sigma> i)\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (ab,\n                ac, ba);\n        p \\<noteq> q;\n        GST (\\<sigma> (Suc i)) = (GST (\\<sigma> i))\n        (p := (a, aa, b), q := (ab, ac, ba));\n        HST (\\<sigma> (Suc i)) =\n        HST (\\<sigma> i) @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> (Suc i))", "apply (metis (full_types) \\<open>prerun sys \\<sigma>\\<close> l old.unit.exhaust prerun_reachable_state system_state.surjective)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p \\<alpha> \\<beta> a aa b q ab ac ba.\n       \\<lbrakk>P (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        GST (\\<sigma> i)\n         p \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (a,\n                aa, b);\n        GST (\\<sigma> i)\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (ab,\n                ac, ba);\n        p \\<noteq> q;\n        GST (\\<sigma> (Suc i)) = (GST (\\<sigma> i))\n        (p := (a, aa, b), q := (ab, ac, ba));\n        HST (\\<sigma> (Suc i)) =\n        HST (\\<sigma> i) @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma> (Suc i))", "apply (metis (full_types) \\<open>prerun sys \\<sigma>\\<close> c old.unit.exhaust prerun_reachable_state system_state.surjective)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (\\<sigma> (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (\\<sigma> i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prerun_valid_TrueI:\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> \\<langle>True\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> \\<lambda>s. True", "unfolding prerun_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>\\<lambda>s. True\\<rceil>) \\<sigma>", "by simp"], ["", "lemma prerun_valid_conjI:\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> P\"\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> Q\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> P \\<^bold>\\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> \\<lambda>s. P s \\<and> Q s", "using assms"], ["proof (prove)\nusing this:\n  sys \\<Turnstile>\\<^bsub>pre\\<^esub> P\n  sys \\<Turnstile>\\<^bsub>pre\\<^esub> Q\n\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> \\<lambda>s. P s \\<and> Q s", "unfolding prerun_valid_def always_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     prerun sys \\<sigma> \\<longrightarrow>\n     (\\<forall>i. \\<lceil>P\\<rceil> (\\<sigma> |\\<^sub>s i))\n  \\<forall>\\<sigma>.\n     prerun sys \\<sigma> \\<longrightarrow>\n     (\\<forall>i. \\<lceil>Q\\<rceil> (\\<sigma> |\\<^sub>s i))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<forall>i.\n           \\<lceil>\\<lambda>s. P s \\<and> Q s\\<rceil>\n            (\\<sigma> |\\<^sub>s i))", "by simp"], ["", "lemma valid_prerun_lift:\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"\n  shows \"sys \\<Turnstile> \\<box>\\<lceil>I\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile> \\<box>\\<lceil>I\\<rceil>", "using assms"], ["proof (prove)\nusing this:\n  sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\n\ngoal (1 subgoal):\n 1. sys \\<Turnstile> \\<box>\\<lceil>I\\<rceil>", "unfolding prerun_valid_def valid_def run_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     prerun sys \\<sigma> \\<longrightarrow>\n     (\\<box>\\<lceil>I\\<rceil>) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<and> FAIR sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>I\\<rceil>) \\<sigma>", "by blast"], ["", "lemma prerun_valid_induct:\n  assumes \"\\<And>\\<sigma>. prerun sys \\<sigma> \\<Longrightarrow> \\<lceil>I\\<rceil> \\<sigma>\"\n  assumes \"\\<And>\\<sigma>. prerun sys \\<sigma> \\<Longrightarrow> (\\<lceil>I\\<rceil> \\<^bold>\\<hookrightarrow> (\\<circle>\\<lceil>I\\<rceil>)) \\<sigma>\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> I", "unfolding prerun_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>I\\<rceil>) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  prerun sys ?\\<sigma> \\<Longrightarrow> \\<lceil>I\\<rceil> ?\\<sigma>\n  prerun sys ?\\<sigma> \\<Longrightarrow>\n  (\\<box>(\\<lambda>s.\n             \\<lceil>I\\<rceil> s \\<longrightarrow>\n             (\\<circle>\\<lceil>I\\<rceil>) s))\n   ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>I\\<rceil>) \\<sigma>", "by (simp add: always_induct)"], ["", "lemma prerun_validI:\n  assumes \"\\<And>s. reachable_state sys s \\<Longrightarrow> I s\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> I", "unfolding prerun_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>I\\<rceil>) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  reachable_state sys ?s \\<Longrightarrow> I ?s\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun sys \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>I\\<rceil>) \\<sigma>", "by (simp add: alwaysI prerun_reachable_state)"], ["", "lemma prerun_validE:\n  assumes \"reachable_state sys s\"\n  assumes \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\"\n  shows \"I s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I s", "using assms"], ["proof (prove)\nusing this:\n  reachable_state sys s\n  sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\n\ngoal (1 subgoal):\n 1. I s", "unfolding prerun_valid_def"], ["proof (prove)\nusing this:\n  reachable_state sys s\n  \\<forall>\\<sigma>.\n     prerun sys \\<sigma> \\<longrightarrow>\n     (\\<box>\\<lceil>I\\<rceil>) \\<sigma>\n\ngoal (1 subgoal):\n 1. I s", "by (metis alwaysE reachable_stateE suffix_state_prop)"], ["", "subsubsection\\<open>Relating reachable states to the initial programs \\label{sec:cimp-decompose-small-step}\\<close>"], ["", "text\\<open>\n\nTo usefully reason about the control locations presumably embedded in\nthe single global invariant, we need to link the programs we have in\nreachable state \\<open>s\\<close> to the programs in the initial states. The\n\\<open>fragments\\<close> function decomposes the program into statements\nthat can be directly executed (\\S\\ref{sec:cimp-decompose}). We also\ncompute the locations we could be at after executing that statement as\na function of the process's local state.\n\nEliding the bodies of \\<open>IF\\<close> and \\<open>WHILE\\<close> statements\nyields smaller (but equivalent) proof obligations.\n\n\\<close>"], ["", "type_synonym  ('answer, 'location, 'question, 'state) loc_comp\n  = \"'state \\<Rightarrow> 'location set\""], ["", "fun lconst :: \"'location set \\<Rightarrow> ('answer, 'location, 'question, 'state) loc_comp\" where\n  \"lconst lp s = lp\""], ["", "definition lcond :: \"'location set \\<Rightarrow> 'location set \\<Rightarrow> 'state bexp\n                   \\<Rightarrow> ('answer, 'location, 'question, 'state) loc_comp\" where\n  \"lcond lp lp' b s = (if b s then lp else lp')\""], ["", "lemma lcond_split:\n  \"Q (lcond lp lp' b s) \\<longleftrightarrow> (b s \\<longrightarrow> Q lp) \\<and> (\\<not>b s \\<longrightarrow> Q lp')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (lcond lp lp' b s) =\n    ((b s \\<longrightarrow> Q lp) \\<and>\n     (\\<not> b s \\<longrightarrow> Q lp'))", "unfolding lcond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (if b s then lp else lp') =\n    ((b s \\<longrightarrow> Q lp) \\<and>\n     (\\<not> b s \\<longrightarrow> Q lp'))", "by (simp split: if_splits)"], ["", "lemma lcond_split_asm:\n  \"Q (lcond lp lp' b s) \\<longleftrightarrow> \\<not> ((b s \\<and> \\<not>Q lp) \\<or> (\\<not>b s \\<and> \\<not> Q lp'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (lcond lp lp' b s) =\n    (\\<not> (b s \\<and> \\<not> Q lp \\<or> \\<not> b s \\<and> \\<not> Q lp'))", "unfolding lcond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (if b s then lp else lp') =\n    (\\<not> (b s \\<and> \\<not> Q lp \\<or> \\<not> b s \\<and> \\<not> Q lp'))", "by (simp split: if_splits)"], ["", "lemmas lcond_splits = lcond_split lcond_split_asm"], ["", "fun\n  fragments :: \"('answer, 'location, 'question, 'state) com\n              \\<Rightarrow> 'location set\n              \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n               \\<times> ('answer, 'location, 'question, 'state) loc_comp ) set\"\nwhere\n  \"fragments (\\<lbrace>l\\<rbrace> IF b THEN c FI) aft\n       = { (\\<lbrace>l\\<rbrace> IF b THEN c' FI, lcond (atC c) aft b) |c'. True }\n        \\<union> fragments c aft\"\n| \"fragments (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI) aft\n       = { (\\<lbrace>l\\<rbrace> IF b THEN c1' ELSE c2' FI, lcond (atC c1) (atC c2) b) |c1' c2'. True }\n        \\<union> fragments c1 aft \\<union> fragments c2 aft\"\n| \"fragments (LOOP DO c OD) aft = fragments c (atC c)\"\n| \"fragments (\\<lbrace>l\\<rbrace> WHILE b DO c OD) aft\n       =  fragments c {l} \\<union> { (\\<lbrace>l\\<rbrace> WHILE b DO c' OD, lcond (atC c) aft b) |c'. True }\"\n| \"fragments (c1;; c2) aft = fragments c1 (atC c2) \\<union> fragments c2 aft\"\n| \"fragments (c1 \\<oplus> c2) aft = fragments c1 aft \\<union> fragments c2 aft\"\n| \"fragments c aft = { (c, lconst aft) }\""], ["", "fun\n  fragmentsL :: \"('answer, 'location, 'question, 'state) com list\n               \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                 \\<times> ('answer, 'location, 'question, 'state) loc_comp ) set\"\nwhere\n  \"fragmentsL [] = {}\"\n| \"fragmentsL [c] = fragments c {}\"\n| \"fragmentsL (c # c' # cs) = fragments c (atC c') \\<union> fragmentsL (c' # cs)\""], ["", "abbreviation\n  fragmentsLS :: \"('answer, 'location, 'question, 'state) local_state\n               \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                 \\<times> ('answer, 'location, 'question, 'state) loc_comp ) set\"\nwhere\n  \"fragmentsLS s \\<equiv> fragmentsL (cPGM s)\""], ["", "text\\<open>\n\nWe show that taking system steps preserves fragments.\n\n\\<close>"], ["", "lemma small_step_fragmentsLS:\n  assumes \"s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\"\n  shows \"fragmentsLS s' \\<subseteq> fragmentsLS s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fragmentsLS s' \\<subseteq> fragmentsLS s", "using assms"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n\ngoal (1 subgoal):\n 1. fragmentsLS s' \\<subseteq> fragmentsLS s", "by induct (case_tac [!] cs, auto)"], ["", "lemma reachable_state_fragmentsLS:\n  assumes \"reachable_state sys sh\"\n  shows \"fragmentsLS (GST sh p) \\<subseteq> fragments (PGMs sys p) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fragmentsLS (GST sh p) \\<subseteq> fragments (PGMs sys p) {}", "using assms"], ["proof (prove)\nusing this:\n  reachable_state sys sh\n\ngoal (1 subgoal):\n 1. fragmentsLS (GST sh p) \\<subseteq> fragments (PGMs sys p) {}", "by (induct rule: reachable_state_induct)\n   (auto simp: initial_state_def dest: subsetD[OF small_step_fragmentsLS])"], ["", "inductive\n  basic_com :: \"('answer, 'location, 'question, 'state) com \\<Rightarrow> bool\"\nwhere\n  \"basic_com (\\<lbrace>l\\<rbrace> Request action val)\"\n| \"basic_com (\\<lbrace>l\\<rbrace> Response action)\"\n| \"basic_com (\\<lbrace>l\\<rbrace> LocalOp R)\"\n| \"basic_com (\\<lbrace>l\\<rbrace> IF b THEN c FI)\"\n| \"basic_com (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI)\"\n| \"basic_com (\\<lbrace>l\\<rbrace> WHILE b DO c OD)\""], ["", "lemma fragments_basic_com:\n  assumes \"(c', aft') \\<in> fragments c aft\"\n  shows \"basic_com c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic_com c'", "using assms"], ["proof (prove)\nusing this:\n  (c', aft') \\<in> fragments c aft\n\ngoal (1 subgoal):\n 1. basic_com c'", "by (induct c arbitrary: aft) (auto intro: basic_com.intros)"], ["", "lemma fragmentsL_basic_com:\n  assumes \"(c', aft') \\<in> fragmentsL cs\"\n  shows \"basic_com c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic_com c'", "using assms"], ["proof (prove)\nusing this:\n  (c', aft') \\<in> fragmentsL cs\n\ngoal (1 subgoal):\n 1. basic_com c'", "apply (induct cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (c', aft') \\<in> fragmentsL [] \\<Longrightarrow> basic_com c'\n 2. \\<And>a cs.\n       \\<lbrakk>(c', aft') \\<in> fragmentsL cs \\<Longrightarrow>\n                basic_com c';\n        (c', aft') \\<in> fragmentsL (a # cs)\\<rbrakk>\n       \\<Longrightarrow> basic_com c'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>(c', aft') \\<in> fragmentsL cs \\<Longrightarrow>\n                basic_com c';\n        (c', aft') \\<in> fragmentsL (a # cs)\\<rbrakk>\n       \\<Longrightarrow> basic_com c'", "apply (case_tac cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a cs.\n       \\<lbrakk>(c', aft') \\<in> fragmentsL cs \\<Longrightarrow>\n                basic_com c';\n        (c', aft') \\<in> fragmentsL (a # cs); cs = []\\<rbrakk>\n       \\<Longrightarrow> basic_com c'\n 2. \\<And>a cs aa list.\n       \\<lbrakk>(c', aft') \\<in> fragmentsL cs \\<Longrightarrow>\n                basic_com c';\n        (c', aft') \\<in> fragmentsL (a # cs); cs = aa # list\\<rbrakk>\n       \\<Longrightarrow> basic_com c'", "apply (auto simp: fragments_basic_com)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nTo reason about system transitions we need to identify which basic\nstatement gets executed next. To that end we factor out the recursive\ncases of the @{term \"small_step\"} semantics into \\emph{contexts},\nwhich isolate the \\<open>basic_com\\<close> commands with immediate\nexternally-visible behaviour. Note that non-determinism means that\nmore than one \\<open>basic_com\\<close> can be enabled at a time.\n\nThe representation of evaluation contexts follows @{cite\n[cite_macro=citet] \"DBLP:journals/jar/Berghofer12\"}. This style of\noperational semantics was originated by @{cite [cite_macro=citet]\n\"FelleisenHieb:1992\"}.\n\n\\<close>"], ["", "type_synonym ('answer, 'location, 'question, 'state) ctxt\n  = \"(('answer, 'location, 'question, 'state) com \\<Rightarrow> ('answer, 'location, 'question, 'state) com)\n   \\<times> (('answer, 'location, 'question, 'state) com \\<Rightarrow> ('answer, 'location, 'question, 'state) com list)\""], ["", "inductive_set\n  ctxt :: \"('answer, 'location, 'question, 'state) ctxt set\"\nwhere\n  C_Hole: \"(id, \\<langle>[]\\<rangle>) \\<in> ctxt\"\n| C_Loop: \"(E, fctxt) \\<in> ctxt \\<Longrightarrow> (\\<lambda>c1. LOOP DO E c1 OD, \\<lambda>c1. fctxt c1 @ [LOOP DO E c1 OD]) \\<in> ctxt\"\n| C_Seq: \"(E, fctxt) \\<in> ctxt \\<Longrightarrow> (\\<lambda>c1. E c1;; c2, \\<lambda>c1. fctxt c1 @ [c2]) \\<in> ctxt\"\n| C_Choose1: \"(E, fctxt) \\<in> ctxt \\<Longrightarrow> (\\<lambda>c1. E c1 \\<oplus> c2, fctxt) \\<in> ctxt\"\n| C_Choose2: \"(E, fctxt) \\<in> ctxt \\<Longrightarrow> (\\<lambda>c2. c1 \\<oplus> E c2, fctxt) \\<in> ctxt\""], ["", "text\\<open>\n\nWe can decompose a small step into a context and a @{const \"basic_com\"}.\n\n\\<close>"], ["", "fun\n  decompose_com :: \"('answer, 'location, 'question, 'state) com\n                      \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                        \\<times> ('answer, 'location, 'question, 'state) ctxt ) set\"\nwhere\n  \"decompose_com (LOOP DO c1 OD) = { (c, \\<lambda>t. LOOP DO ictxt t OD, \\<lambda>t. fctxt t @ [LOOP DO ictxt t OD]) |c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com c1 }\"\n| \"decompose_com (c1;; c2) = { (c, \\<lambda>t. ictxt t;; c2, \\<lambda>t. fctxt t @ [c2]) |c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com c1 }\"\n| \"decompose_com (c1 \\<oplus> c2) = { (c, \\<lambda>t. ictxt t \\<oplus> c2, fctxt) |c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com c1 }\n                           \\<union> { (c, \\<lambda>t. c1 \\<oplus> ictxt t, fctxt) |c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com c2 }\"\n| \"decompose_com c = {(c, id, \\<langle>[]\\<rangle>)}\""], ["", "definition\n  decomposeLS :: \"('answer, 'location, 'question, 'state) local_state\n               \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                 \\<times> (('answer, 'location, 'question, 'state) com \\<Rightarrow> ('answer, 'location, 'question, 'state) com)\n                 \\<times> (('answer, 'location, 'question, 'state) com \\<Rightarrow> ('answer, 'location, 'question, 'state) com list) ) set\"\nwhere\n  \"decomposeLS s = (case cPGM s of c # _ \\<Rightarrow> decompose_com c | _ \\<Rightarrow> {})\""], ["", "lemma ctxt_inj:\n  assumes \"(E, fctxt) \\<in> ctxt\"\n  assumes \"E x = E y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  (E, fctxt) \\<in> ctxt\n  E x = E y\n\ngoal (1 subgoal):\n 1. x = y", "by (induct set: ctxt) auto"], ["", "lemma decompose_com_non_empty: \"decompose_com c \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_com c \\<noteq> {}", "by (induct c) auto"], ["", "lemma decompose_com_basic_com:\n  assumes \"(c', ctxts) \\<in> decompose_com c\"\n  shows \"basic_com c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic_com c'", "using assms"], ["proof (prove)\nusing this:\n  (c', ctxts) \\<in> decompose_com c\n\ngoal (1 subgoal):\n 1. basic_com c'", "by (induct c arbitrary: c' ctxts) (auto intro: basic_com.intros)"], ["", "lemma decomposeLS_basic_com:\n  assumes \"(c', ctxts) \\<in> decomposeLS s\"\n  shows \"basic_com c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic_com c'", "using assms"], ["proof (prove)\nusing this:\n  (c', ctxts) \\<in> decomposeLS s\n\ngoal (1 subgoal):\n 1. basic_com c'", "unfolding decomposeLS_def"], ["proof (prove)\nusing this:\n  (c', ctxts)\n  \\<in> (case cPGM s of [] \\<Rightarrow> {}\n         | c # x \\<Rightarrow> decompose_com c)\n\ngoal (1 subgoal):\n 1. basic_com c'", "by (simp add: decompose_com_basic_com split: list.splits)"], ["", "lemma decompose_com_ctxt:\n  assumes \"(c', ctxts) \\<in> decompose_com c\"\n  shows \"ctxts \\<in> ctxt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ctxts \\<in> ctxt", "using assms"], ["proof (prove)\nusing this:\n  (c', ctxts) \\<in> decompose_com c\n\ngoal (1 subgoal):\n 1. ctxts \\<in> ctxt", "by (induct c arbitrary: c' ctxts) (auto intro: ctxt.intros)"], ["", "lemma decompose_com_ictxt:\n  assumes \"(c', ictxt, fctxt) \\<in> decompose_com c\"\n  shows \"ictxt c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ictxt c' = c", "using assms"], ["proof (prove)\nusing this:\n  (c', ictxt, fctxt) \\<in> decompose_com c\n\ngoal (1 subgoal):\n 1. ictxt c' = c", "by (induct c arbitrary: c' ictxt fctxt) auto"], ["", "lemma decompose_com_small_step:\n  assumes as: \"(c' # fctxt c' @ cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\"\n  assumes ds: \"(c', ictxt, fctxt) \\<in> decompose_com c\"\n  shows \"(c # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "using decompose_com_ctxt[OF ds] as decompose_com_ictxt[OF ds]"], ["proof (prove)\nusing this:\n  (ictxt, fctxt) \\<in> ctxt\n  (c' # fctxt c' @ cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n  ictxt c' = c\n\ngoal (1 subgoal):\n 1. (c # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "by (induct ictxt fctxt arbitrary: c cs)\n   (cases s', fastforce simp: fun_eq_iff dest: ctxt_inj)+"], ["", "theorem context_decompose:\n  \"s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<longleftrightarrow> (\\<exists>(c, ictxt, fctxt) \\<in> decomposeLS s.\n                     cPGM s = ictxt c # tl (cPGM s)\n                   \\<and> (c # fctxt c @ tl (cPGM s), cTKN s, cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n                   \\<and> (\\<forall>l\\<in>atC c. cTKN s' = Some l))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' =\n    (\\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n        cPGM s = ictxt c # tl (cPGM s) \\<and>\n        (c # fctxt c @ tl (cPGM s), cTKN s,\n         cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n        (\\<forall>l\\<in>atC c. cTKN s' = Some l))", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<Longrightarrow>\n    \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n 2. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l) \\<Longrightarrow>\n    s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "assume ?lhs"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n\ngoal (2 subgoals):\n 1. s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<Longrightarrow>\n    \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n 2. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l) \\<Longrightarrow>\n    s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "show ?rhs"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n\ngoal (1 subgoal):\n 1. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l)", "unfolding decomposeLS_def"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n\ngoal (1 subgoal):\n 1. \\<exists>(c, ictxt, fctxt)\n             \\<in>case cPGM s of [] \\<Rightarrow> {}\n                  | c # x \\<Rightarrow> decompose_com c.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l)", "proof(induct rule: small_step.induct)"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 13 subgoals...", "case (Choose1 c1 cs s \\<alpha> cs' s' c2)"], ["proof (state)\nthis:\n  (c1 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c1 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c1 # cs, s) = ictxt c # tl (cPGM (c1 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c1 # cs, s)), cTKN (c1 # cs, s),\n        cLST\n         (c1 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (13 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  (c1 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c1 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c1 # cs, s) = ictxt c # tl (cPGM (c1 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c1 # cs, s)), cTKN (c1 # cs, s),\n        cLST\n         (c1 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)", "show ?case"], ["proof (prove)\nusing this:\n  (c1 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c1 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c1 # cs, s) = ictxt c # tl (cPGM (c1 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c1 # cs, s)), cTKN (c1 # cs, s),\n        cLST\n         (c1 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>case cPGM (c1 \\<oplus> c2 # cs, s) of [] \\<Rightarrow> {}\n                   | c # x \\<Rightarrow> decompose_com c.\n       case a of\n       (c, ictxt, fctxt) \\<Rightarrow>\n         cPGM (c1 \\<oplus> c2 # cs, s) =\n         ictxt c # tl (cPGM (c1 \\<oplus> c2 # cs, s)) \\<and>\n         (c # fctxt c @ tl (cPGM (c1 \\<oplus> c2 # cs, s)),\n          cTKN (c1 \\<oplus> c2 # cs, s),\n          cLST\n           (c1 \\<oplus> c2 # cs,\n            s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n         (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(aa a # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (a, aa, b) \\<in> decompose_com (aa a); c1 = aa a;\n        (a # b a @ cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC a. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(c,\n    \\<lambda>t. ictxt t \\<oplus> c2, fctxt) |\n   c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com (aa a)} \\<union>\n  {(c, \\<lambda>t. aa a \\<oplus> ictxt t, fctxt) |c fctxt ictxt.\n   (c, ictxt, fctxt) \\<in> decompose_com c2}.\n                            case x of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              aa a \\<oplus> c2 = ictxt c \\<and>\n                              (c # fctxt c @ cs,\n                               s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                   s') \\<and>\n                              (\\<forall>l\\<in>atC c. fst s' = Some l)", "apply (rename_tac c ictxt fctxt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c1 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(ca,\n    \\<lambda>t. ictxta t \\<oplus> c2, fctxt) |\n   ca fctxt ictxta.\n   (ca, ictxta, fctxt) \\<in> decompose_com (ictxt c)} \\<union>\n  {(ca, \\<lambda>t. ictxt c \\<oplus> ictxta t, fctxt) |ca fctxt ictxta.\n   (ca, ictxta, fctxt) \\<in> decompose_com c2}.\n                            case x of\n                            (ca, ictxta, fctxt) \\<Rightarrow>\n                              ictxt c \\<oplus> c2 = ictxta ca \\<and>\n                              (ca # fctxt ca @ cs,\n                               s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                   s') \\<and>\n                              (\\<forall>l\\<in>atC ca. fst s' = Some l)", "apply (rule_tac x=\"(c, \\<lambda>t. ictxt t \\<oplus> c2, fctxt)\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c1 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> case (c, \\<lambda>t. ictxt t \\<oplus> c2, fctxt) of\n                         (ca, ictxta, fctxt) \\<Rightarrow>\n                           ictxt c \\<oplus> c2 = ictxta ca \\<and>\n                           (ca # fctxt ca @ cs,\n                            s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                s') \\<and>\n                           (\\<forall>l\\<in>atC ca. fst s' = Some l)\n 2. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c1 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> (c, \\<lambda>t. ictxt t \\<oplus> c2, fctxt)\n                         \\<in> {(ca, \\<lambda>t. ictxta t \\<oplus> c2,\n                                 fctxt) |\n                                ca fctxt ictxta.\n                                (ca, ictxta, fctxt)\n                                \\<in> decompose_com (ictxt c)} \\<union>\n                               {(ca, \\<lambda>t. ictxt c \\<oplus> ictxta t,\n                                 fctxt) |\n                                ca fctxt ictxta.\n                                (ca, ictxta, fctxt) \\<in> decompose_com c2}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a\\<in>case cPGM (c1 \\<oplus> c2 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c1 \\<oplus> c2 # cs, s) =\n       ictxt c # tl (cPGM (c1 \\<oplus> c2 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c1 \\<oplus> c2 # cs, s)),\n        cTKN (c1 \\<oplus> c2 # cs, s),\n        cLST\n         (c1 \\<oplus> c2 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (12 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 12 subgoals...", "case (Choose2 c2 cs s \\<alpha> cs' s' c1)"], ["proof (state)\nthis:\n  (c2 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c2 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c2 # cs, s) = ictxt c # tl (cPGM (c2 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c2 # cs, s)), cTKN (c2 # cs, s),\n        cLST\n         (c2 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (12 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  (c2 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c2 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c2 # cs, s) = ictxt c # tl (cPGM (c2 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c2 # cs, s)), cTKN (c2 # cs, s),\n        cLST\n         (c2 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)", "show ?case"], ["proof (prove)\nusing this:\n  (c2 # cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s')\n  \\<exists>a\\<in>case cPGM (c2 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c2 # cs, s) = ictxt c # tl (cPGM (c2 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c2 # cs, s)), cTKN (c2 # cs, s),\n        cLST\n         (c2 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>case cPGM (c1 \\<oplus> c2 # cs, s) of [] \\<Rightarrow> {}\n                   | c # x \\<Rightarrow> decompose_com c.\n       case a of\n       (c, ictxt, fctxt) \\<Rightarrow>\n         cPGM (c1 \\<oplus> c2 # cs, s) =\n         ictxt c # tl (cPGM (c1 \\<oplus> c2 # cs, s)) \\<and>\n         (c # fctxt c @ tl (cPGM (c1 \\<oplus> c2 # cs, s)),\n          cTKN (c1 \\<oplus> c2 # cs, s),\n          cLST\n           (c1 \\<oplus> c2 # cs,\n            s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n         (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(aa a # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (a, aa, b) \\<in> decompose_com (aa a); c2 = aa a;\n        (a # b a @ cs, s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC a. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(c,\n    \\<lambda>t. ictxt t \\<oplus> aa a, fctxt) |\n   c fctxt ictxt. (c, ictxt, fctxt) \\<in> decompose_com c1} \\<union>\n  {(c, \\<lambda>t. c1 \\<oplus> ictxt t, fctxt) |c fctxt ictxt.\n   (c, ictxt, fctxt) \\<in> decompose_com (aa a)}.\n                            case x of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              c1 \\<oplus> aa a = ictxt c \\<and>\n                              (c # fctxt c @ cs,\n                               s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                   s') \\<and>\n                              (\\<forall>l\\<in>atC c. fst s' = Some l)", "apply (rename_tac c ictxt fctxt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c2 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(ca,\n    \\<lambda>t. ictxta t \\<oplus> ictxt c, fctxt) |\n   ca fctxt ictxta. (ca, ictxta, fctxt) \\<in> decompose_com c1} \\<union>\n  {(ca, \\<lambda>t. c1 \\<oplus> ictxta t, fctxt) |ca fctxt ictxta.\n   (ca, ictxta, fctxt) \\<in> decompose_com (ictxt c)}.\n                            case x of\n                            (ca, ictxta, fctxt) \\<Rightarrow>\n                              c1 \\<oplus> ictxt c = ictxta ca \\<and>\n                              (ca # fctxt ca @ cs,\n                               s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                   s') \\<and>\n                              (\\<forall>l\\<in>atC ca. fst s' = Some l)", "apply (rule_tac x=\"(c, \\<lambda>t. c1 \\<oplus> ictxt t, fctxt)\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c2 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> case (c, \\<lambda>t. c1 \\<oplus> ictxt t, fctxt) of\n                         (ca, ictxta, fctxt) \\<Rightarrow>\n                           c1 \\<oplus> ictxt c = ictxta ca \\<and>\n                           (ca # fctxt ca @ cs,\n                            s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\n                                s') \\<and>\n                           (\\<forall>l\\<in>atC ca. fst s' = Some l)\n 2. \\<And>c ictxt fctxt.\n       \\<lbrakk>(ictxt c # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        (c, ictxt, fctxt) \\<in> decompose_com (ictxt c); c2 = ictxt c;\n        (c # fctxt c @ cs,\n         s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<forall>l\\<in>atC c. fst s' = Some l\\<rbrakk>\n       \\<Longrightarrow> (c, \\<lambda>t. c1 \\<oplus> ictxt t, fctxt)\n                         \\<in> {(ca, \\<lambda>t. ictxta t \\<oplus> ictxt c,\n                                 fctxt) |\n                                ca fctxt ictxta.\n                                (ca, ictxta, fctxt)\n                                \\<in> decompose_com c1} \\<union>\n                               {(ca, \\<lambda>t. c1 \\<oplus> ictxta t,\n                                 fctxt) |\n                                ca fctxt ictxta.\n                                (ca, ictxta, fctxt)\n                                \\<in> decompose_com (ictxt c)}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a\\<in>case cPGM (c1 \\<oplus> c2 # cs, s) of [] \\<Rightarrow> {}\n                 | c # x \\<Rightarrow> decompose_com c.\n     case a of\n     (c, ictxt, fctxt) \\<Rightarrow>\n       cPGM (c1 \\<oplus> c2 # cs, s) =\n       ictxt c # tl (cPGM (c1 \\<oplus> c2 # cs, s)) \\<and>\n       (c # fctxt c @ tl (cPGM (c1 \\<oplus> c2 # cs, s)),\n        cTKN (c1 \\<oplus> c2 # cs, s),\n        cLST\n         (c1 \\<oplus> c2 # cs,\n          s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n       (\\<forall>l\\<in>atC c. cTKN (cs', s') = Some l)\n\ngoal (11 subgoals):\n 1. \\<And>\\<alpha> action s s' val \\<beta> l cs uu_.\n       \\<lbrakk>\\<alpha> = action s; s' \\<in> val \\<beta> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM\n        (\\<lbrace>l\\<rbrace> Request action val # cs, uu_, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (c, ictxt, fctxt) \\<Rightarrow>\n                              cPGM\n                               (\\<lbrace>l\\<rbrace> Request action val # cs,\n                                uu_, s) =\n                              ictxt c #\n                              tl (cPGM\n                                   (\\<lbrace>l\\<rbrace> Request action val #\n                                    cs,\n                                    uu_, s)) \\<and>\n                              (c #\n                               fctxt c @\n                               tl (cPGM\n                                    (\\<lbrace>l\\<rbrace> Request action val #\n                                     cs,\n                                     uu_, s)),\n                               cTKN\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_, s),\n                               cLST\n                                (\\<lbrace>l\\<rbrace> Request action val #\n                                 cs,\n                                 uu_,\n                                 s)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> (cs,\n    Some l, s') \\<and>\n                              (\\<forall>la\\<in>atC c.\n                                  cTKN (cs, Some l, s') = Some la)\n 2. \\<And>s' \\<beta> action \\<alpha> s l cs uv_.\n       (s', \\<beta>) \\<in> action \\<alpha> s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> Response action # cs, uv_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> Response action # cs, uv_,\n               s)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> (cs,\n                        Some l, s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 3. \\<And>s' R s l cs uw_.\n       s' \\<in> R s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s) =\n            ictxt c #\n            tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> LocalOp R # cs, uw_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s') \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (cs, Some l, s') = Some la)\n 4. \\<And>b s l c cs ux_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, ux_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (c # cs, Some l, s) = Some la)\n 5. \\<And>b s l c cs uy_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c FI # cs, uy_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\n 6. \\<And>b s l c1 c2 cs uz_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             uz_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, uz_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c1 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c1 # cs, Some l, s) = Some la)\n 7. \\<And>b s l c1 c2 cs va_.\n       \\<not> b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI #\n                             cs,\n                             va_, s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (c, ictxt, fctxt) \\<Rightarrow>\n            cPGM\n             (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s) =\n            ictxt c #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                  s)) \\<and>\n            (c #\n             fctxt c @\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n                   s)),\n             cTKN\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs, va_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c2 # cs, Some l,\n                  s) \\<and>\n            (\\<forall>la\\<in>atC c. cTKN (c2 # cs, Some l, s) = Some la)\n 8. \\<And>c cs s \\<alpha> cs' s'.\n       \\<lbrakk>(c # LOOP DO c OD # cs,\n                 s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s');\n        \\<exists>a\\<in>case cPGM (c # LOOP DO c OD # cs, s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (c # LOOP DO c OD # cs, s) =\n             ictxt ca # tl (cPGM (c # LOOP DO c OD # cs, s)) \\<and>\n             (ca # fctxt ca @ tl (cPGM (c # LOOP DO c OD # cs, s)),\n              cTKN (c # LOOP DO c OD # cs, s),\n              cLST\n               (c # LOOP DO c OD # cs,\n                s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs', s') \\<and>\n             (\\<forall>l\\<in>atC ca. cTKN (cs', s') = Some l)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>case cPGM (LOOP DO c OD # cs, s) of\n  [] \\<Rightarrow> {} | c # x \\<Rightarrow> decompose_com c.\n                            case a of\n                            (ca, ictxt, fctxt) \\<Rightarrow>\n                              cPGM (LOOP DO c OD # cs, s) =\n                              ictxt ca #\n                              tl (cPGM (LOOP DO c OD # cs, s)) \\<and>\n                              (ca #\n                               fctxt ca @ tl (cPGM (LOOP DO c OD # cs, s)),\n                               cTKN (LOOP DO c OD # cs, s),\n                               cLST\n                                (LOOP DO c OD # cs,\n                                 s)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> (cs',\ns') \\<and>\n                              (\\<forall>l\\<in>atC ca.\n                                  cTKN (cs', s') = Some l)\n 9. \\<And>b s l c cs vb_.\n       b s \\<Longrightarrow>\n       \\<exists>a\\<in>case cPGM\n                            (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n                             s) of\n                      [] \\<Rightarrow> {}\n                      | c # x \\<Rightarrow> decompose_com c.\n          case a of\n          (ca, ictxt, fctxt) \\<Rightarrow>\n            cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s) =\n            ictxt ca #\n            tl (cPGM\n                 (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)) \\<and>\n            (ca #\n             fctxt ca @\n             tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s)),\n             cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_, s),\n             cLST\n              (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vb_,\n               s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (c #\n                  \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs,\n                  Some l, s) \\<and>\n            (\\<forall>la\\<in>atC ca.\n                cTKN\n                 (c # \\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, Some l, s) =\n                Some la)\n 10. \\<And>b s l c cs vc_.\n        \\<not> b s \\<Longrightarrow>\n        \\<exists>a\\<in>case cPGM\n                             (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                              s) of\n                       [] \\<Rightarrow> {}\n                       | c # x \\<Rightarrow> decompose_com c.\n           case a of\n           (ca, ictxt, fctxt) \\<Rightarrow>\n             cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s) =\n             ictxt ca #\n             tl (cPGM\n                  (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)) \\<and>\n             (ca #\n              fctxt ca @\n              tl (cPGM (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s)),\n              cTKN (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_, s),\n              cLST\n               (\\<lbrace>l\\<rbrace> WHILE b DO c OD # cs, vc_,\n                s)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> (cs, Some l,\n                   s) \\<and>\n             (\\<forall>la\\<in>atC ca. cTKN (cs, Some l, s) = Some la)\nA total of 11 subgoals...", "qed fastforce+"], ["proof (state)\nthis:\n  \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n     cPGM s = ictxt c # tl (cPGM s) \\<and>\n     (c # fctxt c @ tl (cPGM s), cTKN s,\n      cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n     (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n\ngoal (1 subgoal):\n 1. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l) \\<Longrightarrow>\n    s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l) \\<Longrightarrow>\n    s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n     cPGM s = ictxt c # tl (cPGM s) \\<and>\n     (c # fctxt c @ tl (cPGM s), cTKN s,\n      cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n     (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n\ngoal (1 subgoal):\n 1. \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n       cPGM s = ictxt c # tl (cPGM s) \\<and>\n       (c # fctxt c @ tl (cPGM s), cTKN s,\n        cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n       (\\<forall>l\\<in>atC c. cTKN s' = Some l) \\<Longrightarrow>\n    s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "then"], ["proof (chain)\npicking this:\n  \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n     cPGM s = ictxt c # tl (cPGM s) \\<and>\n     (c # fctxt c @ tl (cPGM s), cTKN s,\n      cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n     (\\<forall>l\\<in>atC c. cTKN s' = Some l)", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS s.\n     cPGM s = ictxt c # tl (cPGM s) \\<and>\n     (c # fctxt c @ tl (cPGM s), cTKN s,\n      cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n     (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "unfolding decomposeLS_def"], ["proof (prove)\nusing this:\n  \\<exists>(c, ictxt, fctxt)\n           \\<in>case cPGM s of [] \\<Rightarrow> {}\n                | c # x \\<Rightarrow> decompose_com c.\n     cPGM s = ictxt c # tl (cPGM s) \\<and>\n     (c # fctxt c @ tl (cPGM s), cTKN s,\n      cLST s) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s' \\<and>\n     (\\<forall>l\\<in>atC c. cTKN s' = Some l)\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'", "by (cases s) (auto split: list.splits dest: decompose_com_small_step)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> s'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWhile we only use this result left-to-right (to decompose a small step\ninto a basic one), this equivalence shows that we lose no information\nin doing so.\n\nDecomposing a compound command preserves @{const \\<open>fragments\\<close>} too.\n\n\\<close>"], ["", "fun\n  loc_compC :: \"('answer, 'location, 'question, 'state) com\n                            \\<Rightarrow> ('answer, 'location, 'question, 'state) com list\n                            \\<Rightarrow> ('answer, 'location, 'question, 'state) loc_comp\"\nwhere\n  \"loc_compC (\\<lbrace>l\\<rbrace> IF b THEN c FI) cs = lcond (atC c) (atCs cs) b\"\n| \"loc_compC (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI) cs = lcond (atC c1) (atC c2) b\"\n| \"loc_compC (LOOP DO c OD) cs = lconst (atC c)\"\n| \"loc_compC (\\<lbrace>l\\<rbrace> WHILE b DO c OD) cs = lcond (atC c) (atCs cs) b\"\n| \"loc_compC c cs = lconst (atCs cs)\""], ["", "lemma decompose_fragments:\n  assumes \"(c, ictxt, fctxt) \\<in> decompose_com c0\"\n  shows \"(c, loc_compC c (fctxt c @ cs)) \\<in> fragments c0 (atCs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c0 (atCs cs)", "using assms"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decompose_com c0\n\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c0 (atCs cs)", "proof(induct c0 arbitrary: c ictxt fctxt cs)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (LOOP DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (LOOP DO c0 OD) (atCs cs)\n 7. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 8. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 ;; c02) (atCs cs)\n 9. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "case (Loop c01 c ictxt fctxt cs)"], ["proof (state)\nthis:\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ?cs)) \\<in> fragments c01 (atCs ?cs)\n  (c, ictxt, fctxt) \\<in> decompose_com (LOOP DO c01 OD)\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (LOOP DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (LOOP DO c0 OD) (atCs cs)\n 7. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 8. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 ;; c02) (atCs cs)\n 9. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "from Loop.prems Loop.hyps(1)[where cs=\"ictxt c # cs\"]"], ["proof (chain)\npicking this:\n  (c, ictxt, fctxt) \\<in> decompose_com (LOOP DO c01 OD)\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ictxt c # cs))\n  \\<in> fragments c01 (atCs (ictxt c # cs))", "show ?case"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decompose_com (LOOP DO c01 OD)\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ictxt c # cs))\n  \\<in> fragments c01 (atCs (ictxt c # cs))\n\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ cs))\n    \\<in> fragments (LOOP DO c01 OD) (atCs cs)", "by (auto simp: decompose_com_ictxt)"], ["proof (state)\nthis:\n  (c, loc_compC c (fctxt c @ cs)) \\<in> fragments (LOOP DO c01 OD) (atCs cs)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 7. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 ;; c02) (atCs cs)\n 8. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 7. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 ;; c02) (atCs cs)\n 8. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "case (Seq c01 c02 c ictxt fctxt cs)"], ["proof (state)\nthis:\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ?cs)) \\<in> fragments c01 (atCs ?cs)\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ?cs)) \\<in> fragments c02 (atCs ?cs)\n  (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 7. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 ;; c02) (atCs cs)\n 8. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "from Seq.prems Seq.hyps(1)[where cs=\"c02 # cs\"]"], ["proof (chain)\npicking this:\n  (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ c02 # cs))\n  \\<in> fragments c01 (atCs (c02 # cs))", "show ?case"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decompose_com (c01 ;; c02)\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com c01 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ c02 # cs))\n  \\<in> fragments c01 (atCs (c02 # cs))\n\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ cs)) \\<in> fragments (c01 ;; c02) (atCs cs)", "by auto"], ["proof (state)\nthis:\n  (c, loc_compC c (fctxt c @ cs)) \\<in> fragments (c01 ;; c02) (atCs cs)\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 x3 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Request x2 x3) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Request x2 x3) (atCs cs)\n 2. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> Response x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> Response x2) (atCs cs)\n 3. \\<And>x1 x2 c ictxt fctxt cs.\n       (c, ictxt, fctxt)\n       \\<in> decompose_com\n              (\\<lbrace>x1\\<rbrace> LocalOp x2) \\<Longrightarrow>\n       (c, loc_compC c (fctxt c @ cs))\n       \\<in> fragments (\\<lbrace>x1\\<rbrace> LocalOp x2) (atCs cs)\n 4. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c0 FI)\n                                (atCs cs)\n 5. \\<And>x1 x2 c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> IF x2 THEN c01 ELSE c02 FI)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> IF x2 THEN c01\n                                 ELSE c02 FI)\n                                (atCs cs)\n 6. \\<And>x1 x2 c0 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c0 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c0 (atCs cs);\n        (c, ictxt, fctxt)\n        \\<in> decompose_com\n               (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments\n                                (\\<lbrace>x1\\<rbrace> WHILE x2 DO c0 OD)\n                                (atCs cs)\n 7. \\<And>c01 c02 c ictxt fctxt cs.\n       \\<lbrakk>\\<And>c ictxt fctxt cs.\n                   (c, ictxt, fctxt)\n                   \\<in> decompose_com c01 \\<Longrightarrow>\n                   (c, loc_compC c (fctxt c @ cs))\n                   \\<in> fragments c01 (atCs cs);\n        \\<And>c ictxt fctxt cs.\n           (c, ictxt, fctxt) \\<in> decompose_com c02 \\<Longrightarrow>\n           (c, loc_compC c (fctxt c @ cs)) \\<in> fragments c02 (atCs cs);\n        (c, ictxt, fctxt) \\<in> decompose_com (c01 \\<oplus> c02)\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ cs))\n                         \\<in> fragments (c01 \\<oplus> c02) (atCs cs)", "qed auto"], ["", "lemma at_decompose:\n  assumes \"(c, ictxt, fctxt) \\<in> decompose_com c0\"\n  shows \"atC c \\<subseteq> atC c0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atC c \\<subseteq> atC c0", "using assms"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decompose_com c0\n\ngoal (1 subgoal):\n 1. atC c \\<subseteq> atC c0", "by (induct c0 arbitrary: c ictxt fctxt; fastforce)"], ["", "lemma at_decomposeLS:\n  assumes \"(c, ictxt, fctxt) \\<in> decomposeLS s\"\n  shows \"atC c \\<subseteq> atCs (cPGM s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atC c \\<subseteq> atCs (cPGM s)", "using assms"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decomposeLS s\n\ngoal (1 subgoal):\n 1. atC c \\<subseteq> atCs (cPGM s)", "unfolding decomposeLS_def"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt)\n  \\<in> (case cPGM s of [] \\<Rightarrow> {}\n         | c # x \\<Rightarrow> decompose_com c)\n\ngoal (1 subgoal):\n 1. atC c \\<subseteq> atCs (cPGM s)", "by (auto simp: at_decompose split: list.splits)"], ["", "lemma decomposeLS_fragmentsLS:\n  assumes \"(c, ictxt, fctxt) \\<in> decomposeLS s\"\n  shows \"(c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s", "using assms"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decomposeLS s\n\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s", "proof(cases \"cPGM s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(c, ictxt, fctxt) \\<in> decomposeLS s; cPGM s = []\\<rbrakk>\n    \\<Longrightarrow> (c, loc_compC c (fctxt c @ tl (cPGM s)))\n                      \\<in> fragmentsLS s\n 2. \\<And>a list.\n       \\<lbrakk>(c, ictxt, fctxt) \\<in> decomposeLS s;\n        cPGM s = a # list\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ tl (cPGM s)))\n                         \\<in> fragmentsLS s", "case (Cons d ds)"], ["proof (state)\nthis:\n  cPGM s = d # ds\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(c, ictxt, fctxt) \\<in> decomposeLS s; cPGM s = []\\<rbrakk>\n    \\<Longrightarrow> (c, loc_compC c (fctxt c @ tl (cPGM s)))\n                      \\<in> fragmentsLS s\n 2. \\<And>a list.\n       \\<lbrakk>(c, ictxt, fctxt) \\<in> decomposeLS s;\n        cPGM s = a # list\\<rbrakk>\n       \\<Longrightarrow> (c, loc_compC c (fctxt c @ tl (cPGM s)))\n                         \\<in> fragmentsLS s", "with assms decompose_fragments[where cs=\"ds\"]"], ["proof (chain)\npicking this:\n  (c, ictxt, fctxt) \\<in> decomposeLS s\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com ?c0.0 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ds)) \\<in> fragments ?c0.0 (atCs ds)\n  cPGM s = d # ds", "show ?thesis"], ["proof (prove)\nusing this:\n  (c, ictxt, fctxt) \\<in> decomposeLS s\n  (?c, ?ictxt, ?fctxt) \\<in> decompose_com ?c0.0 \\<Longrightarrow>\n  (?c, loc_compC ?c (?fctxt ?c @ ds)) \\<in> fragments ?c0.0 (atCs ds)\n  cPGM s = d # ds\n\ngoal (1 subgoal):\n 1. (c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s", "by (cases ds) (auto simp: decomposeLS_def)"], ["proof (state)\nthis:\n  (c, loc_compC c (fctxt c @ tl (cPGM s))) \\<in> fragmentsLS s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, ictxt, fctxt) \\<in> decomposeLS s; cPGM s = []\\<rbrakk>\n    \\<Longrightarrow> (c, loc_compC c (fctxt c @ tl (cPGM s)))\n                      \\<in> fragmentsLS s", "qed (simp add: decomposeLS_def)"], ["", "lemma small_step_loc_compC:\n  assumes \"basic_com c\"\n  assumes \"(c # cs, ls) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ls'\"\n  shows \"loc_compC c cs (snd ls) = atCs (cPGM ls')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_compC c cs (snd ls) = atCs (cPGM ls')", "using assms"], ["proof (prove)\nusing this:\n  basic_com c\n  (c # cs, ls) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ls'\n\ngoal (1 subgoal):\n 1. loc_compC c cs (snd ls) = atCs (cPGM ls')", "by (fastforce elim: basic_com.cases elim!: small_step_inv split: lcond_splits)"], ["", "text\\<open>\n\nThe headline result allows us to constrain the initial and final states\nof a given small step in terms of the original programs, provided the\ninitial state is reachable.\n\n\\<close>"], ["", "theorem decompose_small_step:\n  assumes \"GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps'\"\n  assumes \"reachable_state sys sh\"\n  obtains c cs aft\n    where \"(c, aft) \\<in> fragments (PGMs sys p) {}\"\n      and \"atC c \\<subseteq> atCs (cPGM (GST sh p))\"\n      and \"aft (cLST (GST sh p)) = atCs (cPGM ps')\"\n      and \"(c # cs, cTKN (GST sh p), cLST (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps'\"\n      and \"\\<forall>l\\<in>atC c. cTKN ps' = Some l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c aft cs.\n        \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n         atC c \\<subseteq> atCs (cPGM (GST sh p));\n         aft (cLST (GST sh p)) = atCs (cPGM ps');\n         (c # cs, cTKN (GST sh p),\n          cLST (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n         \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps'\n  reachable_state sys sh\n\ngoal (1 subgoal):\n 1. (\\<And>c aft cs.\n        \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n         atC c \\<subseteq> atCs (cPGM (GST sh p));\n         aft (cLST (GST sh p)) = atCs (cPGM ps');\n         (c # cs, cTKN (GST sh p),\n          cLST (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n         \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c aft cs.\n                \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                 atC c \\<subseteq> atCs (cPGM (GST sh p));\n                 aft (cLST (GST sh p)) = atCs (cPGM ps');\n                 (c # cs, cTKN (GST sh p),\n                  cLST\n                   (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                 \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n     reachable_state sys sh\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (frule iffD1[OF context_decompose])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c aft cs.\n                \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                 atC c \\<subseteq> atCs (cPGM (GST sh p));\n                 aft (cLST (GST sh p)) = atCs (cPGM ps');\n                 (c # cs, cTKN (GST sh p),\n                  cLST\n                   (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                 \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n     reachable_state sys sh;\n     \\<exists>(c, ictxt, fctxt)\\<in>decomposeLS (GST sh p).\n        cPGM (GST sh p) = ictxt c # tl (cPGM (GST sh p)) \\<and>\n        (c # fctxt c @ tl (cPGM (GST sh p)), cTKN (GST sh p),\n         cLST (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps' \\<and>\n        (\\<forall>l\\<in>atC c. cTKN ps' = Some l)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule decomposeLS_fragmentsLS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l;\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragmentsLS (GST sh p)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule at_decomposeLS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l;\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragmentsLS (GST sh p);\n        atC a \\<subseteq> atCs (cPGM (GST sh p))\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule (1) subsetD[OF reachable_state_fragmentsLS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l;\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragmentsLS (GST sh p);\n        atC a \\<subseteq> atCs (cPGM (GST sh p));\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragments (PGMs sys p) {}\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule decomposeLS_basic_com)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l;\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragmentsLS (GST sh p);\n        atC a \\<subseteq> atCs (cPGM (GST sh p));\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragments (PGMs sys p) {};\n        basic_com a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule (1) small_step_loc_compC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>c aft cs.\n                   \\<lbrakk>(c, aft) \\<in> fragments (PGMs sys p) {};\n                    atC c \\<subseteq> atCs (cPGM (GST sh p));\n                    aft (cLST (GST sh p)) = atCs (cPGM ps');\n                    (c # cs,\n                     snd (GST sh\n                           p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n                    \\<forall>l\\<in>atC c. cTKN ps' = Some l\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        GST sh p \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        reachable_state sys sh; (a, aa, b) \\<in> decomposeLS (GST sh p);\n        cPGM (GST sh p) = aa a # tl (cPGM (GST sh p));\n        (a # b a @ tl (cPGM (GST sh p)),\n         snd (GST sh p)) \\<rightarrow>\\<^bsub>\\<alpha>\\<^esub> ps';\n        \\<forall>l\\<in>atC a. cTKN ps' = Some l;\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragmentsLS (GST sh p);\n        atC a \\<subseteq> atCs (cPGM (GST sh p));\n        (a, loc_compC a (b a @ tl (cPGM (GST sh p))))\n        \\<in> fragments (PGMs sys p) {};\n        basic_com a;\n        loc_compC a (b a @ tl (cPGM (GST sh p))) (cLST (GST sh p)) =\n        atCs (cPGM ps')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nReasoning by induction over the reachable states\nwith @{thm [source] \"decompose_small_step\"} is quite tedious. We\nprovide a very simple VCG that generates friendlier local proof\nobligations in \\S\\ref{sec:vcg}.\n\n\\<close>"], ["", "subsection\\<open>Simple-minded Hoare Logic/VCG for CIMP \\label{sec:vcg}\\<close>"], ["", "text\\<open>\n\n\\label{sec:cimp-vcg}\n\nWe do not develop a proper Hoare logic or full VCG for CIMP: this\nmachinery merely packages up the subgoals that arise from induction\nover the reachable states (\\S\\ref{sec:cimp-invariants}). This is\nsomewhat in the spirit of @{cite [cite_macro=citet] \"Ridge:2009\"}.\n\nNote that this approach is not compositional: it consults the original\nsystem to find matching communicating pairs, and \\<open>aft\\<close>\ntracks the labels of possible successor statements. More serious Hoare\nlogics are provided by @{cite [cite_macro=citet]\n\"DBLP:journals/acta/Lamport80\" and \"DBLP:journals/toplas/LamportS84\"\nand \"CousotCousot89-IC\"}.\n\nIntuitively we need to discharge a proof obligation for either @{const\n\"Request\"}s or @{const \"Response\"}s but not both. Here we choose to\nfocus on @{const \"Request\"}s as we expect to have more local\ninformation available about these.\n\n\\<close>"], ["", "inductive\n  vcg :: \"('answer, 'location, 'proc, 'question, 'state) programs\n        \\<Rightarrow> 'proc\n        \\<Rightarrow> ('answer, 'location, 'question, 'state) loc_comp\n        \\<Rightarrow> ('answer, 'location, 'proc, 'question, 'state) state_pred\n        \\<Rightarrow> ('answer, 'location, 'question, 'state) com\n        \\<Rightarrow> ('answer, 'location, 'proc, 'question, 'state) state_pred\n        \\<Rightarrow> bool\" (\"_, _, _ \\<turnstile>/ \\<lbrace>_\\<rbrace>/ _/ \\<lbrace>_\\<rbrace>\" [11,0,0,0,0,0] 11)\nwhere\n  \"\\<lbrakk> \\<And>aft' action' s ps' p's' l' \\<beta> s' p'.\n      \\<lbrakk> pre s; (\\<lbrace>l'\\<rbrace> Response action', aft') \\<in> fragments (coms p') {}; p \\<noteq> p';\n        ps' \\<in> val \\<beta> (s\\<down> p); (p's', \\<beta>) \\<in> action' (action (s\\<down> p)) (s\\<down> p');\n        at p l s; at p' l' s;\n        AT s' = (AT s)(p := aft (s\\<down> p), p' := aft' (s\\<down> p'));\n        s'\\<down> = s\\<down>(p := ps', p' := p's');\n        taken p l s';\n        HST s' = HST s @ [(action (s\\<down> p), \\<beta>)];\n        \\<forall>p''\\<in>-{p,p'}. GST s' p'' = GST s p''\n      \\<rbrakk> \\<Longrightarrow> post s'\n   \\<rbrakk> \\<Longrightarrow> coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> Request action val \\<lbrace>post\\<rbrace>\"\n| \"\\<lbrakk> \\<And>s ps' s'.\n      \\<lbrakk> pre s; ps' \\<in> f (s\\<down> p);\n        at p l s;\n        AT s' = (AT s)(p := aft (s\\<down> p));\n        s'\\<down> = s\\<down>(p := ps');\n        taken p l s';\n        HST s' = HST s;\n        \\<forall>p''\\<in>-{p}. GST s' p'' = GST s p''\n      \\<rbrakk> \\<Longrightarrow> post s'\n   \\<rbrakk> \\<Longrightarrow> coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> LocalOp f \\<lbrace>post\\<rbrace>\"\n| \"\\<lbrakk> \\<And>s s'.\n      \\<lbrakk> pre s;\n        at p l s;\n        AT s' = (AT s)(p := aft (s\\<down> p));\n        s'\\<down> = s\\<down>;\n        taken p l s';\n        HST s' = HST s;\n        \\<forall>p''\\<in>-{p}. GST s' p'' = GST s p''\n      \\<rbrakk> \\<Longrightarrow> post s'\n   \\<rbrakk> \\<Longrightarrow> coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> IF b THEN t FI \\<lbrace>post\\<rbrace>\"\n| \"\\<lbrakk> \\<And>s s'.\n      \\<lbrakk> pre s;\n        at p l s;\n        AT s' = (AT s)(p := aft (s\\<down> p));\n        s'\\<down> = s\\<down>;\n        taken p l s';\n        HST s' = HST s;\n        \\<forall>p''\\<in>-{p}. GST s' p'' = GST s p''\n      \\<rbrakk> \\<Longrightarrow> post s'\n   \\<rbrakk> \\<Longrightarrow> coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> IF b THEN t ELSE e FI \\<lbrace>post\\<rbrace>\"\n| \"\\<lbrakk> \\<And>s s'.\n      \\<lbrakk> pre s;\n        at p l s;\n        AT s' = (AT s)(p := aft (s\\<down> p));\n        s'\\<down> = s\\<down>;\n        taken p l s';\n        HST s' = HST s;\n        \\<forall>p''\\<in>-{p}. GST s' p'' = GST s p''\n      \\<rbrakk> \\<Longrightarrow> post s'\n   \\<rbrakk> \\<Longrightarrow> coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> WHILE b DO c OD \\<lbrace>post\\<rbrace>\"\n\\<comment> \\<open>There are no proof obligations for the following commands, but including them makes some basic rules hold (\\S\\ref{sec:cimp:vcg_rules}):\\<close>\n| \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> Response action \\<lbrace>post\\<rbrace>\"\n| \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> c1 ;; c2 \\<lbrace>post\\<rbrace>\"\n| \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> LOOP DO c OD \\<lbrace>post\\<rbrace>\"\n| \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> c1 \\<oplus> c2 \\<lbrace>post\\<rbrace>\""], ["", "text\\<open>\n\nWe abbreviate invariance with one-sided validity syntax.\n\n\\<close>"], ["", "abbreviation valid_inv (\"_, _, _ \\<turnstile>/ \\<lbrace>_\\<rbrace>/ _\" [11,0,0,0,0] 11) where\n  \"coms, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c \\<equiv> coms, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c \\<lbrace>I\\<rbrace>\""], ["", "inductive_cases vcg_inv:\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> Request action val \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> LocalOp f \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> IF b THEN t FI \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> IF b THEN t ELSE e FI \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> WHILE b DO c OD \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> LOOP DO c OD \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> \\<lbrace>l\\<rbrace> Response action \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> c1 ;; c2 \\<lbrace>post\\<rbrace>\"\n  \"coms, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> Choose c1 c2 \\<lbrace>post\\<rbrace>\""], ["", "text\\<open>\n\nWe tweak @{const \"fragments\"} by omitting @{const \"Response\"}s,\nyielding fewer obligations\n\n\\<close>"], ["", "fun\n  vcg_fragments' :: \"('answer, 'location, 'question, 'state) com\n               \\<Rightarrow> 'location set\n               \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                 \\<times> ('answer, 'location, 'question, 'state) loc_comp ) set\"\nwhere\n  \"vcg_fragments' (\\<lbrace>l\\<rbrace> Response action) aft = {}\"\n| \"vcg_fragments' (\\<lbrace>l\\<rbrace> IF b THEN c FI) aft\n       = vcg_fragments' c aft\n       \\<union> { (\\<lbrace>l\\<rbrace> IF b THEN c' FI, lcond (atC c) aft b) |c'. True }\"\n| \"vcg_fragments' (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI) aft\n       = vcg_fragments' c2 aft \\<union> vcg_fragments' c1 aft\n       \\<union> { (\\<lbrace>l\\<rbrace> IF b THEN c1' ELSE c2' FI, lcond (atC c1) (atC c2) b) |c1' c2'. True }\"\n| \"vcg_fragments' (LOOP DO c OD) aft = vcg_fragments' c (atC c)\"\n| \"vcg_fragments' (\\<lbrace>l\\<rbrace> WHILE b DO c OD) aft\n       = vcg_fragments' c {l} \\<union> { (\\<lbrace>l\\<rbrace> WHILE b DO c' OD, lcond (atC c) aft b) |c'. True }\"\n| \"vcg_fragments' (c1 ;; c2) aft = vcg_fragments' c2 aft \\<union> vcg_fragments' c1 (atC c2)\"\n| \"vcg_fragments' (c1 \\<oplus> c2) aft = vcg_fragments' c1 aft \\<union> vcg_fragments' c2 aft\"\n| \"vcg_fragments' c aft = {(c, lconst aft)}\""], ["", "abbreviation\n  vcg_fragments :: \"('answer, 'location, 'question, 'state) com\n                  \\<Rightarrow> ( ('answer, 'location, 'question, 'state) com\n                    \\<times> ('answer, 'location, 'question, 'state) loc_comp ) set\"\nwhere\n  \"vcg_fragments c \\<equiv> vcg_fragments' c {}\""], ["", "fun isResponse :: \"('answer, 'location, 'question, 'state) com \\<Rightarrow> bool\" where\n  \"isResponse (\\<lbrace>l\\<rbrace> Response action) \\<longleftrightarrow> True\"\n| \"isResponse _ \\<longleftrightarrow> False\""], ["", "lemma fragments_vcg_fragments':\n  \"\\<lbrakk> (c, aft) \\<in> fragments c' aft'; \\<not>isResponse c \\<rbrakk> \\<Longrightarrow> (c, aft) \\<in> vcg_fragments' c' aft'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, aft) \\<in> fragments c' aft'; \\<not> isResponse c\\<rbrakk>\n    \\<Longrightarrow> (c, aft) \\<in> vcg_fragments' c' aft'", "by (induct c' arbitrary: aft') auto"], ["", "lemma vcg_fragments'_fragments:\n  \"vcg_fragments' c' aft' \\<subseteq> fragments c' aft'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcg_fragments' c' aft' \\<subseteq> fragments c' aft'", "by (induct c' arbitrary: aft') (auto 10 0)"], ["", "lemma VCG_step:\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>pre\\<rbrace> c \\<lbrace>post\\<rbrace>\"\n  assumes S: \"system_step p sh' sh\"\n  assumes R: \"reachable_state sys sh\"\n  assumes P: \"pre sh\"\n  shows \"post sh'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post sh'", "using S"], ["proof (prove)\nusing this:\n  system_step p sh' sh\n\ngoal (1 subgoal):\n 1. post sh'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa ls'.\n       \\<lbrakk>p = {pa}; GST sh pa \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls';\n        GST sh' = (GST sh)(pa := ls'); HST sh' = HST sh\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 2. \\<And>pa \\<alpha> \\<beta> ls1' q ls2'.\n       \\<lbrakk>p = {pa, q};\n        GST sh\n         pa \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1';\n        GST sh\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2';\n        pa \\<noteq> q; GST sh' = (GST sh)(pa := ls1', q := ls2');\n        HST sh' = HST sh @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> post sh'", "case LocalStep"], ["proof (state)\nthis:\n  p = {p_}\n  GST sh p_ \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_\n  GST sh' = (GST sh)(p_ := ls'_)\n  HST sh' = HST sh\n\ngoal (2 subgoals):\n 1. \\<And>pa ls'.\n       \\<lbrakk>p = {pa}; GST sh pa \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls';\n        GST sh' = (GST sh)(pa := ls'); HST sh' = HST sh\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 2. \\<And>pa \\<alpha> \\<beta> ls1' q ls2'.\n       \\<lbrakk>p = {pa, q};\n        GST sh\n         pa \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1';\n        GST sh\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2';\n        pa \\<noteq> q; GST sh' = (GST sh)(pa := ls1', q := ls2');\n        HST sh' = HST sh @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> post sh'", "with P"], ["proof (chain)\npicking this:\n  pre sh\n  p = {p_}\n  GST sh p_ \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_\n  GST sh' = (GST sh)(p_ := ls'_)\n  HST sh' = HST sh", "show ?thesis"], ["proof (prove)\nusing this:\n  pre sh\n  p = {p_}\n  GST sh p_ \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_\n  GST sh' = (GST sh)(p_ := ls'_)\n  HST sh' = HST sh\n\ngoal (1 subgoal):\n 1. post sh'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre sh; p = {p_};\n     GST sh p_ \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n     GST sh' = (GST sh)(p_ := ls'_); HST sh' = HST sh\\<rbrakk>\n    \\<Longrightarrow> post sh'", "apply (erule decompose_small_step[OF _ R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs aft.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l\\<rbrakk>\n       \\<Longrightarrow> post sh'", "apply (frule fragments_basic_com)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs aft.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l; basic_com c\\<rbrakk>\n       \\<Longrightarrow> post sh'", "apply (erule basic_com.cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c cs aft l action val.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> Request action val\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 2. \\<And>c cs aft l action.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> Response action\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 3. \\<And>c cs aft l R.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> LocalOp R\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 4. \\<And>c cs aft l b ca.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> IF b THEN ca FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 5. \\<And>c cs aft l b c1 c2.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 6. \\<And>c cs aft l b ca.\n       \\<lbrakk>pre sh; p = {p_}; GST sh' = (GST sh)(p_ := ls'_);\n        HST sh' = HST sh; (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST (GST sh p_)) \\<rightarrow>\\<^bsub>\\<tau>\\<^esub> ls'_;\n        \\<forall>l\\<in>atC c. cTKN ls'_ = Some l;\n        c = \\<lbrace>l\\<rbrace> WHILE b DO ca OD\\<rbrakk>\n       \\<Longrightarrow> post sh'", "apply (fastforce dest!: fragments_vcg_fragments' V[rule_format]\n                      elim: vcg_inv elim!: small_step_inv\n                      simp: LST_def AT_def taken_def fun_eq_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  post sh'\n\ngoal (1 subgoal):\n 1. \\<And>pa \\<alpha> \\<beta> ls1' q ls2'.\n       \\<lbrakk>p = {pa, q};\n        GST sh\n         pa \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1';\n        GST sh\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2';\n        pa \\<noteq> q; GST sh' = (GST sh)(pa := ls1', q := ls2');\n        HST sh' = HST sh @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> post sh'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa \\<alpha> \\<beta> ls1' q ls2'.\n       \\<lbrakk>p = {pa, q};\n        GST sh\n         pa \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1';\n        GST sh\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2';\n        pa \\<noteq> q; GST sh' = (GST sh)(pa := ls1', q := ls2');\n        HST sh' = HST sh @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> post sh'", "case CommunicationStep"], ["proof (state)\nthis:\n  p = {p_, q_}\n  GST sh\n   p_ \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_\n  GST sh\n   q_ \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_\n  p_ \\<noteq> q_\n  GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_)\n  HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)]\n\ngoal (1 subgoal):\n 1. \\<And>pa \\<alpha> \\<beta> ls1' q ls2'.\n       \\<lbrakk>p = {pa, q};\n        GST sh\n         pa \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>, \\<beta>\\<guillemotright>\\<^esub> ls1';\n        GST sh\n         q \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>, \\<beta>\\<guillemotleft>\\<^esub> ls2';\n        pa \\<noteq> q; GST sh' = (GST sh)(pa := ls1', q := ls2');\n        HST sh' = HST sh @ [(\\<alpha>, \\<beta>)]\\<rbrakk>\n       \\<Longrightarrow> post sh'", "with P"], ["proof (chain)\npicking this:\n  pre sh\n  p = {p_, q_}\n  GST sh\n   p_ \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_\n  GST sh\n   q_ \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_\n  p_ \\<noteq> q_\n  GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_)\n  HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)]", "show ?thesis"], ["proof (prove)\nusing this:\n  pre sh\n  p = {p_, q_}\n  GST sh\n   p_ \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_\n  GST sh\n   q_ \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_\n  p_ \\<noteq> q_\n  GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_)\n  HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)]\n\ngoal (1 subgoal):\n 1. post sh'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre sh; p = {p_, q_};\n     GST sh\n      p_ \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n     GST sh\n      q_ \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n     p_ \\<noteq> q_; GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n     HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)]\\<rbrakk>\n    \\<Longrightarrow> post sh'", "apply (erule decompose_small_step[OF _ R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs aft.\n       \\<lbrakk>pre sh; p = {p_, q_};\n        GST sh\n         q_ \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        p_ \\<noteq> q_; GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST\n          (GST sh\n            p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        \\<forall>l\\<in>atC c. cTKN ls1'_ = Some l\\<rbrakk>\n       \\<Longrightarrow> post sh'", "apply (erule decompose_small_step[OF _ R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs aft ca csa afta.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (c, aft) \\<in> fragments (PGMs sys p_) {};\n        atC c \\<subseteq> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (c # cs, cTKN (GST sh p_),\n         cLST\n          (GST sh\n            p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        \\<forall>l\\<in>atC c. cTKN ls1'_ = Some l;\n        (ca, afta) \\<in> fragments (PGMs sys q_) {};\n        atC ca \\<subseteq> atCs (cPGM (GST sh q_));\n        afta (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (ca # csa, cTKN (GST sh q_),\n         cLST\n          (GST sh\n            q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        \\<forall>l\\<in>atC ca. cTKN ls2'_ = Some l\\<rbrakk>\n       \\<Longrightarrow> post sh'", "subgoal for c cs aft c' cs' aft'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n     GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n     HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n     (c, aft) \\<in> fragments (PGMs sys p_) {};\n     atC c \\<subseteq> atCs (cPGM (GST sh p_));\n     aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n     (c # cs, cTKN (GST sh p_),\n      cLST\n       (GST sh\n         p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n     \\<forall>l\\<in>atC c. cTKN ls1'_ = Some l;\n     (c', aft') \\<in> fragments (PGMs sys q_) {};\n     atC c' \\<subseteq> atCs (cPGM (GST sh q_));\n     aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n     (c' # cs', cTKN (GST sh q_),\n      cLST\n       (GST sh\n         q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n     \\<forall>l\\<in>atC c'. cTKN ls2'_ = Some l\\<rbrakk>\n    \\<Longrightarrow> post sh'", "apply (frule fragments_basic_com[where c'=c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n     GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n     HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n     (c, aft) \\<in> fragments (PGMs sys p_) {};\n     atC c \\<subseteq> atCs (cPGM (GST sh p_));\n     aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n     (c # cs, cTKN (GST sh p_),\n      cLST\n       (GST sh\n         p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n     \\<forall>l\\<in>atC c. cTKN ls1'_ = Some l;\n     (c', aft') \\<in> fragments (PGMs sys q_) {};\n     atC c' \\<subseteq> atCs (cPGM (GST sh q_));\n     aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n     (c' # cs', cTKN (GST sh q_),\n      cLST\n       (GST sh\n         q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n     \\<forall>l\\<in>atC c'. cTKN ls2'_ = Some l; basic_com c\\<rbrakk>\n    \\<Longrightarrow> post sh'", "apply (frule fragments_basic_com[where c'=c'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n     GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n     HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n     (c, aft) \\<in> fragments (PGMs sys p_) {};\n     atC c \\<subseteq> atCs (cPGM (GST sh p_));\n     aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n     (c # cs, cTKN (GST sh p_),\n      cLST\n       (GST sh\n         p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n     \\<forall>l\\<in>atC c. cTKN ls1'_ = Some l;\n     (c', aft') \\<in> fragments (PGMs sys q_) {};\n     atC c' \\<subseteq> atCs (cPGM (GST sh q_));\n     aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n     (c' # cs', cTKN (GST sh q_),\n      cLST\n       (GST sh\n         q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n     \\<forall>l\\<in>atC c'. cTKN ls2'_ = Some l; basic_com c;\n     basic_com c'\\<rbrakk>\n    \\<Longrightarrow> post sh'", "apply (elim basic_com.cases; clarsimp elim!: small_step_inv)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>l action val la actiona s' s uv_ sa s'a uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)\n        (p_ := (cs, Some l, s'a), q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(action sa, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft sa = atCs cs;\n        (\\<lbrace>la\\<rbrace> Response actiona, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> Response actiona;\n        snd (GST sh q_) = (uv_, s);\n        (s', \\<beta>_) \\<in> actiona (action sa) s;\n        ls2'_ = (cs', Some la, s'); snd (GST sh p_) = (uu_, sa);\n        s'a \\<in> val \\<beta>_ sa; ls1'_ = (cs, Some l, s'a);\n        \\<alpha>_ = action sa\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 2. \\<And>l action val la b ca s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> IF b THEN ca FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF b THEN ca FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> IF b THEN ca FI;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 3. \\<And>l action val la b c1 c2 s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 4. \\<And>l action val la b ca s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> WHILE b DO ca OD, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> WHILE b DO ca OD # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> WHILE b DO ca OD;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 5. \\<And>l b ca la action s' s uv_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> Response action, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> Response action;\n        snd (GST sh q_) = (uv_, s); (s', \\<beta>_) \\<in> action \\<alpha>_ s;\n        ls2'_ = (cs', Some la, s')\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 6. \\<And>l b ca la ba caa.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> IF ba THEN caa FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF ba THEN caa FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> IF ba THEN caa FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 7. \\<And>l b ca la ba c1 c2.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 8. \\<And>l b ca la ba caa.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> WHILE ba DO caa OD, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> WHILE ba DO caa OD # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> WHILE ba DO caa OD\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 9. \\<And>l b c1 c2 la action s' s uv_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> Response action, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI;\n        c' = \\<lbrace>la\\<rbrace> Response action;\n        snd (GST sh q_) = (uv_, s); (s', \\<beta>_) \\<in> action \\<alpha>_ s;\n        ls2'_ = (cs', Some la, s')\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 10. \\<And>l b c1 c2 la ba ca.\n        \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n         GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n         HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n         (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI, aft)\n         \\<in> fragments (PGMs sys p_) {};\n         l \\<in> atCs (cPGM (GST sh p_));\n         aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n         (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs,\n          snd (GST sh\n                p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n         cTKN ls1'_ = Some l;\n         (\\<lbrace>la\\<rbrace> IF ba THEN ca FI, aft')\n         \\<in> fragments (PGMs sys q_) {};\n         la \\<in> atCs (cPGM (GST sh q_));\n         aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n         (\\<lbrace>la\\<rbrace> IF ba THEN ca FI # cs',\n          snd (GST sh\n                q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n         cTKN ls2'_ = Some la;\n         c = \\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI;\n         c' = \\<lbrace>la\\<rbrace> IF ba THEN ca FI\\<rbrakk>\n        \\<Longrightarrow> post sh'\nA total of 16 subgoals...", "apply (drule fragments_vcg_fragments')"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>l action val la actiona s' s uv_ sa s'a uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)\n        (p_ := (cs, Some l, s'a), q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(action sa, \\<beta>_)];\n        l \\<in> atCs (cPGM (GST sh p_)); aft sa = atCs cs;\n        (\\<lbrace>la\\<rbrace> Response actiona, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> Response actiona;\n        snd (GST sh q_) = (uv_, s);\n        (s', \\<beta>_) \\<in> actiona (action sa) s;\n        ls2'_ = (cs', Some la, s'); snd (GST sh p_) = (uu_, sa);\n        s'a \\<in> val \\<beta>_ sa; ls1'_ = (cs, Some l, s'a);\n        \\<alpha>_ = action sa\\<rbrakk>\n       \\<Longrightarrow> \\<not> isResponse\n                                 (\\<lbrace>l\\<rbrace> Request action val)\n 2. \\<And>l action val la actiona s' s uv_ sa s'a uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)\n        (p_ := (cs, Some l, s'a), q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(action sa, \\<beta>_)];\n        l \\<in> atCs (cPGM (GST sh p_)); aft sa = atCs cs;\n        (\\<lbrace>la\\<rbrace> Response actiona, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> Response actiona;\n        snd (GST sh q_) = (uv_, s);\n        (s', \\<beta>_) \\<in> actiona (action sa) s;\n        ls2'_ = (cs', Some la, s'); snd (GST sh p_) = (uu_, sa);\n        s'a \\<in> val \\<beta>_ sa; ls1'_ = (cs, Some l, s'a);\n        \\<alpha>_ = action sa;\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> vcg_fragments (PGMs sys p_)\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 3. \\<And>l action val la b ca s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> IF b THEN ca FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF b THEN ca FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> IF b THEN ca FI;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 4. \\<And>l action val la b c1 c2 s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> IF b THEN c1 ELSE c2 FI;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 5. \\<And>l action val la b ca s s' uu_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := (cs, Some l, s'), q_ := ls2'_);\n        HST sh' = HST sh @ [(action s, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> Request action val, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_)); aft s = atCs cs;\n        (\\<lbrace>la\\<rbrace> WHILE b DO ca OD, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> WHILE b DO ca OD # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>action\n                     s, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> Request action val;\n        c' = \\<lbrace>la\\<rbrace> WHILE b DO ca OD;\n        snd (GST sh p_) = (uu_, s); s' \\<in> val \\<beta>_ s;\n        ls1'_ = (cs, Some l, s'); \\<alpha>_ = action s\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 6. \\<And>l b ca la action s' s uv_.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := (cs', Some la, s'));\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> Response action, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n        c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> Response action;\n        snd (GST sh q_) = (uv_, s); (s', \\<beta>_) \\<in> action \\<alpha>_ s;\n        ls2'_ = (cs', Some la, s')\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 7. \\<And>l b ca la ba caa.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> IF ba THEN caa FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF ba THEN caa FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> IF ba THEN caa FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 8. \\<And>l b ca la ba c1 c2.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> IF ba THEN c1 ELSE c2 FI\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 9. \\<And>l b ca la ba caa.\n       \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n        GST sh' = (GST sh)(p_ := ls1'_, q_ := ls2'_);\n        HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI, aft)\n        \\<in> fragments (PGMs sys p_) {};\n        l \\<in> atCs (cPGM (GST sh p_));\n        aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n        (\\<lbrace>l\\<rbrace> IF b THEN ca FI # cs,\n         snd (GST sh\n               p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n        cTKN ls1'_ = Some l;\n        (\\<lbrace>la\\<rbrace> WHILE ba DO caa OD, aft')\n        \\<in> fragments (PGMs sys q_) {};\n        la \\<in> atCs (cPGM (GST sh q_));\n        aft' (cLST (GST sh q_)) = atCs (cPGM ls2'_);\n        (\\<lbrace>la\\<rbrace> WHILE ba DO caa OD # cs',\n         snd (GST sh\n               q_)) \\<rightarrow>\\<^bsub>\\<guillemotright>\\<alpha>_, \\<beta>_\\<guillemotleft>\\<^esub> ls2'_;\n        cTKN ls2'_ = Some la; c = \\<lbrace>l\\<rbrace> IF b THEN ca FI;\n        c' = \\<lbrace>la\\<rbrace> WHILE ba DO caa OD\\<rbrakk>\n       \\<Longrightarrow> post sh'\n 10. \\<And>l b c1 c2 la action s' s uv_.\n        \\<lbrakk>pre sh; p = {p_, q_}; p_ \\<noteq> q_;\n         GST sh' = (GST sh)(p_ := ls1'_, q_ := (cs', Some la, s'));\n         HST sh' = HST sh @ [(\\<alpha>_, \\<beta>_)];\n         (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI, aft)\n         \\<in> fragments (PGMs sys p_) {};\n         l \\<in> atCs (cPGM (GST sh p_));\n         aft (cLST (GST sh p_)) = atCs (cPGM ls1'_);\n         (\\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI # cs,\n          snd (GST sh\n                p_)) \\<rightarrow>\\<^bsub>\\<guillemotleft>\\<alpha>_, \\<beta>_\\<guillemotright>\\<^esub> ls1'_;\n         cTKN ls1'_ = Some l;\n         (\\<lbrace>la\\<rbrace> Response action, aft')\n         \\<in> fragments (PGMs sys q_) {};\n         la \\<in> atCs (cPGM (GST sh q_)); aft' s = atCs cs';\n         c = \\<lbrace>l\\<rbrace> IF b THEN c1 ELSE c2 FI;\n         c' = \\<lbrace>la\\<rbrace> Response action;\n         snd (GST sh q_) = (uv_, s);\n         (s', \\<beta>_) \\<in> action \\<alpha>_ s;\n         ls2'_ = (cs', Some la, s')\\<rbrakk>\n        \\<Longrightarrow> post sh'\nA total of 17 subgoals...", "apply (fastforce dest!: V[rule_format]\n                      elim: vcg_inv elim!: small_step_inv\n                      simp: LST_def AT_def taken_def fun_eq_iff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  post sh'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe user sees the conclusion of \\<open>V\\<close> for each element of @{const \\<open>vcg_fragments\\<close>}.\n\n\\<close>"], ["", "lemma VCG_step_inv_stable:\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c\"\n  assumes \"prerun sys \\<sigma>\"\n  shows \"(\\<lceil>I\\<rceil> \\<^bold>\\<hookrightarrow> \\<circle>\\<lceil>I\\<rceil>) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box>(\\<lambda>s.\n               \\<lceil>I\\<rceil> s \\<longrightarrow>\n               (\\<circle>\\<lceil>I\\<rceil>) s))\n     \\<sigma>", "apply (rule alwaysI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lceil>I\\<rceil> (\\<sigma> |\\<^sub>s i) \\<longrightarrow>\n       (\\<circle>\\<lceil>I\\<rceil>) (\\<sigma> |\\<^sub>s i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       I (\\<sigma> i) \\<Longrightarrow>\n       (\\<circle>\\<lceil>I\\<rceil>) (\\<sigma> |\\<^sub>s i)", "apply (rule nextI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       I (\\<sigma> i) \\<Longrightarrow>\n       \\<lceil>I\\<rceil> (\\<sigma> |\\<^sub>s i |\\<^sub>s Suc 0)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. I (\\<sigma> i) \\<Longrightarrow> I (\\<sigma> (Suc i))", "using assms(2)"], ["proof (prove)\nusing this:\n  prerun sys \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>i. I (\\<sigma> i) \\<Longrightarrow> I (\\<sigma> (Suc i))", "unfolding prerun_def"], ["proof (prove)\nusing this:\n  (initial_state sys (GST (\\<sigma> 0)) \\<and> HST (\\<sigma> 0) = []) \\<and>\n  (\\<box>system_step_reflclp) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>i. I (\\<sigma> i) \\<Longrightarrow> I (\\<sigma> (Suc i))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = []; (\\<box>system_step_reflclp) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "apply (erule_tac i=i in alwaysE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        system_step_reflclp (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "unfolding system_step_reflclp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        (\\<lambda>sh sh'.\n            \\<exists>pls. system_step pls sh' sh)\\<^sup>=\\<^sup>=\n         ((\\<sigma> |\\<^sub>s i) 0) ((\\<sigma> |\\<^sub>s i) 1)\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        (\\<exists>pls.\n            system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)) \\<or>\n        \\<sigma> i = \\<sigma> (Suc i)\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "apply (erule disjE; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i pls.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "using VCG_step[where pre=I and post=I] V assms(2) prerun_reachable_state"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p.\n              \\<forall>(c, aft)\\<in>vcg_fragments (PGMs ?sys p).\n                 PGMs ?sys, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c;\n   system_step ?p ?sh' ?sh; reachable_state ?sys ?sh; I ?sh\\<rbrakk>\n  \\<Longrightarrow> I ?sh'\n  \\<forall>(c, aft)\\<in>vcg_fragments (PGMs sys ?p).\n     PGMs sys, ?p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c\n  prerun sys \\<sigma>\n  prerun ?sys ?\\<sigma> \\<Longrightarrow>\n  reachable_state ?sys (?\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i pls.\n       \\<lbrakk>I (\\<sigma> i); initial_state sys (GST (\\<sigma> 0));\n        HST (\\<sigma> 0) = [];\n        system_step pls (\\<sigma> (Suc i)) (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> (Suc i))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VCG:\n  assumes I: \"\\<forall>s. initial_state sys s \\<longrightarrow> I (\\<lparr>GST = s, HST = []\\<rparr>)\"\n  assumes V: \"\\<And>p. \\<forall>(c, aft) \\<in> vcg_fragments (PGMs sys p). PGMs sys, p, aft \\<turnstile> \\<lbrace>I\\<rbrace> c\"\n  shows \"sys \\<Turnstile>\\<^bsub>pre\\<^esub> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys \\<Turnstile>\\<^bsub>pre\\<^esub> I", "apply (rule prerun_valid_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       prerun sys \\<sigma> \\<Longrightarrow> \\<lceil>I\\<rceil> \\<sigma>\n 2. \\<And>\\<sigma>.\n       prerun sys \\<sigma> \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  \\<lceil>I\\<rceil> s \\<longrightarrow>\n                  (\\<circle>\\<lceil>I\\<rceil>) s))\n        \\<sigma>", "apply (clarsimp simp: prerun_def state_prop_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>initial_state sys (GST (\\<sigma> 0)); HST (\\<sigma> 0) = [];\n        (\\<box>system_step_reflclp) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (\\<sigma> 0)\n 2. \\<And>\\<sigma>.\n       prerun sys \\<sigma> \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  \\<lceil>I\\<rceil> s \\<longrightarrow>\n                  (\\<circle>\\<lceil>I\\<rceil>) s))\n        \\<sigma>", "apply (metis (full_types) I old.unit.exhaust system_state.surjective)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       prerun sys \\<sigma> \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  \\<lceil>I\\<rceil> s \\<longrightarrow>\n                  (\\<circle>\\<lceil>I\\<rceil>) s))\n        \\<sigma>", "using VCG_step_inv_stable[OF V]"], ["proof (prove)\nusing this:\n  prerun sys ?\\<sigma> \\<Longrightarrow>\n  (\\<box>(\\<lambda>s.\n             \\<lceil>I\\<rceil> s \\<longrightarrow>\n             (\\<circle>\\<lceil>I\\<rceil>) s))\n   ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       prerun sys \\<sigma> \\<Longrightarrow>\n       (\\<box>(\\<lambda>s.\n                  \\<lceil>I\\<rceil> s \\<longrightarrow>\n                  (\\<circle>\\<lceil>I\\<rceil>) s))\n        \\<sigma>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas VCG_valid = valid_prerun_lift[OF VCG, of sys I] for sys I"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}