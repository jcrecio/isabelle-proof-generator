{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP/CIMP_pred.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP", "problem_names": ["lemma triv: \"P \\<Longrightarrow> P\"", "lemma always_eventually_pigeonhole:\n  \"(\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) \\<longleftrightarrow> (\\<exists>m\\<le>k::nat. \\<forall>i::nat. \\<exists>n\\<ge>i. P m n)\""], "translations": [["", "lemma triv: \"P \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> P", "by simp"], ["", "lemma always_eventually_pigeonhole:\n  \"(\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) \\<longleftrightarrow> (\\<exists>m\\<le>k::nat. \\<forall>i::nat. \\<exists>n\\<ge>i. P m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n    (\\<exists>m\\<le>k. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>0. P m n) =\n    (\\<exists>m\\<le>0. \\<forall>i. \\<exists>n\\<ge>i. P m n)\n 2. \\<And>k.\n       (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n       (\\<exists>m\\<le>k.\n           \\<forall>i. \\<exists>n\\<ge>i. P m n) \\<Longrightarrow>\n       (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n) =\n       (\\<exists>m\\<le>Suc k. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "case (Suc k)"], ["proof (state)\nthis:\n  (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n  (\\<exists>m\\<le>k. \\<forall>i. \\<exists>n\\<ge>i. P m n)\n\ngoal (2 subgoals):\n 1. (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>0. P m n) =\n    (\\<exists>m\\<le>0. \\<forall>i. \\<exists>n\\<ge>i. P m n)\n 2. \\<And>k.\n       (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n       (\\<exists>m\\<le>k.\n           \\<forall>i. \\<exists>n\\<ge>i. P m n) \\<Longrightarrow>\n       (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n) =\n       (\\<exists>m\\<le>Suc k. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n  (\\<exists>m\\<le>k. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n) =\n  (\\<exists>m\\<le>k. \\<forall>i. \\<exists>n\\<ge>i. P m n)\n\ngoal (1 subgoal):\n 1. (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n) =\n    (\\<exists>m\\<le>Suc k. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "apply (auto 8 0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n;\n        m \\<le> k; \\<forall>i. \\<exists>n\\<ge>i. P m n;\n        \\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc k.\n                            \\<forall>i. \\<exists>n\\<ge>i. P m n\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<le>k.\n                   \\<exists>i. \\<forall>n\\<ge>i. \\<not> P m n;\n        \\<forall>n\\<ge>i. \\<forall>m\\<le>k. \\<not> P m n;\n        \\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc k.\n                            \\<forall>i. \\<exists>n\\<ge>i. P m n", "using le_SucI"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> ?m \\<le> Suc ?n\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>k. P m n;\n        m \\<le> k; \\<forall>i. \\<exists>n\\<ge>i. P m n;\n        \\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc k.\n                            \\<forall>i. \\<exists>n\\<ge>i. P m n\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<le>k.\n                   \\<exists>i. \\<forall>n\\<ge>i. \\<not> P m n;\n        \\<forall>n\\<ge>i. \\<forall>m\\<le>k. \\<not> P m n;\n        \\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc k.\n                            \\<forall>i. \\<exists>n\\<ge>i. P m n", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>m\\<le>k.\n                   \\<exists>i. \\<forall>n\\<ge>i. \\<not> P m n;\n        \\<forall>n\\<ge>i. \\<forall>m\\<le>k. \\<not> P m n;\n        \\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc k.\n                            \\<forall>i. \\<exists>n\\<ge>i. P m n", "apply (metis (full_types) le_Suc_eq nat_le_linear order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>Suc k. P m n) =\n  (\\<exists>m\\<le>Suc k. \\<forall>i. \\<exists>n\\<ge>i. P m n)\n\ngoal (1 subgoal):\n 1. (\\<forall>i. \\<exists>n\\<ge>i. \\<exists>m\\<le>0. P m n) =\n    (\\<exists>m\\<le>0. \\<forall>i. \\<exists>n\\<ge>i. P m n)", "qed simp"], ["", "(*>*)"], ["", "section\\<open> Point-free notation \\<close>"], ["", "text\\<open>\n\n\\label{sec:cimp-lifted-predicates}\n\nTypically we define predicates as functions of a state. The following\nprovide a somewhat comfortable point-free imitation of Isabelle/HOL's\noperators.\n\n\\<close>"], ["", "abbreviation (input)\n  pred_K :: \"'b \\<Rightarrow> 'a \\<Rightarrow> 'b\" (\"\\<langle>_\\<rangle>\") where\n  \"\\<langle>f\\<rangle> \\<equiv> \\<lambda>s. f\""], ["", "abbreviation (input)\n  pred_not :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"\\<^bold>\\<not> _\" [40] 40) where\n  \"\\<^bold>\\<not>a \\<equiv> \\<lambda>s. \\<not>a s\""], ["", "abbreviation (input)\n  pred_conj :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixr \"\\<^bold>\\<and>\" 35) where\n  \"a \\<^bold>\\<and> b \\<equiv> \\<lambda>s. a s \\<and> b s\""], ["", "abbreviation (input)\n  pred_disj :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixr \"\\<^bold>\\<or>\" 30) where\n  \"a \\<^bold>\\<or> b \\<equiv> \\<lambda>s. a s \\<or> b s\""], ["", "abbreviation (input)\n  pred_implies :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixr \"\\<^bold>\\<longrightarrow>\" 25) where\n  \"a \\<^bold>\\<longrightarrow> b \\<equiv> \\<lambda>s. a s \\<longrightarrow> b s\""], ["", "abbreviation (input)\n  pred_iff :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixr \"\\<^bold>\\<longleftrightarrow>\" 25) where\n  \"a \\<^bold>\\<longleftrightarrow> b \\<equiv> \\<lambda>s. a s \\<longleftrightarrow> b s\""], ["", "abbreviation (input)\n  pred_eq :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold>=\" 40) where\n  \"a \\<^bold>= b \\<equiv> \\<lambda>s. a s = b s\""], ["", "abbreviation (input)\n  pred_member :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold>\\<in>\" 40) where\n  \"a \\<^bold>\\<in> b \\<equiv> \\<lambda>s. a s \\<in> b s\""], ["", "abbreviation (input)\n  pred_neq :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold>\\<noteq>\" 40) where\n  \"a \\<^bold>\\<noteq> b \\<equiv> \\<lambda>s. a s \\<noteq> b s\""], ["", "abbreviation (input)\n  pred_If :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" (\"(If (_)/ Then (_)/ Else (_))\" [0, 0, 10] 10)\n  where \"If P Then x Else y \\<equiv> \\<lambda>s. if P s then x s else y s\""], ["", "abbreviation (input)\n  pred_less :: \"('a \\<Rightarrow> 'b::ord) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold><\" 40) where\n  \"a \\<^bold>< b \\<equiv> \\<lambda>s. a s < b s\""], ["", "abbreviation (input)\n  pred_le :: \"('a \\<Rightarrow> 'b::ord) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold>\\<le>\" 40) where\n  \"a \\<^bold>\\<le> b \\<equiv> \\<lambda>s. a s \\<le> b s\""], ["", "abbreviation (input)\n  pred_plus :: \"('a \\<Rightarrow> 'b::plus) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" (infixl \"\\<^bold>+\" 65) where\n  \"a \\<^bold>+ b \\<equiv> \\<lambda>s. a s + b s\""], ["", "abbreviation (input)\n  pred_minus :: \"('a \\<Rightarrow> 'b::minus) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" (infixl \"\\<^bold>-\" 65) where\n  \"a \\<^bold>- b \\<equiv> \\<lambda>s. a s - b s\""], ["", "abbreviation (input)\n  fun_fanout :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> 'a \\<Rightarrow> 'b \\<times> 'c\" (infix \"\\<^bold>\\<bowtie>\" 35) where\n  \"f \\<^bold>\\<bowtie> g \\<equiv> \\<lambda>x. (f x, g x)\""], ["", "abbreviation (input)\n  pred_all :: \"('b \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (binder \"\\<^bold>\\<forall>\" 10) where\n  \"\\<^bold>\\<forall>x. P x \\<equiv> \\<lambda>s. \\<forall>x. P x s\""], ["", "abbreviation (input)\n  pred_ex :: \"('b \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" (binder \"\\<^bold>\\<exists>\" 10) where\n  \"\\<^bold>\\<exists>x. P x \\<equiv> \\<lambda>s. \\<exists>x. P x s\""], ["", "abbreviation (input)\n  pred_app :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'c\" (infixl \"\\<^bold>$\" 100) where\n  \"f \\<^bold>$ g \\<equiv> \\<lambda>s. f (g s) s\""], ["", "abbreviation (input)\n  pred_subseteq :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<^bold>\\<subseteq>\" 50) where\n  \"A \\<^bold>\\<subseteq> B \\<equiv> \\<lambda>s. A s \\<subseteq> B s\""], ["", "abbreviation (input)\n  pred_union :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a \\<Rightarrow> 'b set\" (infixl \"\\<^bold>\\<union>\" 65) where\n  \"a \\<^bold>\\<union> b \\<equiv> \\<lambda>s. a s \\<union> b s\""], ["", "abbreviation (input)\n  pred_inter :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a \\<Rightarrow> 'b set\" (infixl \"\\<^bold>\\<inter>\" 65) where\n  \"a \\<^bold>\\<inter> b \\<equiv> \\<lambda>s. a s \\<inter> b s\""], ["", "text\\<open>\n\nMore application specific.\n\n\\<close>"], ["", "abbreviation (input)\n  pred_conjoin :: \"('a \\<Rightarrow> bool) list \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"pred_conjoin xs \\<equiv> foldr (\\<^bold>\\<and>) xs \\<langle>True\\<rangle>\""], ["", "abbreviation (input)\n  pred_disjoin :: \"('a \\<Rightarrow> bool) list \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"pred_disjoin xs \\<equiv> foldr (\\<^bold>\\<or>) xs \\<langle>False\\<rangle>\""], ["", "abbreviation (input)\n  pred_is_none :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"NULL _\" [40] 40) where\n  \"NULL a \\<equiv> \\<lambda>s. a s = None\""], ["", "abbreviation (input)\n  pred_empty :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"EMPTY _\" [40] 40) where\n  \"EMPTY a \\<equiv> \\<lambda>s. a s = {}\""], ["", "abbreviation (input)\n  pred_list_null :: \"('a \\<Rightarrow> 'b list) \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"LIST'_NULL _\" [40] 40) where\n  \"LIST_NULL a \\<equiv> \\<lambda>s. a s = []\""], ["", "abbreviation (input)\n  pred_list_append :: \"('a \\<Rightarrow> 'b list) \\<Rightarrow> ('a \\<Rightarrow> 'b list) \\<Rightarrow> 'a \\<Rightarrow> 'b list\" (infixr \"\\<^bold>@\" 65) where\n  \"xs \\<^bold>@ ys \\<equiv> \\<lambda>s. xs s @ ys s\""], ["", "abbreviation (input)\n  pred_pair :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'c) \\<Rightarrow> 'a \\<Rightarrow> 'b \\<times> 'c\" (infixr \"\\<^bold>\\<otimes>\" 60) where\n  \"a \\<^bold>\\<otimes> b \\<equiv> \\<lambda>s. (a s, b s)\""], ["", "abbreviation (input)\n  pred_singleton :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b set\" where\n  \"pred_singleton x \\<equiv> \\<lambda>s. {x s}\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}