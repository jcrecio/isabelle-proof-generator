{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP/Infinite_Sequences.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentIMP", "problem_names": ["lemma suffix_eval: \"(\\<sigma> |\\<^sub>s i) j = \\<sigma> (j + i)\"", "lemma suffix_plus: \"\\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s (m + n)\"", "lemma suffix_commute: \"((\\<sigma> |\\<^sub>s n) |\\<^sub>s m) = ((\\<sigma> |\\<^sub>s m) |\\<^sub>s n)\"", "lemma suffix_plus_com: \"\\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s (m + n)\"", "lemma suffix_zero: \"\\<sigma> |\\<^sub>s 0 = \\<sigma>\"", "lemma comp_suffix: \"f \\<circ> \\<sigma> |\\<^sub>s i = (f \\<circ> \\<sigma>) |\\<^sub>s i\"", "lemmas suffix_simps[simp] =\n  comp_suffix\n  suffix_eval\n  suffix_plus_com\n  suffix_zero", "lemma length_stake[simp]: \"length (stake n s) = n\"", "lemma shift_simps[simp]:\n   \"(xs @- \\<sigma>) 0 = (if xs = [] then \\<sigma> 0 else hd xs)\"\n   \"(xs @- \\<sigma>) |\\<^sub>s Suc 0 = (if xs = [] then \\<sigma> |\\<^sub>s Suc 0 else tl xs @- \\<sigma>)\"", "lemma stake_nil[simp]:\n  \"stake i \\<sigma> = [] \\<longleftrightarrow> i = 0\"", "lemma stake_shift:\n  \"stake i (w @- \\<sigma>) = take i w @ stake (i - length w) \\<sigma>\"", "lemma shift_snth_less[simp]:\n  assumes \"i < length xs\"\n  shows \"(xs @- \\<sigma>) i = xs ! i\"", "lemma shift_snth_ge[simp]:\n  assumes \"i \\<ge> length xs\"\n  shows \"(xs @- \\<sigma>) i = \\<sigma> (i - length xs)\"", "lemma shift_snth:\n  \"(xs @- \\<sigma>) i = (if i < length xs then xs ! i else \\<sigma> (i - length xs))\"", "lemma suffix_shift:\n  \"(xs @- \\<sigma>) |\\<^sub>s i = drop i xs @- (\\<sigma> |\\<^sub>s i - length xs)\"", "lemma stake_nth[simp]:\n  assumes \"i < j\"\n  shows \"stake j s ! i = s i\"", "lemma stake_suffix_id:\n  \"stake i \\<sigma> @- (\\<sigma> |\\<^sub>s i) = \\<sigma>\"", "lemma id_stake_snth_suffix:\n  \"\\<sigma> = (stake i \\<sigma> @ [\\<sigma> i]) @- (\\<sigma> |\\<^sub>s Suc i)\"", "lemma stake_add[simp]:\n  \"stake i \\<sigma> @ stake j (\\<sigma> |\\<^sub>s i) = stake (i + j) \\<sigma>\"", "lemma stake_append: \"stake n (u @- s) = take (min (length u) n) u @ stake (n - length u) s\"", "lemma stake_shift_stake_shift:\n  \"stake i \\<sigma> @- stake j (\\<sigma> |\\<^sub>s i) @- \\<beta> = stake (i + j) \\<sigma> @- \\<beta>\"", "lemma stake_suffix_drop:\n  \"stake i (\\<sigma> |\\<^sub>s j) = drop j (stake (i + j) \\<sigma>)\"", "lemma stake_suffix:\n  assumes \"i \\<le> j\"\n  shows \"stake j \\<sigma> @- u |\\<^sub>s i = \\<sigma>(i \\<rightarrow> j - i) @- u\"", "lemma safety_def2: \\<comment> \\<open>Contraposition gives the customary prefix-closure definition\\<close>\n  \"safety P \\<longleftrightarrow> (\\<forall>\\<sigma>. (\\<forall>i. \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow> P \\<sigma>)\"", "lemmas safetyI = iffD2[OF safety_def, rule_format]", "lemmas safetyI2 = iffD2[OF safety_def2, rule_format]", "lemmas livenessI = iffD2[OF liveness_def, rule_format]", "lemma safety_False:\n  shows \"safety (\\<lambda>\\<sigma>. False)\"", "lemma safety_True:\n  shows \"safety (\\<lambda>\\<sigma>. True)\"", "lemma safety_state_prop:\n  shows \"safety (\\<lambda>\\<sigma>. P (\\<sigma> 0))\"", "lemma safety_invariant:\n  shows \"safety (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> i))\"", "lemma safety_transition_relation:\n  shows \"safety (\\<lambda>\\<sigma>. \\<forall>i. (\\<sigma> i, \\<sigma> (i + 1)) \\<in> R)\"", "lemma safety_conj:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<^bold>\\<and> Q)\"", "lemma safety_always_eventually[simplified]:\n  assumes \"safety P\"\n  assumes \"\\<forall>i. \\<exists>j\\<ge>i. \\<exists>\\<beta>. P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>)\"\n  shows \"P \\<sigma>\"", "lemma safety_disj:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<^bold>\\<or> Q)\"", "lemma decomp:\n  \"P = (Safe P \\<^bold>\\<and> Live P)\"", "lemma safe:\n  \"safety (Safe P)\"", "lemma live:\n  \"liveness (Live P)\"", "lemma absolute_liveness_liveness:\n  assumes \"absolute_liveness P\"\n  shows \"liveness P\"", "lemma stable_absolute_liveness:\n  assumes \"P \\<sigma>\"\n  assumes \"\\<not>P \\<sigma>'\" \\<comment>\\<open> extra hypothesis \\<close>\n  shows \"stable P \\<longleftrightarrow> absolute_liveness (\\<^bold>\\<not> P)\"", "lemma fairness_safety:\n  assumes \"safety P\"\n  assumes \"fairness F\"\n  shows \"(\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>) \\<longleftrightarrow> (\\<forall>\\<sigma>. P \\<sigma>)\""], "translations": [["", "lemma suffix_eval: \"(\\<sigma> |\\<^sub>s i) j = \\<sigma> (j + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> |\\<^sub>s i) j = \\<sigma> (j + i)", "unfolding suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (j + i) = \\<sigma> (j + i)", "by simp"], ["", "lemma suffix_plus: \"\\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m + n", "unfolding suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j. \\<sigma> (j + m + n)) =\n    (\\<lambda>j. \\<sigma> (j + (m + n)))", "by (simp add: add.assoc)"], ["", "lemma suffix_commute: \"((\\<sigma> |\\<^sub>s n) |\\<^sub>s m) = ((\\<sigma> |\\<^sub>s m) |\\<^sub>s n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m |\\<^sub>s n", "by (simp add: suffix_plus add.commute)"], ["", "lemma suffix_plus_com: \"\\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s m + n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s m + n", "have \"\\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m + n", "by (rule suffix_plus)"], ["proof (state)\nthis:\n  \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m + n\n\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s m + n", "then"], ["proof (chain)\npicking this:\n  \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m + n", "show \"\\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s (m + n)\""], ["proof (prove)\nusing this:\n  \\<sigma> |\\<^sub>s n |\\<^sub>s m = \\<sigma> |\\<^sub>s m + n\n\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s m + n", "by (simp add: suffix_commute)"], ["proof (state)\nthis:\n  \\<sigma> |\\<^sub>s m |\\<^sub>s n = \\<sigma> |\\<^sub>s m + n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma suffix_zero: \"\\<sigma> |\\<^sub>s 0 = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> |\\<^sub>s 0 = \\<sigma>", "unfolding suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j. \\<sigma> (j + 0)) = \\<sigma>", "by simp"], ["", "lemma comp_suffix: \"f \\<circ> \\<sigma> |\\<^sub>s i = (f \\<circ> \\<sigma>) |\\<^sub>s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> \\<sigma> |\\<^sub>s i = (f \\<circ> \\<sigma>) |\\<^sub>s i", "unfolding suffix_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (\\<sigma> (x + i))) = (\\<lambda>j. f (\\<sigma> (j + i)))", "by simp"], ["", "lemmas suffix_simps[simp] =\n  comp_suffix\n  suffix_eval\n  suffix_plus_com\n  suffix_zero"], ["", "lemma length_stake[simp]: \"length (stake n s) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (stake n s) = n", "by (induct n arbitrary: s) auto"], ["", "lemma shift_simps[simp]:\n   \"(xs @- \\<sigma>) 0 = (if xs = [] then \\<sigma> 0 else hd xs)\"\n   \"(xs @- \\<sigma>) |\\<^sub>s Suc 0 = (if xs = [] then \\<sigma> |\\<^sub>s Suc 0 else tl xs @- \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) 0 = (if xs = [] then \\<sigma> 0 else hd xs) &&&\n    xs @- \\<sigma> |\\<^sub>s Suc 0 =\n    (if xs = [] then \\<sigma> |\\<^sub>s Suc 0 else tl xs @- \\<sigma>)", "by (induct xs) auto"], ["", "lemma stake_nil[simp]:\n  \"stake i \\<sigma> = [] \\<longleftrightarrow> i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stake i \\<sigma> = []) = (i = 0)", "by (cases i; clarsimp)"], ["", "lemma stake_shift:\n  \"stake i (w @- \\<sigma>) = take i w @ stake (i - length w) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i (w @- \\<sigma>) = take i w @ stake (i - length w) \\<sigma>", "by (induct i arbitrary: w) (auto simp: neq_Nil_conv)"], ["", "lemma shift_snth_less[simp]:\n  assumes \"i < length xs\"\n  shows \"(xs @- \\<sigma>) i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) i = xs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) i = xs ! i", "proof(induct i arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> (xs @- \\<sigma>) 0 = xs ! 0\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   i < length xs \\<Longrightarrow>\n                   (xs @- \\<sigma>) i = xs ! i;\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> (xs @- \\<sigma>) (Suc i) = xs ! Suc i", "case (Suc i xs)"], ["proof (state)\nthis:\n  i < length ?xs \\<Longrightarrow> (?xs @- \\<sigma>) i = ?xs ! i\n  Suc i < length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> (xs @- \\<sigma>) 0 = xs ! 0\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   i < length xs \\<Longrightarrow>\n                   (xs @- \\<sigma>) i = xs ! i;\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> (xs @- \\<sigma>) (Suc i) = xs ! Suc i", "then"], ["proof (chain)\npicking this:\n  i < length ?xs \\<Longrightarrow> (?xs @- \\<sigma>) i = ?xs ! i\n  Suc i < length xs", "show ?case"], ["proof (prove)\nusing this:\n  i < length ?xs \\<Longrightarrow> (?xs @- \\<sigma>) i = ?xs ! i\n  Suc i < length xs\n\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) (Suc i) = xs ! Suc i", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  (xs @- \\<sigma>) (Suc i) = xs ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>xs. 0 < length xs \\<Longrightarrow> (xs @- \\<sigma>) 0 = xs ! 0", "qed (simp add: hd_conv_nth nth_tl)"], ["", "lemma shift_snth_ge[simp]:\n  assumes \"i \\<ge> length xs\"\n  shows \"(xs @- \\<sigma>) i = \\<sigma> (i - length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) i = \\<sigma> (i - length xs)", "using assms"], ["proof (prove)\nusing this:\n  length xs \\<le> i\n\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) i = \\<sigma> (i - length xs)", "proof(induct i arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs \\<le> 0 \\<Longrightarrow>\n       (xs @- \\<sigma>) 0 = \\<sigma> (0 - length xs)\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @- \\<sigma>) i = \\<sigma> (i - length xs);\n        length xs \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> (xs @- \\<sigma>) (Suc i) =\n                         \\<sigma> (Suc i - length xs)", "case (Suc i xs)"], ["proof (state)\nthis:\n  length ?xs \\<le> i \\<Longrightarrow>\n  (?xs @- \\<sigma>) i = \\<sigma> (i - length ?xs)\n  length xs \\<le> Suc i\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs \\<le> 0 \\<Longrightarrow>\n       (xs @- \\<sigma>) 0 = \\<sigma> (0 - length xs)\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs \\<le> i \\<Longrightarrow>\n                   (xs @- \\<sigma>) i = \\<sigma> (i - length xs);\n        length xs \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> (xs @- \\<sigma>) (Suc i) =\n                         \\<sigma> (Suc i - length xs)", "then"], ["proof (chain)\npicking this:\n  length ?xs \\<le> i \\<Longrightarrow>\n  (?xs @- \\<sigma>) i = \\<sigma> (i - length ?xs)\n  length xs \\<le> Suc i", "show ?case"], ["proof (prove)\nusing this:\n  length ?xs \\<le> i \\<Longrightarrow>\n  (?xs @- \\<sigma>) i = \\<sigma> (i - length ?xs)\n  length xs \\<le> Suc i\n\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) (Suc i) = \\<sigma> (Suc i - length xs)", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  (xs @- \\<sigma>) (Suc i) = \\<sigma> (Suc i - length xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       length xs \\<le> 0 \\<Longrightarrow>\n       (xs @- \\<sigma>) 0 = \\<sigma> (0 - length xs)", "qed simp"], ["", "lemma shift_snth:\n  \"(xs @- \\<sigma>) i = (if i < length xs then xs ! i else \\<sigma> (i - length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @- \\<sigma>) i =\n    (if i < length xs then xs ! i else \\<sigma> (i - length xs))", "by simp"], ["", "lemma suffix_shift:\n  \"(xs @- \\<sigma>) |\\<^sub>s i = drop i xs @- (\\<sigma> |\\<^sub>s i - length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @- \\<sigma> |\\<^sub>s i =\n    drop i xs @- (\\<sigma> |\\<^sub>s i - length xs)", "proof(induct i arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs @- \\<sigma> |\\<^sub>s 0 =\n       drop 0 xs @- (\\<sigma> |\\<^sub>s 0 - length xs)\n 2. \\<And>i xs.\n       (\\<And>xs.\n           xs @- \\<sigma> |\\<^sub>s i =\n           drop i xs @-\n           (\\<sigma> |\\<^sub>s i - length xs)) \\<Longrightarrow>\n       xs @- \\<sigma> |\\<^sub>s Suc i =\n       drop (Suc i) xs @- (\\<sigma> |\\<^sub>s Suc i - length xs)", "case (Suc i xs)"], ["proof (state)\nthis:\n  ?xs @- \\<sigma> |\\<^sub>s i =\n  drop i ?xs @- (\\<sigma> |\\<^sub>s i - length ?xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs @- \\<sigma> |\\<^sub>s 0 =\n       drop 0 xs @- (\\<sigma> |\\<^sub>s 0 - length xs)\n 2. \\<And>i xs.\n       (\\<And>xs.\n           xs @- \\<sigma> |\\<^sub>s i =\n           drop i xs @-\n           (\\<sigma> |\\<^sub>s i - length xs)) \\<Longrightarrow>\n       xs @- \\<sigma> |\\<^sub>s Suc i =\n       drop (Suc i) xs @- (\\<sigma> |\\<^sub>s Suc i - length xs)", "then"], ["proof (chain)\npicking this:\n  ?xs @- \\<sigma> |\\<^sub>s i =\n  drop i ?xs @- (\\<sigma> |\\<^sub>s i - length ?xs)", "show ?case"], ["proof (prove)\nusing this:\n  ?xs @- \\<sigma> |\\<^sub>s i =\n  drop i ?xs @- (\\<sigma> |\\<^sub>s i - length ?xs)\n\ngoal (1 subgoal):\n 1. xs @- \\<sigma> |\\<^sub>s Suc i =\n    drop (Suc i) xs @- (\\<sigma> |\\<^sub>s Suc i - length xs)", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  xs @- \\<sigma> |\\<^sub>s Suc i =\n  drop (Suc i) xs @- (\\<sigma> |\\<^sub>s Suc i - length xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs @- \\<sigma> |\\<^sub>s 0 =\n       drop 0 xs @- (\\<sigma> |\\<^sub>s 0 - length xs)", "qed simp"], ["", "lemma stake_nth[simp]:\n  assumes \"i < j\"\n  shows \"stake j s ! i = s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake j s ! i = s i", "using assms"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. stake j s ! i = s i", "by (induct j arbitrary: s i) (simp_all add: nth_Cons')"], ["", "lemma stake_suffix_id:\n  \"stake i \\<sigma> @- (\\<sigma> |\\<^sub>s i) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i \\<sigma> @- (\\<sigma> |\\<^sub>s i) = \\<sigma>", "by (induct i) (simp_all add: fun_eq_iff shift_snth split: nat.splits)"], ["", "lemma id_stake_snth_suffix:\n  \"\\<sigma> = (stake i \\<sigma> @ [\\<sigma> i]) @- (\\<sigma> |\\<^sub>s Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> =\n    (stake i \\<sigma> @ [\\<sigma> i]) @- (\\<sigma> |\\<^sub>s Suc i)", "using stake_suffix_id"], ["proof (prove)\nusing this:\n  stake ?i ?\\<sigma> @- (?\\<sigma> |\\<^sub>s ?i) = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> =\n    (stake i \\<sigma> @ [\\<sigma> i]) @- (\\<sigma> |\\<^sub>s Suc i)", "apply (metis Suc_diff_le append_Nil2 diff_is_0_eq length_stake lessI nat.simps(3) nat_le_linear shift_snth stake_nil stake_shift take_Suc_conv_app_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stake_add[simp]:\n  \"stake i \\<sigma> @ stake j (\\<sigma> |\\<^sub>s i) = stake (i + j) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i \\<sigma> @ \\<sigma>(i \\<rightarrow> j) = stake (i + j) \\<sigma>", "apply (induct i arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       stake 0 \\<sigma> @ \\<sigma>(0 \\<rightarrow> j) =\n       stake (0 + j) \\<sigma>\n 2. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @ \\<sigma>(i \\<rightarrow> j) =\n           stake (i + j) \\<sigma>) \\<Longrightarrow>\n       stake (Suc i) \\<sigma> @ \\<sigma>(Suc i \\<rightarrow> j) =\n       stake (Suc i + j) \\<sigma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @ \\<sigma>(i \\<rightarrow> j) =\n           stake (i + j) \\<sigma>) \\<Longrightarrow>\n       stake (Suc i) \\<sigma> @ \\<sigma>(Suc i \\<rightarrow> j) =\n       stake (Suc i + j) \\<sigma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @ \\<sigma>(i \\<rightarrow> j) =\n           stake (i + j) \\<sigma>) \\<Longrightarrow>\n       \\<sigma>(Suc 0 \\<rightarrow> i) @ \\<sigma>(Suc i \\<rightarrow> j) =\n       \\<sigma>(Suc 0 \\<rightarrow> i + j)", "apply (metis One_nat_def plus_1_eq_Suc suffix_plus_com)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stake_append: \"stake n (u @- s) = take (min (length u) n) u @ stake (n - length u) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake n (u @- s) = take (min (length u) n) u @ stake (n - length u) s", "proof (induct n arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       stake 0 (u @- s) = take (min (length u) 0) u @ stake (0 - length u) s\n 2. \\<And>n u.\n       (\\<And>u.\n           stake n (u @- s) =\n           take (min (length u) n) u @\n           stake (n - length u) s) \\<Longrightarrow>\n       stake (Suc n) (u @- s) =\n       take (min (length u) (Suc n)) u @ stake (Suc n - length u) s", "case (Suc n)"], ["proof (state)\nthis:\n  stake n (?u @- s) = take (min (length ?u) n) ?u @ stake (n - length ?u) s\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       stake 0 (u @- s) = take (min (length u) 0) u @ stake (0 - length u) s\n 2. \\<And>n u.\n       (\\<And>u.\n           stake n (u @- s) =\n           take (min (length u) n) u @\n           stake (n - length u) s) \\<Longrightarrow>\n       stake (Suc n) (u @- s) =\n       take (min (length u) (Suc n)) u @ stake (Suc n - length u) s", "then"], ["proof (chain)\npicking this:\n  stake n (?u @- s) = take (min (length ?u) n) ?u @ stake (n - length ?u) s", "show ?case"], ["proof (prove)\nusing this:\n  stake n (?u @- s) = take (min (length ?u) n) ?u @ stake (n - length ?u) s\n\ngoal (1 subgoal):\n 1. stake (Suc n) (u @- s) =\n    take (min (length u) (Suc n)) u @ stake (Suc n - length u) s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u.\n                stake n (u @- s) =\n                take (min (length u) n) u @ stake (n - length u) s;\n     u \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd u #\n                      take (min (length u - Suc 0) n) (tl u) @\n                      stake (n - (length u - Suc 0)) s =\n                      take (min (length u) (Suc n)) u @\n                      stake (Suc n - length u) s", "apply (cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u.\n                stake n (u @- s) =\n                take (min (length u) n) u @ stake (n - length u) s;\n     u \\<noteq> []; u = []\\<rbrakk>\n    \\<Longrightarrow> hd u #\n                      take (min (length u - Suc 0) n) (tl u) @\n                      stake (n - (length u - Suc 0)) s =\n                      take (min (length u) (Suc n)) u @\n                      stake (Suc n - length u) s\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>u.\n                   stake n (u @- s) =\n                   take (min (length u) n) u @ stake (n - length u) s;\n        u \\<noteq> []; u = a # list\\<rbrakk>\n       \\<Longrightarrow> hd u #\n                         take (min (length u - Suc 0) n) (tl u) @\n                         stake (n - (length u - Suc 0)) s =\n                         take (min (length u) (Suc n)) u @\n                         stake (Suc n - length u) s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  stake (Suc n) (u @- s) =\n  take (min (length u) (Suc n)) u @ stake (Suc n - length u) s\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       stake 0 (u @- s) = take (min (length u) 0) u @ stake (0 - length u) s", "qed auto"], ["", "lemma stake_shift_stake_shift:\n  \"stake i \\<sigma> @- stake j (\\<sigma> |\\<^sub>s i) @- \\<beta> = stake (i + j) \\<sigma> @- \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i \\<sigma> @- \\<sigma>(i \\<rightarrow> j) @- \\<beta> =\n    stake (i + j) \\<sigma> @- \\<beta>", "apply (induct i arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       stake 0 \\<sigma> @- \\<sigma>(0 \\<rightarrow> j) @- \\<beta> =\n       stake (0 + j) \\<sigma> @- \\<beta>\n 2. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @- \\<sigma>(i \\<rightarrow> j) @- \\<beta> =\n           stake (i + j) \\<sigma> @- \\<beta>) \\<Longrightarrow>\n       stake (Suc i) \\<sigma> @-\n       \\<sigma>(Suc i \\<rightarrow> j) @- \\<beta> =\n       stake (Suc i + j) \\<sigma> @- \\<beta>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @- \\<sigma>(i \\<rightarrow> j) @- \\<beta> =\n           stake (i + j) \\<sigma> @- \\<beta>) \\<Longrightarrow>\n       stake (Suc i) \\<sigma> @-\n       \\<sigma>(Suc i \\<rightarrow> j) @- \\<beta> =\n       stake (Suc i + j) \\<sigma> @- \\<beta>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       (\\<And>\\<sigma>.\n           stake i \\<sigma> @- \\<sigma>(i \\<rightarrow> j) @- \\<beta> =\n           stake (i + j) \\<sigma> @- \\<beta>) \\<Longrightarrow>\n       (\\<lambda>ia.\n           case ia of 0 \\<Rightarrow> \\<sigma> 0\n           | Suc ia \\<Rightarrow>\n               (\\<sigma>(Suc 0 \\<rightarrow> i) @-\n                \\<sigma>(Suc i \\<rightarrow> j) @- \\<beta>)\n                ia) =\n       (\\<lambda>ia.\n           case ia of 0 \\<Rightarrow> \\<sigma> 0\n           | Suc ia \\<Rightarrow>\n               (\\<sigma>(Suc 0 \\<rightarrow> i + j) @- \\<beta>) ia)", "apply (metis One_nat_def plus_1_eq_Suc suffix_plus_com)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stake_suffix_drop:\n  \"stake i (\\<sigma> |\\<^sub>s j) = drop j (stake (i + j) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>(j \\<rightarrow> i) = drop j (stake (i + j) \\<sigma>)", "by (metis append_eq_conv_conj length_stake semiring_normalization_rules(24) stake_add)"], ["", "lemma stake_suffix:\n  assumes \"i \\<le> j\"\n  shows \"stake j \\<sigma> @- u |\\<^sub>s i = \\<sigma>(i \\<rightarrow> j - i) @- u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake j \\<sigma> @- u |\\<^sub>s i = \\<sigma>(i \\<rightarrow> j - i) @- u", "by (simp add: assms stake_suffix_drop suffix_shift)"], ["", "subsection\\<open>Decomposing safety and liveness \\label{sec:infinite_sequences-safety-liveness}\\<close>"], ["", "text\\<open>\n\nFamously properties on infinite sequences can be decomposed into\n@{emph \\<open>safety\\<close>} and @{emph \\<open>liveness\\<close>}\nproperties @{cite \"AlpernSchneider:1985\" and \"Schneider:1987\"}. See\n@{cite [cite_macro=citet] \"Kindler:1994\"} for an overview.\n\n\\<close>"], ["", "definition safety :: \"'a seq_pred \\<Rightarrow> bool\" where\n  \"safety P \\<longleftrightarrow> (\\<forall>\\<sigma>. \\<not>P \\<sigma> \\<longrightarrow> (\\<exists>i. \\<forall>\\<beta>. \\<not>P (stake i \\<sigma> @- \\<beta>)))\""], ["", "lemma safety_def2: \\<comment> \\<open>Contraposition gives the customary prefix-closure definition\\<close>\n  \"safety P \\<longleftrightarrow> (\\<forall>\\<sigma>. (\\<forall>i. \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow> P \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety P =\n    (\\<forall>\\<sigma>.\n        (\\<forall>i.\n            \\<exists>\\<beta>.\n               P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n        P \\<sigma>)", "unfolding safety_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>.\n        \\<not> P \\<sigma> \\<longrightarrow>\n        (\\<exists>i.\n            \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>))) =\n    (\\<forall>\\<sigma>.\n        (\\<forall>i.\n            \\<exists>\\<beta>.\n               P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n        P \\<sigma>)", "by blast"], ["", "definition liveness :: \"'a seq_pred \\<Rightarrow> bool\" where\n  \"liveness P \\<longleftrightarrow> (\\<forall>\\<alpha>. \\<exists>\\<sigma>. P (\\<alpha> @- \\<sigma>))\""], ["", "lemmas safetyI = iffD2[OF safety_def, rule_format]"], ["", "lemmas safetyI2 = iffD2[OF safety_def2, rule_format]"], ["", "lemmas livenessI = iffD2[OF liveness_def, rule_format]"], ["", "lemma safety_False:\n  shows \"safety (\\<lambda>\\<sigma>. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>\\<sigma>. False)", "by (rule safetyI) simp"], ["", "lemma safety_True:\n  shows \"safety (\\<lambda>\\<sigma>. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>\\<sigma>. True)", "by (rule safetyI) simp"], ["", "lemma safety_state_prop:\n  shows \"safety (\\<lambda>\\<sigma>. P (\\<sigma> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>\\<sigma>. P (\\<sigma> 0))", "by (rule safetyI) auto"], ["", "lemma safety_invariant:\n  shows \"safety (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>\\<sigma>. \\<forall>i. P (\\<sigma> i))", "apply (rule safetyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> (\\<forall>i. P (\\<sigma> i)) \\<Longrightarrow>\n       \\<exists>i.\n          \\<forall>\\<beta>.\n             \\<not> (\\<forall>ia. P ((stake i \\<sigma> @- \\<beta>) ia))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<not> P (\\<sigma> i) \\<Longrightarrow>\n       \\<exists>i.\n          \\<forall>\\<beta>.\n             \\<exists>ia. \\<not> P ((stake i \\<sigma> @- \\<beta>) ia)", "apply (metis length_stake lessI shift_snth_less stake_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safety_transition_relation:\n  shows \"safety (\\<lambda>\\<sigma>. \\<forall>i. (\\<sigma> i, \\<sigma> (i + 1)) \\<in> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety\n     (\\<lambda>\\<sigma>. \\<forall>i. (\\<sigma> i, \\<sigma> (i + 1)) \\<in> R)", "apply (rule safetyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> (\\<forall>i.\n                  (\\<sigma> i, \\<sigma> (i + 1)) \\<in> R) \\<Longrightarrow>\n       \\<exists>i.\n          \\<forall>\\<beta>.\n             \\<not> (\\<forall>ia.\n                        ((stake i \\<sigma> @- \\<beta>) ia,\n                         (stake i \\<sigma> @- \\<beta>) (ia + 1))\n                        \\<in> R)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       (\\<sigma> i, \\<sigma> (Suc i)) \\<notin> R \\<Longrightarrow>\n       \\<exists>i.\n          \\<forall>\\<beta>.\n             \\<exists>ia.\n                ((stake i \\<sigma> @- \\<beta>) ia,\n                 (stake i \\<sigma> @- \\<beta>) (Suc ia))\n                \\<notin> R", "apply (metis (no_types, hide_lams) Suc_eq_plus1 add.left_neutral add_Suc_right add_diff_cancel_left' le_add1 list.sel(1) list.simps(3) shift_simps(1) stake.simps(2) stake_suffix suffix_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safety_conj:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<^bold>\\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>s. P s \\<and> Q s)", "using assms"], ["proof (prove)\nusing this:\n  safety P\n  safety Q\n\ngoal (1 subgoal):\n 1. safety (\\<lambda>s. P s \\<and> Q s)", "unfolding safety_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     \\<not> P \\<sigma> \\<longrightarrow>\n     (\\<exists>i. \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>))\n  \\<forall>\\<sigma>.\n     \\<not> Q \\<sigma> \\<longrightarrow>\n     (\\<exists>i. \\<forall>\\<beta>. \\<not> Q (stake i \\<sigma> @- \\<beta>))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> (P \\<sigma> \\<and> Q \\<sigma>) \\<longrightarrow>\n       (\\<exists>i.\n           \\<forall>\\<beta>.\n              \\<not> (P (stake i \\<sigma> @- \\<beta>) \\<and>\n                      Q (stake i \\<sigma> @- \\<beta>)))", "by blast"], ["", "lemma safety_always_eventually[simplified]:\n  assumes \"safety P\"\n  assumes \"\\<forall>i. \\<exists>j\\<ge>i. \\<exists>\\<beta>. P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>)\"\n  shows \"P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  safety P\n  \\<forall>i.\n     \\<exists>j\\<ge>i.\n        \\<exists>\\<beta>. P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>)\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "unfolding safety_def2"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     (\\<forall>i.\n         \\<exists>\\<beta>.\n            P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n     P \\<sigma>\n  \\<forall>i.\n     \\<exists>j\\<ge>i.\n        \\<exists>\\<beta>. P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>)\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<sigma>.\n                (\\<forall>i.\n                    \\<exists>\\<beta>.\n                       P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n                P \\<sigma>;\n     \\<forall>i.\n        \\<exists>j\\<ge>i.\n           \\<exists>\\<beta>.\n              P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>)\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply (drule_tac x=\\<sigma> in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                \\<exists>j\\<ge>i.\n                   \\<exists>\\<beta>.\n                      P (\\<sigma>(0 \\<rightarrow> j) @- \\<beta>);\n     (\\<forall>i.\n         \\<exists>\\<beta>.\n            P (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n     P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   \\<exists>j\\<ge>i.\n                      \\<exists>\\<beta>. P (stake j \\<sigma> @- \\<beta>);\n        \\<not> P \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>)", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<exists>j\\<ge>i.\n           \\<exists>\\<beta>. P (stake j \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j \\<beta>.\n       \\<lbrakk>\\<not> P \\<sigma>; i \\<le> j;\n        P (stake j \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>)", "apply (rule_tac x=\"(stake j \\<sigma> @- \\<beta>) |\\<^sub>s i\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j \\<beta>.\n       \\<lbrakk>\\<not> P \\<sigma>; i \\<le> j;\n        P (stake j \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> P (stake i \\<sigma> @-\n                            (stake j \\<sigma> @- \\<beta> |\\<^sub>s i))", "apply (simp add: stake_shift_stake_shift stake_suffix)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safety_disj:\n  assumes \"safety P\"\n  assumes \"safety Q\"\n  shows \"safety (P \\<^bold>\\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (\\<lambda>s. P s \\<or> Q s)", "unfolding safety_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<forall>i.\n           \\<exists>\\<beta>.\n              P (stake i \\<sigma> @- \\<beta>) \\<or>\n              Q (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n       P \\<sigma> \\<or> Q \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  safety P\n  safety Q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<forall>i.\n           \\<exists>\\<beta>.\n              P (stake i \\<sigma> @- \\<beta>) \\<or>\n              Q (stake i \\<sigma> @- \\<beta>)) \\<longrightarrow>\n       P \\<sigma> \\<or> Q \\<sigma>", "by (metis safety_always_eventually add_diff_cancel_right' diff_le_self le_add_same_cancel2)"], ["", "text\\<open>\n\nThe decomposition is given by a form of closure.\n\n\\<close>"], ["", "definition M\\<^sub>p :: \"'a seq_pred \\<Rightarrow> 'a seq_pred\" where\n  \"M\\<^sub>p P = (\\<lambda>\\<sigma>. \\<forall>i. \\<exists>\\<beta>. P (stake i \\<sigma> @- \\<beta>))\""], ["", "definition Safe :: \"'a seq_pred \\<Rightarrow> 'a seq_pred\" where\n  \"Safe P = (P \\<^bold>\\<or> M\\<^sub>p P)\""], ["", "definition Live :: \"'a seq_pred \\<Rightarrow> 'a seq_pred\" where\n  \"Live P = (P \\<^bold>\\<or> \\<^bold>\\<not>M\\<^sub>p P)\""], ["", "lemma decomp:\n  \"P = (Safe P \\<^bold>\\<and> Live P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (\\<lambda>s. Safe P s \\<and> Live P s)", "unfolding Safe_def Live_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    (\\<lambda>s.\n        (P s \\<or> M\\<^sub>p P s) \\<and> (P s \\<or> \\<not> M\\<^sub>p P s))", "by blast"], ["", "lemma safe:\n  \"safety (Safe P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safety (Safe P)", "unfolding Safe_def safety_def M\\<^sub>p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> (P \\<sigma> \\<or>\n               (\\<forall>i.\n                   \\<exists>\\<beta>.\n                      P (stake i \\<sigma> @- \\<beta>))) \\<longrightarrow>\n       (\\<exists>i.\n           \\<forall>\\<beta>.\n              \\<not> (P (stake i \\<sigma> @- \\<beta>) \\<or>\n                      (\\<forall>ia.\n                          \\<exists>\\<beta>'.\n                             P (stake ia (stake i \\<sigma> @- \\<beta>) @-\n                                \\<beta>'))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<forall>\\<beta>.\n                               \\<not> P (stake i \\<sigma> @- \\<beta>) \\<and>\n                               (\\<exists>ia.\n                                   \\<forall>\\<beta>'.\n\\<not> P (stake ia (stake i \\<sigma> @- \\<beta>) @- \\<beta>'))", "apply (simp add: stake_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<forall>\\<beta>.\n                               \\<not> P (stake i \\<sigma> @- \\<beta>) \\<and>\n                               (\\<exists>ia.\n                                   \\<forall>\\<beta>'.\n\\<not> P ((take ia (stake i \\<sigma>) @ stake (ia - i) \\<beta>) @-\n          \\<beta>'))", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>.\n                            \\<not> P (stake i \\<sigma> @- \\<beta>) \\<and>\n                            (\\<exists>ia.\n                                \\<forall>\\<beta>'.\n                                   \\<not> P\n     ((take ia (stake i \\<sigma>) @ stake (ia - i) \\<beta>) @- \\<beta>'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i \\<beta>.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia.\n                            \\<forall>\\<beta>'.\n                               \\<not> P\n ((take ia (stake i \\<sigma>) @ stake (ia - i) \\<beta>) @- \\<beta>')", "apply (rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i \\<beta>.\n       \\<lbrakk>\\<not> P \\<sigma>;\n        \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<beta>'.\n                            \\<not> P ((take i (stake i \\<sigma>) @\n stake (i - i) \\<beta>) @-\n\\<beta>')", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma live:\n  \"liveness (Live P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liveness (Live P)", "proof(rule livenessI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "fix \\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "have \"(\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or> \\<not>(\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n    (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n  (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n  (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "have \"?this \\<longleftrightarrow> (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>) \\<or> (\\<forall>\\<gamma>. \\<not>P (\\<alpha> @- \\<gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n     (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))) =\n    (\\<exists>\\<beta>.\n        P (\\<alpha> @- \\<beta>) \\<or>\n        (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>)))", "by blast"], ["proof (state)\nthis:\n  ((\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n   (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))) =\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "also"], ["proof (state)\nthis:\n  ((\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>)) \\<or>\n   (\\<nexists>\\<beta>. P (\\<alpha> @- \\<beta>))) =\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>) \\<or> (\\<exists>i. i = length \\<alpha> \\<and> (\\<forall>\\<gamma>. \\<not>P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<beta>.\n        P (\\<alpha> @- \\<beta>) \\<or>\n        (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>))) =\n    (\\<exists>\\<beta>.\n        P (\\<alpha> @- \\<beta>) \\<or>\n        (\\<exists>i.\n            i = length \\<alpha> \\<and>\n            (\\<forall>\\<gamma>.\n                \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))))", "by (simp add: stake_shift)"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>))) =\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<exists>i.\n          i = length \\<alpha> \\<and>\n          (\\<forall>\\<gamma>.\n              \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "also"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<forall>\\<gamma>. \\<not> P (\\<alpha> @- \\<gamma>))) =\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<exists>i.\n          i = length \\<alpha> \\<and>\n          (\\<forall>\\<gamma>.\n              \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "have \"\\<dots> \\<longrightarrow> (\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>) \\<or> (\\<exists>i. (\\<forall>\\<gamma>. \\<not>P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<beta>.\n        P (\\<alpha> @- \\<beta>) \\<or>\n        (\\<exists>i.\n            i = length \\<alpha> \\<and>\n            (\\<forall>\\<gamma>.\n                \\<not> P (stake i (\\<alpha> @- \\<beta>) @-\n                          \\<gamma>)))) \\<longrightarrow>\n    (\\<exists>\\<beta>.\n        P (\\<alpha> @- \\<beta>) \\<or>\n        (\\<exists>i.\n            \\<forall>\\<gamma>.\n               \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>)))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<exists>i.\n          i = length \\<alpha> \\<and>\n          (\\<forall>\\<gamma>.\n              \\<not> P (stake i (\\<alpha> @- \\<beta>) @-\n                        \\<gamma>)))) \\<longrightarrow>\n  (\\<exists>\\<beta>.\n      P (\\<alpha> @- \\<beta>) \\<or>\n      (\\<exists>i.\n          \\<forall>\\<gamma>.\n             \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))", "have \"\\<exists>\\<beta>. P (\\<alpha> @- \\<beta>) \\<or> (\\<exists>i. \\<forall>\\<gamma>. \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>.\n       P (\\<alpha> @- \\<beta>) \\<or>\n       (\\<exists>i.\n           \\<forall>\\<gamma>.\n              \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))", "."], ["proof (state)\nthis:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))", "show \"\\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)", "unfolding Live_def M\\<^sub>p_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>.\n     P (\\<alpha> @- \\<beta>) \\<or>\n     (\\<exists>i.\n         \\<forall>\\<gamma>.\n            \\<not> P (stake i (\\<alpha> @- \\<beta>) @- \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>.\n       P (\\<alpha> @- \\<sigma>) \\<or>\n       \\<not> (\\<forall>i.\n                  \\<exists>\\<beta>.\n                     P (stake i (\\<alpha> @- \\<sigma>) @- \\<beta>))", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. Live P (\\<alpha> @- \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\n@{cite \"Sistla:1994\"} proceeds to give a topological analysis of fairness. An \\<^emph>\\<open>absolute\\<close>\nliveness property is a liveness property whose complement is stable.\n\n\\<close>"], ["", "definition absolute_liveness :: \"'a seq_pred \\<Rightarrow> bool\" where \\<comment> \\<open> closed under prepending any finite sequence \\<close>\n  \"absolute_liveness P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> (\\<forall>\\<sigma> \\<alpha>. P \\<sigma> \\<longrightarrow> P (\\<alpha> @- \\<sigma>))\""], ["", "definition stable :: \"'a seq_pred \\<Rightarrow> bool\" where \\<comment> \\<open> closed under suffixes \\<close>\n  \"stable P \\<longleftrightarrow> (\\<exists>\\<sigma>. P \\<sigma>) \\<and> (\\<forall>\\<sigma> i. P \\<sigma> \\<longrightarrow> P (\\<sigma> |\\<^sub>s i))\""], ["", "lemma absolute_liveness_liveness:\n  assumes \"absolute_liveness P\"\n  shows \"liveness P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liveness P", "using assms"], ["proof (prove)\nusing this:\n  absolute_liveness P\n\ngoal (1 subgoal):\n 1. liveness P", "unfolding absolute_liveness_def liveness_def"], ["proof (prove)\nusing this:\n  Ex P \\<and>\n  (\\<forall>\\<sigma> \\<alpha>.\n      P \\<sigma> \\<longrightarrow> P (\\<alpha> @- \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<alpha>. \\<exists>\\<sigma>. P (\\<alpha> @- \\<sigma>)", "by blast"], ["", "lemma stable_absolute_liveness:\n  assumes \"P \\<sigma>\"\n  assumes \"\\<not>P \\<sigma>'\" \\<comment>\\<open> extra hypothesis \\<close>\n  shows \"stable P \\<longleftrightarrow> absolute_liveness (\\<^bold>\\<not> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable P = absolute_liveness (\\<lambda>s. \\<not> P s)", "using assms"], ["proof (prove)\nusing this:\n  P \\<sigma>\n  \\<not> P \\<sigma>'\n\ngoal (1 subgoal):\n 1. stable P = absolute_liveness (\\<lambda>s. \\<not> P s)", "unfolding stable_def absolute_liveness_def"], ["proof (prove)\nusing this:\n  P \\<sigma>\n  \\<not> P \\<sigma>'\n\ngoal (1 subgoal):\n 1. (Ex P \\<and>\n     (\\<forall>\\<sigma> i.\n         P \\<sigma> \\<longrightarrow> P (\\<sigma> |\\<^sub>s i))) =\n    ((\\<exists>s. \\<not> P s) \\<and>\n     (\\<forall>\\<sigma> \\<alpha>.\n         \\<not> P \\<sigma> \\<longrightarrow>\n         \\<not> P (\\<alpha> @- \\<sigma>)))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma>'' \\<alpha>.\n       \\<lbrakk>P \\<sigma>; \\<not> P \\<sigma>';\n        \\<forall>\\<sigma>.\n           P \\<sigma> \\<longrightarrow>\n           (\\<forall>i. P (\\<sigma> |\\<^sub>s i));\n        P x; \\<not> P \\<sigma>''; P (\\<alpha> @- \\<sigma>'')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s \\<sigma>'' i.\n       \\<lbrakk>P \\<sigma>; \\<not> P \\<sigma>';\n        \\<forall>\\<sigma>.\n           \\<not> P \\<sigma> \\<longrightarrow>\n           (\\<forall>\\<alpha>. \\<not> P (\\<alpha> @- \\<sigma>));\n        \\<not> P s; P \\<sigma>''\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma>'' |\\<^sub>s i)", "apply (metis cancel_comm_monoid_add_class.diff_cancel drop_eq_Nil order_refl shift.simps(1) suffix_shift suffix_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s \\<sigma>'' i.\n       \\<lbrakk>P \\<sigma>; \\<not> P \\<sigma>';\n        \\<forall>\\<sigma>.\n           \\<not> P \\<sigma> \\<longrightarrow>\n           (\\<forall>\\<alpha>. \\<not> P (\\<alpha> @- \\<sigma>));\n        \\<not> P s; P \\<sigma>''\\<rbrakk>\n       \\<Longrightarrow> P (\\<sigma>'' |\\<^sub>s i)", "apply (metis stake_suffix_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\ntext\\<open>\n\nFairness ala Sistla. Unmotivated.\n\nFIXME safety properties are insensitive to fairness.\nFIXME typically we prove \\<open>sys \\<longrightarrow> safety\\<close>. The result below doesn't appear strong enough.\nFIXME observe fairness is a special liveness property.\n\n\\<close>\n*)"], ["", "definition fairness :: \"'a seq_pred \\<Rightarrow> bool\" where\n  \"fairness P \\<longleftrightarrow> stable P \\<and> absolute_liveness P\""], ["", "lemma fairness_safety:\n  assumes \"safety P\"\n  assumes \"fairness F\"\n  shows \"(\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>) \\<longleftrightarrow> (\\<forall>\\<sigma>. P \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>) =\n    (\\<forall>\\<sigma>. P \\<sigma>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       F \\<sigma> \\<longrightarrow> P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. P \\<sigma>\n 2. \\<forall>\\<sigma>. P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  safety P\n  fairness F\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       F \\<sigma> \\<longrightarrow> P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. P \\<sigma>\n 2. \\<forall>\\<sigma>. P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>;\n        safety P; fairness F\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<forall>\\<sigma>. P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>", "unfolding safety_def fairness_def stable_def absolute_liveness_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>;\n        \\<forall>\\<sigma>.\n           \\<not> P \\<sigma> \\<longrightarrow>\n           (\\<exists>i.\n               \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>));\n        (Ex F \\<and>\n         (\\<forall>\\<sigma> i.\n             F \\<sigma> \\<longrightarrow> F (\\<sigma> |\\<^sub>s i))) \\<and>\n        Ex F \\<and>\n        (\\<forall>\\<sigma> \\<alpha>.\n            F \\<sigma> \\<longrightarrow> F (\\<alpha> @- \\<sigma>))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<forall>\\<sigma>. P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> x xa.\n       \\<lbrakk>\\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>;\n        \\<forall>\\<sigma>.\n           \\<not> P \\<sigma> \\<longrightarrow>\n           (\\<exists>i.\n               \\<forall>\\<beta>. \\<not> P (stake i \\<sigma> @- \\<beta>));\n        F x;\n        \\<forall>\\<sigma>.\n           F \\<sigma> \\<longrightarrow>\n           (\\<forall>i. F (\\<sigma> |\\<^sub>s i));\n        \\<forall>\\<sigma>.\n           F \\<sigma> \\<longrightarrow>\n           (\\<forall>\\<alpha>. F (\\<alpha> @- \\<sigma>));\n        F xa\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<forall>\\<sigma>. P \\<sigma> \\<Longrightarrow>\n    \\<forall>\\<sigma>. F \\<sigma> \\<longrightarrow> P \\<sigma>", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}