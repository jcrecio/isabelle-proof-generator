{"file_name": "/home/qj213/afp-2021-10-22/thys/Treaps/Treap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Treaps", "problem_names": ["lemma treap_of_unique:\n  \"\\<lbrakk> treap t;  inj_on snd (set_tree t) \\<rbrakk>\n  \\<Longrightarrow> treap_of (set_tree t) = t\"", "lemma treap_unique:\n  \"\\<lbrakk> treap t1; treap t2; set_tree t1 = set_tree t2; inj_on snd (set_tree t1) \\<rbrakk>\n  \\<Longrightarrow> t1 = t2\"\n  for t1 t2 :: \"('k::linorder * 'p::linorder) tree\"", "lemma ins_neq_Leaf: \"ins k p t \\<noteq> \\<langle>\\<rangle>\"", "lemma keys_ins: \"keys (ins k p t) = Set.insert k (keys t)\"", "lemma prios_ins: \"prios (ins k p t) \\<subseteq> {p} \\<union> prios t\"", "lemma prios_ins': \"k \\<notin> keys t \\<Longrightarrow> prios (ins k p t) = {p} \\<union> prios t\"", "lemma set_tree_ins: \"set_tree (ins k p t) \\<subseteq> {(k,p)} \\<union> set_tree t\"", "lemma set_tree_ins': \"k \\<notin> keys t \\<Longrightarrow>  {(k,p)} \\<union> set_tree t \\<subseteq> set_tree (ins k p t)\"", "lemma set_tree_ins_eq: \"k \\<notin> keys t \\<Longrightarrow> set_tree (ins k p t) = {(k,p)} \\<union> set_tree t\"", "lemma prios_ins_special:\n  \"\\<lbrakk> ins k p t = Node l (k',p') r;  p' = p; p \\<in> prios r \\<union> prios l \\<rbrakk>\n  \\<Longrightarrow> p \\<in> prios t\"", "lemma treap_NodeI:\n  \"\\<lbrakk> treap l; treap r;\n     \\<forall>k' \\<in> keys l. k' < k; \\<forall>k' \\<in> keys r. k < k';\n     \\<forall>p' \\<in> prios l. p \\<le> p'; \\<forall>p' \\<in> prios r. p \\<le> p' \\<rbrakk>\n  \\<Longrightarrow> treap (Node l (k,p) r)\"", "lemma treap_rotate1:\n  assumes \"treap l2\" \"treap r2\" \"treap r\" \"\\<not> p1 \\<le> p2\" \"k < k1\" and\n  ins: \"ins k p l = Node l2 (k2,p2) r2\" and treap_ins: \"treap (ins k p l)\"\n  and treap: \"treap \\<langle>l, (k1, p1), r\\<rangle>\"\n  shows \"treap (Node l2 (k2,p2) (Node r2 (k1,p1) r))\"", "lemma treap_rotate2:\n  assumes \"treap l\" \"treap l2\" \"treap r2\" \"\\<not> p1 \\<le> p2\" \"k1 < k\" and\n  ins: \"ins k p r = Node l2 (k2,p2) r2\" and treap_ins: \"treap (ins k p r)\"\n  and treap: \"treap \\<langle>l, (k1, p1), r\\<rangle>\"\n  shows \"treap (Node (Node l (k1,p1) l2) (k2,p2) r2)\"", "lemma treap_ins: \"treap t \\<Longrightarrow> treap (ins k p t)\"", "lemma treap_of_set_tree_unique:\n  \"\\<lbrakk> finite A; inj_on fst A; inj_on snd A \\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of A) = A\"", "lemma treap_of_subset: \"set_tree (treap_of A) \\<subseteq> A\"", "lemma treap_treap_of:\n  \"treap (treap_of A)\"", "lemma treap_Leaf: \"treap \\<langle>\\<rangle>\"", "lemma foldl_ins_treap: \"treap t \\<Longrightarrow> treap (foldl (\\<lambda>t' (x, p). ins x p t') t xs)\"", "lemma foldl_ins_set_tree: \n  assumes \"inj_on fst (set ys)\" \"inj_on snd (set ys)\" \"distinct ys\" \"fst ` (set ys) \\<inter> keys t = {}\"\n  shows \"set_tree (foldl (\\<lambda>t' (x, p). ins x p t') t ys) = set ys \\<union> set_tree t\"", "lemma foldl_ins_treap_of:\n  assumes \"distinct ys\" \"inj_on fst (set ys)\" \"inj_on snd (set ys)\"\n shows \"(foldl (\\<lambda>t' (x, p). ins x p t') Leaf ys) = treap_of (set ys)\""], "translations": [["", "lemma treap_of_unique:\n  \"\\<lbrakk> treap t;  inj_on snd (set_tree t) \\<rbrakk>\n  \\<Longrightarrow> treap_of (set_tree t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>treap t; inj_on snd (set_tree t)\\<rbrakk>\n    \\<Longrightarrow> treap_of (set_tree t) = t", "proof(induction \"set_tree t\" arbitrary: t rule: treap_of.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>x xb ta.\n                   \\<lbrakk>\\<not> (infinite (set_tree t) \\<or>\n                                    set_tree t = {});\n                    x = arg_min_on snd (set_tree t);\n                    set_tree ta = {p \\<in> set_tree t. fst p < fst x};\n                    xb = {p \\<in> set_tree t. fst x < fst p}; treap ta;\n                    inj_on snd (set_tree ta)\\<rbrakk>\n                   \\<Longrightarrow> treap_of (set_tree ta) = ta;\n        \\<And>x xa ta.\n           \\<lbrakk>\\<not> (infinite (set_tree t) \\<or> set_tree t = {});\n            x = arg_min_on snd (set_tree t);\n            xa = {p \\<in> set_tree t. fst p < fst x};\n            set_tree ta = {p \\<in> set_tree t. fst x < fst p}; treap ta;\n            inj_on snd (set_tree ta)\\<rbrakk>\n           \\<Longrightarrow> treap_of (set_tree ta) = ta;\n        treap t; inj_on snd (set_tree t)\\<rbrakk>\n       \\<Longrightarrow> treap_of (set_tree t) = t", "case (1 t)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite (set_tree t) \\<or> set_tree t = {});\n   ?x = arg_min_on snd (set_tree t);\n   set_tree ?t = {p \\<in> set_tree t. fst p < fst ?x};\n   ?xb = {p \\<in> set_tree t. fst ?x < fst p}; treap ?t;\n   inj_on snd (set_tree ?t)\\<rbrakk>\n  \\<Longrightarrow> treap_of (set_tree ?t) = ?t\n  \\<lbrakk>\\<not> (infinite (set_tree t) \\<or> set_tree t = {});\n   ?x = arg_min_on snd (set_tree t);\n   ?xa = {p \\<in> set_tree t. fst p < fst ?x};\n   set_tree ?t = {p \\<in> set_tree t. fst ?x < fst p}; treap ?t;\n   inj_on snd (set_tree ?t)\\<rbrakk>\n  \\<Longrightarrow> treap_of (set_tree ?t) = ?t\n  treap t\n  inj_on snd (set_tree t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>x xb ta.\n                   \\<lbrakk>\\<not> (infinite (set_tree t) \\<or>\n                                    set_tree t = {});\n                    x = arg_min_on snd (set_tree t);\n                    set_tree ta = {p \\<in> set_tree t. fst p < fst x};\n                    xb = {p \\<in> set_tree t. fst x < fst p}; treap ta;\n                    inj_on snd (set_tree ta)\\<rbrakk>\n                   \\<Longrightarrow> treap_of (set_tree ta) = ta;\n        \\<And>x xa ta.\n           \\<lbrakk>\\<not> (infinite (set_tree t) \\<or> set_tree t = {});\n            x = arg_min_on snd (set_tree t);\n            xa = {p \\<in> set_tree t. fst p < fst x};\n            set_tree ta = {p \\<in> set_tree t. fst x < fst p}; treap ta;\n            inj_on snd (set_tree ta)\\<rbrakk>\n           \\<Longrightarrow> treap_of (set_tree ta) = ta;\n        treap t; inj_on snd (set_tree t)\\<rbrakk>\n       \\<Longrightarrow> treap_of (set_tree t) = t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap_of (set_tree t) = t", "proof (cases \"infinite (set_tree t) \\<or> set_tree t = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite (set_tree t) \\<or> set_tree t = {} \\<Longrightarrow>\n    treap_of (set_tree t) = t\n 2. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "case True"], ["proof (state)\nthis:\n  infinite (set_tree t) \\<or> set_tree t = {}\n\ngoal (2 subgoals):\n 1. infinite (set_tree t) \\<or> set_tree t = {} \\<Longrightarrow>\n    treap_of (set_tree t) = t\n 2. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite (set_tree t) \\<or> set_tree t = {}\n\ngoal (1 subgoal):\n 1. treap_of (set_tree t) = t", "by(simp add: treap_of.simps)"], ["proof (state)\nthis:\n  treap_of (set_tree t) = t\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "case False"], ["proof (state)\nthis:\n  \\<not> (infinite (set_tree t) \\<or> set_tree t = {})\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "let ?m = \"arg_min_on snd (set_tree t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "let ?L = \"{p \\<in> set_tree t. fst p < fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "let ?R = \"{p \\<in> set_tree t. fst p > fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "obtain l a r where t: \"t = Node l a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        t = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  \\<not> (infinite (set_tree t) \\<or> set_tree t = {})\n\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        t = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases t) auto"], ["proof (state)\nthis:\n  t = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have \"\\<forall>kp \\<in> set_tree t. snd a \\<le> snd kp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>kp\\<in>set_tree t. snd a \\<le> snd kp", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  treap t\n\ngoal (1 subgoal):\n 1. \\<forall>kp\\<in>set_tree t. snd a \\<le> snd kp", "by(auto simp add: t treap_def ball_Un)\n        (metis image_eqI snd_conv tree.set_map)+"], ["proof (state)\nthis:\n  \\<forall>kp\\<in>set_tree t. snd a \\<le> snd kp\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "hence \"a = ?m\""], ["proof (prove)\nusing this:\n  \\<forall>kp\\<in>set_tree t. snd a \\<le> snd kp\n\ngoal (1 subgoal):\n 1. a = arg_min_on snd (set_tree t)", "by (metis \"1.prems\"(2) False arg_min_if_finite(1) arg_min_if_finite(2) inj_on_def \n          le_neq_trans t tree.set_intros(2))"], ["proof (state)\nthis:\n  a = arg_min_on snd (set_tree t)\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have \"treap l\" \"treap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap l &&& treap r", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  treap t\n\ngoal (1 subgoal):\n 1. treap l &&& treap r", "by(auto simp: treap_def t)"], ["proof (state)\nthis:\n  treap l\n  treap r\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have l: \"set_tree l = {p \\<in> set_tree t. fst p < fst a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree l = {p \\<in> set_tree t. fst p < fst a}", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  treap t\n\ngoal (1 subgoal):\n 1. set_tree l = {p \\<in> set_tree t. fst p < fst a}", "by(auto simp add: treap_def t ball_Un tree.set_map)"], ["proof (state)\nthis:\n  set_tree l = {p \\<in> set_tree t. fst p < fst a}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have r: \"set_tree r = {p \\<in> set_tree t. fst p > fst a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree r = {p \\<in> set_tree t. fst a < fst p}", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  treap t\n\ngoal (1 subgoal):\n 1. set_tree r = {p \\<in> set_tree t. fst a < fst p}", "by(auto simp add: treap_def t ball_Un tree.set_map)"], ["proof (state)\nthis:\n  set_tree r = {p \\<in> set_tree t. fst a < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have \"l = treap_of ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l =\n    treap_of {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))}", "using \"1.hyps\"(1)[OF False \\<open>a = ?m\\<close> l r \\<open>treap l\\<close>]\n        l \\<open>a = ?m\\<close> \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  inj_on snd (set_tree l) \\<Longrightarrow> treap_of (set_tree l) = l\n  set_tree l = {p \\<in> set_tree t. fst p < fst a}\n  a = arg_min_on snd (set_tree t)\n  inj_on snd (set_tree t)\n\ngoal (1 subgoal):\n 1. l =\n    treap_of {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))}", "by (fastforce simp add: inj_on_def)"], ["proof (state)\nthis:\n  l =\n  treap_of {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have \"r = treap_of ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r =\n    treap_of {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}", "using \"1.hyps\"(2)[OF False \\<open>a = ?m\\<close> l r \\<open>treap r\\<close>]\n        r \\<open>a = ?m\\<close> \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  inj_on snd (set_tree r) \\<Longrightarrow> treap_of (set_tree r) = r\n  set_tree r = {p \\<in> set_tree t. fst a < fst p}\n  a = arg_min_on snd (set_tree t)\n  inj_on snd (set_tree t)\n\ngoal (1 subgoal):\n 1. r =\n    treap_of {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}", "by (fastforce simp add: inj_on_def)"], ["proof (state)\nthis:\n  r =\n  treap_of {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "have \"t = Node (treap_of ?L) ?m (treap_of ?R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t =\n    \\<langle>treap_of\n              {p \\<in> set_tree t.\n               fst p < fst (arg_min_on snd (set_tree t))},\n     arg_min_on snd (set_tree t),\n     treap_of\n      {p \\<in> set_tree t.\n       fst (arg_min_on snd (set_tree t)) < fst p}\\<rangle>", "using \\<open>a = ?m\\<close> \\<open>l = treap_of ?L\\<close> \\<open>r = treap_of ?R\\<close>"], ["proof (prove)\nusing this:\n  a = arg_min_on snd (set_tree t)\n  l =\n  treap_of {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))}\n  r =\n  treap_of {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}\n\ngoal (1 subgoal):\n 1. t =\n    \\<langle>treap_of\n              {p \\<in> set_tree t.\n               fst p < fst (arg_min_on snd (set_tree t))},\n     arg_min_on snd (set_tree t),\n     treap_of\n      {p \\<in> set_tree t.\n       fst (arg_min_on snd (set_tree t)) < fst p}\\<rangle>", "by(subst t) simp"], ["proof (state)\nthis:\n  t =\n  \\<langle>treap_of\n            {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))},\n   arg_min_on snd (set_tree t),\n   treap_of\n    {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (infinite (set_tree t) \\<or> set_tree t = {}) \\<Longrightarrow>\n    treap_of (set_tree t) = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t =\n  \\<langle>treap_of\n            {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))},\n   arg_min_on snd (set_tree t),\n   treap_of\n    {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}\\<rangle>\n\ngoal (1 subgoal):\n 1. treap_of (set_tree t) = t", "using False"], ["proof (prove)\nusing this:\n  t =\n  \\<langle>treap_of\n            {p \\<in> set_tree t. fst p < fst (arg_min_on snd (set_tree t))},\n   arg_min_on snd (set_tree t),\n   treap_of\n    {p \\<in> set_tree t. fst (arg_min_on snd (set_tree t)) < fst p}\\<rangle>\n  \\<not> (infinite (set_tree t) \\<or> set_tree t = {})\n\ngoal (1 subgoal):\n 1. treap_of (set_tree t) = t", "by (subst treap_of.simps) simp"], ["proof (state)\nthis:\n  treap_of (set_tree t) = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap_of (set_tree t) = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treap_unique:\n  \"\\<lbrakk> treap t1; treap t2; set_tree t1 = set_tree t2; inj_on snd (set_tree t1) \\<rbrakk>\n  \\<Longrightarrow> t1 = t2\"\n  for t1 t2 :: \"('k::linorder * 'p::linorder) tree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>treap t1; treap t2; set_tree t1 = set_tree t2;\n     inj_on snd (set_tree t1)\\<rbrakk>\n    \\<Longrightarrow> t1 = t2", "by (metis treap_of_unique)"], ["", "fun ins :: \"'k::linorder \\<Rightarrow> 'p::linorder \\<Rightarrow> ('k \\<times> 'p) tree \\<Rightarrow> ('k \\<times> 'p) tree\" where\n\"ins k p Leaf = \\<langle>Leaf, (k,p), Leaf\\<rangle>\" |\n\"ins k p \\<langle>l, (k1,p1), r\\<rangle> =\n  (if k < k1 then\n     (case ins k p l of\n       \\<langle>l2, (k2,p2), r2\\<rangle> \\<Rightarrow>\n         if p1 \\<le> p2 then \\<langle>\\<langle>l2, (k2,p2), r2\\<rangle>, (k1,p1), r\\<rangle>\n         else \\<langle>l2, (k2,p2), \\<langle>r2, (k1,p1), r\\<rangle>\\<rangle>)\n   else\n   if k > k1 then\n     (case ins k p r of\n       \\<langle>l2, (k2,p2), r2\\<rangle> \\<Rightarrow>\n         if p1 \\<le> p2 then \\<langle>l, (k1,p1), \\<langle>l2, (k2,p2), r2\\<rangle>\\<rangle>\n         else \\<langle>\\<langle>l, (k1,p1), l2\\<rangle>, (k2,p2), r2\\<rangle>)\n   else \\<langle>l, (k1,p1), r\\<rangle>)\""], ["", "lemma ins_neq_Leaf: \"ins k p t \\<noteq> \\<langle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins k p t \\<noteq> \\<langle>\\<rangle>", "by (induction t rule: ins.induct) (auto split: tree.split)"], ["", "lemma keys_ins: \"keys (ins k p t) = Set.insert k (keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (ins k p t) = insert k (keys t)", "proof (induction t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k p.\n       keys (ins k p \\<langle>\\<rangle>) =\n       insert k (keys \\<langle>\\<rangle>)\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                keys (ins k p l) = insert k (keys l);\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> keys (ins k p r) = insert k (keys r)\\<rbrakk>\n       \\<Longrightarrow> keys (ins k p \\<langle>l, (k1, p1), r\\<rangle>) =\n                         insert k (keys \\<langle>l, (k1, p1), r\\<rangle>)", "case 2"], ["proof (state)\nthis:\n  k_ < k1_ \\<Longrightarrow> keys (ins k_ p_ l_) = insert k_ (keys l_)\n  \\<lbrakk>\\<not> k_ < k1_; k1_ < k_\\<rbrakk>\n  \\<Longrightarrow> keys (ins k_ p_ r_) = insert k_ (keys r_)\n\ngoal (2 subgoals):\n 1. \\<And>k p.\n       keys (ins k p \\<langle>\\<rangle>) =\n       insert k (keys \\<langle>\\<rangle>)\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                keys (ins k p l) = insert k (keys l);\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> keys (ins k p r) = insert k (keys r)\\<rbrakk>\n       \\<Longrightarrow> keys (ins k p \\<langle>l, (k1, p1), r\\<rangle>) =\n                         insert k (keys \\<langle>l, (k1, p1), r\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  k_ < k1_ \\<Longrightarrow> keys (ins k_ p_ l_) = insert k_ (keys l_)\n  \\<lbrakk>\\<not> k_ < k1_; k1_ < k_\\<rbrakk>\n  \\<Longrightarrow> keys (ins k_ p_ r_) = insert k_ (keys r_)", "show ?case"], ["proof (prove)\nusing this:\n  k_ < k1_ \\<Longrightarrow> keys (ins k_ p_ l_) = insert k_ (keys l_)\n  \\<lbrakk>\\<not> k_ < k1_; k1_ < k_\\<rbrakk>\n  \\<Longrightarrow> keys (ins k_ p_ r_) = insert k_ (keys r_)\n\ngoal (1 subgoal):\n 1. keys (ins k_ p_ \\<langle>l_, (k1_, p1_), r_\\<rangle>) =\n    insert k_ (keys \\<langle>l_, (k1_, p1_), r_\\<rangle>)", "by (simp add: ins_neq_Leaf split: tree.split prod.split) (safe; fastforce)"], ["proof (state)\nthis:\n  keys (ins k_ p_ \\<langle>l_, (k1_, p1_), r_\\<rangle>) =\n  insert k_ (keys \\<langle>l_, (k1_, p1_), r_\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>k p.\n       keys (ins k p \\<langle>\\<rangle>) =\n       insert k (keys \\<langle>\\<rangle>)", "qed (simp)"], ["", "lemma prios_ins: \"prios (ins k p t) \\<subseteq> {p} \\<union> prios t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prios (ins k p t) \\<subseteq> {p} \\<union> prios t", "apply(induction t rule: ins.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k p.\n       prios (ins k p \\<langle>\\<rangle>)\n       \\<subseteq> {p} \\<union> prios \\<langle>\\<rangle>\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                prios (ins k p l) \\<subseteq> {p} \\<union> prios l;\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r)\n                          \\<subseteq> {p} \\<union> prios r\\<rbrakk>\n       \\<Longrightarrow> prios (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n                         \\<subseteq> {p} \\<union>\n                                     prios \\<langle>l, (k1, p1), r\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                prios (ins k p l) \\<subseteq> {p} \\<union> prios l;\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r)\n                          \\<subseteq> {p} \\<union> prios r\\<rbrakk>\n       \\<Longrightarrow> prios (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n                         \\<subseteq> {p} \\<union>\n                                     prios \\<langle>l, (k1, p1), r\\<rangle>", "apply (simp add: ins_neq_Leaf split: tree.split prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                prios (ins k p l) \\<subseteq> insert p (prios l);\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r)\n                          \\<subseteq> insert p (prios r)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x21 a b x23.\n                            ins k p r =\n                            \\<langle>x21, (a, b),\n                             x23\\<rangle> \\<longrightarrow>\n                            (\\<forall>x21a a ba x23a.\n                                ins k p l =\n                                \\<langle>x21a, (a, ba),\n                                 x23a\\<rangle> \\<longrightarrow>\n                                (k1 < k \\<longrightarrow>\n                                 (k < k1 \\<longrightarrow>\n                                  (ba = p1 \\<or>\n                                   ba = p \\<or>\n                                   ba \\<in> prios l \\<or>\n                                   ba \\<in> prios r) \\<and>\n                                  prios x21a\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios x23a\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios r\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r))) \\<and>\n                                 (\\<not> k < k1 \\<longrightarrow>\n                                  (b = p1 \\<or>\n                                   b = p \\<or>\n                                   b \\<in> prios l \\<or>\n                                   b \\<in> prios r) \\<and>\n                                  prios l\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios x21\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios x23\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)))) \\<and>\n                                (\\<not> k1 < k \\<longrightarrow>\n                                 (k < k1 \\<longrightarrow>\n                                  (ba = p1 \\<or>\n                                   ba = p \\<or>\n                                   ba \\<in> prios l \\<or>\n                                   ba \\<in> prios r) \\<and>\n                                  prios x21a\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios x23a\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios r\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r))) \\<and>\n                                 (k = k1 \\<longrightarrow>\n                                  prios l\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)) \\<and>\n                                  prios r\n                                  \\<subseteq> insert p1\n         (insert p (prios l \\<union> prios r)))))", "by (safe; fastforce)"], ["", "lemma prios_ins': \"k \\<notin> keys t \\<Longrightarrow> prios (ins k p t) = {p} \\<union> prios t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> keys t \\<Longrightarrow>\n    prios (ins k p t) = {p} \\<union> prios t", "apply(induction t rule: ins.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k p.\n       k \\<notin> keys \\<langle>\\<rangle> \\<Longrightarrow>\n       prios (ins k p \\<langle>\\<rangle>) =\n       {p} \\<union> prios \\<langle>\\<rangle>\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; k \\<notin> keys l\\<rbrakk>\n                \\<Longrightarrow> prios (ins k p l) = {p} \\<union> prios l;\n        \\<lbrakk>\\<not> k < k1; k1 < k; k \\<notin> keys r\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r) = {p} \\<union> prios r;\n        k \\<notin> keys \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> prios (ins k p \\<langle>l, (k1, p1), r\\<rangle>) =\n                         {p} \\<union> prios \\<langle>l, (k1, p1), r\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; k \\<notin> keys l\\<rbrakk>\n                \\<Longrightarrow> prios (ins k p l) = {p} \\<union> prios l;\n        \\<lbrakk>\\<not> k < k1; k1 < k; k \\<notin> keys r\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r) = {p} \\<union> prios r;\n        k \\<notin> keys \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> prios (ins k p \\<langle>l, (k1, p1), r\\<rangle>) =\n                         {p} \\<union> prios \\<langle>l, (k1, p1), r\\<rangle>", "apply (simp add: ins_neq_Leaf split: tree.split prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>k < k1 \\<Longrightarrow>\n                prios (ins k p l) = insert p (prios l);\n        \\<lbrakk>\\<not> k < k1; k1 < k\\<rbrakk>\n        \\<Longrightarrow> prios (ins k p r) = insert p (prios r);\n        k \\<noteq> k1 \\<and>\n        k \\<notin> keys l \\<and> k \\<notin> keys r\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x21 a b x23.\n                            (p1 \\<le> b \\<longrightarrow>\n                             ins k p r =\n                             \\<langle>x21, (a, b),\n                              x23\\<rangle> \\<longrightarrow>\n                             (\\<forall>x21a a ba x23a.\n                                 (p1 \\<le> ba \\<longrightarrow>\n                                  ins k p l =\n                                  \\<langle>x21a, (a, ba),\n                                   x23a\\<rangle> \\<longrightarrow>\n                                  (k1 < k \\<longrightarrow>\n                                   (k < k1 \\<longrightarrow>\n                                    insert p1\n                                     (insert ba\n (prios x21a \\<union> prios x23a \\<union> prios r)) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r))) \\<and>\n                                   (\\<not> k < k1 \\<longrightarrow>\n                                    insert b\n                                     (insert p1\n (prios l \\<union> (prios x21 \\<union> prios x23))) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r)))) \\<and>\n                                  (\\<not> k1 < k \\<longrightarrow>\n                                   k < k1 \\<longrightarrow>\n                                   insert p1\n                                    (insert ba\n(prios x21a \\<union> prios x23a \\<union> prios r)) =\n                                   insert p1\n                                    (insert p\n(prios l \\<union> prios r)))) \\<and>\n                                 (\\<not> p1 \\<le> ba \\<longrightarrow>\n                                  ins k p l =\n                                  \\<langle>x21a, (a, ba),\n                                   x23a\\<rangle> \\<longrightarrow>\n                                  (k1 < k \\<longrightarrow>\n                                   (k < k1 \\<longrightarrow>\n                                    insert p1\n                                     (insert ba\n (prios x21a \\<union> (prios x23a \\<union> prios r))) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r))) \\<and>\n                                   (\\<not> k < k1 \\<longrightarrow>\n                                    insert b\n                                     (insert p1\n (prios l \\<union> (prios x21 \\<union> prios x23))) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r)))) \\<and>\n                                  (\\<not> k1 < k \\<longrightarrow>\n                                   k < k1 \\<longrightarrow>\n                                   insert p1\n                                    (insert ba\n(prios x21a \\<union> (prios x23a \\<union> prios r))) =\n                                   insert p1\n                                    (insert p\n(prios l \\<union> prios r)))))) \\<and>\n                            (\\<not> p1 \\<le> b \\<longrightarrow>\n                             ins k p r =\n                             \\<langle>x21, (a, b),\n                              x23\\<rangle> \\<longrightarrow>\n                             (\\<forall>x21a a ba x23a.\n                                 (p1 \\<le> ba \\<longrightarrow>\n                                  ins k p l =\n                                  \\<langle>x21a, (a, ba),\n                                   x23a\\<rangle> \\<longrightarrow>\n                                  (k1 < k \\<longrightarrow>\n                                   (k < k1 \\<longrightarrow>\n                                    insert p1\n                                     (insert ba\n (prios x21a \\<union> prios x23a \\<union> prios r)) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r))) \\<and>\n                                   (\\<not> k < k1 \\<longrightarrow>\n                                    insert b\n                                     (insert p1\n (prios l \\<union> prios x21 \\<union> prios x23)) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r)))) \\<and>\n                                  (\\<not> k1 < k \\<longrightarrow>\n                                   k < k1 \\<longrightarrow>\n                                   insert p1\n                                    (insert ba\n(prios x21a \\<union> prios x23a \\<union> prios r)) =\n                                   insert p1\n                                    (insert p\n(prios l \\<union> prios r)))) \\<and>\n                                 (\\<not> p1 \\<le> ba \\<longrightarrow>\n                                  ins k p l =\n                                  \\<langle>x21a, (a, ba),\n                                   x23a\\<rangle> \\<longrightarrow>\n                                  (k1 < k \\<longrightarrow>\n                                   (k < k1 \\<longrightarrow>\n                                    insert p1\n                                     (insert ba\n (prios x21a \\<union> (prios x23a \\<union> prios r))) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r))) \\<and>\n                                   (\\<not> k < k1 \\<longrightarrow>\n                                    insert b\n                                     (insert p1\n (prios l \\<union> prios x21 \\<union> prios x23)) =\n                                    insert p1\n                                     (insert p\n (prios l \\<union> prios r)))) \\<and>\n                                  (\\<not> k1 < k \\<longrightarrow>\n                                   k < k1 \\<longrightarrow>\n                                   insert p1\n                                    (insert ba\n(prios x21a \\<union> (prios x23a \\<union> prios r))) =\n                                   insert p1\n                                    (insert p\n(prios l \\<union> prios r))))))", "by (safe; fastforce)"], ["", "lemma set_tree_ins: \"set_tree (ins k p t) \\<subseteq> {(k,p)} \\<union> set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (ins k p t) \\<subseteq> {(k, p)} \\<union> set_tree t", "by (induction t rule: ins.induct) (auto simp add: ins_neq_Leaf split: tree.split prod.split)"], ["", "lemma set_tree_ins': \"k \\<notin> keys t \\<Longrightarrow>  {(k,p)} \\<union> set_tree t \\<subseteq> set_tree (ins k p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> keys t \\<Longrightarrow>\n    {(k, p)} \\<union> set_tree t \\<subseteq> set_tree (ins k p t)", "by (induction t rule: ins.induct) (auto simp add: ins_neq_Leaf split: tree.split prod.split)"], ["", "lemma set_tree_ins_eq: \"k \\<notin> keys t \\<Longrightarrow> set_tree (ins k p t) = {(k,p)} \\<union> set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> keys t \\<Longrightarrow>\n    set_tree (ins k p t) = {(k, p)} \\<union> set_tree t", "using set_tree_ins set_tree_ins'"], ["proof (prove)\nusing this:\n  set_tree (ins ?k ?p ?t) \\<subseteq> {(?k, ?p)} \\<union> set_tree ?t\n  ?k \\<notin> keys ?t \\<Longrightarrow>\n  {(?k, ?p)} \\<union> set_tree ?t \\<subseteq> set_tree (ins ?k ?p ?t)\n\ngoal (1 subgoal):\n 1. k \\<notin> keys t \\<Longrightarrow>\n    set_tree (ins k p t) = {(k, p)} \\<union> set_tree t", "by blast"], ["", "lemma prios_ins_special:\n  \"\\<lbrakk> ins k p t = Node l (k',p') r;  p' = p; p \\<in> prios r \\<union> prios l \\<rbrakk>\n  \\<Longrightarrow> p \\<in> prios t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ins k p t = \\<langle>l, (k', p'), r\\<rangle>; p' = p;\n     p \\<in> prios r \\<union> prios l\\<rbrakk>\n    \\<Longrightarrow> p \\<in> prios t", "by (induction k p t arbitrary: l k' p' r rule: ins.induct)\n     (fastforce simp add: ins_neq_Leaf split: tree.splits prod.splits if_splits)+"], ["", "lemma treap_NodeI:\n  \"\\<lbrakk> treap l; treap r;\n     \\<forall>k' \\<in> keys l. k' < k; \\<forall>k' \\<in> keys r. k < k';\n     \\<forall>p' \\<in> prios l. p \\<le> p'; \\<forall>p' \\<in> prios r. p \\<le> p' \\<rbrakk>\n  \\<Longrightarrow> treap (Node l (k,p) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>treap l; treap r; \\<forall>k'\\<in>keys l. k' < k;\n     \\<forall>k'\\<in>keys r. k < k'; \\<forall>p'\\<in>prios l. p \\<le> p';\n     \\<forall>p'\\<in>prios r. p \\<le> p'\\<rbrakk>\n    \\<Longrightarrow> treap \\<langle>l, (k, p), r\\<rangle>", "by (auto simp: treap_def)"], ["", "lemma treap_rotate1:\n  assumes \"treap l2\" \"treap r2\" \"treap r\" \"\\<not> p1 \\<le> p2\" \"k < k1\" and\n  ins: \"ins k p l = Node l2 (k2,p2) r2\" and treap_ins: \"treap (ins k p l)\"\n  and treap: \"treap \\<langle>l, (k1, p1), r\\<rangle>\"\n  shows \"treap (Node l2 (k2,p2) (Node r2 (k1,p1) r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>l2, (k2, p2), \\<langle>r2, (k1, p1), r\\<rangle>\\<rangle>", "proof(rule treap_NodeI[OF \\<open>treap l2\\<close> treap_NodeI[OF \\<open>treap r2\\<close> \\<open>treap r\\<close>]])"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys r2. k' < k1\n 2. \\<forall>k'\\<in>keys r. k1 < k'\n 3. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys l2. k' < k2\n 6. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 7. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "from keys_ins[of k p l]"], ["proof (chain)\npicking this:\n  keys (ins k p l) = insert k (keys l)", "have 1: \"keys r2 \\<subseteq> {k} \\<union> keys l\""], ["proof (prove)\nusing this:\n  keys (ins k p l) = insert k (keys l)\n\ngoal (1 subgoal):\n 1. keys r2 \\<subseteq> {k} \\<union> keys l", "by(auto simp: ins)"], ["proof (state)\nthis:\n  keys r2 \\<subseteq> {k} \\<union> keys l\n\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys r2. k' < k1\n 2. \\<forall>k'\\<in>keys r. k1 < k'\n 3. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys l2. k' < k2\n 6. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 7. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "from treap"], ["proof (chain)\npicking this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>", "have 2: \"\\<forall>k'\\<in>keys l. k' < k1\""], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l. k' < k1", "by (simp add: treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys l. k' < k1\n\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys r2. k' < k1\n 2. \\<forall>k'\\<in>keys r. k1 < k'\n 3. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys l2. k' < k2\n 6. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 7. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "show \"\\<forall>k'\\<in>keys r2. k' < k1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r2. k' < k1", "using 1 2 \\<open>k < k1\\<close>"], ["proof (prove)\nusing this:\n  keys r2 \\<subseteq> {k} \\<union> keys l\n  \\<forall>k'\\<in>keys l. k' < k1\n  k < k1\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r2. k' < k1", "by blast"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys r2. k' < k1\n\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys l2. k' < k2\n 5. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 6. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys l2. k' < k2\n 5. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 6. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "from treap"], ["proof (chain)\npicking this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>", "have 2: \"\\<forall>p'\\<in>prios l. p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios l. p1 \\<le> p'", "by (simp add: treap_def)"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios l. p1 \\<le> p'\n\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys l2. k' < k2\n 5. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 6. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "show \"\\<forall>p'\\<in>prios r2. p1 \\<le> p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios r2. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios r2 \\<Longrightarrow> p1 \\<le> p'", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios r2 \\<Longrightarrow> p1 \\<le> p'", "assume \"p' \\<in> prios r2\""], ["proof (state)\nthis:\n  p' \\<in> prios r2\n\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios r2 \\<Longrightarrow> p1 \\<le> p'", "hence \"p' = p \\<or> p' \\<in> prios l\""], ["proof (prove)\nusing this:\n  p' \\<in> prios r2\n\ngoal (1 subgoal):\n 1. p' = p \\<or> p' \\<in> prios l", "using prios_ins[of k p l] ins"], ["proof (prove)\nusing this:\n  p' \\<in> prios r2\n  prios (ins k p l) \\<subseteq> {p} \\<union> prios l\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. p' = p \\<or> p' \\<in> prios l", "by auto"], ["proof (state)\nthis:\n  p' = p \\<or> p' \\<in> prios l\n\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios r2 \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p' = p \\<or> p' \\<in> prios l\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "assume [simp]: \"p' = p\""], ["proof (state)\nthis:\n  p' = p\n\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "have \"p2 = p \\<or> p2 \\<in> prios l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = p \\<or> p2 \\<in> prios l", "using prios_ins[of k p l] ins"], ["proof (prove)\nusing this:\n  prios (ins k p l) \\<subseteq> {p} \\<union> prios l\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. p2 = p \\<or> p2 \\<in> prios l", "by simp"], ["proof (state)\nthis:\n  p2 = p \\<or> p2 \\<in> prios l\n\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 = p \\<or> p2 \\<in> prios l\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 = p \\<Longrightarrow> p1 \\<le> p'\n 2. p2 \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "assume \"p2 = p\""], ["proof (state)\nthis:\n  p2 = p\n\ngoal (2 subgoals):\n 1. p2 = p \\<Longrightarrow> p1 \\<le> p'\n 2. p2 \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 = p\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using prios_ins_special[OF ins] \\<open>p' \\<in> prios r2\\<close> 2"], ["proof (prove)\nusing this:\n  p2 = p\n  \\<lbrakk>p2 = p; p \\<in> prios r2 \\<union> prios l2\\<rbrakk>\n  \\<Longrightarrow> p \\<in> prios l\n  p' \\<in> prios r2\n  \\<forall>p'\\<in>prios l. p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by auto"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p2 \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p2 \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "assume \"p2 \\<in> prios l\""], ["proof (state)\nthis:\n  p2 \\<in> prios l\n\ngoal (1 subgoal):\n 1. p2 \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 \\<in> prios l\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using 2 \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  p2 \\<in> prios l\n  \\<forall>p'\\<in>prios l. p1 \\<le> p'\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by blast"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "assume \"p' \\<in> prios l\""], ["proof (state)\nthis:\n  p' \\<in> prios l\n\ngoal (1 subgoal):\n 1. p' \\<in> prios l \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p' \\<in> prios l\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using 2"], ["proof (prove)\nusing this:\n  p' \\<in> prios l\n  \\<forall>p'\\<in>prios l. p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by blast"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios r2. p1 \\<le> p'\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "have \"k2 = k \\<or> k2 \\<in> keys l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k2 = k \\<or> k2 \\<in> keys l", "using keys_ins[of k p l] ins"], ["proof (prove)\nusing this:\n  keys (ins k p l) = insert k (keys l)\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. k2 = k \\<or> k2 \\<in> keys l", "by (auto)"], ["proof (state)\nthis:\n  k2 = k \\<or> k2 \\<in> keys l\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "hence 1: \"k2 < k1\""], ["proof (prove)\nusing this:\n  k2 = k \\<or> k2 \\<in> keys l\n\ngoal (1 subgoal):\n 1. k2 < k1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k2 = k \\<Longrightarrow> k2 < k1\n 2. k2 \\<in> keys l \\<Longrightarrow> k2 < k1", "assume \"k2 = k\""], ["proof (state)\nthis:\n  k2 = k\n\ngoal (2 subgoals):\n 1. k2 = k \\<Longrightarrow> k2 < k1\n 2. k2 \\<in> keys l \\<Longrightarrow> k2 < k1", "thus \"k2 < k1\""], ["proof (prove)\nusing this:\n  k2 = k\n\ngoal (1 subgoal):\n 1. k2 < k1", "using \\<open>k < k1\\<close>"], ["proof (prove)\nusing this:\n  k2 = k\n  k < k1\n\ngoal (1 subgoal):\n 1. k2 < k1", "by simp"], ["proof (state)\nthis:\n  k2 < k1\n\ngoal (1 subgoal):\n 1. k2 \\<in> keys l \\<Longrightarrow> k2 < k1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k2 \\<in> keys l \\<Longrightarrow> k2 < k1", "assume \"k2 \\<in> keys l\""], ["proof (state)\nthis:\n  k2 \\<in> keys l\n\ngoal (1 subgoal):\n 1. k2 \\<in> keys l \\<Longrightarrow> k2 < k1", "thus \"k2 < k1\""], ["proof (prove)\nusing this:\n  k2 \\<in> keys l\n\ngoal (1 subgoal):\n 1. k2 < k1", "using treap"], ["proof (prove)\nusing this:\n  k2 \\<in> keys l\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. k2 < k1", "by (auto simp: treap_def)"], ["proof (state)\nthis:\n  k2 < k1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k2 < k1\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "have 2: \"\\<forall>k'\\<in>keys r2. k2 < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r2. k2 < k'", "using treap_ins"], ["proof (prove)\nusing this:\n  treap (ins k p l)\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r2. k2 < k'", "by(simp add: ins treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys r2. k2 < k'\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "have 3: \"\\<forall>k'\\<in>keys r. k2 < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r. k2 < k'", "using 1 treap"], ["proof (prove)\nusing this:\n  k2 < k1\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r. k2 < k'", "by(auto simp: treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys r. k2 < k'\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n 5. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "show \"\\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'", "using 1 2 3"], ["proof (prove)\nusing this:\n  k2 < k1\n  \\<forall>k'\\<in>keys r2. k2 < k'\n  \\<forall>k'\\<in>keys r. k2 < k'\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'", "by auto"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys \\<langle>r2, (k1, p1), r\\<rangle>. k2 < k'\n\ngoal (5 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 5. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>p'\\<in>prios l2. p2 \\<le> p'\n 5. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "show \"\\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "using ins treap_ins treap \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n  treap (ins k p l)\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'", "by (auto simp: treap_def ball_Un)"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios \\<langle>r2, (k1, p1), r\\<rangle>. p2 \\<le> p'\n\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys r. k1 < k'\n 2. \\<forall>p'\\<in>prios r. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys l2. k' < k2\n 4. \\<forall>p'\\<in>prios l2. p2 \\<le> p'", "qed (use ins treap_ins treap in \\<open>auto simp: treap_def ball_Un\\<close>)"], ["", "lemma treap_rotate2:\n  assumes \"treap l\" \"treap l2\" \"treap r2\" \"\\<not> p1 \\<le> p2\" \"k1 < k\" and\n  ins: \"ins k p r = Node l2 (k2,p2) r2\" and treap_ins: \"treap (ins k p r)\"\n  and treap: \"treap \\<langle>l, (k1, p1), r\\<rangle>\"\n  shows \"treap (Node (Node l (k1,p1) l2) (k2,p2) r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>\\<langle>l, (k1, p1), l2\\<rangle>, (k2, p2), r2\\<rangle>", "proof(rule treap_NodeI[OF treap_NodeI[OF \\<open>treap l\\<close> \\<open>treap l2\\<close>] \\<open>treap r2\\<close>])"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>k'\\<in>keys l2. k1 < k'\n 3. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 6. \\<forall>k'\\<in>keys r2. k2 < k'\n 7. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "from keys_ins[of k p r]"], ["proof (chain)\npicking this:\n  keys (ins k p r) = insert k (keys r)", "have 1: \"keys l2 \\<subseteq> {k} \\<union> keys r\""], ["proof (prove)\nusing this:\n  keys (ins k p r) = insert k (keys r)\n\ngoal (1 subgoal):\n 1. keys l2 \\<subseteq> {k} \\<union> keys r", "by(auto simp: ins)"], ["proof (state)\nthis:\n  keys l2 \\<subseteq> {k} \\<union> keys r\n\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>k'\\<in>keys l2. k1 < k'\n 3. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 6. \\<forall>k'\\<in>keys r2. k2 < k'\n 7. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "from treap"], ["proof (chain)\npicking this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>", "have 2: \"\\<forall>k'\\<in>keys r. k1 < k'\""], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys r. k1 < k'", "by (simp add: treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys r. k1 < k'\n\ngoal (8 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>k'\\<in>keys l2. k1 < k'\n 3. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 5. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 6. \\<forall>k'\\<in>keys r2. k2 < k'\n 7. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 8. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "show \"\\<forall>k'\\<in>keys l2. k1 < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l2. k1 < k'", "using 1 2 \\<open>k1 < k\\<close>"], ["proof (prove)\nusing this:\n  keys l2 \\<subseteq> {k} \\<union> keys r\n  \\<forall>k'\\<in>keys r. k1 < k'\n  k1 < k\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l2. k1 < k'", "by blast"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys l2. k1 < k'\n\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 5. \\<forall>k'\\<in>keys r2. k2 < k'\n 6. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 5. \\<forall>k'\\<in>keys r2. k2 < k'\n 6. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "from treap"], ["proof (chain)\npicking this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>", "have 2: \"\\<forall>p'\\<in>prios r. p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios r. p1 \\<le> p'", "by (simp add: treap_def)"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios r. p1 \\<le> p'\n\ngoal (7 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n 4. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 5. \\<forall>k'\\<in>keys r2. k2 < k'\n 6. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 7. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "show \"\\<forall>p'\\<in>prios l2. p1 \\<le> p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios l2. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios l2 \\<Longrightarrow> p1 \\<le> p'", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios l2 \\<Longrightarrow> p1 \\<le> p'", "assume \"p' \\<in> prios l2\""], ["proof (state)\nthis:\n  p' \\<in> prios l2\n\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios l2 \\<Longrightarrow> p1 \\<le> p'", "hence \"p' = p \\<or> p' \\<in> prios r\""], ["proof (prove)\nusing this:\n  p' \\<in> prios l2\n\ngoal (1 subgoal):\n 1. p' = p \\<or> p' \\<in> prios r", "using prios_ins[of k p r] ins"], ["proof (prove)\nusing this:\n  p' \\<in> prios l2\n  prios (ins k p r) \\<subseteq> {p} \\<union> prios r\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. p' = p \\<or> p' \\<in> prios r", "by auto"], ["proof (state)\nthis:\n  p' = p \\<or> p' \\<in> prios r\n\ngoal (1 subgoal):\n 1. \\<And>p'. p' \\<in> prios l2 \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p' = p \\<or> p' \\<in> prios r\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "assume [simp]: \"p' = p\""], ["proof (state)\nthis:\n  p' = p\n\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "have \"p2 = p \\<or> p2 \\<in> prios r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = p \\<or> p2 \\<in> prios r", "using prios_ins[of k p r] ins"], ["proof (prove)\nusing this:\n  prios (ins k p r) \\<subseteq> {p} \\<union> prios r\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. p2 = p \\<or> p2 \\<in> prios r", "by simp"], ["proof (state)\nthis:\n  p2 = p \\<or> p2 \\<in> prios r\n\ngoal (2 subgoals):\n 1. p' = p \\<Longrightarrow> p1 \\<le> p'\n 2. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 = p \\<or> p2 \\<in> prios r\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 = p \\<Longrightarrow> p1 \\<le> p'\n 2. p2 \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "assume \"p2 = p\""], ["proof (state)\nthis:\n  p2 = p\n\ngoal (2 subgoals):\n 1. p2 = p \\<Longrightarrow> p1 \\<le> p'\n 2. p2 \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 = p\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using prios_ins_special[OF ins] \\<open>p' \\<in> prios l2\\<close> 2"], ["proof (prove)\nusing this:\n  p2 = p\n  \\<lbrakk>p2 = p; p \\<in> prios r2 \\<union> prios l2\\<rbrakk>\n  \\<Longrightarrow> p \\<in> prios r\n  p' \\<in> prios l2\n  \\<forall>p'\\<in>prios r. p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by auto"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p2 \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p2 \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "assume \"p2 \\<in> prios r\""], ["proof (state)\nthis:\n  p2 \\<in> prios r\n\ngoal (1 subgoal):\n 1. p2 \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p2 \\<in> prios r\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using 2 \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  p2 \\<in> prios r\n  \\<forall>p'\\<in>prios r. p1 \\<le> p'\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by blast"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "assume \"p' \\<in> prios r\""], ["proof (state)\nthis:\n  p' \\<in> prios r\n\ngoal (1 subgoal):\n 1. p' \\<in> prios r \\<Longrightarrow> p1 \\<le> p'", "thus \"p1 \\<le> p'\""], ["proof (prove)\nusing this:\n  p' \\<in> prios r\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "using 2"], ["proof (prove)\nusing this:\n  p' \\<in> prios r\n  \\<forall>p'\\<in>prios r. p1 \\<le> p'\n\ngoal (1 subgoal):\n 1. p1 \\<le> p'", "by blast"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<le> p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios l2. p1 \\<le> p'\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "have \"k2 = k \\<or> k2 \\<in> keys r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k2 = k \\<or> k2 \\<in> keys r", "using keys_ins[of k p r] ins"], ["proof (prove)\nusing this:\n  keys (ins k p r) = insert k (keys r)\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. k2 = k \\<or> k2 \\<in> keys r", "by (auto)"], ["proof (state)\nthis:\n  k2 = k \\<or> k2 \\<in> keys r\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "hence 1: \"k1 < k2\""], ["proof (prove)\nusing this:\n  k2 = k \\<or> k2 \\<in> keys r\n\ngoal (1 subgoal):\n 1. k1 < k2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k2 = k \\<Longrightarrow> k1 < k2\n 2. k2 \\<in> keys r \\<Longrightarrow> k1 < k2", "assume \"k2 = k\""], ["proof (state)\nthis:\n  k2 = k\n\ngoal (2 subgoals):\n 1. k2 = k \\<Longrightarrow> k1 < k2\n 2. k2 \\<in> keys r \\<Longrightarrow> k1 < k2", "thus \"k1 < k2\""], ["proof (prove)\nusing this:\n  k2 = k\n\ngoal (1 subgoal):\n 1. k1 < k2", "using \\<open>k1 < k\\<close>"], ["proof (prove)\nusing this:\n  k2 = k\n  k1 < k\n\ngoal (1 subgoal):\n 1. k1 < k2", "by simp"], ["proof (state)\nthis:\n  k1 < k2\n\ngoal (1 subgoal):\n 1. k2 \\<in> keys r \\<Longrightarrow> k1 < k2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k2 \\<in> keys r \\<Longrightarrow> k1 < k2", "assume \"k2 \\<in> keys r\""], ["proof (state)\nthis:\n  k2 \\<in> keys r\n\ngoal (1 subgoal):\n 1. k2 \\<in> keys r \\<Longrightarrow> k1 < k2", "thus \"k1 < k2\""], ["proof (prove)\nusing this:\n  k2 \\<in> keys r\n\ngoal (1 subgoal):\n 1. k1 < k2", "using treap"], ["proof (prove)\nusing this:\n  k2 \\<in> keys r\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. k1 < k2", "by (auto simp: treap_def)"], ["proof (state)\nthis:\n  k1 < k2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k1 < k2\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "have 2: \"\\<forall>k'\\<in>keys l. k' < k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l. k' < k2", "using 1 treap"], ["proof (prove)\nusing this:\n  k1 < k2\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l. k' < k2", "by(auto simp: treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys l. k' < k2\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "have 3: \"\\<forall>k'\\<in>keys l2. k' < k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l2. k' < k2", "using treap_ins"], ["proof (prove)\nusing this:\n  treap (ins k p r)\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys l2. k' < k2", "by(auto simp: ins treap_def)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys l2. k' < k2\n\ngoal (6 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n 4. \\<forall>k'\\<in>keys r2. k2 < k'\n 5. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 6. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "show \"\\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2", "using 1 2 3"], ["proof (prove)\nusing this:\n  k1 < k2\n  \\<forall>k'\\<in>keys l. k' < k2\n  \\<forall>k'\\<in>keys l2. k' < k2\n\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2", "by auto"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys \\<langle>l, (k1, p1), l2\\<rangle>. k' < k2\n\ngoal (5 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys r2. k2 < k'\n 4. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 5. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys r2. k2 < k'\n 4. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n 5. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "show \"\\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'", "using ins treap_ins treap \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n  treap (ins k p r)\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'", "by (auto simp: treap_def ball_Un)"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>prios \\<langle>l, (k1, p1), l2\\<rangle>. p2 \\<le> p'\n\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 3. \\<forall>k'\\<in>keys r2. k2 < k'\n 4. \\<forall>p'\\<in>prios r2. p2 \\<le> p'", "qed (use ins treap_ins treap in \\<open>auto simp: treap_def ball_Un\\<close>)"], ["", "lemma treap_ins: \"treap t \\<Longrightarrow> treap (ins k p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap t \\<Longrightarrow> treap (ins k p t)", "proof(induction t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k p.\n       treap \\<langle>\\<rangle> \\<Longrightarrow>\n       treap (ins k p \\<langle>\\<rangle>)\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "case 1"], ["proof (state)\nthis:\n  treap \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>k p.\n       treap \\<langle>\\<rangle> \\<Longrightarrow>\n       treap (ins k p \\<langle>\\<rangle>)\n 2. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?case"], ["proof (prove)\nusing this:\n  treap \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k_ p_ \\<langle>\\<rangle>)", "by (simp add: treap_def)"], ["proof (state)\nthis:\n  treap (ins k_ p_ \\<langle>\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "case (2 k p l k1 p1 r)"], ["proof (state)\nthis:\n  \\<lbrakk>k < k1; treap l\\<rbrakk> \\<Longrightarrow> treap (ins k p l)\n  \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n  \\<Longrightarrow> treap (ins k p r)\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have \"treap l\" \"treap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap l &&& treap r", "using \"2.prems\""], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. treap l &&& treap r", "by(auto simp: treap_def tree.set_map)"], ["proof (state)\nthis:\n  treap l\n  treap r\n\ngoal (1 subgoal):\n 1. \\<And>k p l k1 p1 r.\n       \\<lbrakk>\\<lbrakk>k < k1; treap l\\<rbrakk>\n                \\<Longrightarrow> treap (ins k p l);\n        \\<lbrakk>\\<not> k < k1; k1 < k; treap r\\<rbrakk>\n        \\<Longrightarrow> treap (ins k p r);\n        treap \\<langle>l, (k1, p1), r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"k < k1\""], ["proof (state)\nthis:\n  k < k1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "obtain l2 k2 p2 r2 where ins: \"ins k p l = Node l2 (k2,p2) r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2 k2 p2 r2.\n        ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis ins_neq_Leaf neq_Leaf_iff prod.collapse)"], ["proof (state)\nthis:\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "note treap_ins = \"2.IH\"(1)[OF \\<open>k < k1\\<close> \\<open>treap l\\<close>]"], ["proof (state)\nthis:\n  treap (ins k p l)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "hence \"treap l2\" \"treap r2\""], ["proof (prove)\nusing this:\n  treap (ins k p l)\n\ngoal (1 subgoal):\n 1. treap l2 &&& treap r2", "using ins"], ["proof (prove)\nusing this:\n  treap (ins k p l)\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. treap l2 &&& treap r2", "by (auto simp add: treap_def)"], ["proof (state)\nthis:\n  treap l2\n  treap r2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"p1 \\<le> p2\""], ["proof (state)\nthis:\n  p1 \\<le> p2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have \"treap (Node (Node l2 (k2,p2) r2) (k1,p1) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>\\<langle>l2, (k2, p2), r2\\<rangle>, (k1, p1), r\\<rangle>", "apply(rule treap_NodeI[OF treap_ins[unfolded ins] \\<open>treap r\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys \\<langle>l2, (k2, p2), r2\\<rangle>. k' < k1\n 2. \\<forall>k'\\<in>keys r. k1 < k'\n 3. \\<forall>p'\\<in>prios \\<langle>l2, (k2, p2), r2\\<rangle>. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios r. p1 \\<le> p'", "using ins treap_ins \\<open>k < k1\\<close> \"2.prems\" keys_ins[of k p l]"], ["proof (prove)\nusing this:\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n  treap (ins k p l)\n  k < k1\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n  keys (ins k p l) = insert k (keys l)\n\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys \\<langle>l2, (k2, p2), r2\\<rangle>. k' < k1\n 2. \\<forall>k'\\<in>keys r. k1 < k'\n 3. \\<forall>p'\\<in>prios \\<langle>l2, (k2, p2), r2\\<rangle>. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios r. p1 \\<le> p'", "by (auto simp add: treap_def ball_Un order_trans[OF \\<open>p1 \\<le> p2\\<close>])"], ["proof (state)\nthis:\n  treap \\<langle>\\<langle>l2, (k2, p2), r2\\<rangle>, (k1, p1), r\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  treap \\<langle>\\<langle>l2, (k2, p2), r2\\<rangle>, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "using \\<open>k < k1\\<close> ins \\<open>p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  treap \\<langle>\\<langle>l2, (k2, p2), r2\\<rangle>, (k1, p1), r\\<rangle>\n  k < k1\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n  p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"\\<not> p1 \\<le> p2\""], ["proof (state)\nthis:\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have \"treap (Node l2 (k2,p2) (Node r2 (k1,p1) r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>l2, (k2, p2), \\<langle>r2, (k1, p1), r\\<rangle>\\<rangle>", "by(rule treap_rotate1[OF \\<open>treap l2\\<close> \\<open>treap r2\\<close>  \\<open>treap r\\<close> \\<open>\\<not> p1 \\<le> p2\\<close>\n            \\<open>k < k1\\<close> ins treap_ins \"2.prems\"])"], ["proof (state)\nthis:\n  treap \\<langle>l2, (k2, p2), \\<langle>r2, (k1, p1), r\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  treap \\<langle>l2, (k2, p2), \\<langle>r2, (k1, p1), r\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "using \\<open>k < k1\\<close> ins \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  treap \\<langle>l2, (k2, p2), \\<langle>r2, (k1, p1), r\\<rangle>\\<rangle>\n  k < k1\n  ins k p l = \\<langle>l2, (k2, p2), r2\\<rangle>\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> k < k1 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < k1 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"\\<not> k < k1\""], ["proof (state)\nthis:\n  \\<not> k < k1\n\ngoal (1 subgoal):\n 1. \\<not> k < k1 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"k > k1\""], ["proof (state)\nthis:\n  k1 < k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "obtain l2 k2 p2 r2 where ins: \"ins k p r = Node l2 (k2,p2) r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2 k2 p2 r2.\n        ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis ins_neq_Leaf neq_Leaf_iff prod.collapse)"], ["proof (state)\nthis:\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "note treap_ins = \"2.IH\"(2)[OF \\<open>\\<not> k < k1\\<close> \\<open>k > k1\\<close> \\<open>treap r\\<close>]"], ["proof (state)\nthis:\n  treap (ins k p r)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "hence \"treap l2\" \"treap r2\""], ["proof (prove)\nusing this:\n  treap (ins k p r)\n\ngoal (1 subgoal):\n 1. treap l2 &&& treap r2", "using ins"], ["proof (prove)\nusing this:\n  treap (ins k p r)\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. treap l2 &&& treap r2", "by (auto simp add: treap_def)"], ["proof (state)\nthis:\n  treap l2\n  treap r2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have fst: \"\\<forall>k' \\<in> set_tree (map_tree fst (ins k p r)).\n                 k' = k \\<or> k' \\<in> set_tree (map_tree fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>keys (ins k p r). k' = k \\<or> k' \\<in> keys r", "by(simp add: keys_ins)"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>keys (ins k p r). k' = k \\<or> k' \\<in> keys r\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"p1 \\<le> p2\""], ["proof (state)\nthis:\n  p1 \\<le> p2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have \"treap (Node l (k1,p1) (ins k p r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>l, (k1, p1), ins k p r\\<rangle>", "apply(rule treap_NodeI[OF \\<open>treap l\\<close> treap_ins])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>k'\\<in>keys (ins k p r). k1 < k'\n 3. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios (ins k p r). p1 \\<le> p'", "using ins treap_ins \\<open>k > k1\\<close> \"2.prems\" keys_ins[of k p r]"], ["proof (prove)\nusing this:\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n  treap (ins k p r)\n  k1 < k\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n  keys (ins k p r) = insert k (keys r)\n\ngoal (4 subgoals):\n 1. \\<forall>k'\\<in>keys l. k' < k1\n 2. \\<forall>k'\\<in>keys (ins k p r). k1 < k'\n 3. \\<forall>p'\\<in>prios l. p1 \\<le> p'\n 4. \\<forall>p'\\<in>prios (ins k p r). p1 \\<le> p'", "by (auto simp: treap_def ball_Un order_trans[OF \\<open>p1 \\<le> p2\\<close>])"], ["proof (state)\nthis:\n  treap \\<langle>l, (k1, p1), ins k p r\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), ins k p r\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "using \\<open>\\<not> k < k1\\<close> \\<open>k > k1\\<close> ins \\<open>p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  treap \\<langle>l, (k1, p1), ins k p r\\<rangle>\n  \\<not> k < k1\n  k1 < k\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n  p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"\\<not> p1 \\<le> p2\""], ["proof (state)\nthis:\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "have \"treap (Node (Node l (k1,p1) l2) (k2,p2) r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>\\<langle>l, (k1, p1), l2\\<rangle>, (k2, p2), r2\\<rangle>", "by(rule treap_rotate2[OF \\<open>treap l\\<close> \\<open>treap l2\\<close> \\<open>treap r2\\<close> \\<open>\\<not> p1 \\<le> p2\\<close>\n             \\<open>k1 < k\\<close> ins treap_ins \"2.prems\"])"], ["proof (state)\nthis:\n  treap \\<langle>\\<langle>l, (k1, p1), l2\\<rangle>, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<le> p2 \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  treap \\<langle>\\<langle>l, (k1, p1), l2\\<rangle>, (k2, p2), r2\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "using \\<open>\\<not> k < k1\\<close>  \\<open>k > k1\\<close> ins \\<open>\\<not> p1 \\<le> p2\\<close>"], ["proof (prove)\nusing this:\n  treap \\<langle>\\<langle>l, (k1, p1), l2\\<rangle>, (k2, p2), r2\\<rangle>\n  \\<not> k < k1\n  k1 < k\n  ins k p r = \\<langle>l2, (k2, p2), r2\\<rangle>\n  \\<not> p1 \\<le> p2\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> k1 < k \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k1 < k \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "assume \"\\<not> k > k1\""], ["proof (state)\nthis:\n  \\<not> k1 < k\n\ngoal (1 subgoal):\n 1. \\<not> k1 < k \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "hence \"k = k1\""], ["proof (prove)\nusing this:\n  \\<not> k1 < k\n\ngoal (1 subgoal):\n 1. k = k1", "using \\<open>\\<not> k < k1\\<close>"], ["proof (prove)\nusing this:\n  \\<not> k1 < k\n  \\<not> k < k1\n\ngoal (1 subgoal):\n 1. k = k1", "by auto"], ["proof (state)\nthis:\n  k = k1\n\ngoal (1 subgoal):\n 1. \\<not> k1 < k \\<Longrightarrow>\n    treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = k1\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "using \"2.prems\""], ["proof (prove)\nusing this:\n  k = k1\n  treap \\<langle>l, (k1, p1), r\\<rangle>\n\ngoal (1 subgoal):\n 1. treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)", "by(simp)"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap (ins k p \\<langle>l, (k1, p1), r\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treap_of_set_tree_unique:\n  \"\\<lbrakk> finite A; inj_on fst A; inj_on snd A \\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; inj_on fst A; inj_on snd A\\<rbrakk>\n    \\<Longrightarrow> set_tree (treap_of A) = A", "proof(induction \"A\" rule: treap_of.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}; finite xa;\n                    inj_on fst xa; inj_on snd xa\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) = xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}; finite xb; inj_on fst xb;\n            inj_on snd xb\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) = xb;\n        finite KP; inj_on fst KP; inj_on snd KP\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) = KP", "case (1 A)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}; finite xa;\n                    inj_on fst xa; inj_on snd xa\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) = xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}; finite xb; inj_on fst xb;\n            inj_on snd xb\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) = xb;\n        finite KP; inj_on fst KP; inj_on snd KP\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) = KP", "note IH = 1"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}; finite xa;\n                    inj_on fst xa; inj_on snd xa\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) = xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}; finite xb; inj_on fst xb;\n            inj_on snd xb\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) = xb;\n        finite KP; inj_on fst KP; inj_on snd KP\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) = KP", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of A) = A", "proof (cases \"infinite A \\<or> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow> set_tree (treap_of A) = A\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "assume \"infinite A \\<or> A = {}\""], ["proof (state)\nthis:\n  infinite A \\<or> A = {}\n\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow> set_tree (treap_of A) = A\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n  infinite A \\<or> A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n  infinite A \\<or> A = {}\n\ngoal (1 subgoal):\n 1. set_tree (treap_of A) = A", "by (simp add: treap_of.simps)"], ["proof (state)\nthis:\n  set_tree (treap_of A) = A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "assume not_inf_or_empty: \"\\<not> (infinite A \\<or> A = {})\""], ["proof (state)\nthis:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "let ?m = \"arg_min_on snd A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "let ?L = \"{p \\<in> A. fst p < fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "let ?R = \"{p \\<in> A. fst p > fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "obtain l a r where t: \"treap_of A = Node l a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_inf_or_empty"], ["proof (prove)\nusing this:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"treap_of A\") (auto simp: Let_def elim!: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have [simp]: \"inj_on fst {p \\<in> A. fst p < fst (arg_min_on snd A)}\"\n                 \"inj_on snd {p \\<in> A. fst p < fst (arg_min_on snd A)}\"\n                 \"inj_on fst {p \\<in> A. fst (arg_min_on snd A) < fst p}\"\n                 \"inj_on snd {p \\<in> A. fst (arg_min_on snd A) < fst p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inj_on fst {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n     inj_on snd {p \\<in> A. fst p < fst (arg_min_on snd A)}) &&&\n    inj_on fst {p \\<in> A. fst (arg_min_on snd A) < fst p} &&&\n    inj_on snd {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n\ngoal (1 subgoal):\n 1. (inj_on fst {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n     inj_on snd {p \\<in> A. fst p < fst (arg_min_on snd A)}) &&&\n    inj_on fst {p \\<in> A. fst (arg_min_on snd A) < fst p} &&&\n    inj_on snd {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto intro: inj_on_subset)"], ["proof (state)\nthis:\n  inj_on fst {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  inj_on snd {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  inj_on fst {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  inj_on snd {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have lr: \"l = treap_of ?L\" \"r = treap_of ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n    r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n    r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "then"], ["proof (chain)\npicking this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have l: \"set_tree l = ?L\""], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. set_tree l = {p \\<in> A. fst p < fst (arg_min_on snd A)}", "using not_inf_or_empty IH"], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<not> (infinite A \\<or> A = {})\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xa; inj_on fst ?xa; inj_on snd ?xa\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) = ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n  finite A\n  inj_on fst A\n  inj_on snd A\n\ngoal (1 subgoal):\n 1. set_tree l = {p \\<in> A. fst p < fst (arg_min_on snd A)}", "by auto"], ["proof (state)\nthis:\n  set_tree l = {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have \"r = treap_of ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "then"], ["proof (chain)\npicking this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have r: \"set_tree r = ?R\""], ["proof (prove)\nusing this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. set_tree r = {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using not_inf_or_empty IH(2)"], ["proof (prove)\nusing this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<not> (infinite A \\<or> A = {})\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x}; ?xb = {p \\<in> A. fst ?x < fst p};\n   finite ?xb; inj_on fst ?xb; inj_on snd ?xb\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) = ?xb\n\ngoal (1 subgoal):\n 1. set_tree r = {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto)"], ["proof (state)\nthis:\n  set_tree r = {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have a: \"a = ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "by (elim treap_of.elims) (simp add: Let_def split: if_splits)"], ["proof (state)\nthis:\n  a = arg_min_on snd A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have \"a \\<noteq> fst (arg_min_on snd A)\" if \"(a,b) \\<in> A\" \"(a, b) \\<noteq> arg_min_on snd A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> fst (arg_min_on snd A)", "using IH(4,5) that not_inf_or_empty arg_min_if_finite(1) inj_on_eq_iff"], ["proof (prove)\nusing this:\n  inj_on fst A\n  inj_on snd A\n  (a, b) \\<in> A\n  (a, b) \\<noteq> arg_min_on snd A\n  \\<not> (infinite A \\<or> A = {})\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> arg_min_on ?f ?S \\<in> ?S\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (?f ?x = ?f ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> fst (arg_min_on snd A)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> fst (arg_min_on snd A)\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> fst (arg_min_on snd A)", "have \"a < fst (arg_min_on snd A)\" \n       if \"(a,b) \\<in> A\" \"(a, b) \\<noteq> arg_min_on snd A\" \"fst (arg_min_on snd A) \\<ge> a\" for a b"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> fst (arg_min_on snd A)\n\ngoal (1 subgoal):\n 1. a < fst (arg_min_on snd A)", "using le_neq_trans that"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> fst (arg_min_on snd A)\n  \\<lbrakk>?a \\<le> ?b; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> ?a < ?b\n  (a, b) \\<in> A\n  (a, b) \\<noteq> arg_min_on snd A\n  a \\<le> fst (arg_min_on snd A)\n\ngoal (1 subgoal):\n 1. a < fst (arg_min_on snd A)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A;\n   ?a \\<le> fst (arg_min_on snd A)\\<rbrakk>\n  \\<Longrightarrow> ?a < fst (arg_min_on snd A)\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A;\n   ?a \\<le> fst (arg_min_on snd A)\\<rbrakk>\n  \\<Longrightarrow> ?a < fst (arg_min_on snd A)\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "have \"arg_min_on snd A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_min_on snd A \\<in> A", "using not_inf_or_empty arg_min_if_finite"], ["proof (prove)\nusing this:\n  \\<not> (infinite A \\<or> A = {})\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> arg_min_on ?f ?S \\<in> ?S\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>x\\<in>?S. ?f x < ?f (arg_min_on ?f ?S))\n\ngoal (1 subgoal):\n 1. arg_min_on snd A \\<in> A", "by auto"], ["proof (state)\nthis:\n  arg_min_on snd A \\<in> A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A;\n   ?a \\<le> fst (arg_min_on snd A)\\<rbrakk>\n  \\<Longrightarrow> ?a < fst (arg_min_on snd A)\n  arg_min_on snd A \\<in> A", "have A: \"A = {?m} \\<union> ?L \\<union> ?R\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> A; (?a, ?b) \\<noteq> arg_min_on snd A;\n   ?a \\<le> fst (arg_min_on snd A)\\<rbrakk>\n  \\<Longrightarrow> ?a < fst (arg_min_on snd A)\n  arg_min_on snd A \\<in> A\n\ngoal (1 subgoal):\n 1. A =\n    {arg_min_on snd A} \\<union>\n    {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n    {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by auto"], ["proof (state)\nthis:\n  A =\n  {arg_min_on snd A} \\<union>\n  {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n  {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) = A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of A) = A", "using l r a A t"], ["proof (prove)\nusing this:\n  set_tree l = {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  set_tree r = {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  a = arg_min_on snd A\n  A =\n  {arg_min_on snd A} \\<union>\n  {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n  {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. set_tree (treap_of A) = A", "by force"], ["proof (state)\nthis:\n  set_tree (treap_of A) = A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_tree (treap_of A) = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treap_of_subset: \"set_tree (treap_of A) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of A) \\<subseteq> A", "proof(induction \"A\" rule: treap_of.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) \\<subseteq> xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) \\<subseteq> xb\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) \\<subseteq> KP", "case (1 A)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) \\<subseteq> ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) \\<subseteq> ?xb\n\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) \\<subseteq> xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) \\<subseteq> xb\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) \\<subseteq> KP", "note IH = 1"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) \\<subseteq> ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) \\<subseteq> ?xb\n\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n                   \\<Longrightarrow> set_tree (treap_of xa) \\<subseteq> xa;\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n           \\<Longrightarrow> set_tree (treap_of xb) \\<subseteq> xb\\<rbrakk>\n       \\<Longrightarrow> set_tree (treap_of KP) \\<subseteq> KP", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of A) \\<subseteq> A", "proof (cases \"infinite A \\<or> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "assume \"infinite A \\<or> A = {}\""], ["proof (state)\nthis:\n  infinite A \\<or> A = {}\n\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "with IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) \\<subseteq> ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) \\<subseteq> ?xb\n  infinite A \\<or> A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xa) \\<subseteq> ?xa\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> set_tree (treap_of ?xb) \\<subseteq> ?xb\n  infinite A \\<or> A = {}\n\ngoal (1 subgoal):\n 1. set_tree (treap_of A) \\<subseteq> A", "by (simp add: treap_of.simps)"], ["proof (state)\nthis:\n  set_tree (treap_of A) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "assume not_inf_or_empty: \"\\<not> (infinite A \\<or> A = {})\""], ["proof (state)\nthis:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "let ?m = \"arg_min_on snd A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "let ?L = \"{p \\<in> A. fst p < fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "let ?R = \"{p \\<in> A. fst p > fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "obtain l a r where t: \"treap_of A = Node l a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not_inf_or_empty"], ["proof (prove)\nusing this:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"treap_of A\")\n                                (auto simp add: Let_def  elim!: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "have \"l = treap_of ?L\" \"r = treap_of ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n    r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n    r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "have \"set_tree l \\<subseteq> ?L\" \"set_tree r \\<subseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)} &&&\n    set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n 2. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have \"set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n            \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n    \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}", "by (rule IH) (use not_inf_or_empty in auto)"], ["proof (state)\nthis:\n  set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n  \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (2 subgoals):\n 1. set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n 2. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "then"], ["proof (chain)\npicking this:\n  set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n  \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}", "show \"set_tree l \\<subseteq> ?L\""], ["proof (prove)\nusing this:\n  set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n  \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}", "using \\<open>l = treap_of ?L\\<close>"], ["proof (prove)\nusing this:\n  set_tree (treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)})\n  \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}", "by auto"], ["proof (state)\nthis:\n  set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have \"set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n            \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n    \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (rule IH) (use not_inf_or_empty in auto)"], ["proof (state)\nthis:\n  set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n  \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "then"], ["proof (chain)\npicking this:\n  set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n  \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "show \"set_tree r \\<subseteq> ?R\""], ["proof (prove)\nusing this:\n  set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n  \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using \\<open>r = treap_of ?R\\<close>"], ["proof (prove)\nusing this:\n  set_tree (treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p})\n  \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by auto"], ["proof (state)\nthis:\n  set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "moreover"], ["proof (state)\nthis:\n  set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "have \"a = ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "by (auto elim!: treap_of.elims simp add: Let_def split: if_splits)"], ["proof (state)\nthis:\n  a = arg_min_on snd A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "moreover"], ["proof (state)\nthis:\n  a = arg_min_on snd A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "have \"{?m} \\<union> ?L \\<union> ?R \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {arg_min_on snd A} \\<union>\n    {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n    {p \\<in> A. fst (arg_min_on snd A) < fst p}\n    \\<subseteq> A", "using not_inf_or_empty arg_min_if_finite"], ["proof (prove)\nusing this:\n  \\<not> (infinite A \\<or> A = {})\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> arg_min_on ?f ?S \\<in> ?S\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<not> (\\<exists>x\\<in>?S. ?f x < ?f (arg_min_on ?f ?S))\n\ngoal (1 subgoal):\n 1. {arg_min_on snd A} \\<union>\n    {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n    {p \\<in> A. fst (arg_min_on snd A) < fst p}\n    \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  {arg_min_on snd A} \\<union>\n  {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n  {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow>\n    set_tree (treap_of A) \\<subseteq> A", "ultimately"], ["proof (chain)\npicking this:\n  set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  a = arg_min_on snd A\n  {arg_min_on snd A} \\<union>\n  {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n  {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<subseteq> A", "show ?thesis"], ["proof (prove)\nusing this:\n  set_tree l \\<subseteq> {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  set_tree r \\<subseteq> {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  a = arg_min_on snd A\n  {arg_min_on snd A} \\<union>\n  {p \\<in> A. fst p < fst (arg_min_on snd A)} \\<union>\n  {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set_tree (treap_of A) \\<subseteq> A", "by (auto simp add: t)"], ["proof (state)\nthis:\n  set_tree (treap_of A) \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_tree (treap_of A) \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treap_treap_of:\n  \"treap (treap_of A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (treap_of A)", "proof(induction \"A\" rule: treap_of.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n                   \\<Longrightarrow> treap (treap_of xa);\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n           \\<Longrightarrow> treap (treap_of xb)\\<rbrakk>\n       \\<Longrightarrow> treap (treap_of KP)", "case (1 A)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xa)\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xb)\n\ngoal (1 subgoal):\n 1. \\<And>KP.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n                    x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n                    xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n                   \\<Longrightarrow> treap (treap_of xa);\n        \\<And>x xa xb.\n           \\<lbrakk>\\<not> (infinite KP \\<or> KP = {});\n            x = arg_min_on snd KP; xa = {p \\<in> KP. fst p < fst x};\n            xb = {p \\<in> KP. fst x < fst p}\\<rbrakk>\n           \\<Longrightarrow> treap (treap_of xb)\\<rbrakk>\n       \\<Longrightarrow> treap (treap_of KP)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (treap_of A)", "proof (cases \"infinite A \\<or> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow> treap (treap_of A)\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "case True"], ["proof (state)\nthis:\n  infinite A \\<or> A = {}\n\ngoal (2 subgoals):\n 1. infinite A \\<or> A = {} \\<Longrightarrow> treap (treap_of A)\n 2. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xa)\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xb)\n  infinite A \\<or> A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xa)\n  \\<lbrakk>\\<not> (infinite A \\<or> A = {}); ?x = arg_min_on snd A;\n   ?xa = {p \\<in> A. fst p < fst ?x};\n   ?xb = {p \\<in> A. fst ?x < fst p}\\<rbrakk>\n  \\<Longrightarrow> treap (treap_of ?xb)\n  infinite A \\<or> A = {}\n\ngoal (1 subgoal):\n 1. treap (treap_of A)", "by (simp add: treap_of.simps treap_def)"], ["proof (state)\nthis:\n  treap (treap_of A)\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "case False"], ["proof (state)\nthis:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "let ?m = \"arg_min_on snd A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "let ?L = \"{p \\<in> A. fst p < fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "let ?R = \"{p \\<in> A. fst p > fst ?m}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "obtain l a r where t: \"treap_of A = Node l a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. (\\<And>l a r.\n        treap_of A = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"treap_of A\") (auto simp: Let_def elim!: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have l: \"l = treap_of ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}", "by (auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "then"], ["proof (chain)\npicking this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}", "have treap_l: \"treap l\""], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. treap l", "using False"], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. treap l", "by (auto intro: 1)"], ["proof (state)\nthis:\n  treap l\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "from l"], ["proof (chain)\npicking this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}", "have keys_l: \"keys l \\<subseteq> fst ` ?L\""], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. keys l \\<subseteq> fst ` {p \\<in> A. fst p < fst (arg_min_on snd A)}", "by (auto simp add: tree.set_map intro!: image_mono treap_of_subset)"], ["proof (state)\nthis:\n  keys l \\<subseteq> fst ` {p \\<in> A. fst p < fst (arg_min_on snd A)}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have r: \"r = treap_of ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "then"], ["proof (chain)\npicking this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have treap_r: \"treap r\""], ["proof (prove)\nusing this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. treap r", "using False"], ["proof (prove)\nusing this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  \\<not> (infinite A \\<or> A = {})\n\ngoal (1 subgoal):\n 1. treap r", "by (auto intro: 1)"], ["proof (state)\nthis:\n  treap r\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "from r"], ["proof (chain)\npicking this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}", "have keys_r: \"keys r \\<subseteq> fst ` ?R\""], ["proof (prove)\nusing this:\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> fst ` {p \\<in> A. fst (arg_min_on snd A) < fst p}", "by (auto simp add: tree.set_map intro!: image_mono treap_of_subset)"], ["proof (state)\nthis:\n  keys r \\<subseteq> fst ` {p \\<in> A. fst (arg_min_on snd A) < fst p}\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have prios: \"prios l \\<subseteq> snd ` A\" \"prios r \\<subseteq> snd ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prios l \\<subseteq> snd ` A &&& prios r \\<subseteq> snd ` A", "using l r treap_of_subset image_mono"], ["proof (prove)\nusing this:\n  l = treap_of {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  r = treap_of {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  set_tree (treap_of ?A) \\<subseteq> ?A\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?f ` ?B\n\ngoal (1 subgoal):\n 1. prios l \\<subseteq> snd ` A &&& prios r \\<subseteq> snd ` A", "by (auto simp add: tree.set_map)"], ["proof (state)\nthis:\n  prios l \\<subseteq> snd ` A\n  prios r \\<subseteq> snd ` A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have a: \"a = ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "using t"], ["proof (prove)\nusing this:\n  treap_of A = \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. a = arg_min_on snd A", "by(auto simp: Let_def elim: treap_of.elims split: if_splits)"], ["proof (state)\nthis:\n  a = arg_min_on snd A\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have prios_l: \"\\<And>x. x \\<in> prios l \\<Longrightarrow> snd a \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prios l \\<Longrightarrow> snd a \\<le> x", "by (drule rev_subsetD[OF _ prios(1)]) (use arg_min_least a False in fast)"], ["proof (state)\nthis:\n  ?x \\<in> prios l \\<Longrightarrow> snd a \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "have prios_r: \"\\<And>x. x \\<in> prios r \\<Longrightarrow> snd a \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> prios r \\<Longrightarrow> snd a \\<le> x", "by (drule rev_subsetD[OF _ prios(2)]) (use arg_min_least a False in fast)"], ["proof (state)\nthis:\n  ?x \\<in> prios r \\<Longrightarrow> snd a \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> (infinite A \\<or> A = {}) \\<Longrightarrow> treap (treap_of A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap (treap_of A)", "using prios_r prios_l treap_l treap_r keys_l keys_r a"], ["proof (prove)\nusing this:\n  ?x \\<in> prios r \\<Longrightarrow> snd a \\<le> ?x\n  ?x \\<in> prios l \\<Longrightarrow> snd a \\<le> ?x\n  treap l\n  treap r\n  keys l \\<subseteq> fst ` {p \\<in> A. fst p < fst (arg_min_on snd A)}\n  keys r \\<subseteq> fst ` {p \\<in> A. fst (arg_min_on snd A) < fst p}\n  a = arg_min_on snd A\n\ngoal (1 subgoal):\n 1. treap (treap_of A)", "by (auto simp add: t treap_def dest: rev_subsetD[OF _ keys_l] rev_subsetD[OF _ keys_r])"], ["proof (state)\nthis:\n  treap (treap_of A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treap (treap_of A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treap_Leaf: \"treap \\<langle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap \\<langle>\\<rangle>", "by (simp add: treap_def)"], ["", "lemma foldl_ins_treap: \"treap t \\<Longrightarrow> treap (foldl (\\<lambda>t' (x, p). ins x p t') t xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap t \\<Longrightarrow>\n    treap (foldl (\\<lambda>t' (x, p). ins x p t') t xs)", "using treap_ins"], ["proof (prove)\nusing this:\n  treap ?t \\<Longrightarrow> treap (ins ?k ?p ?t)\n\ngoal (1 subgoal):\n 1. treap t \\<Longrightarrow>\n    treap (foldl (\\<lambda>t' (x, p). ins x p t') t xs)", "by (induction xs arbitrary: t) auto"], ["", "lemma foldl_ins_set_tree: \n  assumes \"inj_on fst (set ys)\" \"inj_on snd (set ys)\" \"distinct ys\" \"fst ` (set ys) \\<inter> keys t = {}\"\n  shows \"set_tree (foldl (\\<lambda>t' (x, p). ins x p t') t ys) = set ys \\<union> set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (foldl (\\<lambda>t' (x, p). ins x p t') t ys) =\n    set ys \\<union> set_tree t", "using assms"], ["proof (prove)\nusing this:\n  inj_on fst (set ys)\n  inj_on snd (set ys)\n  distinct ys\n  fst ` set ys \\<inter> keys t = {}\n\ngoal (1 subgoal):\n 1. set_tree (foldl (\\<lambda>t' (x, p). ins x p t') t ys) =\n    set ys \\<union> set_tree t", "by (induction ys arbitrary: t) (auto simp add: case_prod_beta' set_tree_ins_eq keys_ins)"], ["", "lemma foldl_ins_treap_of:\n  assumes \"distinct ys\" \"inj_on fst (set ys)\" \"inj_on snd (set ys)\"\n shows \"(foldl (\\<lambda>t' (x, p). ins x p t') Leaf ys) = treap_of (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>t' (x, p). ins x p t') \\<langle>\\<rangle> ys =\n    treap_of (set ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct ys\n  inj_on fst (set ys)\n  inj_on snd (set ys)\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>t' (x, p). ins x p t') \\<langle>\\<rangle> ys =\n    treap_of (set ys)", "by (intro treap_unique) (auto simp: treap_Leaf foldl_ins_treap foldl_ins_set_tree \n                                                  treap_treap_of treap_of_set_tree_unique)"], ["", "end"]]}