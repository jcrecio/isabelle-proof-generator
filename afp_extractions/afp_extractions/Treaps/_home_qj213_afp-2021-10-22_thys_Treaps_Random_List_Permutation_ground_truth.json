{"file_name": "/home/qj213/afp-2021-10-22/thys/Treaps/Random_List_Permutation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Treaps", "problem_names": ["lemma linorders_on_empty [simp]: \"linorders_on {} = {{}}\"", "lemma linorders_finite_nonempty:\n  assumes \"finite A\"\n  shows   \"linorders_on A \\<noteq> {}\"", "lemma bij_betw_linorders_on:\n  assumes \"finite A\"\n  shows   \"bij_betw linorder_of_list (permutations_of_set A) (linorders_on A)\"", "lemma sorted_wrt_list_of_set_linorder_of_list [simp]:\n  assumes \"distinct xs\"\n  shows   \"sorted_wrt_list_of_set (linorder_of_list xs) (set xs) = xs\"", "lemma linorder_of_list_sorted_wrt_list_of_set [simp]:\n  assumes \"linorder_on A R\" \"finite A\"\n  shows   \"linorder_of_list (sorted_wrt_list_of_set R A) = R\"", "lemma bij_betw_linorders_on':\n  assumes \"finite A\"\n  shows   \"bij_betw (\\<lambda>R. sorted_wrt_list_of_set R A) (linorders_on A) (permutations_of_set A)\"", "lemma finite_linorders_on [intro]:\n  assumes \"finite A\"\n  shows   \"finite (linorders_on A)\"", "lemma index_distinct_eqI:\n  assumes \"distinct xs\" \"i < length xs\" \"xs ! i = x\"\n  shows   \"index xs x = i\"", "lemma index_permute_list:\n  assumes \"\\<pi> permutes {..<length xs}\" \"distinct xs\" \"x \\<in> set xs\"\n  shows   \"index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)\"", "lemma linorder_of_list_permute:\n  assumes \"\\<pi> permutes {..<length xs}\" \"distinct xs\"\n  shows   \"linorder_of_list (permute_list \\<pi> xs) =\n             map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) (linorder_of_list xs)\"", "lemma inj_on_conv_Ex1: \"inj_on f A \\<longleftrightarrow> (\\<forall>y\\<in>f`A. \\<exists>!x\\<in>A. y = f x)\"", "lemma bij_betw_conv_Ex1: \"bij_betw f A B \\<longleftrightarrow> (\\<forall>y\\<in>B. \\<exists>!x\\<in>A. f x = y) \\<and> B = f ` A\"", "lemma permutesI:\n  assumes \"bij_betw f A A\" \"\\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\"\n  shows   \"f permutes A\"", "lemma linorder_permutation_exists:\n  assumes \"finite A\" \"linorder_on A R\" \"linorder_on A R'\"\n  obtains \\<pi> where \"\\<pi> permutes A\" \"R' = map_relation A \\<pi> R\"", "lemma linorder_from_keys_permute:\n  assumes \"g permutes A\"\n  shows   \"linorder_from_keys A (f \\<circ> g) = map_relation A g (linorder_from_keys A f)\"", "lemma linorder_on_linorder_from_keys [intro]:\n  assumes \"inj_on f A\"\n  shows   \"linorder_on A (linorder_from_keys A f)\"", "lemma linorder_from_keys_empty [simp]: \"linorder_from_keys {} = (\\<lambda>_. {})\"", "lemma emeasure_PiM_diagonal:\n  fixes a b :: real\n  assumes \"x \\<in> A\" \"y \\<in> A\" \"x \\<noteq> y\"\n  assumes \"a < b\" \"finite A\"\n  defines \"M \\<equiv> uniform_measure lborel {a..b}\"\n  shows   \"emeasure (PiM A (\\<lambda>_. M)) {h\\<in>A \\<rightarrow>\\<^sub>E UNIV. h x = h y} = 0\"", "lemma measurable_linorder_from_keys_restrict:\n  assumes fin: \"finite A\"\n  shows \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (A \\<times> A))\"\n  (is \"_ : ?M \\<rightarrow>\\<^sub>M _\")", "lemma measurable_count_space_extend:\n  assumes \"f \\<in> measurable M (count_space A)\" \"A \\<subseteq> B\"\n  shows   \"f \\<in> measurable M (count_space B)\"", "lemma measurable_linorder_from_keys_restrict':\n  assumes fin: \"finite A\" \"A \\<subseteq> B\"\n  shows \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (B \\<times> B))\"", "lemma measurable_linorder_from_keys [measurable]: \n  \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (B \\<times> B))\"", "theorem almost_everywhere_linorder: \"AE R in M. linorder_on A R\"", "theorem random_linorder_by_prios:\n  \"M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)\""], "translations": [["", "lemma linorders_on_empty [simp]: \"linorders_on {} = {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorders_on {} = {{}}", "by (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["", "lemma linorders_finite_nonempty:\n  assumes \"finite A\"\n  shows   \"linorders_on A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorders_on A \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorders_on A \\<noteq> {}", "from finite_distinct_list[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = A \\<and> distinct xs", "obtain xs where \"set xs = A\" \"distinct xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = A; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n\ngoal (1 subgoal):\n 1. linorders_on A \\<noteq> {}", "hence \"linorder_on A (linorder_of_list xs)\""], ["proof (prove)\nusing this:\n  set xs = A\n  distinct xs\n\ngoal (1 subgoal):\n 1. linorder_on A (linorder_of_list xs)", "by auto"], ["proof (state)\nthis:\n  linorder_on A (linorder_of_list xs)\n\ngoal (1 subgoal):\n 1. linorders_on A \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  linorder_on A (linorder_of_list xs)\n\ngoal (1 subgoal):\n 1. linorders_on A \\<noteq> {}", "by (auto simp: linorders_on_def)"], ["proof (state)\nthis:\n  linorders_on A \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  There is an obvious bijection between permutations of a set (i.\\,e.\\ lists with all elements\n  from that set without repetition) and linear orderings on it.\n\\<close>"], ["", "lemma bij_betw_linorders_on:\n  assumes \"finite A\"\n  shows   \"bij_betw linorder_of_list (permutations_of_set A) (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw linorder_of_list (permutations_of_set A) (linorders_on A)", "using bij_betw_linorder_of_list[of A] assms"], ["proof (prove)\nusing this:\n  finite A \\<Longrightarrow>\n  bij_betw linorder_of_list (permutations_of_set A) {R. linorder_on A R}\n  finite A\n\ngoal (1 subgoal):\n 1. bij_betw linorder_of_list (permutations_of_set A) (linorders_on A)", "unfolding linorders_on_def"], ["proof (prove)\nusing this:\n  finite A \\<Longrightarrow>\n  bij_betw linorder_of_list (permutations_of_set A) {R. linorder_on A R}\n  finite A\n\ngoal (1 subgoal):\n 1. bij_betw linorder_of_list (permutations_of_set A)\n     (Collect (linorder_on A))", "by simp"], ["", "lemma sorted_wrt_list_of_set_linorder_of_list [simp]:\n  assumes \"distinct xs\"\n  shows   \"sorted_wrt_list_of_set (linorder_of_list xs) (set xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt_list_of_set (linorder_of_list xs) (set xs) = xs", "by (rule sorted_wrt_list_of_set_eqI[of \"set xs\"]) (insert assms, auto)"], ["", "lemma linorder_of_list_sorted_wrt_list_of_set [simp]:\n  assumes \"linorder_on A R\" \"finite A\"\n  shows   \"linorder_of_list (sorted_wrt_list_of_set R A) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "from assms(1)"], ["proof (chain)\npicking this:\n  linorder_on A R", "have subset: \"R \\<subseteq> A \\<times> A\""], ["proof (prove)\nusing this:\n  linorder_on A R\n\ngoal (1 subgoal):\n 1. R \\<subseteq> A \\<times> A", "by (auto simp: linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  R \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "from assms and subset"], ["proof (chain)\npicking this:\n  linorder_on A R\n  finite A\n  R \\<subseteq> A \\<times> A", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_on A R\n  finite A\n  R \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. linorder_of_list (sorted_wrt_list_of_set R A) = R", "by (auto simp: linorder_of_list_def linorder_sorted_wrt_list_of_set sorted_wrt_linorder_index_le_iff)"], ["proof (state)\nthis:\n  linorder_of_list (sorted_wrt_list_of_set R A) = R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_linorders_on':\n  assumes \"finite A\"\n  shows   \"bij_betw (\\<lambda>R. sorted_wrt_list_of_set R A) (linorders_on A) (permutations_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>R. sorted_wrt_list_of_set R A) (linorders_on A)\n     (permutations_of_set A)", "by (rule bij_betw_byWitness[where f' = linorder_of_list])\n     (insert assms, auto simp: linorders_on_def permutations_of_set_def\n        linorder_sorted_wrt_list_of_set)"], ["", "lemma finite_linorders_on [intro]:\n  assumes \"finite A\"\n  shows   \"finite (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "have \"finite (permutations_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (permutations_of_set A)", "by simp"], ["proof (state)\nthis:\n  finite (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "also"], ["proof (state)\nthis:\n  finite (permutations_of_set A)\n\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "have \"?this \\<longleftrightarrow> finite (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (permutations_of_set A) = finite (linorders_on A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (permutations_of_set A) = finite (linorders_on A)", "by (rule bij_betw_finite [OF bij_betw_linorders_on])"], ["proof (state)\nthis:\n  finite (permutations_of_set A) = finite (linorders_on A)\n\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "finally"], ["proof (chain)\npicking this:\n  finite (linorders_on A)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (linorders_on A)\n\ngoal (1 subgoal):\n 1. finite (linorders_on A)", "."], ["proof (state)\nthis:\n  finite (linorders_on A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we look at the ordering defined by a list that is permuted with some permutation\n  function. For this, we first define the composition of a relation with a function.\n\\<close>"], ["", "definition map_relation :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<times> 'b) set \\<Rightarrow> ('a \\<times> 'a) set\" where\n  \"map_relation A f R = {(x,y)\\<in>A\\<times>A. (f x, f y) \\<in> R}\""], ["", "lemma index_distinct_eqI:\n  assumes \"distinct xs\" \"i < length xs\" \"xs ! i = x\"\n  shows   \"index xs x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x = i", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n  xs ! i = x\n\ngoal (1 subgoal):\n 1. index xs x = i", "by (induction xs arbitrary: i) (auto simp: nth_Cons split: nat.splits)"], ["", "lemma index_permute_list:\n  assumes \"\\<pi> permutes {..<length xs}\" \"distinct xs\" \"x \\<in> set xs\"\n  shows   \"index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)", "have *: \"inv \\<pi> permutes {..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<pi> permutes {..<length xs}", "by (rule permutes_inv) fact"], ["proof (state)\nthis:\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)", "from assms"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  x \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)", "using assms permutes_in_image[OF *]"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  x \\<in> set xs\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  x \\<in> set xs\n  (inv \\<pi> ?x \\<in> {..<length xs}) = (?x \\<in> {..<length xs})\n\ngoal (1 subgoal):\n 1. index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)", "by (intro index_distinct_eqI) (simp_all add: permute_list_nth permutes_inverses)"], ["proof (state)\nthis:\n  index (permute_list \\<pi> xs) x = inv \\<pi> (index xs x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linorder_of_list_permute:\n  assumes \"\\<pi> permutes {..<length xs}\" \"distinct xs\"\n  shows   \"linorder_of_list (permute_list \\<pi> xs) =\n             map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) (linorder_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "note * = permutes_inv[OF assms(1)]"], ["proof (state)\nthis:\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "have less: \"inv \\<pi> i < length xs\" if \"i < length xs\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<pi> i < length xs", "using permutes_in_image[OF *] and that"], ["proof (prove)\nusing this:\n  (inv \\<pi> ?x \\<in> {..<length xs}) = (?x \\<in> {..<length xs})\n  i < length xs\n\ngoal (1 subgoal):\n 1. inv \\<pi> i < length xs", "by simp"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> inv \\<pi> ?i < length xs\n\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "from assms and *"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  inv \\<pi> permutes {..<length xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  distinct xs\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "by (auto simp: linorder_of_list_def map_relation_def index_nth_id index_permute_list less)"], ["proof (state)\nthis:\n  linorder_of_list (permute_list \\<pi> xs) =\n  map_relation (set xs) ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n   (linorder_of_list xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_conv_Ex1: \"inj_on f A \\<longleftrightarrow> (\\<forall>y\\<in>f`A. \\<exists>!x\\<in>A. y = f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A =\n    (\\<forall>y\\<in>f ` A. \\<exists>!x. x \\<in> A \\<and> y = f x)", "by (auto simp: inj_on_def)"], ["", "lemma bij_betw_conv_Ex1: \"bij_betw f A B \\<longleftrightarrow> (\\<forall>y\\<in>B. \\<exists>!x\\<in>A. f x = y) \\<and> B = f ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f A B =\n    ((\\<forall>y\\<in>B. \\<exists>!x. x \\<in> A \\<and> f x = y) \\<and>\n     B = f ` A)", "unfolding bij_betw_def inj_on_conv_Ex1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>y\\<in>f ` A. \\<exists>!x. x \\<in> A \\<and> y = f x) \\<and>\n     f ` A = B) =\n    ((\\<forall>y\\<in>B. \\<exists>!x. x \\<in> A \\<and> f x = y) \\<and>\n     B = f ` A)", "by (auto simp: eq_commute)"], ["", "lemma permutesI:\n  assumes \"bij_betw f A A\" \"\\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\"\n  shows   \"f permutes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f permutes A", "unfolding permutes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<notin> A \\<longrightarrow> f x = x) \\<and>\n    (\\<forall>y. \\<exists>!x. f x = y)", "proof (intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<notin> A \\<Longrightarrow> f x = x\n 2. \\<And>y. \\<exists>!x. f x = y", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<notin> A \\<Longrightarrow> f x = x\n 2. \\<And>y. \\<exists>!x. f x = y", "from assms"], ["proof (chain)\npicking this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x", "have [simp]: \"f x \\<in> A \\<longleftrightarrow> x \\<in> A\" for x"], ["proof (prove)\nusing this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\n\ngoal (1 subgoal):\n 1. (f x \\<in> A) = (x \\<in> A)", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  (f ?x \\<in> A) = (?x \\<in> A)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<notin> A \\<Longrightarrow> f x = x\n 2. \\<And>y. \\<exists>!x. f x = y", "show \"\\<exists>!x. f x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. f x = y", "proof (cases \"y \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> A \\<Longrightarrow> \\<exists>!x. f x = y\n 2. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "case True"], ["proof (state)\nthis:\n  y \\<in> A\n\ngoal (2 subgoals):\n 1. y \\<in> A \\<Longrightarrow> \\<exists>!x. f x = y\n 2. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "also"], ["proof (state)\nthis:\n  y \\<in> A\n\ngoal (2 subgoals):\n 1. y \\<in> A \\<Longrightarrow> \\<exists>!x. f x = y\n 2. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "from assms"], ["proof (chain)\npicking this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x", "have \"A = f ` A\""], ["proof (prove)\nusing this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\n\ngoal (1 subgoal):\n 1. A = f ` A", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  A = f ` A\n\ngoal (2 subgoals):\n 1. y \\<in> A \\<Longrightarrow> \\<exists>!x. f x = y\n 2. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "finally"], ["proof (chain)\npicking this:\n  y \\<in> f ` A", "obtain x where \"x \\<in> A\" \"y = f x\""], ["proof (prove)\nusing this:\n  y \\<in> f ` A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A; y = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n  y = f x\n\ngoal (2 subgoals):\n 1. y \\<in> A \\<Longrightarrow> \\<exists>!x. f x = y\n 2. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "with assms and \\<open>y \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\n  y \\<in> A\n  x \\<in> A\n  y = f x", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw f A A\n  \\<forall>x. x \\<notin> A \\<longrightarrow> f x = x\n  y \\<in> A\n  x \\<in> A\n  y = f x\n\ngoal (1 subgoal):\n 1. \\<exists>!x. f x = y", "by (intro ex1I[of _ x]) (auto simp: bij_betw_def dest: inj_onD)"], ["proof (state)\nthis:\n  \\<exists>!x. f x = y\n\ngoal (1 subgoal):\n 1. y \\<notin> A \\<Longrightarrow> \\<exists>!x. f x = y", "qed (insert assms, auto)"], ["proof (state)\nthis:\n  \\<exists>!x. f x = y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> A \\<Longrightarrow> f x = x", "qed (insert assms, auto)"], ["", "text \\<open>\n  We now show the important lemma that any two linear orderings on a finite set can be\n  mapped onto each other by a permutation.\n\\<close>"], ["", "lemma linorder_permutation_exists:\n  assumes \"finite A\" \"linorder_on A R\" \"linorder_on A R'\"\n  obtains \\<pi> where \"\\<pi> permutes A\" \"R' = map_relation A \\<pi> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define xs where \"xs = sorted_wrt_list_of_set R A\""], ["proof (state)\nthis:\n  xs = sorted_wrt_list_of_set R A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ys where \"ys = sorted_wrt_list_of_set R' A\""], ["proof (state)\nthis:\n  ys = sorted_wrt_list_of_set R' A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have xs_ys: \"distinct xs\" \"distinct ys\" \"set xs = A\" \"set ys = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct xs &&& distinct ys) &&& set xs = A &&& set ys = A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  linorder_on A R\n  linorder_on A R'\n\ngoal (1 subgoal):\n 1. (distinct xs &&& distinct ys) &&& set xs = A &&& set ys = A", "by (simp_all add: linorder_sorted_wrt_list_of_set xs_def ys_def)"], ["proof (state)\nthis:\n  distinct xs\n  distinct ys\n  set xs = A\n  set ys = A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from xs_ys"], ["proof (chain)\npicking this:\n  distinct xs\n  distinct ys\n  set xs = A\n  set ys = A", "have \"mset ys = mset xs\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n  set xs = A\n  set ys = A\n\ngoal (1 subgoal):\n 1. mset ys = mset xs", "by (simp add: set_eq_iff_mset_eq_distinct [symmetric])"], ["proof (state)\nthis:\n  mset ys = mset xs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from mset_eq_permutation[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length xs}; permute_list p xs = ys\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess \\<pi>"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length xs}; permute_list p xs = ys\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  \\<pi> permutes {..<length xs}\n  permute_list \\<pi> xs = ys\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note \\<pi> = this"], ["proof (state)\nthis:\n  \\<pi> permutes {..<length xs}\n  permute_list \\<pi> xs = ys\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define \\<pi>' where \"\\<pi>' = (\\<lambda>x. if x \\<notin> A then x else xs ! inv \\<pi> (index xs x))\""], ["proof (state)\nthis:\n  \\<pi>' =\n  (\\<lambda>x. if x \\<notin> A then x else xs ! inv \\<pi> (index xs x))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<pi>': \"\\<pi>' permutes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' permutes A", "proof (rule permutesI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw \\<pi>' A A\n 2. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "have \"bij_betw ((!) xs \\<circ> inv \\<pi>) {..<length xs} A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((!) xs \\<circ> inv \\<pi>) {..<length xs} A", "by (rule bij_betw_trans permutes_imp_bij permutes_inv \\<pi> bij_betw_nth)+ (simp_all add: xs_ys)"], ["proof (state)\nthis:\n  bij_betw ((!) xs \\<circ> inv \\<pi>) {..<length xs} A\n\ngoal (2 subgoals):\n 1. bij_betw \\<pi>' A A\n 2. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "hence \"bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A\""], ["proof (prove)\nusing this:\n  bij_betw ((!) xs \\<circ> inv \\<pi>) {..<length xs} A\n\ngoal (1 subgoal):\n 1. bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A", "by (rule bij_betw_trans [rotated] bij_betw_index)+\n         (insert bij_betw_index[of xs A \"length xs\"], simp_all add: xs_ys atLeast0LessThan)"], ["proof (state)\nthis:\n  bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A\n\ngoal (2 subgoals):\n 1. bij_betw \\<pi>' A A\n 2. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "also"], ["proof (state)\nthis:\n  bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A\n\ngoal (2 subgoals):\n 1. bij_betw \\<pi>' A A\n 2. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "have \"bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A \\<longleftrightarrow> bij_betw \\<pi>' A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A =\n    bij_betw \\<pi>' A A", "by (rule bij_betw_cong) (auto simp: \\<pi>'_def)"], ["proof (state)\nthis:\n  bij_betw ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) A A =\n  bij_betw \\<pi>' A A\n\ngoal (2 subgoals):\n 1. bij_betw \\<pi>' A A\n 2. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "finally"], ["proof (chain)\npicking this:\n  bij_betw \\<pi>' A A", "show \\<dots>"], ["proof (prove)\nusing this:\n  bij_betw \\<pi>' A A\n\ngoal (1 subgoal):\n 1. bij_betw \\<pi>' A A", "."], ["proof (state)\nthis:\n  bij_betw \\<pi>' A A\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<notin> A \\<longrightarrow> \\<pi>' x = x", "qed (simp_all add: \\<pi>'_def)"], ["proof (state)\nthis:\n  \\<pi>' permutes A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  linorder_on A R\n  linorder_on A R'", "have \"R' = linorder_of_list ys\""], ["proof (prove)\nusing this:\n  finite A\n  linorder_on A R\n  linorder_on A R'\n\ngoal (1 subgoal):\n 1. R' = linorder_of_list ys", "by (simp add: ys_def)"], ["proof (state)\nthis:\n  R' = linorder_of_list ys\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  R' = linorder_of_list ys\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<pi>"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length xs}\n  permute_list \\<pi> xs = ys", "have \"ys = permute_list \\<pi> xs\""], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  permute_list \\<pi> xs = ys\n\ngoal (1 subgoal):\n 1. ys = permute_list \\<pi> xs", "by simp"], ["proof (state)\nthis:\n  ys = permute_list \\<pi> xs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  ys = permute_list \\<pi> xs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"linorder_of_list (permute_list \\<pi> xs) = \n               map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) (linorder_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  permute_list \\<pi> xs = ys\n\ngoal (1 subgoal):\n 1. linorder_of_list (permute_list \\<pi> xs) =\n    map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n     (linorder_of_list xs)", "by (subst linorder_of_list_permute) (simp_all add: xs_ys)"], ["proof (state)\nthis:\n  linorder_of_list (permute_list \\<pi> xs) =\n  map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n   (linorder_of_list xs)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  linorder_of_list (permute_list \\<pi> xs) =\n  map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs)\n   (linorder_of_list xs)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  linorder_on A R\n  linorder_on A R'", "have \"linorder_of_list xs = R\""], ["proof (prove)\nusing this:\n  finite A\n  linorder_on A R\n  linorder_on A R'\n\ngoal (1 subgoal):\n 1. linorder_of_list xs = R", "by (simp add: xs_def)"], ["proof (state)\nthis:\n  linorder_of_list xs = R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R", "have \"R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R\""], ["proof (prove)\nusing this:\n  R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R\n\ngoal (1 subgoal):\n 1. R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R", "."], ["proof (state)\nthis:\n  R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  R' = map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = map_relation A \\<pi>' R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R =\n    map_relation A \\<pi>' R", "by (auto simp: map_relation_def \\<pi>'_def)"], ["proof (state)\nthis:\n  map_relation A ((!) xs \\<circ> inv \\<pi> \\<circ> index xs) R =\n  map_relation A \\<pi>' R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  R' = map_relation A \\<pi>' R", "show ?thesis"], ["proof (prove)\nusing this:\n  R' = map_relation A \\<pi>' R\n\ngoal (1 subgoal):\n 1. thesis", "using \\<pi>' and that[of \\<pi>']"], ["proof (prove)\nusing this:\n  R' = map_relation A \\<pi>' R\n  \\<pi>' permutes A\n  \\<lbrakk>\\<pi>' permutes A; R' = map_relation A \\<pi>' R\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now define the linear ordering defined by some priority function, i.\\,e.\\ a function\n  that injectively associates priorities to every element such that elements with lower priority\n  are smaller in the resulting ordering.\n\\<close>"], ["", "definition linorder_from_keys :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b :: linorder) \\<Rightarrow> ('a \\<times> 'a) set\" where\n  \"linorder_from_keys A f = {(x,y)\\<in>A\\<times>A. f x \\<le> f y}\""], ["", "lemma linorder_from_keys_permute:\n  assumes \"g permutes A\"\n  shows   \"linorder_from_keys A (f \\<circ> g) = map_relation A g (linorder_from_keys A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_from_keys A (f \\<circ> g) =\n    map_relation A g (linorder_from_keys A f)", "using permutes_in_image[OF assms]"], ["proof (prove)\nusing this:\n  (g ?x \\<in> A) = (?x \\<in> A)\n\ngoal (1 subgoal):\n 1. linorder_from_keys A (f \\<circ> g) =\n    map_relation A g (linorder_from_keys A f)", "by (auto simp: map_relation_def linorder_from_keys_def)"], ["", "lemma linorder_on_linorder_from_keys [intro]:\n  assumes \"inj_on f A\"\n  shows   \"linorder_on A (linorder_from_keys A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_on A (linorder_from_keys A f)", "using assms"], ["proof (prove)\nusing this:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. linorder_on A (linorder_from_keys A f)", "by (auto simp: linorder_on_def refl_on_def antisym_def linorder_from_keys_def\n                    trans_def total_on_def dest: inj_onD)"], ["", "lemma linorder_from_keys_empty [simp]: \"linorder_from_keys {} = (\\<lambda>_. {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_from_keys {} = (\\<lambda>_. {})", "by (simp add: linorder_from_keys_def fun_eq_iff)"], ["", "text \\<open>\n  We now show another important fact, namely that when we draw $n$ values i.\\,i.\\,d.\\ uniformly\n  from a non-trivial real interval, we almost surely get distinct values.\n\\<close>"], ["", "lemma emeasure_PiM_diagonal:\n  fixes a b :: real\n  assumes \"x \\<in> A\" \"y \\<in> A\" \"x \\<noteq> y\"\n  assumes \"a < b\" \"finite A\"\n  defines \"M \\<equiv> uniform_measure lborel {a..b}\"\n  shows   \"emeasure (PiM A (\\<lambda>_. M)) {h\\<in>A \\<rightarrow>\\<^sub>E UNIV. h x = h y} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  M \\<equiv> uniform_measure lborel {a..b}", "have M: \"prob_space M\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  M \\<equiv> uniform_measure lborel {a..b}\n\ngoal (1 subgoal):\n 1. prob_space M", "unfolding M_def"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  uniform_measure lborel {a..b} \\<equiv> uniform_measure lborel {a..b}\n\ngoal (1 subgoal):\n 1. prob_space (uniform_measure lborel {a..b})", "by (intro prob_space_uniform_measure) auto"], ["proof (state)\nthis:\n  prob_space M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "then"], ["proof (chain)\npicking this:\n  prob_space M", "interpret product_prob_space \"\\<lambda>_. M\" A"], ["proof (prove)\nusing this:\n  prob_space M\n\ngoal (1 subgoal):\n 1. product_prob_space (\\<lambda>_. M)", "unfolding product_prob_space_def product_prob_space_axioms_def product_sigma_finite_def"], ["proof (prove)\nusing this:\n  prob_space M\n\ngoal (1 subgoal):\n 1. (\\<forall>i. sigma_finite_measure M) \\<and> (\\<forall>i. prob_space M)", "by (auto simp: prob_space_imp_sigma_finite)"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "from M"], ["proof (chain)\npicking this:\n  prob_space M", "interpret pair_sigma_finite M M"], ["proof (prove)\nusing this:\n  prob_space M\n\ngoal (1 subgoal):\n 1. pair_sigma_finite M M", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have [measurable]: \"{h\\<in>extensional {x, y}. h x = h y} \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "have \"{h\\<in>extensional {x,y}. h x = h y} = {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y} =\n    {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}", "by (auto simp: extensional_def space_PiM)"], ["proof (state)\nthis:\n  {h \\<in> extensional {x, y}. h x = h y} =\n  {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}\n\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "also"], ["proof (state)\nthis:\n  {h \\<in> extensional {x, y}. h x = h y} =\n  {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}\n\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "have \"... \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "by measurable"], ["proof (state)\nthis:\n  {h \\<in> space (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel)). h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\n\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "finally"], ["proof (chain)\npicking this:\n  {h \\<in> extensional {x, y}. h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "show ?thesis"], ["proof (prove)\nusing this:\n  {h \\<in> extensional {x, y}. h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\n\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))", "."], ["proof (state)\nthis:\n  {h \\<in> extensional {x, y}. h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {h \\<in> extensional {x, y}. h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>i. lborel))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have [simp]: \"sets (PiM A (\\<lambda>_. M)) = sets (PiM A (\\<lambda>_. lborel))\" for A :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (Pi\\<^sub>M A (\\<lambda>_. M)) =\n    sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "by (intro sets_PiM_cong refl) (simp_all add: M_def)"], ["proof (state)\nthis:\n  sets (Pi\\<^sub>M ?A2 (\\<lambda>_. M)) =\n  sets (Pi\\<^sub>M ?A2 (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have sets_M_M: \"sets (M \\<Otimes>\\<^sub>M M) = sets (borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (M \\<Otimes>\\<^sub>M M) = sets (borel \\<Otimes>\\<^sub>M borel)", "by (intro sets_pair_measure_cong) (auto simp: M_def)"], ["proof (state)\nthis:\n  sets (M \\<Otimes>\\<^sub>M M) = sets (borel \\<Otimes>\\<^sub>M borel)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have [measurable]: \"(\\<lambda>(b, a). if b = a then 1 else 0) \\<in> borel_measurable (M \\<Otimes>\\<^sub>M M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(b, a). if b = a then 1::'b else (0::'b))\n    \\<in> borel_measurable (M \\<Otimes>\\<^sub>M M)", "unfolding measurable_split_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if fst x = snd x then 1::'b else (0::'b))\n    \\<in> borel_measurable (M \\<Otimes>\\<^sub>M M)", "by (subst measurable_cong_sets[OF sets_M_M refl])\n       (auto intro!: measurable_If measurable_const measurable_equality_set)"], ["proof (state)\nthis:\n  (\\<lambda>(b, a). if b = a then 1::?'b3 else (0::?'b3))\n  \\<in> borel_measurable (M \\<Otimes>\\<^sub>M M)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"{h\\<in>A \\<rightarrow>\\<^sub>E UNIV. h x = h y} = \n          (\\<lambda>h. restrict h {x, y}) -` {h\\<in>extensional {x, y}. h x = h y} \\<inter> space (PiM A (\\<lambda>_. M :: real measure))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    (\\<lambda>h. restrict h {x, y}) -`\n    {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n    space (Pi\\<^sub>M A (\\<lambda>_. M))", "by (auto simp: space_PiM PiE_def extensional_def M_def)"], ["proof (state)\nthis:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n  (\\<lambda>h. restrict h {x, y}) -`\n  {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n  (\\<lambda>h. restrict h {x, y}) -`\n  {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. M))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"emeasure (PiM A (\\<lambda>_. M)) \\<dots> = \n               emeasure (distr (PiM A (\\<lambda>_. M)) (PiM {x,y} (\\<lambda>_. lborel :: real measure)) \n                 (\\<lambda>h. restrict h {x,y})) {h\\<in>extensional {x, y}. h x = h y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     ((\\<lambda>h. restrict h {x, y}) -`\n      {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n      space (Pi\\<^sub>M A (\\<lambda>_. M))) =\n    emeasure\n     (distr (Pi\\<^sub>M A (\\<lambda>_. M))\n       (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n       (\\<lambda>h. restrict h {x, y}))\n     {h \\<in> extensional {x, y}. h x = h y}", "proof (rule emeasure_distr [symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y})\n 2. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "have \"(\\<lambda>h. restrict h {x, y}) \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h. restrict h {x, y})\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  M \\<equiv> uniform_measure lborel {a..b}\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. restrict h {x, y})\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)", "by (intro measurable_restrict_subset) auto"], ["proof (state)\nthis:\n  (\\<lambda>h. restrict h {x, y})\n  \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n        Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)\n\ngoal (2 subgoals):\n 1. P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y})\n 2. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "also"], ["proof (state)\nthis:\n  (\\<lambda>h. restrict h {x, y})\n  \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n        Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)\n\ngoal (2 subgoals):\n 1. P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y})\n 2. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "have \"\\<dots> = Pi\\<^sub>M A (\\<lambda>_. M) \\<rightarrow>\\<^sub>M Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n    Pi\\<^sub>M {x, y} (\\<lambda>_. lborel) =\n    Pi\\<^sub>M A (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n    Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)", "by (intro sets_PiM_cong measurable_cong_sets refl) (simp_all add: M_def)"], ["proof (state)\nthis:\n  Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n  Pi\\<^sub>M {x, y} (\\<lambda>_. lborel) =\n  Pi\\<^sub>M A (\\<lambda>_. M) \\<rightarrow>\\<^sub>M\n  Pi\\<^sub>M {x, y} (\\<lambda>_. lborel)\n\ngoal (2 subgoals):\n 1. P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y})\n 2. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "finally"], ["proof (chain)\npicking this:\n  P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n   (\\<lambda>h. restrict h {x, y})", "show \"(\\<lambda>h. restrict h {x, y}) \\<in> \\<dots>\""], ["proof (prove)\nusing this:\n  P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n   (\\<lambda>h. restrict h {x, y})\n\ngoal (1 subgoal):\n 1. P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y})", "."], ["proof (state)\nthis:\n  P.random_variable (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n   (\\<lambda>h. restrict h {x, y})\n\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "show \"{h\\<in>extensional {x, y}. h x = h y} \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> extensional {x, y}. h x = h y}\n    \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))", "by simp"], ["proof (state)\nthis:\n  {h \\<in> extensional {x, y}. h x = h y}\n  \\<in> sets (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n   ((\\<lambda>h. restrict h {x, y}) -`\n    {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n    space (Pi\\<^sub>M A (\\<lambda>_. M))) =\n  emeasure\n   (distr (Pi\\<^sub>M A (\\<lambda>_. M))\n     (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y}))\n   {h \\<in> extensional {x, y}. h x = h y}\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n   ((\\<lambda>h. restrict h {x, y}) -`\n    {h \\<in> extensional {x, y}. h x = h y} \\<inter>\n    space (Pi\\<^sub>M A (\\<lambda>_. M))) =\n  emeasure\n   (distr (Pi\\<^sub>M A (\\<lambda>_. M))\n     (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y}))\n   {h \\<in> extensional {x, y}. h x = h y}\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"distr (PiM A (\\<lambda>_. M)) (PiM {x,y} (\\<lambda>_. lborel :: real measure)) (\\<lambda>h. restrict h {x,y}) =\n               distr (PiM A (\\<lambda>_. M)) (PiM {x,y} (\\<lambda>_. M)) (\\<lambda>h. restrict h {x,y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (Pi\\<^sub>M A (\\<lambda>_. M))\n     (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n     (\\<lambda>h. restrict h {x, y}) =\n    distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n     (\\<lambda>h. restrict h {x, y})", "by (intro distr_cong refl sets_PiM_cong) (simp_all add: M_def)"], ["proof (state)\nthis:\n  distr (Pi\\<^sub>M A (\\<lambda>_. M))\n   (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n   (\\<lambda>h. restrict h {x, y}) =\n  distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n   (\\<lambda>h. restrict h {x, y})\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  distr (Pi\\<^sub>M A (\\<lambda>_. M))\n   (Pi\\<^sub>M {x, y} (\\<lambda>_. lborel))\n   (\\<lambda>h. restrict h {x, y}) =\n  distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n   (\\<lambda>h. restrict h {x, y})\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  M \\<equiv> uniform_measure lborel {a..b}", "have \"\\<dots> = Pi\\<^sub>M {x, y} (\\<lambda>i. M)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n  a < b\n  finite A\n  M \\<equiv> uniform_measure lborel {a..b}\n\ngoal (1 subgoal):\n 1. distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n     (\\<lambda>h. restrict h {x, y}) =\n    Pi\\<^sub>M {x, y} (\\<lambda>i. M)", "by (intro distr_restrict [symmetric]) auto"], ["proof (state)\nthis:\n  distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n   (\\<lambda>h. restrict h {x, y}) =\n  Pi\\<^sub>M {x, y} (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  distr (Pi\\<^sub>M A (\\<lambda>_. M)) (Pi\\<^sub>M {x, y} (\\<lambda>_. M))\n   (\\<lambda>h. restrict h {x, y}) =\n  Pi\\<^sub>M {x, y} (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"emeasure \\<dots> {h\\<in>extensional {x, y}. h x = h y} =\n    nn_integral \\<dots> (\\<lambda>h. indicator {h\\<in>extensional {x, y}. h x = h y} h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n     {h \\<in> extensional {x, y}. h x = h y} =\n    integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n     (indicator {h \\<in> extensional {x, y}. h x = h y})", "by (intro nn_integral_indicator [symmetric]) simp_all"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   {h \\<in> extensional {x, y}. h x = h y} =\n  integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   (indicator {h \\<in> extensional {x, y}. h x = h y})\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   {h \\<in> extensional {x, y}. h x = h y} =\n  integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   (indicator {h \\<in> extensional {x, y}. h x = h y})\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = nn_integral (Pi\\<^sub>M {x, y} (\\<lambda>i. M)) (\\<lambda>h. if h x = h y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n     (indicator {h \\<in> extensional {x, y}. h x = h y}) =\n    \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                       \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M)", "by (intro nn_integral_cong) (auto simp add: indicator_def space_PiM PiE_def)"], ["proof (state)\nthis:\n  integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   (indicator {h \\<in> extensional {x, y}. h x = h y}) =\n  \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                     \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (Pi\\<^sub>M {x, y} (\\<lambda>i. M))\n   (indicator {h \\<in> extensional {x, y}. h x = h y}) =\n  \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                     \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M)\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "from \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"\\<dots> = (\\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0) \\<partial>(M \\<Otimes>\\<^sub>M M))\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                       \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M) =\n    \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                       \\<partial>M \\<Otimes>\\<^sub>M M", "by (intro product_nn_integral_pair) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                     \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M) =\n  \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                     \\<partial>M \\<Otimes>\\<^sub>M M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ h. (if h x = h y then 1 else 0)\n                     \\<partial>Pi\\<^sub>M {x, y} (\\<lambda>i. M) =\n  \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                     \\<partial>M \\<Otimes>\\<^sub>M M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. (\\<integral>\\<^sup>+y. (if x = y then 1 else 0) \\<partial>M) \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                       \\<partial>M \\<Otimes>\\<^sub>M M =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n        \\<partial>M\n                       \\<partial>M", "by (subst M.nn_integral_fst [symmetric]) simp_all"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                     \\<partial>M \\<Otimes>\\<^sub>M M =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n      \\<partial>M\n                     \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ z. (if fst z = snd z then 1 else 0)\n                     \\<partial>M \\<Otimes>\\<^sub>M M =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n      \\<partial>M\n                     \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. (\\<integral>\\<^sup>+y. indicator {x} y \\<partial>M) \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n        \\<partial>M\n                       \\<partial>M =\n    \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M", "by (simp add: indicator_def eq_commute)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n      \\<partial>M\n                     \\<partial>M =\n  \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ y. (if x = y then 1 else 0)\n      \\<partial>M\n                     \\<partial>M =\n  \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M =\n    \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M", "by (subst nn_integral_indicator) (simp_all add: M_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M =\n  \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. integral\\<^sup>N M (indicator {x}) \\<partial>M =\n  \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. 0 \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M =\n    \\<integral>\\<^sup>+ x. 0 \\<partial>M", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (uniform_measure lborel {a..b}) {x}\n                       \\<partial>uniform_measure lborel {a..b} =\n    \\<integral>\\<^sup>+ x. 0 \\<partial>uniform_measure lborel {a..b}", "by (intro nn_integral_cong_AE refl AE_uniform_measureI) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M =\n  \\<integral>\\<^sup>+ x. 0 \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure M {x} \\<partial>M =\n  \\<integral>\\<^sup>+ x. 0 \\<partial>M\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. 0 \\<partial>M = 0", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. 0 \\<partial>M = 0\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "finally"], ["proof (chain)\npicking this:\n  emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n   {h. h \\<in> A \\<rightarrow>\\<^sub>E UNIV \\<and> h x = h y} =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n   {h. h \\<in> A \\<rightarrow>\\<^sub>E UNIV \\<and> h x = h y} =\n  0\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n     {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n    0", "."], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M A (\\<lambda>_. M))\n   {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y} =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_linorder_from_keys_restrict:\n  assumes fin: \"finite A\"\n  shows \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (A \\<times> A))\"\n  (is \"_ : ?M \\<rightarrow>\\<^sub>M _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_from_keys A\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. borel) \\<rightarrow>\\<^sub>M\n          count_space (Pow (A \\<times> A))", "apply (subst measurable_count_space_eq2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (Pow (A \\<times> A))\n 2. linorder_from_keys A\n    \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)) \\<rightarrow>\n          Pow (A \\<times> A) \\<and>\n    (\\<forall>a\\<in>Pow (A \\<times> A).\n        linorder_from_keys A -` {a} \\<inter>\n        space (Pi\\<^sub>M A (\\<lambda>_. borel))\n        \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel)))", "apply (auto simp add: fin linorder_from_keys_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "note fin[simp]"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "fix R"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "assume \"R \\<subseteq> A \\<times> A\""], ["proof (state)\nthis:\n  R \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "then"], ["proof (chain)\npicking this:\n  R \\<subseteq> A \\<times> A", "have \"linorder_from_keys A -` {R} \\<inter> space ?M =\n    {f \\<in> space ?M. \\<forall>x\\<in>A. \\<forall>y\\<in>A. (x, y) \\<in> R \\<longleftrightarrow> f x \\<le> f y}\""], ["proof (prove)\nusing this:\n  R \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. linorder_from_keys A -` {R} \\<inter>\n    space (Pi\\<^sub>M A (\\<lambda>_. borel)) =\n    {f \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)).\n     \\<forall>x\\<in>A. \\<forall>y\\<in>A. ((x, y) \\<in> R) = (f x \\<le> f y)}", "by (auto simp add: linorder_from_keys_def set_eq_iff)"], ["proof (state)\nthis:\n  linorder_from_keys A -` {R} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. borel)) =\n  {f \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)).\n   \\<forall>x\\<in>A. \\<forall>y\\<in>A. ((x, y) \\<in> R) = (f x \\<le> f y)}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "also"], ["proof (state)\nthis:\n  linorder_from_keys A -` {R} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. borel)) =\n  {f \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)).\n   \\<forall>x\\<in>A. \\<forall>y\\<in>A. ((x, y) \\<in> R) = (f x \\<le> f y)}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "have \"\\<dots> \\<in> sets ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)).\n     \\<forall>x\\<in>A. \\<forall>y\\<in>A. ((x, y) \\<in> R) = (f x \\<le> f y)}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "by measurable"], ["proof (state)\nthis:\n  {f \\<in> space (Pi\\<^sub>M A (\\<lambda>_. borel)).\n   \\<forall>x\\<in>A. \\<forall>y\\<in>A. ((x, y) \\<in> R) = (f x \\<le> f y)}\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<subseteq> A \\<times> A \\<Longrightarrow>\n       linorder_from_keys A -` {a} \\<inter>\n       space (Pi\\<^sub>M A (\\<lambda>_. borel))\n       \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "finally"], ["proof (chain)\npicking this:\n  linorder_from_keys A -` {R} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. borel))\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "show \"linorder_from_keys A -` {R} \\<inter> space ?M \\<in> sets ?M\""], ["proof (prove)\nusing this:\n  linorder_from_keys A -` {R} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. borel))\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))\n\ngoal (1 subgoal):\n 1. linorder_from_keys A -` {R} \\<inter>\n    space (Pi\\<^sub>M A (\\<lambda>_. borel))\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))", "."], ["proof (state)\nthis:\n  linorder_from_keys A -` {R} \\<inter>\n  space (Pi\\<^sub>M A (\\<lambda>_. borel))\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. borel))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_count_space_extend:\n  assumes \"f \\<in> measurable M (count_space A)\" \"A \\<subseteq> B\"\n  shows   \"f \\<in> measurable M (count_space B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "note assms(1)"], ["proof (state)\nthis:\n  f \\<in> M \\<rightarrow>\\<^sub>M count_space A\n\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "also"], ["proof (state)\nthis:\n  f \\<in> M \\<rightarrow>\\<^sub>M count_space A\n\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "have \"count_space A = restrict_space (count_space B) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_space A = restrict_space (count_space B) A", "using assms(2)"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. count_space A = restrict_space (count_space B) A", "by (subst restrict_count_space) (simp_all add: Int_absorb2)"], ["proof (state)\nthis:\n  count_space A = restrict_space (count_space B) A\n\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "finally"], ["proof (chain)\npicking this:\n  f \\<in> M \\<rightarrow>\\<^sub>M restrict_space (count_space B) A", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> M \\<rightarrow>\\<^sub>M restrict_space (count_space B) A\n\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M count_space B", "by (simp add: measurable_restrict_space2_iff)"], ["proof (state)\nthis:\n  f \\<in> M \\<rightarrow>\\<^sub>M count_space B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_linorder_from_keys_restrict':\n  assumes fin: \"finite A\" \"A \\<subseteq> B\"\n  shows \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (B \\<times> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_from_keys A\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. borel) \\<rightarrow>\\<^sub>M\n          count_space (Pow (B \\<times> B))", "apply (rule measurable_count_space_extend)"], ["proof (prove)\ngoal (2 subgoals):\n 1. linorder_from_keys A\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. borel) \\<rightarrow>\\<^sub>M\n          count_space ?A\n 2. ?A \\<subseteq> Pow (B \\<times> B)", "apply (rule measurable_linorder_from_keys_restrict[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow (A \\<times> A) \\<subseteq> Pow (B \\<times> B)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. Pow (A \\<times> A) \\<subseteq> Pow (B \\<times> B)", "by auto"], ["", "context\n  fixes a b :: real and A :: \"'a set\" and M and B\n  assumes fin: \"finite A\" and ab: \"a < b\" and B: \"A \\<subseteq> B\"\n  defines \"M \\<equiv> distr (PiM A (\\<lambda>_. uniform_measure lborel {a..b})) \n                  (count_space (Pow (B \\<times> B))) (linorder_from_keys A)\"\nbegin"], ["", "lemma measurable_linorder_from_keys [measurable]: \n  \"linorder_from_keys A \\<in> Pi\\<^sub>M A (\\<lambda>_. borel :: real measure) \\<rightarrow>\\<^sub>M count_space (Pow (B \\<times> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_from_keys A\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. borel) \\<rightarrow>\\<^sub>M\n          count_space (Pow (B \\<times> B))", "by (rule measurable_linorder_from_keys_restrict') (auto simp: fin B)"], ["", "text \\<open>\n  The ordering defined by randomly-chosen priorities is almost surely linear:\n\\<close>"], ["", "theorem almost_everywhere_linorder: \"AE R in M. linorder_on A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "define N where \"N = PiM A (\\<lambda>_. uniform_measure lborel {a..b})\""], ["proof (state)\nthis:\n  N = Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b})\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "have [simp]: \"sets (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b})) = sets (PiM A (\\<lambda>_. lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b})) =\n    sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "by (intro sets_PiM_cong) simp_all"], ["proof (state)\nthis:\n  sets (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b})) =\n  sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "let ?M_A = \"(Pi\\<^sub>M A (\\<lambda>_. lborel :: real measure))\""], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "have meas: \"{h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j} \\<in> sets ?M_A\"\n    if [simp]: \"i \\<in> A\" \"j \\<in> A\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "have \"{h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j} = {h \\<in> space ?M_A. h i = h j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j} =\n    {h \\<in> space (Pi\\<^sub>M A (\\<lambda>_. lborel)). h i = h j}", "by (auto simp: space_PiM)"], ["proof (state)\nthis:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j} =\n  {h \\<in> space (Pi\\<^sub>M A (\\<lambda>_. lborel)). h i = h j}\n\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "also"], ["proof (state)\nthis:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j} =\n  {h \\<in> space (Pi\\<^sub>M A (\\<lambda>_. lborel)). h i = h j}\n\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "have \"... \\<in> sets ?M_A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h \\<in> space (Pi\\<^sub>M A (\\<lambda>_. lborel)). h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "by measurable"], ["proof (state)\nthis:\n  {h \\<in> space (Pi\\<^sub>M A (\\<lambda>_. lborel)). h i = h j}\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "finally"], ["proof (chain)\npicking this:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "show ?thesis"], ["proof (prove)\nusing this:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))", "."], ["proof (state)\nthis:\n  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}\n  \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<in> A; ?j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h ?i = h ?j}\n                    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "define X :: \"('a \\<Rightarrow> real) set\" where \"X = (\\<Union>x\\<in>A. \\<Union>y\\<in>A-{x}. {h\\<in>A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\""], ["proof (state)\nthis:\n  X =\n  (\\<Union>x\\<in>A.\n      \\<Union>y\\<in>A - {x}.\n         {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "have \"AE f in N. inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE f in N. inj_on f A", "proof (rule AE_I)"], ["proof (state)\ngoal (3 subgoals):\n 1. {f \\<in> space N. \\<not> inj_on f A} \\<subseteq> ?N\n 2. emeasure N ?N = 0\n 3. ?N \\<in> sets N", "show \"{f \\<in> space N. \\<not> inj_on f A} \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f \\<in> space N. \\<not> inj_on f A} \\<subseteq> X", "by (auto simp: inj_on_def X_def space_PiM N_def)"], ["proof (state)\nthis:\n  {f \\<in> space N. \\<not> inj_on f A} \\<subseteq> X\n\ngoal (2 subgoals):\n 1. emeasure N X = 0\n 2. X \\<in> sets N", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. emeasure N X = 0\n 2. X \\<in> sets N", "show \"X \\<in> sets N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> sets N", "unfolding X_def N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A.\n        \\<Union>y\\<in>A - {x}.\n           {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))", "using meas"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> A; ?j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h ?i = h ?j}\n                    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A.\n        \\<Union>y\\<in>A - {x}.\n           {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\n    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))", "by (auto intro!: countable_finite fin sets.countable_UN')"], ["proof (state)\nthis:\n  X \\<in> sets N\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure N X = 0", "have \"emeasure N X \\<le> (\\<Sum>i\\<in>A. emeasure N (\\<Union>y\\<in>A - {i}. {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure N X\n    \\<le> (\\<Sum>i\\<in>A.\n             emeasure N\n              (\\<Union>y\\<in>A - {i}.\n                  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))", "unfolding X_def N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n     (\\<Union>x\\<in>A.\n         \\<Union>y\\<in>A - {x}.\n            {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\n    \\<le> (\\<Sum>i\\<in>A.\n             emeasure\n              (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n              (\\<Union>y\\<in>A - {i}.\n                  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))", "using fin meas"], ["proof (prove)\nusing this:\n  finite A\n  \\<lbrakk>?i \\<in> A; ?j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h ?i = h ?j}\n                    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n     (\\<Union>x\\<in>A.\n         \\<Union>y\\<in>A - {x}.\n            {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h x = h y})\n    \\<le> (\\<Sum>i\\<in>A.\n             emeasure\n              (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n              (\\<Union>y\\<in>A - {i}.\n                  {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))", "by (intro emeasure_subadditive_finite) \n         (auto simp: disjoint_family_on_def intro!: sets.countable_UN' countable_finite)"], ["proof (state)\nthis:\n  emeasure N X\n  \\<le> (\\<Sum>i\\<in>A.\n           emeasure N\n            (\\<Union>y\\<in>A - {i}.\n                {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "also"], ["proof (state)\nthis:\n  emeasure N X\n  \\<le> (\\<Sum>i\\<in>A.\n           emeasure N\n            (\\<Union>y\\<in>A - {i}.\n                {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "have \"\\<dots> \\<le> (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A-{i}. emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       emeasure N\n        (\\<Union>y\\<in>A - {i}.\n            {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n    \\<le> (\\<Sum>i\\<in>A.\n             \\<Sum>j\\<in>A - {i}.\n               emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n        (\\<Union>y\\<in>A - {i}.\n            {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n    \\<le> (\\<Sum>i\\<in>A.\n             \\<Sum>j\\<in>A - {i}.\n               emeasure\n                (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n                {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})", "using fin meas"], ["proof (prove)\nusing this:\n  finite A\n  \\<lbrakk>?i \\<in> A; ?j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h ?i = h ?j}\n                    \\<in> sets (Pi\\<^sub>M A (\\<lambda>_. lborel))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n        (\\<Union>y\\<in>A - {i}.\n            {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n    \\<le> (\\<Sum>i\\<in>A.\n             \\<Sum>j\\<in>A - {i}.\n               emeasure\n                (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n                {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})", "by (intro emeasure_subadditive_finite sum_mono) \n         (auto simp: disjoint_family_on_def intro!: sets.countable_UN' countable_finite)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A.\n     emeasure N\n      (\\<Union>y\\<in>A - {i}.\n          {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n  \\<le> (\\<Sum>i\\<in>A.\n           \\<Sum>j\\<in>A - {i}.\n             emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A.\n     emeasure N\n      (\\<Union>y\\<in>A - {i}.\n          {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h y}))\n  \\<le> (\\<Sum>i\\<in>A.\n           \\<Sum>j\\<in>A - {i}.\n             emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j})\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "have \"\\<dots> = (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A-{i}. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       \\<Sum>j\\<in>A - {i}.\n         emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}) =\n    (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       \\<Sum>j\\<in>A - {i}.\n         emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n          {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}) =\n    (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0)", "using fin ab"], ["proof (prove)\nusing this:\n  finite A\n  a < b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A.\n       \\<Sum>j\\<in>A - {i}.\n         emeasure (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n          {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}) =\n    (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0)", "by (intro sum.cong refl emeasure_PiM_diagonal) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A.\n     \\<Sum>j\\<in>A - {i}.\n       emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}) =\n  (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0)\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A.\n     \\<Sum>j\\<in>A - {i}.\n       emeasure N {h \\<in> A \\<rightarrow>\\<^sub>E UNIV. h i = h j}) =\n  (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0)\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>A. \\<Sum>j\\<in>A - {i}. 0) = 0\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "finally"], ["proof (chain)\npicking this:\n  emeasure N X \\<le> 0", "show \"emeasure N X = 0\""], ["proof (prove)\nusing this:\n  emeasure N X \\<le> 0\n\ngoal (1 subgoal):\n 1. emeasure N X = 0", "by simp"], ["proof (state)\nthis:\n  emeasure N X = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE f in N. inj_on f A\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "hence \"AE f in N. linorder_on A (linorder_from_keys A f)\""], ["proof (prove)\nusing this:\n  AE f in N. inj_on f A\n\ngoal (1 subgoal):\n 1. AE f in N. linorder_on A (linorder_from_keys A f)", "by eventually_elim auto"], ["proof (state)\nthis:\n  AE f in N. linorder_on A (linorder_from_keys A f)\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  AE f in N. linorder_on A (linorder_from_keys A f)\n\ngoal (1 subgoal):\n 1. almost_everywhere M (linorder_on A)", "unfolding M_def N_def"], ["proof (prove)\nusing this:\n  AE f in Pi\\<^sub>M A\n           (\\<lambda>_.\n               uniform_measure lborel\n                {a..b}). linorder_on A (linorder_from_keys A f)\n\ngoal (1 subgoal):\n 1. almost_everywhere\n     (distr (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n       (count_space (Pow (B \\<times> B))) (linorder_from_keys A))\n     (linorder_on A)", "by (subst AE_distr_iff) auto"], ["proof (state)\nthis:\n  almost_everywhere M (linorder_on A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Furthermore, this is equivalent to choosing one of the $|A|!$ linear orderings uniformly\n  at random.\n\\<close>"], ["", "theorem random_linorder_by_prios:\n  \"M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "from linorders_finite_nonempty[OF fin]"], ["proof (chain)\npicking this:\n  linorders_on A \\<noteq> {}", "obtain R where R: \"linorder_on A R\""], ["proof (prove)\nusing this:\n  linorders_on A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>R. linorder_on A R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: linorders_on_def)"], ["proof (state)\nthis:\n  linorder_on A R\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have *: \"emeasure M {R} \\<le> emeasure M {R'}\" if \"linorder_on A R\" \"linorder_on A R'\" for R R'"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "define N where \"N = PiM A (\\<lambda>_. uniform_measure lborel {a..b})\""], ["proof (state)\nthis:\n  N = Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b})\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "from linorder_permutation_exists[OF fin that]"], ["proof (chain)\npicking this:\n  (\\<And>\\<pi>.\n      \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain \\<pi> where \\<pi>: \"\\<pi> permutes A\" \"R' = map_relation A \\<pi> R\""], ["proof (prove)\nusing this:\n  (\\<And>\\<pi>.\n      \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>\\<pi> permutes A; R' = map_relation A \\<pi> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> permutes A\n  R' = map_relation A \\<pi> R\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"(\\<lambda>f. f \\<circ> \\<pi>) \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel :: real measure) \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel :: real measure)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. f \\<circ> \\<pi>)\n    \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M A (\\<lambda>_. lborel)", "by (auto intro!: measurable_PiM_single' measurable_PiM_component_rev\n          simp: comp_def permutes_in_image[OF \\<pi>(1)] space_PiM PiE_def extensional_def)"], ["proof (state)\nthis:\n  (\\<lambda>f. f \\<circ> \\<pi>)\n  \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n        Pi\\<^sub>M A (\\<lambda>_. lborel)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  (\\<lambda>f. f \\<circ> \\<pi>)\n  \\<in> Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n        Pi\\<^sub>M A (\\<lambda>_. lborel)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"\\<dots> = N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n    Pi\\<^sub>M A (\\<lambda>_. lborel) =\n    N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n    Pi\\<^sub>M A (\\<lambda>_. lborel) =\n    Pi\\<^sub>M A\n     (\\<lambda>_. uniform_measure lborel {a..b}) \\<rightarrow>\\<^sub>M\n    Pi\\<^sub>M A (\\<lambda>_. lborel)", "by (intro measurable_cong_sets refl sets_PiM_cong) simp_all"], ["proof (state)\nthis:\n  Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M\n  Pi\\<^sub>M A (\\<lambda>_. lborel) =\n  N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>f. f \\<circ> \\<pi>)\n  \\<in> N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)", "have [measurable]: \"(\\<lambda>f. f \\<circ> \\<pi>) \\<in> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>f. f \\<circ> \\<pi>)\n  \\<in> N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)\n\ngoal (1 subgoal):\n 1. (\\<lambda>f. f \\<circ> \\<pi>)\n    \\<in> N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)", "."], ["proof (state)\nthis:\n  (\\<lambda>f. f \\<circ> \\<pi>)\n  \\<in> N \\<rightarrow>\\<^sub>M Pi\\<^sub>M A (\\<lambda>_. lborel)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have [simp]: \"measurable N X = measurable (PiM A (\\<lambda>_. lborel)) X\" for X :: \"('a \\<times> 'a) set measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<rightarrow>\\<^sub>M X =\n    Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M X", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M A\n     (\\<lambda>_. uniform_measure lborel {a..b}) \\<rightarrow>\\<^sub>M\n    X =\n    Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M X", "by (intro measurable_cong_sets refl sets_PiM_cong) simp_all"], ["proof (state)\nthis:\n  N \\<rightarrow>\\<^sub>M ?X =\n  Pi\\<^sub>M A (\\<lambda>_. lborel) \\<rightarrow>\\<^sub>M ?X\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have [simp]: \"measurable M X = measurable (count_space (Pow (B \\<times> B))) X\" for X :: \"('a \\<times> 'a) set measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<rightarrow>\\<^sub>M X =\n    count_space (Pow (B \\<times> B)) \\<rightarrow>\\<^sub>M X", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n     (count_space (Pow (B \\<times> B)))\n     (linorder_from_keys A) \\<rightarrow>\\<^sub>M\n    X =\n    count_space (Pow (B \\<times> B)) \\<rightarrow>\\<^sub>M X", "by simp"], ["proof (state)\nthis:\n  M \\<rightarrow>\\<^sub>M ?X =\n  count_space (Pow (B \\<times> B)) \\<rightarrow>\\<^sub>M ?X\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have M_eq: \"M = distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A)", "by (simp only: M_def N_def)"], ["proof (state)\nthis:\n  M = distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  M = distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"N = distr N (PiM A (\\<lambda>_. lborel)) (\\<lambda>f. f \\<circ> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N =\n    distr N (Pi\\<^sub>M A (\\<lambda>_. lborel))\n     (\\<lambda>f. f \\<circ> \\<pi>)", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}) =\n    distr (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n     (Pi\\<^sub>M A (\\<lambda>_. lborel)) (\\<lambda>f. f \\<circ> \\<pi>)", "by (rule PiM_uniform_measure_permute [symmetric]) fact+"], ["proof (state)\nthis:\n  N =\n  distr N (Pi\\<^sub>M A (\\<lambda>_. lborel)) (\\<lambda>f. f \\<circ> \\<pi>)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  N =\n  distr N (Pi\\<^sub>M A (\\<lambda>_. lborel)) (\\<lambda>f. f \\<circ> \\<pi>)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"distr \\<dots> (count_space (Pow (B \\<times> B))) (linorder_from_keys A) = \n                 distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr\n     (distr N (Pi\\<^sub>M A (\\<lambda>_. lborel))\n       (\\<lambda>f. f \\<circ> \\<pi>))\n     (count_space (Pow (B \\<times> B))) (linorder_from_keys A) =\n    distr N (count_space (Pow (B \\<times> B)))\n     (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>))", "by (intro distr_distr) simp_all"], ["proof (state)\nthis:\n  distr\n   (distr N (Pi\\<^sub>M A (\\<lambda>_. lborel))\n     (\\<lambda>f. f \\<circ> \\<pi>))\n   (count_space (Pow (B \\<times> B))) (linorder_from_keys A) =\n  distr N (count_space (Pow (B \\<times> B)))\n   (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  distr\n   (distr N (Pi\\<^sub>M A (\\<lambda>_. lborel))\n     (\\<lambda>f. f \\<circ> \\<pi>))\n   (count_space (Pow (B \\<times> B))) (linorder_from_keys A) =\n  distr N (count_space (Pow (B \\<times> B)))\n   (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"\\<dots> = distr N (count_space (Pow (B \\<times> B))) (map_relation A \\<pi> \\<circ> linorder_from_keys A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr N (count_space (Pow (B \\<times> B)))\n     (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>)) =\n    distr N (count_space (Pow (B \\<times> B)))\n     (map_relation A \\<pi> \\<circ> linorder_from_keys A)", "by (intro distr_cong refl) (auto simp: linorder_from_keys_permute[OF \\<pi>(1)])"], ["proof (state)\nthis:\n  distr N (count_space (Pow (B \\<times> B)))\n   (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>)) =\n  distr N (count_space (Pow (B \\<times> B)))\n   (map_relation A \\<pi> \\<circ> linorder_from_keys A)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  distr N (count_space (Pow (B \\<times> B)))\n   (linorder_from_keys A \\<circ> (\\<lambda>f. f \\<circ> \\<pi>)) =\n  distr N (count_space (Pow (B \\<times> B)))\n   (map_relation A \\<pi> \\<circ> linorder_from_keys A)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"\\<dots> = distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr N (count_space (Pow (B \\<times> B)))\n     (map_relation A \\<pi> \\<circ> linorder_from_keys A) =\n    distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)", "unfolding M_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr N (count_space (Pow (B \\<times> B)))\n     (map_relation A \\<pi> \\<circ> linorder_from_keys A) =\n    distr\n     (distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A))\n     (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)", "using B"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. distr N (count_space (Pow (B \\<times> B)))\n     (map_relation A \\<pi> \\<circ> linorder_from_keys A) =\n    distr\n     (distr N (count_space (Pow (B \\<times> B))) (linorder_from_keys A))\n     (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)", "by (intro distr_distr [symmetric]) (auto simp: map_relation_def)"], ["proof (state)\nthis:\n  distr N (count_space (Pow (B \\<times> B)))\n   (map_relation A \\<pi> \\<circ> linorder_from_keys A) =\n  distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "finally"], ["proof (chain)\npicking this:\n  M = distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)", "have M_eq': \"distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>) = M\""], ["proof (prove)\nusing this:\n  M = distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)\n\ngoal (1 subgoal):\n 1. distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>) = M", ".."], ["proof (state)\nthis:\n  distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>) = M\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "from that"], ["proof (chain)\npicking this:\n  linorder_on A R\n  linorder_on A R'", "have subset': \"R \\<subseteq> B \\<times> B\" \"R' \\<subseteq> B \\<times> B\""], ["proof (prove)\nusing this:\n  linorder_on A R\n  linorder_on A R'\n\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B &&& R' \\<subseteq> B \\<times> B", "using B"], ["proof (prove)\nusing this:\n  linorder_on A R\n  linorder_on A R'\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. R \\<subseteq> B \\<times> B &&& R' \\<subseteq> B \\<times> B", "by (auto simp: linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  R \\<subseteq> B \\<times> B\n  R' \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "hence \"emeasure M {R} \\<le> emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M)\""], ["proof (prove)\nusing this:\n  R \\<subseteq> B \\<times> B\n  R' \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. emeasure M {R}\n    \\<le> emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M)", "using subset'"], ["proof (prove)\nusing this:\n  R \\<subseteq> B \\<times> B\n  R' \\<subseteq> B \\<times> B\n  R \\<subseteq> B \\<times> B\n  R' \\<subseteq> B \\<times> B\n\ngoal (1 subgoal):\n 1. emeasure M {R}\n    \\<le> emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M)", "by (intro emeasure_mono) (auto simp: M_def \\<pi> )"], ["proof (state)\nthis:\n  emeasure M {R}\n  \\<le> emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  emeasure M {R}\n  \\<le> emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M)\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "have \"\\<dots> = emeasure (distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)) {R'} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M) =\n    emeasure\n     (distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>))\n     {R'}", "by (rule emeasure_distr [symmetric]) (insert subset' B, auto simp: map_relation_def)"], ["proof (state)\nthis:\n  emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M) =\n  emeasure\n   (distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)) {R'}\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "also"], ["proof (state)\nthis:\n  emeasure M (map_relation A \\<pi> -` {R'} \\<inter> space M) =\n  emeasure\n   (distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>)) {R'}\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "note M_eq'"], ["proof (state)\nthis:\n  distr M (count_space (Pow (B \\<times> B))) (map_relation A \\<pi>) = M\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "finally"], ["proof (chain)\npicking this:\n  emeasure M {R} \\<le> emeasure M {R'}", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure M {R} \\<le> emeasure M {R'}\n\ngoal (1 subgoal):\n 1. emeasure M {R} \\<le> emeasure M {R'}", "."], ["proof (state)\nthis:\n  emeasure M {R} \\<le> emeasure M {R'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>linorder_on A ?R; linorder_on A ?R'\\<rbrakk>\n  \\<Longrightarrow> emeasure M {?R} \\<le> emeasure M {?R'}\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have same_prob: \"emeasure M {R'} = emeasure M {R}\" if \"linorder_on A R'\" for R'"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M {R'} = emeasure M {R}", "using *[of R R'] and *[of R' R] and R and that"], ["proof (prove)\nusing this:\n  \\<lbrakk>linorder_on A R; linorder_on A R'\\<rbrakk>\n  \\<Longrightarrow> emeasure M {R} \\<le> emeasure M {R'}\n  \\<lbrakk>linorder_on A R'; linorder_on A R\\<rbrakk>\n  \\<Longrightarrow> emeasure M {R'} \\<le> emeasure M {R}\n  linorder_on A R\n  linorder_on A R'\n\ngoal (1 subgoal):\n 1. emeasure M {R'} = emeasure M {R}", "by simp"], ["proof (state)\nthis:\n  linorder_on A ?R' \\<Longrightarrow> emeasure M {?R'} = emeasure M {R}\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "from ab"], ["proof (chain)\npicking this:\n  a < b", "have \"prob_space M\""], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. prob_space M", "unfolding M_def"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. prob_space\n     (distr (Pi\\<^sub>M A (\\<lambda>_. uniform_measure lborel {a..b}))\n       (count_space (Pow (B \\<times> B))) (linorder_from_keys A))", "by (intro prob_space.prob_space_distr prob_space_PiM prob_space_uniform_measure) simp_all"], ["proof (state)\nthis:\n  prob_space M\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "hence \"1 = emeasure M (Pow (B \\<times> B))\""], ["proof (prove)\nusing this:\n  prob_space M\n\ngoal (1 subgoal):\n 1. 1 = emeasure M (Pow (B \\<times> B))", "using prob_space.emeasure_space_1[OF \\<open>prob_space M\\<close>]"], ["proof (prove)\nusing this:\n  prob_space M\n  emeasure M (space M) = 1\n\ngoal (1 subgoal):\n 1. 1 = emeasure M (Pow (B \\<times> B))", "by (simp add: M_def)"], ["proof (state)\nthis:\n  1 = emeasure M (Pow (B \\<times> B))\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  1 = emeasure M (Pow (B \\<times> B))\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have \"(Pow (B \\<times> B)) = linorders_on A \\<union> ((Pow (B \\<times> B))-linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow (B \\<times> B) =\n    linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)", "using B"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. Pow (B \\<times> B) =\n    linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)", "by (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  Pow (B \\<times> B) =\n  linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  Pow (B \\<times> B) =\n  linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have \"emeasure M \\<dots> = emeasure M (linorders_on A) + emeasure M (Pow (B \\<times> B)-linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M\n     (linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)) =\n    emeasure M (linorders_on A) +\n    emeasure M (Pow (B \\<times> B) - linorders_on A)", "using B"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. emeasure M\n     (linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)) =\n    emeasure M (linorders_on A) +\n    emeasure M (Pow (B \\<times> B) - linorders_on A)", "by (subst plus_emeasure) (auto simp: M_def linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  emeasure M\n   (linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)) =\n  emeasure M (linorders_on A) +\n  emeasure M (Pow (B \\<times> B) - linorders_on A)\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  emeasure M\n   (linorders_on A \\<union> (Pow (B \\<times> B) - linorders_on A)) =\n  emeasure M (linorders_on A) +\n  emeasure M (Pow (B \\<times> B) - linorders_on A)\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have \"emeasure M (Pow (B \\<times> B)-linorders_on A) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (Pow (B \\<times> B) - linorders_on A) = 0", "using almost_everywhere_linorder"], ["proof (prove)\nusing this:\n  almost_everywhere M (linorder_on A)\n\ngoal (1 subgoal):\n 1. emeasure M (Pow (B \\<times> B) - linorders_on A) = 0", "by (subst (asm) AE_iff_measurable) (auto simp: linorders_on_def M_def)"], ["proof (state)\nthis:\n  emeasure M (Pow (B \\<times> B) - linorders_on A) = 0\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  emeasure M (Pow (B \\<times> B) - linorders_on A) = 0\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "from fin"], ["proof (chain)\npicking this:\n  finite A", "have \"emeasure M (linorders_on A) = (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'})\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. emeasure M (linorders_on A) =\n    (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'})", "using B"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. emeasure M (linorders_on A) =\n    (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'})", "by (intro emeasure_eq_sum_singleton) \n               (auto simp: M_def  linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  emeasure M (linorders_on A) =\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'})\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  emeasure M (linorders_on A) =\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'})\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "have \"\\<dots> = (\\<Sum>R'\\<in>linorders_on A. emeasure M {R})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'}) =\n    (\\<Sum>R'\\<in>linorders_on A. emeasure M {R})", "by (rule sum.cong) (simp_all add: linorders_on_def same_prob)"], ["proof (state)\nthis:\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'}) =\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R})\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R'}) =\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R})\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "from fin"], ["proof (chain)\npicking this:\n  finite A", "have \"\\<dots> = fact (card A) * emeasure M {R}\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>R'\\<in>linorders_on A. emeasure M {R}) =\n    fact (card A) * emeasure M {R}", "by (simp add: linorders_on_def card_finite_linorders)"], ["proof (state)\nthis:\n  (\\<Sum>R'\\<in>linorders_on A. emeasure M {R}) =\n  fact (card A) * emeasure M {R}\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "finally"], ["proof (chain)\npicking this:\n  1 = fact (card A) * emeasure M {R} + 0", "have [simp]: \"emeasure M {R} = inverse (fact (card A))\""], ["proof (prove)\nusing this:\n  1 = fact (card A) * emeasure M {R} + 0\n\ngoal (1 subgoal):\n 1. emeasure M {R} = inverse (fact (card A))", "by (simp add: inverse_ennreal_unique)"], ["proof (state)\nthis:\n  emeasure M {R} = inverse (fact (card A))\n\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)", "proof (rule measure_eqI_countable_AE')"], ["proof (state)\ngoal (7 subgoals):\n 1. sets M = Pow ?B\n 2. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow ?B\n 3. ?\\<Omega> \\<subseteq> ?B\n 4. AE x in M. x \\<in> ?\\<Omega>\n 5. AE x in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). x \\<in> ?\\<Omega>\n 6. countable ?\\<Omega>\n 7. \\<And>x.\n       x \\<in> ?\\<Omega> \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "show \"sets M = Pow (Pow (B \\<times> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets M = Pow (Pow (B \\<times> B))", "by (simp add: M_def)"], ["proof (state)\nthis:\n  sets M = Pow (Pow (B \\<times> B))\n\ngoal (6 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. ?\\<Omega> \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> ?\\<Omega>\n 4. AE x in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). x \\<in> ?\\<Omega>\n 5. countable ?\\<Omega>\n 6. \\<And>x.\n       x \\<in> ?\\<Omega> \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. ?\\<Omega> \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> ?\\<Omega>\n 4. AE x in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). x \\<in> ?\\<Omega>\n 5. countable ?\\<Omega>\n 6. \\<And>x.\n       x \\<in> ?\\<Omega> \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "from \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A", "show \"countable (linorders_on A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. countable (linorders_on A)", "by (blast intro: countable_finite)"], ["proof (state)\nthis:\n  countable (linorders_on A)\n\ngoal (5 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. AE x in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). x \\<in> linorders_on A\n 5. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. AE x in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). x \\<in> linorders_on A\n 5. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "show \"AE R in uniform_measure (count_space (Pow (B \\<times> B))) \n            (linorders_on A). R \\<in> linorders_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE R in uniform_measure (count_space (Pow (B \\<times> B)))\n             (linorders_on A). R \\<in> linorders_on A", "by (rule AE_uniform_measureI) \n         (insert B, auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  AE R in uniform_measure (count_space (Pow (B \\<times> B)))\n           (linorders_on A). R \\<in> linorders_on A\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "fix R'"], ["proof (state)\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "assume R': \"R' \\<in> linorders_on A\""], ["proof (state)\nthis:\n  R' \\<in> linorders_on A\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have subset: \"linorders_on A \\<subseteq> Pow (B \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorders_on A \\<subseteq> Pow (B \\<times> B)", "using B"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. linorders_on A \\<subseteq> Pow (B \\<times> B)", "by (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  linorders_on A \\<subseteq> Pow (B \\<times> B)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have \"emeasure (uniform_measure (count_space (Pow (B \\<times> B))) \n           (linorders_on A)) {R'} = emeasure (count_space (Pow (B \\<times> B))) (linorders_on A \\<inter> {R'}) /\n                                      emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n     {R'} =\n    emeasure (count_space (Pow (B \\<times> B)))\n     (linorders_on A \\<inter> {R'}) /\n    emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)", "using R' B"], ["proof (prove)\nusing this:\n  R' \\<in> linorders_on A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. emeasure\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n     {R'} =\n    emeasure (count_space (Pow (B \\<times> B)))\n     (linorders_on A \\<inter> {R'}) /\n    emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)", "by (subst emeasure_uniform_measure) (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  emeasure\n   (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n   {R'} =\n  emeasure (count_space (Pow (B \\<times> B)))\n   (linorders_on A \\<inter> {R'}) /\n  emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "also"], ["proof (state)\nthis:\n  emeasure\n   (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n   {R'} =\n  emeasure (count_space (Pow (B \\<times> B)))\n   (linorders_on A \\<inter> {R'}) /\n  emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have \"\\<dots> = 1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (count_space (Pow (B \\<times> B)))\n     (linorders_on A \\<inter> {R'}) /\n    emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n    1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)", "using R' B"], ["proof (prove)\nusing this:\n  R' \\<in> linorders_on A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. emeasure (count_space (Pow (B \\<times> B)))\n     (linorders_on A \\<inter> {R'}) /\n    emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n    1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)", "by (subst emeasure_count_space) (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  emeasure (count_space (Pow (B \\<times> B)))\n   (linorders_on A \\<inter> {R'}) /\n  emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n  1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "also"], ["proof (state)\nthis:\n  emeasure (count_space (Pow (B \\<times> B)))\n   (linorders_on A \\<inter> {R'}) /\n  emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n  1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have \"\\<dots> = 1 / fact (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n    1 / fact (card A)", "using fin finite_linorders_on[of A]"], ["proof (prove)\nusing this:\n  finite A\n  finite A \\<Longrightarrow> finite (linorders_on A)\n\ngoal (1 subgoal):\n 1. 1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n    1 / fact (card A)", "by (subst emeasure_count_space [OF subset])\n         (auto simp: divide_ennreal [symmetric] linorders_on_def card_finite_linorders)"], ["proof (state)\nthis:\n  1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n  1 / fact (card A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "also"], ["proof (state)\nthis:\n  1 / emeasure (count_space (Pow (B \\<times> B))) (linorders_on A) =\n  1 / fact (card A)\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have \"\\<dots> = emeasure M {R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / fact (card A) = emeasure M {R}", "by (simp add: field_simps divide_ennreal_def)"], ["proof (state)\nthis:\n  1 / fact (card A) = emeasure M {R}\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "also"], ["proof (state)\nthis:\n  1 / fact (card A) = emeasure M {R}\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "have \"\\<dots> = emeasure M {R'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M {R} = emeasure M {R'}", "using R'"], ["proof (prove)\nusing this:\n  R' \\<in> linorders_on A\n\ngoal (1 subgoal):\n 1. emeasure M {R} = emeasure M {R'}", "by (intro same_prob [symmetric]) (auto simp: linorders_on_def)"], ["proof (state)\nthis:\n  emeasure M {R} = emeasure M {R'}\n\ngoal (4 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A\n 4. \\<And>x.\n       x \\<in> linorders_on A \\<Longrightarrow>\n       emeasure M {x} =\n       emeasure\n        (uniform_measure (count_space (Pow (B \\<times> B)))\n          (linorders_on A))\n        {x}", "finally"], ["proof (chain)\npicking this:\n  emeasure\n   (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n   {R'} =\n  emeasure M {R'}", "show \"emeasure M {R'} = emeasure (uniform_measure (count_space (Pow (B \\<times> B))) \n                    (linorders_on A)) {R'}\""], ["proof (prove)\nusing this:\n  emeasure\n   (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n   {R'} =\n  emeasure M {R'}\n\ngoal (1 subgoal):\n 1. emeasure M {R'} =\n    emeasure\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n     {R'}", ".."], ["proof (state)\nthis:\n  emeasure M {R'} =\n  emeasure\n   (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A))\n   {R'}\n\ngoal (3 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. linorders_on A \\<subseteq> Pow (B \\<times> B)\n 3. AE x in M. x \\<in> linorders_on A", "show \"linorders_on A \\<subseteq> Pow (B \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorders_on A \\<subseteq> Pow (B \\<times> B)", "using B"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. linorders_on A \\<subseteq> Pow (B \\<times> B)", "by (auto simp: linorders_on_def linorder_on_def refl_on_def)"], ["proof (state)\nthis:\n  linorders_on A \\<subseteq> Pow (B \\<times> B)\n\ngoal (2 subgoals):\n 1. sets\n     (uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)) =\n    Pow (Pow (B \\<times> B))\n 2. AE x in M. x \\<in> linorders_on A", "qed (auto simp: M_def linorders_on_def almost_everywhere_linorder)"], ["proof (state)\nthis:\n  M = uniform_measure (count_space (Pow (B \\<times> B))) (linorders_on A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}