{"file_name": "/home/qj213/afp-2021-10-22/thys/Treaps/Treap_Sort_and_BSTs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Treaps", "problem_names": ["lemma insort_key_conv_rec_list:\n  \"insort_key f x xs =\n     rec_list [x] (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs) xs\"", "lemma insort_key_conv_rec_list':\n  \"insort_key = (\\<lambda>f x.\n     rec_list [x] (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs))\"", "lemma bst_of_list_trees:\n  assumes \"set ys \\<subseteq> A\"\n  shows \"bst_of_list ys \\<in> trees A\"", "lemma insort_wrt_insort_key:\n   \"a \\<in> A \\<Longrightarrow>\n   set xs \\<subseteq> A \\<Longrightarrow>\n   insert_wrt (linorder_from_keys A f) a xs = insort_key f a xs\"", "lemma insort_wrt_sort_key:\n  assumes \"set xs \\<subseteq> A\"\n  shows \"insort_wrt (linorder_from_keys A f) xs = sort_key f xs\"", "lemma sort_key_arg_min_on:\n  assumes \"zs \\<noteq> []\"  \"inj_on p (set zs)\"\n  shows \"sort_key p (zs::'a::linorder list) = \n         (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\"", "lemma arg_min_on_image_finite:\n  fixes f :: \"'b \\<Rightarrow> 'c :: linorder\"\n  assumes \"inj_on f (g ` B)\" \"finite B\" \"B \\<noteq> {}\"\n  shows \"arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)\"", "lemma fst_snd_arg_min_on: fixes p::\"'a \\<Rightarrow> 'b::linorder\"\n  assumes \"finite B\" \"inj_on p B\" \"B \\<noteq> {}\"\n  shows   \"fst (arg_min_on snd ((\\<lambda>x. (x, p x)) ` B)) = arg_min_on p B\"", "theorem treap_of_bst_of_list':\n  assumes \"ys = map (\\<lambda>x. (x, p x)) xs\" \"inj_on p (set xs)\" \"xs' = sort_key p xs\"\n  shows \"map_tree fst (treap_of (set ys)) = bst_of_list xs'\""], "translations": [["", "lemma insort_key_conv_rec_list:\n  \"insort_key f x xs =\n     rec_list [x] (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insort_key f x xs =\n    rec_list [x]\n     (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs) xs", "by (induction xs) simp_all"], ["", "lemma insort_key_conv_rec_list':\n  \"insort_key = (\\<lambda>f x.\n     rec_list [x] (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insort_key =\n    (\\<lambda>f x.\n        rec_list [x]\n         (\\<lambda>y ys zs. if f x \\<le> f y then x # y # ys else y # zs))", "by (intro ext) (simp add: insort_key_conv_rec_list)"], ["", "lemma bst_of_list_trees:\n  assumes \"set ys \\<subseteq> A\"\n  shows \"bst_of_list ys \\<in> trees A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_of_list ys \\<in> trees A", "using assms"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> A\n\ngoal (1 subgoal):\n 1. bst_of_list ys \\<in> trees A", "by (induction ys rule: bst_of_list.induct) auto"], ["", "lemma insort_wrt_insort_key:\n   \"a \\<in> A \\<Longrightarrow>\n   set xs \\<subseteq> A \\<Longrightarrow>\n   insert_wrt (linorder_from_keys A f) a xs = insort_key f a xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; set xs \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> insert_wrt (linorder_from_keys A f) a xs =\n                      insort_key f a xs", "unfolding linorder_from_keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; set xs \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> insert_wrt\n                       {(x, y).\n                        (x, y) \\<in> A \\<times> A \\<and> f x \\<le> f y}\n                       a xs =\n                      insort_key f a xs", "by (induction xs) (auto)"], ["", "lemma insort_wrt_sort_key:\n  assumes \"set xs \\<subseteq> A\"\n  shows \"insort_wrt (linorder_from_keys A f) xs = sort_key f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insort_wrt (linorder_from_keys A f) xs = sort_key f xs", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. insort_wrt (linorder_from_keys A f) xs = sort_key f xs", "by (induction xs) (auto simp add: insort_wrt_def insort_wrt_insort_key)"], ["", "text \\<open>\n  The following is an important recurrence for @{term \"sort_key\"} that states that for distinct\n  priorities, sorting a list w.\\,r.\\,t.\\ those priorities can be seen as selection sort, i.\\,e.\\ \n  we can first choose the (unique) element with minimum priority as the first element and then\n  sort the rest of the list and append it.\n\\<close>"], ["", "lemma sort_key_arg_min_on:\n  assumes \"zs \\<noteq> []\"  \"inj_on p (set zs)\"\n  shows \"sort_key p (zs::'a::linorder list) = \n         (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "have \"mset zs = mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset zs =\n    mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset zs =\n    mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "define m where \"m = arg_min_on p (set zs)\""], ["proof (state)\nthis:\n  m = arg_min_on p (set zs)\n\ngoal (1 subgoal):\n 1. mset zs =\n    mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "have \"m \\<in> (set zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> set zs", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_min_on p (set zs) \\<in> set zs", "by (rule arg_min_if_finite) (use assms in auto)"], ["proof (state)\nthis:\n  m \\<in> set zs\n\ngoal (1 subgoal):\n 1. mset zs =\n    mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "then"], ["proof (chain)\npicking this:\n  m \\<in> set zs", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> set zs\n\ngoal (1 subgoal):\n 1. mset zs =\n    mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "by (auto simp add: Let_def m_def)"], ["proof (state)\nthis:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "moreover"], ["proof (state)\nthis:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "have \"linorder_class.sorted\n                 (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "have \"set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs))) \\<subseteq> p ` set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n    \\<subseteq> p ` set zs", "using set_remove1_subset"], ["proof (prove)\nusing this:\n  set (remove1 ?x ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n    \\<subseteq> p ` set zs", "by (fastforce)"], ["proof (state)\nthis:\n  set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n  \\<subseteq> p ` set zs\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "moreover"], ["proof (state)\nthis:\n  set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n  \\<subseteq> p ` set zs\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "have \"\\<And>y. y \\<in> p ` set zs \\<Longrightarrow> p (arg_min_on p (set zs)) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> p ` set zs \\<Longrightarrow>\n       p (arg_min_on p (set zs)) \\<le> y", "using arg_min_least assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S; ?S \\<noteq> {}; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?f (arg_min_on ?f ?S) \\<le> ?f ?y\n  zs \\<noteq> []\n  inj_on p (set zs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> p ` set zs \\<Longrightarrow>\n       p (arg_min_on p (set zs)) \\<le> y", "by force"], ["proof (state)\nthis:\n  ?y \\<in> p ` set zs \\<Longrightarrow> p (arg_min_on p (set zs)) \\<le> ?y\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "ultimately"], ["proof (chain)\npicking this:\n  set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n  \\<subseteq> p ` set zs\n  ?y \\<in> p ` set zs \\<Longrightarrow> p (arg_min_on p (set zs)) \\<le> ?y", "have \"linorder_class.sorted\n        (p (arg_min_on p (set zs)) # map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\""], ["proof (prove)\nusing this:\n  set (map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n  \\<subseteq> p ` set zs\n  ?y \\<in> p ` set zs \\<Longrightarrow> p (arg_min_on p (set zs)) \\<le> ?y\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (p (arg_min_on p (set zs)) #\n      map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))", "by (auto)"], ["proof (state)\nthis:\n  linorder_class.sorted\n   (p (arg_min_on p (set zs)) #\n    map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "then"], ["proof (chain)\npicking this:\n  linorder_class.sorted\n   (p (arg_min_on p (set zs)) #\n    map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_class.sorted\n   (p (arg_min_on p (set zs)) #\n    map p (sort_key p (remove1 (arg_min_on p (set zs)) zs)))\n\ngoal (1 subgoal):\n 1. linorder_class.sorted\n     (map p\n       (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  linorder_class.sorted\n   (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  linorder_class.sorted\n   (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))\n\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "ultimately"], ["proof (chain)\npicking this:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n  linorder_class.sorted\n   (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n  linorder_class.sorted\n   (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))\n\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "using sort_key_inj_key_eq assms"], ["proof (prove)\nusing this:\n  mset zs =\n  mset (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n  linorder_class.sorted\n   (map p (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs)))\n  \\<lbrakk>mset ?xs = mset ?ys; inj_on ?f (set ?xs);\n   linorder_class.sorted (map ?f ?ys)\\<rbrakk>\n  \\<Longrightarrow> sort_key ?f ?xs = ?ys\n  zs \\<noteq> []\n  inj_on p (set zs)\n\ngoal (1 subgoal):\n 1. sort_key p zs =\n    (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))", "by blast"], ["proof (state)\nthis:\n  sort_key p zs =\n  (let z = arg_min_on p (set zs) in z # sort_key p (remove1 z zs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_min_on_image_finite:\n  fixes f :: \"'b \\<Rightarrow> 'c :: linorder\"\n  assumes \"inj_on f (g ` B)\" \"finite B\" \"B \\<noteq> {}\"\n  shows \"arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)", "note * = arg_min_if_finite[OF \\<open>finite B\\<close> \\<open>B \\<noteq> {}\\<close>, of \\<open>f \\<circ> g\\<close>]"], ["proof (state)\nthis:\n  arg_min_on (f \\<circ> g) B \\<in> B\n  \\<not> (\\<exists>x\\<in>B.\n             (f \\<circ> g) x < (f \\<circ> g) (arg_min_on (f \\<circ> g) B))\n\ngoal (1 subgoal):\n 1. arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)", "using assms * arg_min_inj_eq"], ["proof (prove)\nusing this:\n  inj_on f (g ` B)\n  finite B\n  B \\<noteq> {}\n  arg_min_on (f \\<circ> g) B \\<in> B\n  \\<not> (\\<exists>x\\<in>B.\n             (f \\<circ> g) x < (f \\<circ> g) (arg_min_on (f \\<circ> g) B))\n  \\<lbrakk>inj_on ?f {x. ?P x}; ?P ?a;\n   \\<forall>y. ?P y \\<longrightarrow> ?f ?a \\<le> ?f y\\<rbrakk>\n  \\<Longrightarrow> arg_min ?f ?P = ?a\n\ngoal (1 subgoal):\n 1. arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)", "by (smt arg_min_if_finite(1) arg_min_least \n        comp_apply finite_imageI imageE image_eqI image_is_empty inj_onD less_le)"], ["proof (state)\nthis:\n  arg_min_on f (g ` B) = g (arg_min_on (f \\<circ> g) B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_snd_arg_min_on: fixes p::\"'a \\<Rightarrow> 'b::linorder\"\n  assumes \"finite B\" \"inj_on p B\" \"B \\<noteq> {}\"\n  shows   \"fst (arg_min_on snd ((\\<lambda>x. (x, p x)) ` B)) = arg_min_on p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (arg_min_on snd ((\\<lambda>x. (x, p x)) ` B)) = arg_min_on p B", "by (subst arg_min_on_image_finite [OF inj_on_imageI]) \n     (auto simp: o_def assms)"], ["", "text \\<open>\n  The following is now the main result:\n\\<close>"], ["", "theorem treap_of_bst_of_list':\n  assumes \"ys = map (\\<lambda>x. (x, p x)) xs\" \"inj_on p (set xs)\" \"xs' = sort_key p xs\"\n  shows \"map_tree fst (treap_of (set ys)) = bst_of_list xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set ys)) = bst_of_list xs'", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  xs' = sort_key p xs\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set ys)) = bst_of_list xs'", "proof(induction xs' arbitrary: xs ys rule: bst_of_list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xs; inj_on p (set xs);\n        [] = sort_key p xs\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) = bst_of_list []\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "case 1"], ["proof (state)\nthis:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  [] = sort_key p xs\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xs; inj_on p (set xs);\n        [] = sort_key p xs\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) = bst_of_list []\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "from \\<open>[] = sort_key p xs\\<close>[symmetric] \\<open>ys = map (\\<lambda>x. (x, p x)) xs\\<close>"], ["proof (chain)\npicking this:\n  sort_key p xs = []\n  ys = map (\\<lambda>x. (x, p x)) xs", "have \"ys = []\""], ["proof (prove)\nusing this:\n  sort_key p xs = []\n  ys = map (\\<lambda>x. (x, p x)) xs\n\ngoal (1 subgoal):\n 1. ys = []", "by (cases xs) (auto)"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xs; inj_on p (set xs);\n        [] = sort_key p xs\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) = bst_of_list []\n 2. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  ys = []", "show ?case"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set ys)) = bst_of_list []", "by (simp add: treap_of.simps)"], ["proof (state)\nthis:\n  map_tree fst (treap_of (set ys)) = bst_of_list []\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "case (2 z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>?ys = map (\\<lambda>x. (x, p x)) ?xs; inj_on p (set ?xs);\n   filter (\\<lambda>y. y < z) zs = sort_key p ?xs\\<rbrakk>\n  \\<Longrightarrow> map_tree fst (treap_of (set ?ys)) =\n                    bst_of_list (filter (\\<lambda>y. y < z) zs)\n  \\<lbrakk>?ys = map (\\<lambda>x. (x, p x)) ?xs; inj_on p (set ?xs);\n   filter ((<) z) zs = sort_key p ?xs\\<rbrakk>\n  \\<Longrightarrow> map_tree fst (treap_of (set ?ys)) =\n                    bst_of_list (filter ((<) z) zs)\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "note IH = 2(1,2)"], ["proof (state)\nthis:\n  \\<lbrakk>?ys = map (\\<lambda>x. (x, p x)) ?xs; inj_on p (set ?xs);\n   filter (\\<lambda>y. y < z) zs = sort_key p ?xs\\<rbrakk>\n  \\<Longrightarrow> map_tree fst (treap_of (set ?ys)) =\n                    bst_of_list (filter (\\<lambda>y. y < z) zs)\n  \\<lbrakk>?ys = map (\\<lambda>x. (x, p x)) ?xs; inj_on p (set ?xs);\n   filter ((<) z) zs = sort_key p ?xs\\<rbrakk>\n  \\<Longrightarrow> map_tree fst (treap_of (set ?ys)) =\n                    bst_of_list (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "note assms = 2(3,4,5)"], ["proof (state)\nthis:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "define m where \"m = arg_min_on snd (set ys)\""], ["proof (state)\nthis:\n  m = arg_min_on snd (set ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "define ls where \"ls = map (\\<lambda>x. (x, p x)) [y\\<leftarrow>zs . y < z]\""], ["proof (state)\nthis:\n  ls = map (\\<lambda>x. (x, p x)) (filter (\\<lambda>y. y < z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "define rs where \"rs = map (\\<lambda>x. (x, p x)) [y\\<leftarrow>zs . y > z]\""], ["proof (state)\nthis:\n  rs = map (\\<lambda>x. (x, p x)) (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "define L where \"L = {p \\<in> (set ys). fst p < fst m}\""], ["proof (state)\nthis:\n  L = {p \\<in> set ys. fst p < fst m}\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "define R where \"R = {p \\<in> (set ys). fst p > fst m}\""], ["proof (state)\nthis:\n  R = {p \\<in> set ys. fst m < fst p}\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have h1: \"set (z#zs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (z # zs) = set xs", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. set (z # zs) = set xs", "by simp"], ["proof (state)\nthis:\n  set (z # zs) = set xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  set (z # zs) = set xs", "have h2: \"inj_on p {x \\<in> set zs. x < z}\" \"inj_on p (set (filter ((<) z) zs))\"\n    \"inj_on p (set zs)\""], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n\ngoal (1 subgoal):\n 1. inj_on p {x \\<in> set zs. x < z} &&&\n    inj_on p (set (filter ((<) z) zs)) &&& inj_on p (set zs)", "using \\<open>inj_on p (set xs)\\<close>"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p (set xs)\n\ngoal (1 subgoal):\n 1. inj_on p {x \\<in> set zs. x < z} &&&\n    inj_on p (set (filter ((<) z) zs)) &&& inj_on p (set zs)", "by (auto intro!: inj_on_subset[of _ \"set xs\"])"], ["proof (state)\nthis:\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have \"z # zs = (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z # zs =\n    (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z # zs =\n    (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))", "have \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by force"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. z # zs =\n    (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. z # zs =\n    (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))", "by (auto simp add: assms intro!: sort_key_arg_min_on)"], ["proof (state)\nthis:\n  z # zs = (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z # zs = (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "then"], ["proof (chain)\npicking this:\n  z # zs = (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))", "have h3: \"z = arg_min_on p (set xs)\" \"zs = sort_key p (remove1 z xs)\""], ["proof (prove)\nusing this:\n  z # zs = (let z = arg_min_on p (set xs) in z # sort_key p (remove1 z xs))\n\ngoal (1 subgoal):\n 1. z = arg_min_on p (set xs) &&& zs = sort_key p (remove1 z xs)", "unfolding Let_def"], ["proof (prove)\nusing this:\n  z # zs =\n  arg_min_on p (set xs) # sort_key p (remove1 (arg_min_on p (set xs)) xs)\n\ngoal (1 subgoal):\n 1. z = arg_min_on p (set xs) &&& zs = sort_key p (remove1 z xs)", "by auto"], ["proof (state)\nthis:\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have h4: \"sort_key p zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "have \"linorder_class.sorted (map p (z#zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder_class.sorted (map p (z # zs))", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. linorder_class.sorted (map p (z # zs))", "by simp"], ["proof (state)\nthis:\n  linorder_class.sorted (map p (z # zs))\n\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "then"], ["proof (chain)\npicking this:\n  linorder_class.sorted (map p (z # zs))", "have \"linorder_class.sorted (map p zs)\""], ["proof (prove)\nusing this:\n  linorder_class.sorted (map p (z # zs))\n\ngoal (1 subgoal):\n 1. linorder_class.sorted (map p zs)", "by auto"], ["proof (state)\nthis:\n  linorder_class.sorted (map p zs)\n\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "then"], ["proof (chain)\npicking this:\n  linorder_class.sorted (map p zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  linorder_class.sorted (map p zs)\n\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "using h1 h2 sort_key_inj_key_eq"], ["proof (prove)\nusing this:\n  linorder_class.sorted (map p zs)\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  \\<lbrakk>mset ?xs = mset ?ys; inj_on ?f (set ?xs);\n   linorder_class.sorted (map ?f ?ys)\\<rbrakk>\n  \\<Longrightarrow> sort_key ?f ?xs = ?ys\n\ngoal (1 subgoal):\n 1. sort_key p zs = zs", "by blast"], ["proof (state)\nthis:\n  sort_key p zs = zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sort_key p zs = zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "note helpers = h1 h2 h3 h4"], ["proof (state)\nthis:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have \"fst m = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst m = z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst m = z", "have \"fst m = arg_min_on p (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst m = arg_min_on p (set xs)", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (arg_min_on snd (set ys)) = arg_min_on p (set xs)", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. fst (arg_min_on snd (set ys)) = arg_min_on p (set xs)", "by (auto intro!: fst_snd_arg_min_on)"], ["proof (state)\nthis:\n  fst m = arg_min_on p (set xs)\n\ngoal (1 subgoal):\n 1. fst m = z", "also"], ["proof (state)\nthis:\n  fst m = arg_min_on p (set xs)\n\ngoal (1 subgoal):\n 1. fst m = z", "have \"\\<dots> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_min_on p (set xs) = z", "using helpers"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n\ngoal (1 subgoal):\n 1. arg_min_on p (set xs) = z", "by auto"], ["proof (state)\nthis:\n  arg_min_on p (set xs) = z\n\ngoal (1 subgoal):\n 1. fst m = z", "finally"], ["proof (chain)\npicking this:\n  fst m = z", "show ?thesis"], ["proof (prove)\nusing this:\n  fst m = z\n\ngoal (1 subgoal):\n 1. fst m = z", "."], ["proof (state)\nthis:\n  fst m = z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst m = z\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "moreover"], ["proof (state)\nthis:\n  fst m = z\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have \"map_tree fst (treap_of L) = bst_of_list [y\\<leftarrow>zs . y < z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "have \"L = set ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = set ls", "unfolding L_def ls_def \\<open>fst m = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> set ys. fst p < z} =\n    set (map (\\<lambda>x. (x, p x)) (filter (\\<lambda>y. y < z) zs))", "using helpers assms"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. {p \\<in> set ys. fst p < z} =\n    set (map (\\<lambda>x. (x, p x)) (filter (\\<lambda>y. y < z) zs))", "by force"], ["proof (state)\nthis:\n  L = set ls\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "moreover"], ["proof (state)\nthis:\n  L = set ls\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "have \"map_tree fst (treap_of (set ls)) = bst_of_list [y\\<leftarrow>zs . y < z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set ls)) =\n    bst_of_list (filter (\\<lambda>y. y < z) zs)", "unfolding ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst\n     (treap_of\n       (set (map (\\<lambda>x. (x, p x)) (filter (\\<lambda>y. y < z) zs)))) =\n    bst_of_list (filter (\\<lambda>y. y < z) zs)", "using helpers"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n\ngoal (1 subgoal):\n 1. map_tree fst\n     (treap_of\n       (set (map (\\<lambda>x. (x, p x)) (filter (\\<lambda>y. y < z) zs)))) =\n    bst_of_list (filter (\\<lambda>y. y < z) zs)", "by (intro IH(1)[of _ \"[y\\<leftarrow>zs . y < z]\"]) (auto simp add: filter_sort[symmetric])"], ["proof (state)\nthis:\n  map_tree fst (treap_of (set ls)) =\n  bst_of_list (filter (\\<lambda>y. y < z) zs)\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "ultimately"], ["proof (chain)\npicking this:\n  L = set ls\n  map_tree fst (treap_of (set ls)) =\n  bst_of_list (filter (\\<lambda>y. y < z) zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = set ls\n  map_tree fst (treap_of (set ls)) =\n  bst_of_list (filter (\\<lambda>y. y < z) zs)\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)", "by blast"], ["proof (state)\nthis:\n  map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "moreover"], ["proof (state)\nthis:\n  map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have \"map_tree fst (treap_of R) = bst_of_list [y\\<leftarrow>zs . z < y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "have 0: \"R = set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = set rs", "unfolding R_def rs_def \\<open>fst m = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> set ys. z < fst p} =\n    set (map (\\<lambda>x. (x, p x)) (filter ((<) z) zs))", "using helpers assms"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. {p \\<in> set ys. z < fst p} =\n    set (map (\\<lambda>x. (x, p x)) (filter ((<) z) zs))", "by force"], ["proof (state)\nthis:\n  R = set rs\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "moreover"], ["proof (state)\nthis:\n  R = set rs\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "have \"map_tree fst (treap_of (set rs)) = bst_of_list [y\\<leftarrow>zs . z < y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set rs)) = bst_of_list (filter ((<) z) zs)", "unfolding rs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree fst\n     (treap_of (set (map (\\<lambda>x. (x, p x)) (filter ((<) z) zs)))) =\n    bst_of_list (filter ((<) z) zs)", "using helpers"], ["proof (prove)\nusing this:\n  set (z # zs) = set xs\n  inj_on p {x \\<in> set zs. x < z}\n  inj_on p (set (filter ((<) z) zs))\n  inj_on p (set zs)\n  z = arg_min_on p (set xs)\n  zs = sort_key p (remove1 z xs)\n  sort_key p zs = zs\n\ngoal (1 subgoal):\n 1. map_tree fst\n     (treap_of (set (map (\\<lambda>x. (x, p x)) (filter ((<) z) zs)))) =\n    bst_of_list (filter ((<) z) zs)", "by (intro IH(2)[of _ \"[y\\<leftarrow>zs . z < y]\"]) (auto simp add: filter_sort[symmetric])"], ["proof (state)\nthis:\n  map_tree fst (treap_of (set rs)) = bst_of_list (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "ultimately"], ["proof (chain)\npicking this:\n  R = set rs\n  map_tree fst (treap_of (set rs)) = bst_of_list (filter ((<) z) zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  R = set rs\n  map_tree fst (treap_of (set rs)) = bst_of_list (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)", "by blast"], ["proof (state)\nthis:\n  map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "moreover"], ["proof (state)\nthis:\n  map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "have \"treap_of (set ys) = \\<langle>treap_of L, m, treap_of R\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treap_of (set ys) = \\<langle>treap_of L, m, treap_of R\\<rangle>", "unfolding L_def m_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. treap_of (set ys) =\n    \\<langle>treap_of\n              {p \\<in> set ys. fst p < fst (arg_min_on snd (set ys))},\n     arg_min_on snd (set ys),\n     treap_of\n      {p \\<in> set ys. fst (arg_min_on snd (set ys)) < fst p}\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. (x, p x)) xs\n  inj_on p (set xs)\n  z # zs = sort_key p xs\n\ngoal (1 subgoal):\n 1. treap_of (set ys) =\n    \\<langle>treap_of\n              {p \\<in> set ys. fst p < fst (arg_min_on snd (set ys))},\n     arg_min_on snd (set ys),\n     treap_of\n      {p \\<in> set ys. fst (arg_min_on snd (set ys)) < fst p}\\<rangle>", "by (auto simp add: treap_of.simps Let_def)"], ["proof (state)\nthis:\n  treap_of (set ys) = \\<langle>treap_of L, m, treap_of R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa;\n                    inj_on p (set xsa);\n                    filter (\\<lambda>y. y < x) xs = sort_key p xsa\\<rbrakk>\n                   \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                                     bst_of_list\n(filter (\\<lambda>y. y < x) xs);\n        \\<And>xsa ys.\n           \\<lbrakk>ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n            filter ((<) x) xs = sort_key p xsa\\<rbrakk>\n           \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                             bst_of_list (filter ((<) x) xs);\n        ys = map (\\<lambda>x. (x, p x)) xsa; inj_on p (set xsa);\n        x # xs = sort_key p xsa\\<rbrakk>\n       \\<Longrightarrow> map_tree fst (treap_of (set ys)) =\n                         bst_of_list (x # xs)", "ultimately"], ["proof (chain)\npicking this:\n  fst m = z\n  map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)\n  map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)\n  treap_of (set ys) = \\<langle>treap_of L, m, treap_of R\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  fst m = z\n  map_tree fst (treap_of L) = bst_of_list (filter (\\<lambda>y. y < z) zs)\n  map_tree fst (treap_of R) = bst_of_list (filter ((<) z) zs)\n  treap_of (set ys) = \\<langle>treap_of L, m, treap_of R\\<rangle>\n\ngoal (1 subgoal):\n 1. map_tree fst (treap_of (set ys)) = bst_of_list (z # zs)", "by auto"], ["proof (state)\nthis:\n  map_tree fst (treap_of (set ys)) = bst_of_list (z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary treap_of_bst_of_list: \"inj_on p (set zs) \\<Longrightarrow>\n   map_tree fst (treap_of (set (map (\\<lambda>x. (x, p x)) zs))) = bst_of_list (sort_key p zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on p (set zs) \\<Longrightarrow>\n    map_tree fst (treap_of (set (map (\\<lambda>x. (x, p x)) zs))) =\n    bst_of_list (sort_key p zs)", "using treap_of_bst_of_list'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ys = map (\\<lambda>x. (x, ?p x)) ?xs; inj_on ?p (set ?xs);\n   ?xs' = sort_key ?p ?xs\\<rbrakk>\n  \\<Longrightarrow> map_tree fst (treap_of (set ?ys)) = bst_of_list ?xs'\n\ngoal (1 subgoal):\n 1. inj_on p (set zs) \\<Longrightarrow>\n    map_tree fst (treap_of (set (map (\\<lambda>x. (x, p x)) zs))) =\n    bst_of_list (sort_key p zs)", "by blast"], ["", "corollary treap_of_bst_of_list'': \"inj_on p (set zs) \\<Longrightarrow>\n   map_tree fst (treap_of ((\\<lambda>x. (x, p x)) ` set zs)) = bst_of_list (sort_key p zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on p (set zs) \\<Longrightarrow>\n    map_tree fst (treap_of ((\\<lambda>x. (x, p x)) ` set zs)) =\n    bst_of_list (sort_key p zs)", "using treap_of_bst_of_list"], ["proof (prove)\nusing this:\n  inj_on ?p (set ?zs) \\<Longrightarrow>\n  map_tree fst (treap_of (set (map (\\<lambda>x. (x, ?p x)) ?zs))) =\n  bst_of_list (sort_key ?p ?zs)\n\ngoal (1 subgoal):\n 1. inj_on p (set zs) \\<Longrightarrow>\n    map_tree fst (treap_of ((\\<lambda>x. (x, p x)) ` set zs)) =\n    bst_of_list (sort_key p zs)", "by auto"], ["", "corollary fold_ins_bst_of_list: \"distinct zs \\<Longrightarrow> inj_on p (set zs) \\<Longrightarrow>\n   map_tree fst (foldl (\\<lambda>t (x,p). ins x p t) \\<langle>\\<rangle> (map (\\<lambda>x. (x, p x)) zs)) = bst_of_list (sort_key p zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct zs; inj_on p (set zs)\\<rbrakk>\n    \\<Longrightarrow> map_tree fst\n                       (foldl (\\<lambda>t (x, p). ins x p t)\n                         \\<langle>\\<rangle>\n                         (map (\\<lambda>x. (x, p x)) zs)) =\n                      bst_of_list (sort_key p zs)", "by (auto simp add: foldl_ins_treap_of distinct_map inj_on_def inj_on_convol_ident\n                     treap_of_bst_of_list'')"], ["", "end"]]}