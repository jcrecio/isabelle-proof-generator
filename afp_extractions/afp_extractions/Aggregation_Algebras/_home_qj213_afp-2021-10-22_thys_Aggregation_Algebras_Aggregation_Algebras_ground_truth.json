{"file_name": "/home/qj213/afp-2021-10-22/thys/Aggregation_Algebras/Aggregation_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Aggregation_Algebras", "problem_names": ["lemma sum_disjoint:\n  assumes \"x \\<sqinter> y = bot\"\n    shows \"sum ((x \\<squnion> y) \\<sqinter> z) = sum (x \\<sqinter> z) + sum (y \\<sqinter> z)\"", "lemma sum_disjoint_3:\n  assumes \"w \\<sqinter> x = bot\"\n      and \"w \\<sqinter> y = bot\"\n      and \"x \\<sqinter> y = bot\"\n    shows \"sum ((w \\<squnion> x \\<squnion> y) \\<sqinter> z) = sum (w \\<sqinter> z) + sum (x \\<sqinter> z) + sum (y \\<sqinter> z)\"", "lemma sum_symmetric:\n  assumes \"y = y\\<^sup>T\"\n    shows \"sum (x\\<^sup>T \\<sqinter> y) = sum (x \\<sqinter> y)\"", "lemma sum_commute:\n  \"sum x + sum y = sum y + sum x\"", "lemma minarc_bot:\n  \"minarc bot = bot\"", "lemma minarc_bot_iff:\n  \"minarc x = bot \\<longleftrightarrow> x = bot\"", "lemma minarc_meet_bot:\n  assumes \"minarc x \\<sqinter> x = bot\"\n    shows \"minarc x = bot\"", "lemma minarc_meet_bot_minarc_iff:\n  \"minarc x \\<sqinter> x = bot \\<longleftrightarrow> minarc x = bot\"", "lemma minarc_meet_bot_iff:\n  \"minarc x \\<sqinter> x = bot \\<longleftrightarrow> x = bot\"", "lemma minarc_regular:\n  \"regular (minarc x)\"", "lemma minarc_selection:\n  \"selection (minarc x \\<sqinter> y) y\"", "lemma minarc_below_regular:\n  \"regular x \\<Longrightarrow> minarc x \\<le> x\""], "translations": [["", "lemma sum_disjoint:\n  assumes \"x \\<sqinter> y = bot\"\n    shows \"sum ((x \\<squnion> y) \\<sqinter> z) = sum (x \\<sqinter> z) + sum (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum ((x \\<squnion> y) \\<sqinter> z) =\n    sum_class.sum (x \\<sqinter> z) + sum_class.sum (y \\<sqinter> z)", "by (subst sum_plus) (metis assms inf.sup_monoid.add_assoc inf.sup_monoid.add_commute inf_bot_left inf_sup_distrib2 sum_bot)"], ["", "lemma sum_disjoint_3:\n  assumes \"w \\<sqinter> x = bot\"\n      and \"w \\<sqinter> y = bot\"\n      and \"x \\<sqinter> y = bot\"\n    shows \"sum ((w \\<squnion> x \\<squnion> y) \\<sqinter> z) = sum (w \\<sqinter> z) + sum (x \\<sqinter> z) + sum (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum ((w \\<squnion> x \\<squnion> y) \\<sqinter> z) =\n    sum_class.sum (w \\<sqinter> z) + sum_class.sum (x \\<sqinter> z) +\n    sum_class.sum (y \\<sqinter> z)", "by (metis assms inf_sup_distrib2 sup_idem sum_disjoint)"], ["", "lemma sum_symmetric:\n  assumes \"y = y\\<^sup>T\"\n    shows \"sum (x\\<^sup>T \\<sqinter> y) = sum (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum (x\\<^sup>T \\<sqinter> y) = sum_class.sum (x \\<sqinter> y)", "by (metis assms sum_conv conv_dist_inf)"], ["", "lemma sum_commute:\n  \"sum x + sum y = sum y + sum x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_class.sum x + sum_class.sum y = sum_class.sum y + sum_class.sum x", "by (metis inf_commute sum_plus sup_commute)"], ["", "end"], ["", "text \\<open>\nWe next introduce the operation \\<open>minarc\\<close>.\nAxiom \\<open>minarc_below\\<close> expresses that the result of \\<open>minarc\\<close> is contained in the graph ignoring the weights.\nAxiom \\<open>minarc_arc\\<close> states that the result of \\<open>minarc\\<close> is a single unweighted edge if the graph is not empty.\nAxiom \\<open>minarc_min\\<close> specifies that any edge in the graph weighs at least as much as the edge at the position indicated by the result of \\<open>minarc\\<close>, where weights of edges between different nodes are compared by applying the operation \\<open>sum\\<close> to single-edge graphs.\nAxiom \\<open>sum_linear\\<close> requires that aggregated weights are linearly ordered, which is necessary for both Prim's and Kruskal's minimum spanning tree algorithms.\nAxiom \\<open>finite_regular\\<close> ensures that there are only finitely many unweighted graphs, and therefore only finitely many edges and nodes in a graph; again this is necessary for the minimum spanning tree algorithms we consider.\n\\<close>"], ["", "class minarc =\n  fixes minarc :: \"'a \\<Rightarrow> 'a\""], ["", "class m_algebra = s_algebra + minarc +\n  assumes minarc_below: \"minarc x \\<le> --x\"\n  assumes minarc_arc: \"x \\<noteq> bot \\<longrightarrow> arc (minarc x)\"\n  assumes minarc_min: \"arc y \\<and> y \\<sqinter> x \\<noteq> bot \\<longrightarrow> sum (minarc x \\<sqinter> x) \\<le> sum (y \\<sqinter> x)\"\n  assumes sum_linear: \"sum x \\<le> sum y \\<or> sum y \\<le> sum x\"\n  assumes finite_regular: \"finite { x . regular x }\"\nbegin"], ["", "text \\<open>\nAxioms \\<open>minarc_below\\<close> and \\<open>minarc_arc\\<close> suffice to derive the Tarski rule in Stone relation algebras.\n\\<close>"], ["", "subclass stone_relation_algebra_tarski"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_relation_algebra_tarski (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top uminus (1::'a) (*) conv", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "let ?a = \"minarc x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "assume 1: \"regular x\""], ["proof (state)\nthis:\n  regular x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "assume \"x \\<noteq> bot\""], ["proof (state)\nthis:\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "hence \"arc ?a\""], ["proof (prove)\nusing this:\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. arc (minarc x)", "by (simp add: minarc_arc)"], ["proof (state)\nthis:\n  arc (minarc x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "hence \"top = top * ?a * top\""], ["proof (prove)\nusing this:\n  arc (minarc x)\n\ngoal (1 subgoal):\n 1. top = top * minarc x * top", "by (simp add: comp_associative)"], ["proof (state)\nthis:\n  top = top * minarc x * top\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "also"], ["proof (state)\nthis:\n  top = top * minarc x * top\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "have \"... \\<le> top * --x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * minarc x * top \\<le> top * - - x * top", "by (simp add: minarc_below mult_isotone)"], ["proof (state)\nthis:\n  top * minarc x * top \\<le> top * - - x * top\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "finally"], ["proof (chain)\npicking this:\n  top \\<le> top * - - x * top", "show \"top * x * top = top\""], ["proof (prove)\nusing this:\n  top \\<le> top * - - x * top\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * x)", "using 1 antisym"], ["proof (prove)\nusing this:\n  top \\<le> top * - - x * top\n  regular x\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * x)", "by simp"], ["proof (state)\nthis:\n  times_top_class.total (top * x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minarc_bot:\n  \"minarc bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc bot = bot", "by (metis bot_unique minarc_below regular_closed_bot)"], ["", "lemma minarc_bot_iff:\n  \"minarc x = bot \\<longleftrightarrow> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (minarc x = bot) = (x = bot)", "using covector_bot_closed inf_bot_right minarc_arc vector_bot_closed minarc_bot"], ["proof (prove)\nusing this:\n  covector bot\n  ?x \\<sqinter> bot = bot\n  ?x \\<noteq> bot \\<longrightarrow> arc (minarc ?x)\n  vector bot\n  minarc bot = bot\n\ngoal (1 subgoal):\n 1. (minarc x = bot) = (x = bot)", "by fastforce"], ["", "lemma minarc_meet_bot:\n  assumes \"minarc x \\<sqinter> x = bot\"\n    shows \"minarc x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc x = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. minarc x = bot", "have \"minarc x \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minarc x \\<le> - x", "using assms pseudo_complement"], ["proof (prove)\nusing this:\n  minarc x \\<sqinter> x = bot\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. minarc x \\<le> - x", "by auto"], ["proof (state)\nthis:\n  minarc x \\<le> - x\n\ngoal (1 subgoal):\n 1. minarc x = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  minarc x \\<le> - x\n\ngoal (1 subgoal):\n 1. minarc x = bot", "by (metis minarc_below inf_absorb1 inf_import_p inf_p)"], ["proof (state)\nthis:\n  minarc x = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minarc_meet_bot_minarc_iff:\n  \"minarc x \\<sqinter> x = bot \\<longleftrightarrow> minarc x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (minarc x \\<sqinter> x = bot) = (minarc x = bot)", "using comp_inf.semiring.mult_not_zero minarc_meet_bot"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b \\<noteq> bot \\<Longrightarrow>\n  ?a \\<noteq> bot \\<and> ?b \\<noteq> bot\n  minarc ?x \\<sqinter> ?x = bot \\<Longrightarrow> minarc ?x = bot\n\ngoal (1 subgoal):\n 1. (minarc x \\<sqinter> x = bot) = (minarc x = bot)", "by blast"], ["", "lemma minarc_meet_bot_iff:\n  \"minarc x \\<sqinter> x = bot \\<longleftrightarrow> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (minarc x \\<sqinter> x = bot) = (x = bot)", "using inf_bot_right minarc_bot_iff minarc_meet_bot"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> bot = bot\n  (minarc ?x = bot) = (?x = bot)\n  minarc ?x \\<sqinter> ?x = bot \\<Longrightarrow> minarc ?x = bot\n\ngoal (1 subgoal):\n 1. (minarc x \\<sqinter> x = bot) = (x = bot)", "by blast"], ["", "lemma minarc_regular:\n  \"regular (minarc x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (minarc x)", "proof (cases \"x = bot\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = bot \\<Longrightarrow> regular (minarc x)\n 2. x \\<noteq> bot \\<Longrightarrow> regular (minarc x)", "assume \"x = bot\""], ["proof (state)\nthis:\n  x = bot\n\ngoal (2 subgoals):\n 1. x = bot \\<Longrightarrow> regular (minarc x)\n 2. x \\<noteq> bot \\<Longrightarrow> regular (minarc x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = bot\n\ngoal (1 subgoal):\n 1. regular (minarc x)", "by (simp add: minarc_bot)"], ["proof (state)\nthis:\n  regular (minarc x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> bot \\<Longrightarrow> regular (minarc x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> bot \\<Longrightarrow> regular (minarc x)", "assume \"x \\<noteq> bot\""], ["proof (state)\nthis:\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. x \\<noteq> bot \\<Longrightarrow> regular (minarc x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. regular (minarc x)", "by (simp add: arc_regular minarc_arc)"], ["proof (state)\nthis:\n  regular (minarc x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minarc_selection:\n  \"selection (minarc x \\<sqinter> y) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selection (minarc x \\<sqinter> y) y", "using inf_assoc minarc_regular selection_closed_id"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n  regular (minarc ?x)\n  selection ?x ?x\n\ngoal (1 subgoal):\n 1. selection (minarc x \\<sqinter> y) y", "by auto"], ["", "lemma minarc_below_regular:\n  \"regular x \\<Longrightarrow> minarc x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x \\<Longrightarrow> minarc x \\<le> x", "by (metis minarc_below)"], ["", "(*\nlemma sum_bot: \"sum bot = bot\" nitpick [expect=genuine] oops\nlemma plus_bot: \"x + bot = x\" nitpick [expect=genuine] oops\nlemma \"sum x = bot \\<longrightarrow> x = bot\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "class m_kleene_algebra = m_algebra + stone_kleene_relation_algebra"], ["", "end"]]}