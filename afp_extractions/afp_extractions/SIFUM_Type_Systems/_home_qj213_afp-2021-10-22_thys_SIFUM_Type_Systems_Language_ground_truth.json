{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems/Language.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems", "problem_names": ["lemma cxt_inv:\n  \"\\<lbrakk> cxt_to_stmt E c = c' ; \\<And> p q. c' \\<noteq> Seq p q \\<rbrakk> \\<Longrightarrow> E = [] \\<and> c' = c\"", "lemma cxt_inv_assign:\n  \"\\<lbrakk> cxt_to_stmt E c = x \\<leftarrow> e \\<rbrakk> \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\"", "lemma cxt_inv_skip:\n  \"\\<lbrakk> cxt_to_stmt E c = Skip \\<rbrakk> \\<Longrightarrow> c = Skip \\<and> E = []\"", "lemma cxt_inv_stop:\n  \"cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []\"", "lemma cxt_inv_if:\n  \"cxt_to_stmt E c = If e p q \\<Longrightarrow> c = If e p q \\<and> E = []\"", "lemma cxt_inv_while:\n  \"cxt_to_stmt E c = While e p \\<Longrightarrow> c = While e p \\<and> E = []\"", "lemma skip_elim [elim]:\n  \"\\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\"", "lemma assign_elim [elim]:\n  \"\\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem' = mem (x := eval\\<^sub>A mem e)\"", "lemma if_elim [elim]:\n  \"\\<And> P.\n    \\<lbrakk> \\<langle>If b p q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ;\n     \\<lbrakk> c' = p; mem' = mem ; mds' = mds ; eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P ;\n     \\<lbrakk> c' = q; mem' = mem ; mds' = mds ; \\<not> eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma while_elim [elim]:\n  \"\\<lbrakk> \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> c' = If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem\"", "lemma upd_elim [elim]:\n  \"\\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> \\<langle>c, update_modes upd mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\"", "lemma cxt_seq_elim [elim]:\n  \"c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow> (E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2) \\<or> (\\<exists> c' cs. E = c' # cs \\<and> c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\"", "lemma stop_no_eval: \"\\<not> (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\"", "lemma seq_stop_elim [elim]:\n  \"\\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\"", "lemma cxt_stmt_seq:\n  \"c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c\"", "lemma seq_elim [elim]:\n  \"\\<lbrakk> \\<langle>c\\<^sub>1 ;; c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ; c\\<^sub>1 \\<noteq> Stop \\<rbrakk> \\<Longrightarrow>\n  (\\<exists> c\\<^sub>1'. \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and> c' = c\\<^sub>1' ;; c\\<^sub>2)\"", "lemma stop_cxt: \"Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop\""], "translations": [["", "lemma cxt_inv:\n  \"\\<lbrakk> cxt_to_stmt E c = c' ; \\<And> p q. c' \\<noteq> Seq p q \\<rbrakk> \\<Longrightarrow> E = [] \\<and> c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cxt_to_stmt E c = c'; \\<And>p q. c' \\<noteq> p ;; q\\<rbrakk>\n    \\<Longrightarrow> E = [] \\<and> c' = c", "by (metis cxt_to_stmt.simps(1) cxt_to_stmt.simps(2) neq_Nil_conv)"], ["", "lemma cxt_inv_assign:\n  \"\\<lbrakk> cxt_to_stmt E c = x \\<leftarrow> e \\<rbrakk> \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = x \\<leftarrow> e \\<Longrightarrow>\n    c = x \\<leftarrow> e \\<and> E = []", "by (metis Stmt.simps(11) cxt_inv)"], ["", "lemma cxt_inv_skip:\n  \"\\<lbrakk> cxt_to_stmt E c = Skip \\<rbrakk> \\<Longrightarrow> c = Skip \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Skip \\<Longrightarrow> c = Skip \\<and> E = []", "by (metis Stmt.simps(21) cxt_inv)"], ["", "lemma cxt_inv_stop:\n  \"cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []", "by (metis Stmt.simps(40) cxt_inv)"], ["", "lemma cxt_inv_if:\n  \"cxt_to_stmt E c = If e p q \\<Longrightarrow> c = If e p q \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Stmt.If e p q \\<Longrightarrow>\n    c = Stmt.If e p q \\<and> E = []", "by (metis Stmt.simps(37) cxt_inv)"], ["", "lemma cxt_inv_while:\n  \"cxt_to_stmt E c = While e p \\<Longrightarrow> c = While e p \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = While e p \\<Longrightarrow>\n    c = While e p \\<and> E = []", "by (metis Stmt.simps(39) cxt_inv)"], ["", "lemma skip_elim [elim]:\n  \"\\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E c; c' = cxt_to_stmt E c'a; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Skip = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (metis (lifting) cxt_inv_skip cxt_to_stmt.simps(1) skip_elim')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Skip = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (metis Stmt.simps(20))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "by (metis Stmt.simps(18) cxt_inv_skip)"], ["", "lemma assign_elim [elim]:\n  \"\\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem' = mem (x := eval\\<^sub>A mem e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop \\<and> mds = mds' \\<and> mem' = mem(x := eval\\<^sub>A mem e)", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply (rename_tac c c'a E)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply (subgoal_tac \"c = x \\<leftarrow> e \\<and> E = []\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem');\n        c = x \\<leftarrow> e \\<and> E = []\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\n 3. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c = cxt_to_stmt E c\n 2. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> E = []\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 5. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis cxt_inv_assign)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> E = []\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis cxt_inv_assign)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis Stmt.simps(8) cxt_inv_assign)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis Stmt.simps(8) cxt_inv_assign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "by (metis Stmt.simps(8) cxt_inv_assign)"], ["", "inductive_cases if_elim' [elim!]: \"(If b p q, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma if_elim [elim]:\n  \"\\<And> P.\n    \\<lbrakk> \\<langle>If b p q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ;\n     \\<lbrakk> c' = p; mem' = mem ; mds' = mds ; eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P ;\n     \\<lbrakk> c' = q; mem' = mem ; mds' = mds ; \\<not> eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<langle>Stmt.If b p\n                          q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        \\<lbrakk>c' = p; mem' = mem; mds' = mds; eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P c c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E c; c' = cxt_to_stmt E c'a; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis (no_types) cxt_inv_if cxt_to_stmt.simps(1) if_elim')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis Stmt.simps(36))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P", "by (metis Stmt.simps(30) cxt_inv_if)"], ["", "inductive_cases while_elim' [elim!]: \"(While e c, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma while_elim [elim]:\n  \"\\<lbrakk> \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> c' = If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stmt.If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E ca; c' = cxt_to_stmt E c'a;\n        mds' = mds; (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>While e c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "apply (metis (no_types) cxt_inv_while cxt_to_stmt.simps(1) while_elim')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>While e c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "apply (metis Stmt.simps(38))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "by (metis (lifting) Stmt.simps(33) cxt_inv_while)"], ["", "inductive_cases upd_elim' [elim]: \"(c@[upd], mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma upd_elim [elim]:\n  \"\\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> \\<langle>c, update_modes upd mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    \\<langle>c, update_modes upd\n                 mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E ca; c' = cxt_to_stmt E c'a;\n        mds' = mds; (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>c@[upd] = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (metis (lifting) Stmt.simps(28) cxt_inv upd_elim')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>c@[upd] = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (metis Stmt.simps(29))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "by (metis (lifting) Stmt.simps(2) Stmt.simps(29) cxt_inv cxt_to_stmt.simps(1))"], ["", "lemma cxt_seq_elim [elim]:\n  \"c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow> (E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2) \\<or> (\\<exists> c' cs. E = c' # cs \\<and> c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow>\n    E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n    (\\<exists>c' cs.\n        E = c' # cs \\<and>\n        c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')", "apply (cases E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c; E = []\\<rbrakk>\n    \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                      (\\<exists>c' cs.\n                          E = c' # cs \\<and>\n                          c = c\\<^sub>1 \\<and>\n                          c\\<^sub>2 = cxt_to_stmt cs c')\n 2. \\<And>a list.\n       \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        E = a # list\\<rbrakk>\n       \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                         (\\<exists>c' cs.\n                             E = c' # cs \\<and>\n                             c = c\\<^sub>1 \\<and>\n                             c\\<^sub>2 = cxt_to_stmt cs c')", "apply (metis cxt_to_stmt.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        E = a # list\\<rbrakk>\n       \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                         (\\<exists>c' cs.\n                             E = c' # cs \\<and>\n                             c = c\\<^sub>1 \\<and>\n                             c\\<^sub>2 = cxt_to_stmt cs c')", "by (metis Stmt.simps(3) cxt_to_stmt.simps(2))"], ["", "inductive_cases seq_elim' [elim]: \"(c\\<^sub>1 ;; c\\<^sub>2, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma stop_no_eval: \"\\<not> (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w,\n     \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\n    \\<notin> eval\\<^sub>w", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    False", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E c; c' = cxt_to_stmt E c'a; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis cxt_inv_stop stop_no_eval')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Stmt.simps(41))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Stmt.simps(35) cxt_inv_stop)"], ["", "lemma seq_stop_elim [elim]:\n  \"\\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E ca; c' = cxt_to_stmt E c'a;\n        mds' = mds; (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E ca; mds' = mds;\n        (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem');\n        c' = cxt_to_stmt E c'a\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = c \\<and>\n                         mds = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (metis (no_types) cxt_seq_elim cxt_to_stmt.simps(1) seq_elim' stop_no_eval')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (metis Stmt.inject(3) stop_no_eval)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "by (metis Stmt.distinct(23) Stmt.distinct(29) cxt_seq_elim)"], ["", "lemma cxt_stmt_seq:\n  \"c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c", "by (metis cxt_to_stmt.simps(2))"], ["", "lemma seq_elim [elim]:\n  \"\\<lbrakk> \\<langle>c\\<^sub>1 ;; c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ; c\\<^sub>1 \\<noteq> Stop \\<rbrakk> \\<Longrightarrow>\n  (\\<exists> c\\<^sub>1'. \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and> c' = c\\<^sub>1' ;; c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c\\<^sub>1 ;;\n                      c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n             \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n     c\\<^sub>1 \\<noteq> Stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                         c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (erule eval_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c; c' = cxt_to_stmt E c'a;\n        mds' = mds; (c, mem) \\<leadsto>\\<^sub>s (c'a, mem')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem');\n        c' = cxt_to_stmt E c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (drule cxt_seq_elim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n        (\\<exists>c' cs.\n            E = c' # cs \\<and>\n            c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (erule disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        \\<exists>c' cs.\n           E = c' # cs \\<and>\n           c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (metis seq_elim')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop; mds' = mds;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        \\<exists>c' cs.\n           E = c' # cs \\<and>\n           c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c'a c'aa cs.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop; mds' = mds;\n        (c\\<^sub>1, mem) \\<leadsto>\\<^sub>s (c'a, mem');\n        c' = c'a ;; cxt_to_stmt cs c'aa;\n        c\\<^sub>2 = cxt_to_stmt cs c'aa\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c'a, mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2", "apply (metis cxt_to_stmt.simps(1) eval\\<^sub>w.unannotated)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2", "apply (subgoal_tac \"c\\<^sub>1 = (c@[mu])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>(c@[mu]) ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c@[mu], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply (drule cxt_seq_elim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu];\n        E = [] \\<and> c@[mu] = (c@[mu]) ;; c\\<^sub>2 \\<or>\n        (\\<exists>c' cs.\n            E = c' # cs \\<and>\n            c@[mu] = c@[mu] \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c@[mu], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply (metis Stmt.distinct(23) cxt_stmt_seq cxt_to_stmt.simps(1) eval\\<^sub>w.decl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "by (metis Stmt.distinct(23) cxt_seq_elim)"], ["", "lemma stop_cxt: \"Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop", "by (metis Stmt.simps(41) cxt_to_stmt.simps(1) cxt_to_stmt.simps(2) neq_Nil_conv)"], ["", "end"], ["", "end"]]}