{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems/Compositionality.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems", "problem_names": ["lemma differing_finite: \"finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)\"", "lemma differing_lists_finite: \"finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)\"", "lemma subst_not_in_dom : \"\\<lbrakk> x \\<notin> dom \\<sigma> \\<rbrakk> \\<Longrightarrow> mem [\\<mapsto> \\<sigma>] x = mem x\"", "lemma makes_compatible_intro [intro]:\n  \"\\<lbrakk> length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems;\n     (\\<And> i \\<sigma>. \\<lbrakk> i < length cms\\<^sub>1; dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n          (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>]));\n     (\\<And> i x. \\<lbrakk> i < length cms\\<^sub>1; mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<rbrakk> \\<Longrightarrow> \n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i);\n     (length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n     (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i) \\<rbrakk> \\<Longrightarrow>\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"", "lemma compat_low:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> dma x = Low\"", "lemma compat_different:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and> dma x = Low\"", "lemma sound_modes_no_read :\n  \"\\<lbrakk> sound_mode_use (cms, mem); x \\<in> (map snd cms ! i) GuarNoRead; i < length cms \\<rbrakk> \\<Longrightarrow>\n  doesnt_read (fst (cms ! i)) x\"", "lemma compat_different_vars:\n  \"\\<lbrakk> fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\"", "lemma differing_vars_subst [rule_format]:\n  assumes dom\\<sigma>: \"dom \\<sigma> \\<supseteq> differing_vars mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] = mem\\<^sub>2 [\\<mapsto> \\<sigma>]\"", "lemma mm_equiv_low_eq:\n  \"\\<lbrakk> \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\"", "lemma globally_sound_modes_compatible:\n  \"\\<lbrakk> globally_sound_mode_use (cms, mem) \\<rbrakk> \\<Longrightarrow> compatible_modes (map snd cms)\"", "lemma compatible_different_no_read :\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                       \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes x: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read (fst (cms\\<^sub>2 ! i)) x\"", "lemma change_respecting_dom_unique:\n  \"\\<lbrakk> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g \\<rbrakk> \\<Longrightarrow>\n   \\<exists> d. \\<forall> f. dom f = X \\<longrightarrow> d = dom (g f)\"", "lemma func_le_restrict: \"\\<lbrakk> f \\<preceq> g; X \\<subseteq> dom f \\<rbrakk> \\<Longrightarrow> f |` X \\<preceq> g\"", "lemma func_le_dom: \"f \\<preceq> g \\<Longrightarrow> dom f \\<subseteq> dom g\"", "lemma doesnt_read_mutually_exclusive:\n  assumes noread: \"doesnt_read c x\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes unchanged: \"\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' (x := v)\\<rangle>\"\n  shows \"\\<not> (\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>)\"", "lemma doesnt_read_mutually_exclusive':\n  assumes noread: \"doesnt_read c x\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes overwrite: \"\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"\\<not> (\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' (x := v)\\<rangle>)\"", "lemma change_respecting_dom:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X g\"\n  assumes dom\\<sigma>: \"dom \\<sigma> = X\"\n  shows \"dom (g \\<sigma>) \\<subseteq> X\"", "lemma change_respecting_intro [iff]:\n  \"\\<lbrakk> \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>;\n     \\<And> f. dom f = X \\<Longrightarrow>\n           g f \\<preceq> f \\<and>\n           (\\<forall> f'. dom f' = X \\<longrightarrow> dom (g f) = dom (g f')) \\<and>\n           (\\<langle> c, mds, mem [\\<mapsto> f] \\<rangle> \\<leadsto> \\<langle> c', mds', mem' [\\<mapsto> g f] \\<rangle>) \\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\"", "lemma conjI3: \"\\<lbrakk> A; B; C \\<rbrakk> \\<Longrightarrow> A \\<and> B \\<and> C\"", "lemma noread_exists_change_respecting:\n  assumes fin: \"finite (X :: 'Var set)\"\n  assumes eval: \"\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>\"\n  assumes noread: \"\\<forall> x \\<in> X. doesnt_read c x\"\n  shows \"\\<exists> (g :: ('Var \\<rightharpoonup> 'Val) \\<Rightarrow> ('Var \\<rightharpoonup> 'Val)).  change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\"", "lemma differing_vars_neg: \"x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x)\"", "lemma differing_vars_neg_intro:\n  \"\\<lbrakk> mem\\<^sub>1 x = fst (mems ! i) x;\n  mem\\<^sub>2 x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"", "lemma differing_vars_elim [elim]:\n  \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x \\<noteq> mem\\<^sub>1 x) \\<or> (snd (mems ! i) x \\<noteq> mem\\<^sub>2 x)\"", "lemma subst_overrides: \"dom \\<sigma> = dom \\<tau> \\<Longrightarrow> mem [\\<mapsto> \\<tau>] [\\<mapsto> \\<sigma>] = mem [\\<mapsto> \\<sigma>]\"", "lemma dom_restrict_total: \"dom (to_partial f |` X) = X\"", "lemma update_nth_eq:\n  \"\\<lbrakk> xs = ys; n < length xs \\<rbrakk> \\<Longrightarrow> xs = ys [n := xs ! n]\"", "lemma mm_equiv_step:\n  assumes bisim: \"(cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes modes_eq: \"snd cms\\<^sub>1 = snd cms\\<^sub>2\"\n  assumes step: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle> \\<and>\n  (cms\\<^sub>1', mem\\<^sub>1') \\<approx> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle>\"", "lemma change_respecting_doesnt_modify:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X g\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes domf: \"dom f = X\"\n  assumes x_in_dom: \"x \\<in> dom (g f)\"\n  assumes noread: \"doesnt_read (fst cms) x\"\n  shows \"mem x = mem' x\"", "lemma differing_empty_eq:\n  \"\\<lbrakk> differing_vars mem mem' = {} \\<rbrakk> \\<Longrightarrow> mem = mem'\"", "lemma globally_consistent_dom:\n  \"\\<lbrakk> globally_consistent A mds; X \\<subseteq> dom A \\<rbrakk> \\<Longrightarrow> globally_consistent (A |` X) mds\"", "lemma globally_consistent_writable:\n  \"\\<lbrakk> x \\<in> dom A; globally_consistent A mds \\<rbrakk> \\<Longrightarrow> x \\<notin> mds AsmNoWrite\"", "lemma globally_consistent_loweq:\n  assumes globally_consistent: \"globally_consistent A mds\"\n  assumes some: \"A x = Some (v, v')\"\n  assumes low: \"dma x = Low\"\n  shows \"v = v'\"", "lemma globally_consistent_adapt_bisim:\n  assumes bisim: \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\"\n  assumes globally_consistent: \"globally_consistent A mds\"\n  shows \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\"", "lemma makes_compatible_invariant:\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                      \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\"\n  obtains cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\"", "lemma compat_low_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes x_low: \"dma x = Low\"\n  assumes x_readable: \"\\<forall> i < length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoRead\"\n  shows \"mem\\<^sub>1 x = mem\\<^sub>2 x\"", "lemma loc_reach_subset:\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"loc_reach \\<langle>c', mds', mem'\\<rangle> \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>\"", "lemma locally_sound_modes_invariant:\n  assumes sound_modes: \"locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\"", "lemma reachable_modes_subset:\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"reachable_mode_states (cms', mem') \\<subseteq> reachable_mode_states (cms, mem)\"", "lemma globally_sound_modes_invariant:\n  assumes globally_sound: \"globally_sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"globally_sound_mode_use (cms', mem')\"", "lemma loc_reach_mem_diff_subset:\n  assumes mem_diff: \"\\<forall> x. x \\<in> mds AsmNoWrite \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x\"\n  shows \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\"", "lemma loc_reach_mem_diff_eq:\n  assumes mem_diff: \"\\<forall> x. x \\<in> mds AsmNoWrite \\<longrightarrow> mem' x = mem x\"\n  shows \"loc_reach \\<langle>c, mds, mem\\<rangle> = loc_reach \\<langle>c, mds, mem'\\<rangle>\"", "lemma sound_modes_invariant:\n  assumes sound_modes: \"sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"sound_mode_use (cms', mem')\"", "lemma makes_compatible_eval_k:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\" \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> cms\\<^sub>2' mem\\<^sub>2' mems'. sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                              sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                              (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\"", "lemma differing_vars_initially_empty:\n  \"i < n \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i\"", "lemma compatible_refl:\n  assumes coms_secure: \"list_all com_sifum_secure cmds\"\n  assumes low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\"\n  shows \"makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n                          (add_initial_modes cmds, mem\\<^sub>2)\n                          (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\"", "theorem sifum_compositionality:\n  assumes com_secure: \"list_all com_sifum_secure cmds\"\n  assumes no_assms: \"no_assumptions_on_termination cmds\"\n  assumes sound_modes: \"\\<forall> mem. sound_mode_use (add_initial_modes cmds, mem)\"\n  shows \"prog_sifum_secure cmds\""], "translations": [["", "lemma differing_finite: \"finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)", "by (metis UNIV_def Un_UNIV_left finite_Un finite_memory)"], ["", "lemma differing_lists_finite: \"finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)", "by (simp add: differing_finite differing_vars_lists_def)"], ["", "(* Suggestive notation for substitution / function application *)"], ["", "definition subst :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\"\n  where\n  \"subst f mem = (\\<lambda> x. case f x of\n                         None \\<Rightarrow> mem x |\n                         Some v \\<Rightarrow> v)\""], ["", "abbreviation subst_abv :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\" (\"_ [\\<mapsto>_]\" [900, 0] 1000)\n  where\n  \"f [\\<mapsto> \\<sigma>] \\<equiv> subst \\<sigma> f\""], ["", "lemma subst_not_in_dom : \"\\<lbrakk> x \\<notin> dom \\<sigma> \\<rbrakk> \\<Longrightarrow> mem [\\<mapsto> \\<sigma>] x = mem x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<sigma> \\<Longrightarrow> subst \\<sigma> mem x = mem x", "by (simp add: domIff subst_def)"], ["", "fun makes_compatible ::\n  \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow>\n   ('Com, 'Var, 'Val) GlobalConf \\<Rightarrow>\n   ((_, _) Mem \\<times> (_, _) Mem) list \\<Rightarrow>\n  bool\"\n  where\n  \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems =\n  (length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems \\<and>\n   (\\<forall> i. i < length cms\\<^sub>1 \\<longrightarrow>\n       (\\<forall> \\<sigma>. dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<longrightarrow>\n         (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>])) \\<and>\n       (\\<forall> x. (mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High) \\<longrightarrow>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)) \\<and>\n    ((length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or> (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and>\n                                          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)))\""], ["", "(* This just restates the previous definition using meta-quantification. This allows\n  more readable proof blocks that prove each part separately. *)"], ["", "lemma makes_compatible_intro [intro]:\n  \"\\<lbrakk> length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems;\n     (\\<And> i \\<sigma>. \\<lbrakk> i < length cms\\<^sub>1; dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n          (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>]));\n     (\\<And> i x. \\<lbrakk> i < length cms\\<^sub>1; mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<rbrakk> \\<Longrightarrow> \n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i);\n     (length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n     (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i) \\<rbrakk> \\<Longrightarrow>\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length cms\\<^sub>1 = length cms\\<^sub>2 \\<and>\n             length cms\\<^sub>1 = length mems;\n     \\<And>i \\<sigma>.\n        \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1;\n         dom \\<sigma> =\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n        \\<Longrightarrow> (cms\\<^sub>1 ! i,\n                           subst \\<sigma> (fst (mems ! i))) \\<approx>\n                          (cms\\<^sub>2 ! i,\n                           subst \\<sigma> (snd (mems ! i)));\n     \\<And>i x.\n        \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1;\n         mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n        \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\nmem\\<^sub>2 mems i;\n     length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n     (\\<forall>x.\n         \\<exists>i<length cms\\<^sub>1.\n            x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                        i)\\<rbrakk>\n    \\<Longrightarrow> makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n                       (cms\\<^sub>2, mem\\<^sub>2) mems", "by auto"], ["", "(* First, some auxiliary lemmas about makes_compatible: *)"], ["", "lemma compat_low:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> dma x = Low\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i \\<sqsubset> length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma x = Low", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i \\<sqsubset> length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma x = Low", "assume \"i < length cms\\<^sub>1\" and *: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\" and\n    \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\""], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i \\<sqsubset> length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma x = Low", "then"], ["proof (chain)\npicking this:\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have\n    \"(mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High) \\<longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (prove)\nusing this:\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (simp add: Let_def, blast)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i \\<sqsubset> length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma x = Low", "with *"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "show \"dma x = Low\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. dma x = Low", "by (cases \"dma x\") blast"], ["proof (state)\nthis:\n  dma x = Low\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compat_different:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and> dma x = Low\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i \\<sqsubset> length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and>\n                      dma x = Low", "by (cases \"dma x\", auto)"], ["", "lemma sound_modes_no_read :\n  \"\\<lbrakk> sound_mode_use (cms, mem); x \\<in> (map snd cms ! i) GuarNoRead; i < length cms \\<rbrakk> \\<Longrightarrow>\n  doesnt_read (fst (cms ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "fix cms mem x i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "assume sound_modes: \"sound_mode_use (cms, mem)\" and \"i < length cms\""], ["proof (state)\nthis:\n  sound_mode_use (cms, mem)\n  i \\<sqsubset> length cms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "hence \"locally_sound_mode_use (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n  i \\<sqsubset> length cms\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms ! i, mem)", "by (auto simp: sound_mode_use_def list_all_length)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "moreover"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "assume \"x \\<in> (map snd cms ! i) GuarNoRead\""], ["proof (state)\nthis:\n  x \\<in> (map snd cms ! i) GuarNoRead\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoRead; i \\<sqsubset> length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  locally_sound_mode_use (cms ! i, mem)\n  x \\<in> (map snd cms ! i) GuarNoRead", "show \"doesnt_read (fst (cms !i)) x\""], ["proof (prove)\nusing this:\n  locally_sound_mode_use (cms ! i, mem)\n  x \\<in> (map snd cms ! i) GuarNoRead\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms ! i)) x", "apply (simp add: locally_sound_mode_use_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c' mds'.\n                (\\<exists>mem'.\n                    \\<langle>c', mds', mem'\\<rangle>\n                    \\<in> loc_reach (cms ! i, mem)) \\<longrightarrow>\n                (\\<forall>x.\n                    (x \\<in> mds' GuarNoRead \\<longrightarrow>\n                     doesnt_read c' x) \\<and>\n                    (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n                     doesnt_modify c' x));\n     x \\<in> (map snd cms ! i) GuarNoRead\\<rbrakk>\n    \\<Longrightarrow> doesnt_read (fst (cms ! i)) x", "by (metis prod.exhaust \\<open>i < length cms\\<close> fst_conv loc_reach.refl nth_map snd_conv)"], ["proof (state)\nthis:\n  doesnt_read (fst (cms ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compat_different_vars:\n  \"\\<lbrakk> fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "hence \"fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x", "by (simp add: differing_vars_lists_def differing_vars_def)"], ["proof (state)\nthis:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "moreover"], ["proof (state)\nthis:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"fst (mems ! i) x = snd (mems ! i) x\""], ["proof (state)\nthis:\n  fst (mems ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n  fst (mems ! i) x = snd (mems ! i) x", "show \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n  fst (mems ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_subst [rule_format]:\n  assumes dom\\<sigma>: \"dom \\<sigma> \\<supseteq> differing_vars mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] = mem\\<^sub>2 [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> mem\\<^sub>1 = subst \\<sigma> mem\\<^sub>2", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "from dom\\<sigma>"], ["proof (chain)\npicking this:\n  differing_vars mem\\<^sub>1 mem\\<^sub>2 \\<subseteq> dom \\<sigma>", "show \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] x = mem\\<^sub>2 [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\nusing this:\n  differing_vars mem\\<^sub>1 mem\\<^sub>2 \\<subseteq> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "unfolding subst_def differing_vars_def"], ["proof (prove)\nusing this:\n  {x. mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x} \\<subseteq> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> mem\\<^sub>1 x\n     | Some v \\<Rightarrow> v) =\n    (case \\<sigma> x of None \\<Rightarrow> mem\\<^sub>2 x\n     | Some v \\<Rightarrow> v)", "by (cases \"\\<sigma> x\", auto)"], ["proof (state)\nthis:\n  subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mm_equiv_low_eq:\n  \"\\<lbrakk> \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "unfolding mm_equiv.simps strong_low_bisim_mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<R> lc\\<^sub>1 lc\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> = lc\\<^sub>1 \\<and>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> = lc\\<^sub>2 \\<and>\n       (sym \\<R> \\<and>\n        closed_glob_consistent \\<R> \\<and>\n        (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n            (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n            \\<in> \\<R> \\<longrightarrow>\n            mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n            (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n                \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n                (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                    \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                    (\\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>,\n                     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)\n                    \\<in> \\<R>)))) \\<and>\n       (lc\\<^sub>1, lc\\<^sub>2) \\<in> \\<R> \\<Longrightarrow>\n    mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "by fast"], ["", "lemma globally_sound_modes_compatible:\n  \"\\<lbrakk> globally_sound_mode_use (cms, mem) \\<rbrakk> \\<Longrightarrow> compatible_modes (map snd cms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms, mem) \\<Longrightarrow>\n    compatible_modes (map snd cms)", "by (simp add: globally_sound_mode_use_def reachable_mode_states_def, auto)"], ["", "(* map snd cms1 = map snd cms2 states that both global configurations use the same modes *)"], ["", "lemma compatible_different_no_read :\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                       \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes x: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have len: \"length cms\\<^sub>1 = length cms\\<^sub>2\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = length cms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "let ?X\\<^sub>i = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "from compat ile x"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have a: \"dma x = Low\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. dma x = Low", "by (metis compat_low)"], ["proof (state)\nthis:\n  dma x = Low\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "from compat ile x"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have b: \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x", "by (metis compat_different)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "with a and compat ile x"], ["proof (chain)\npicking this:\n  dma x = Low\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x", "obtain j where\n    jprop: \"j < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\""], ["proof (prove)\nusing this:\n  dma x = Low\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i \\<sqsubset> length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<sqsubset> length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "let ?X\\<^sub>j = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "obtain \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\" where dom\\<sigma>: \"dom \\<sigma> = ?X\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    dom ?\\<sigma>12 = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "let ?\\<sigma> = \"\\<lambda> x. if (x \\<in> ?X\\<^sub>j) then Some some_val else None\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    dom ?\\<sigma>12 = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "show \"dom ?\\<sigma> = ?X\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n            then Some some_val else None) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "unfolding dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. (if a \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n         then Some some_val else None) \\<noteq>\n        None} =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "by auto"], ["proof (state)\nthis:\n  dom (\\<lambda>x.\n          if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n          then Some some_val else None) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "let ?mdss = \"map snd cms\\<^sub>1\" and\n      ?mems\\<^sub>1j = \"fst (mems ! j)\" and\n      ?mems\\<^sub>2j = \"snd (mems ! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "from jprop dom\\<sigma>"], ["proof (chain)\npicking this:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have subst_eq:\n  \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1j x \\<and> ?mems\\<^sub>2j [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n    subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n  subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "from compat jprop dom\\<sigma>"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have \"(cms\\<^sub>1 ! j, ?mems\\<^sub>1j [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! j, ?mems\\<^sub>2j [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n    (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "hence low_eq: \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] =\\<^bsub>?mdss ! j\\<^esub>\\<^sup>l ?mems\\<^sub>2j [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                           \\<sigma> (snd (mems ! j))", "using modes_eq"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                           \\<sigma> (snd (mems ! j))", "by (metis (no_types) jprop len mm_equiv_low_eq nth_map surjective_pairing)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "with jprop and b"], ["proof (chain)\npicking this:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "have \"x \\<in> (?mdss ! j) AsmNoRead\""], ["proof (prove)\nusing this:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "assume \"x \\<notin> (?mdss ! j) AsmNoRead\""], ["proof (state)\nthis:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "then"], ["proof (chain)\npicking this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead", "have mems_eq: \"?mems\\<^sub>1j x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "using \\<open>dma x = Low\\<close> low_eq subst_eq"], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead\n  dma x = Low\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n  subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n  subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "by (metis (full_types) low_mds_eq_def subst_eq)"], ["proof (state)\nthis:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "hence \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (metis compat_different_vars jprop)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "hence False"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. False", "by (metis b)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "}"], ["proof (state)\nthis:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<sqsubset> length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoRead \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead", "by metis"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "hence \"x \\<in> (?mdss ! i) GuarNoRead\""], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoRead", "using sound_modes jprop"], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoRead\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoRead", "by (metis compatible_modes_def globally_sound_modes_compatible\n      length_map sound_mode_use.simps x ile)"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoRead\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "thus \"doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoRead\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "using sound_modes ile"], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoRead\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  i \\<sqsubset> length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read (fst (cms\\<^sub>2 ! i)) x", "by (metis len modes_eq sound_modes_no_read)"], ["proof (state)\nthis:\n  doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n  doesnt_read (fst (cms\\<^sub>2 ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition func_le :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 60)\n  where \"f \\<preceq> g = (\\<forall> x \\<in> dom f. f x = g x)\""], ["", "fun change_respecting ::\n  \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow>\n   ('Com, 'Var, 'Val) LocalConf \\<Rightarrow>\n   'Var set \\<Rightarrow>\n   (('Var \\<rightharpoonup> 'Val) \\<Rightarrow>\n   ('Var \\<rightharpoonup> 'Val)) \\<Rightarrow> bool\"\n  where \"change_respecting (cms, mem) (cms', mem') X g =\n      ((cms, mem) \\<leadsto> (cms', mem') \\<and>\n       (\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> g \\<sigma> \\<preceq> \\<sigma>) \\<and>\n       (\\<forall> \\<sigma> \\<sigma>'. dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow> dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n       (\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> g \\<sigma>])))\""], ["", "lemma change_respecting_dom_unique:\n  \"\\<lbrakk> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g \\<rbrakk> \\<Longrightarrow>\n   \\<exists> d. \\<forall> f. dom f = X \\<longrightarrow> d = dom (g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X g \\<Longrightarrow>\n    \\<exists>d. \\<forall>f. dom f = X \\<longrightarrow> d = dom (g f)", "by (metis change_respecting.simps)"], ["", "lemma func_le_restrict: \"\\<lbrakk> f \\<preceq> g; X \\<subseteq> dom f \\<rbrakk> \\<Longrightarrow> f |` X \\<preceq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<preceq> g; X \\<subseteq> dom f\\<rbrakk>\n    \\<Longrightarrow> f |` X \\<preceq> g", "by (auto simp: func_le_def)"], ["", "definition to_partial :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b)\"\n  where \"to_partial f = (\\<lambda> x. Some (f x))\""], ["", "lemma func_le_dom: \"f \\<preceq> g \\<Longrightarrow> dom f \\<subseteq> dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<preceq> g \\<Longrightarrow> dom f \\<subseteq> dom g", "by (auto simp add: func_le_def, metis domIff option.simps(2))"], ["", "lemma doesnt_read_mutually_exclusive:\n  assumes noread: \"doesnt_read c x\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes unchanged: \"\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' (x := v)\\<rangle>\"\n  shows \"\\<not> (\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle>)", "using assms"], ["proof (prove)\nusing this:\n  doesnt_read c x\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>v.\n     \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'(x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle>)", "apply (case_tac \"mem' x = some_val\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>doesnt_read c x;\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle>;\n     \\<forall>v.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'(x := v)\\<rangle>;\n     mem' x = some_val\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>v.\n                                 \\<langle>c, mds, mem\n                                 (x := v)\\<rangle> \\<leadsto>\n                                 \\<langle>c', mds', mem'\\<rangle>)\n 2. \\<lbrakk>doesnt_read c x;\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle>;\n     \\<forall>v.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'(x := v)\\<rangle>;\n     mem' x \\<noteq> some_val\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>v.\n                                 \\<langle>c, mds, mem\n                                 (x := v)\\<rangle> \\<leadsto>\n                                 \\<langle>c', mds', mem'\\<rangle>)", "apply (metis (full_types) prod.inject deterministic different_values fun_upd_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>doesnt_read c x;\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle>;\n     \\<forall>v.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'(x := v)\\<rangle>;\n     mem' x \\<noteq> some_val\\<rbrakk>\n    \\<Longrightarrow> \\<not> (\\<forall>v.\n                                 \\<langle>c, mds, mem\n                                 (x := v)\\<rangle> \\<leadsto>\n                                 \\<langle>c', mds', mem'\\<rangle>)", "by (metis (full_types) prod.inject deterministic fun_upd_same)"], ["", "lemma doesnt_read_mutually_exclusive':\n  assumes noread: \"doesnt_read c x\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes overwrite: \"\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"\\<not> (\\<forall> v. \\<langle>c, mds, mem (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' (x := v)\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'(x := v)\\<rangle>)", "by (metis assms doesnt_read_mutually_exclusive)"], ["", "lemma change_respecting_dom:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X g\"\n  assumes dom\\<sigma>: \"dom \\<sigma> = X\"\n  shows \"dom (g \\<sigma>) \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) \\<subseteq> X", "by (metis assms change_respecting.simps func_le_dom)"], ["", "lemma change_respecting_intro [iff]:\n  \"\\<lbrakk> \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>;\n     \\<And> f. dom f = X \\<Longrightarrow>\n           g f \\<preceq> f \\<and>\n           (\\<forall> f'. dom f' = X \\<longrightarrow> dom (g f) = dom (g f')) \\<and>\n           (\\<langle> c, mds, mem [\\<mapsto> f] \\<rangle> \\<leadsto> \\<langle> c', mds', mem' [\\<mapsto> g f] \\<rangle>) \\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'\\<rangle>;\n     \\<And>f.\n        dom f = X \\<Longrightarrow>\n        g f \\<preceq> f \\<and>\n        (\\<forall>f'.\n            dom f' = X \\<longrightarrow> dom (g f) = dom (g f')) \\<and>\n        \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g f) mem'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                       \\<langle>c', mds', mem'\\<rangle> X g", "unfolding change_respecting.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'\\<rangle>;\n     \\<And>f.\n        dom f = X \\<Longrightarrow>\n        g f \\<preceq> f \\<and>\n        (\\<forall>f'.\n            dom f' = X \\<longrightarrow> dom (g f) = dom (g f')) \\<and>\n        \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g f) mem'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                      \\<langle>c', mds', mem'\\<rangle> \\<and>\n                      (\\<forall>\\<sigma>.\n                          dom \\<sigma> = X \\<longrightarrow>\n                          g \\<sigma> \\<preceq> \\<sigma>) \\<and>\n                      (\\<forall>\\<sigma> \\<sigma>'.\n                          dom \\<sigma> = X \\<and>\n                          dom \\<sigma>' = X \\<longrightarrow>\n                          dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n                      (\\<forall>\\<sigma>.\n                          dom \\<sigma> = X \\<longrightarrow>\n                          \\<langle>c, mds, subst \\<sigma>\n      mem\\<rangle> \\<leadsto>\n                          \\<langle>c', mds', subst (g \\<sigma>)\n        mem'\\<rangle>)", "by blast"], ["", "(* Used for a proof block in the following lemma *)"], ["", "lemma conjI3: \"\\<lbrakk> A; B; C \\<rbrakk> \\<Longrightarrow> A \\<and> B \\<and> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A; B; C\\<rbrakk> \\<Longrightarrow> A \\<and> B \\<and> C", "by simp"], ["", "lemma noread_exists_change_respecting:\n  assumes fin: \"finite (X :: 'Var set)\"\n  assumes eval: \"\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>\"\n  assumes noread: \"\\<forall> x \\<in> X. doesnt_read c x\"\n  shows \"\\<exists> (g :: ('Var \\<rightharpoonup> 'Val) \\<Rightarrow> ('Var \\<rightharpoonup> 'Val)).  change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> X g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> X g", "let ?lc = \"\\<langle>c, mds, mem\\<rangle>\" and ?lc' = \"\\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> X g", "from fin eval noread"], ["proof (chain)\npicking this:\n  finite X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read c x", "show \"\\<exists> g. change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\""], ["proof (prove)\nusing this:\n  finite X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read c x\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> X g", "proof (induct \"X\" arbitrary: mem mem' rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> {})\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "case empty"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read c a\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> {})\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "let ?g = \"\\<lambda> \\<sigma>. Map.empty\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> {})\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "have \"mem [\\<mapsto> Map.empty] = mem\" \"mem' [\\<mapsto> ?g Map.empty] = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst Map.empty mem = mem &&& subst Map.empty mem' = mem'", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case None of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v) =\n    mem &&&\n    (\\<lambda>x.\n        case None of None \\<Rightarrow> mem' x | Some v \\<Rightarrow> v) =\n    mem'", "by auto"], ["proof (state)\nthis:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> {})\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "hence \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> {} ?g\""], ["proof (prove)\nusing this:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> {} (\\<lambda>\\<sigma>. Map.empty)", "using empty"], ["proof (prove)\nusing this:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read c a\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> {} (\\<lambda>\\<sigma>. Map.empty)", "unfolding change_respecting.simps func_le_def subst_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      case None of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v) =\n  mem\n  (\\<lambda>x.\n      case None of None \\<Rightarrow> mem' x | Some v \\<Rightarrow> v) =\n  mem'\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read c a\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle> \\<and>\n    (\\<forall>\\<sigma>.\n        dom \\<sigma> = {} \\<longrightarrow>\n        (\\<forall>x\\<in>dom Map.empty. None = \\<sigma> x)) \\<and>\n    (\\<forall>\\<sigma> \\<sigma>'.\n        dom \\<sigma> = {} \\<and> dom \\<sigma>' = {} \\<longrightarrow>\n        dom Map.empty = dom Map.empty) \\<and>\n    (\\<forall>\\<sigma>.\n        dom \\<sigma> = {} \\<longrightarrow>\n        \\<langle>c, mds, \\<lambda>x.\n                            case \\<sigma> x of None \\<Rightarrow> mem x\n                            | Some v \\<Rightarrow> v\\<rangle> \\<leadsto>\n        \\<langle>c', mds', \\<lambda>x.\n                              case None of None \\<Rightarrow> mem' x\n                              | Some v \\<Rightarrow> v\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> {} (\\<lambda>\\<sigma>. Map.empty)\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> {})\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> {} (\\<lambda>\\<sigma>. Map.empty)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> {} a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a.\n     change_respecting \\<langle>c, mds, mem\\<rangle>\n      \\<langle>c', mds', mem'\\<rangle> {} a\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "case (insert x X)"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "then"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a", "obtain g\\<^sub>X where IH: \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a\n\ngoal (1 subgoal):\n 1. (\\<And>g\\<^sub>X.\n        change_respecting \\<langle>c, mds, mem\\<rangle>\n         \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis insert_iff)"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "(* Unfortunately, it is necessary to define the required function in advance for\n       all case distinctions we want to make. *)"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "define g where \"g \\<sigma> =\n       (let \\<sigma>' = \\<sigma> |` X in\n        (if (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> \\<sigma>'] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X \\<sigma>'] (x := v)\\<rangle>)\n         then (\\<lambda> y :: 'Var.\n                    if x = y\n                    then \\<sigma> y\n                    else g\\<^sub>X \\<sigma>' y)\n         else (\\<lambda> y. g\\<^sub>X \\<sigma>' y)))\"\n      for \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\nthis:\n  g ?\\<sigma> =\n  (let \\<sigma>' = ?\\<sigma> |` X\n   in if \\<forall>v.\n            \\<langle>c, mds, (subst \\<sigma>' mem)\n            (x := v)\\<rangle> \\<leadsto>\n            \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n            (x := v)\\<rangle>\n      then \\<lambda>y. if x = y then ?\\<sigma> y else g\\<^sub>X \\<sigma>' y\n      else g\\<^sub>X \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "have \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> (insert x X) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> (insert x X) g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>\n 2. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "show \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>", "using insert"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "next \\<comment> \\<open>We first show that property (2) is satisfied.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "fix \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "let ?\\<sigma>\\<^sub>X = \"\\<sigma> |` X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "assume \"dom \\<sigma> = insert x X\""], ["proof (state)\nthis:\n  dom \\<sigma> = insert x X\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "hence \"dom ?\\<sigma>\\<^sub>X = X\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = insert x X\n\ngoal (1 subgoal):\n 1. dom (\\<sigma> |` X) = X", "by (metis dom_restrict inf_absorb2 subset_insertI)"], ["proof (state)\nthis:\n  dom (\\<sigma> |` X) = X\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "from insert"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a", "have \"doesnt_read c x\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a\n\ngoal (1 subgoal):\n 1. doesnt_read c x", "by auto"], ["proof (state)\nthis:\n  doesnt_read c x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  doesnt_read c x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "from IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X", "have eval\\<^sub>X: \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>", "using \\<open>dom ?\\<sigma>\\<^sub>X = X\\<close>"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom (\\<sigma> |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>)\n  dom (\\<sigma> |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>", "have\n        noread\\<^sub>x:\n        \"(\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v) \\<rangle>) \\<or>\n        (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>)\""], ["proof (prove)\nusing this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)", "unfolding doesnt_read_def"], ["proof (prove)\nusing this:\n  \\<forall>mds mem c' mds' mem'.\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'(x := v)\\<rangle>) \\<or>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'\\<rangle>)\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = insert x X \\<Longrightarrow>\n       g f \\<preceq> f \\<and>\n       (\\<forall>f'.\n           dom f' = insert x X \\<longrightarrow>\n           dom (g f) = dom (g f')) \\<and>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g f) mem'\\<rangle>", "show \"g \\<sigma> \\<preceq> \\<sigma> \\<and>\n            (\\<forall> \\<sigma>'. dom \\<sigma>' = insert x X \\<longrightarrow> dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n            \\<langle>c, mds, mem [\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g \\<sigma>]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<sigma> \\<preceq> \\<sigma> \\<and>\n    (\\<forall>\\<sigma>'.\n        dom \\<sigma>' = insert x X \\<longrightarrow>\n        dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "proof (rule conjI3)"], ["proof (state)\ngoal (3 subgoals):\n 1. g \\<sigma> \\<preceq> \\<sigma>\n 2. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 3. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "from noread\\<^sub>x"], ["proof (chain)\npicking this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)", "show \"g \\<sigma> \\<preceq> \\<sigma>\""], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. g \\<sigma> \\<preceq> \\<sigma>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "assume nowrite: \"\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto>\n                 \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>", "have g_simp [simp]: \"g \\<sigma> = (\\<lambda> y. if y = x then \\<sigma> y else g\\<^sub>X ?\\<sigma>\\<^sub>X y)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. g \\<sigma> =\n    (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)", "by auto"], ["proof (state)\nthis:\n  g \\<sigma> =\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "thus \"g \\<sigma> \\<preceq> \\<sigma>\""], ["proof (prove)\nusing this:\n  g \\<sigma> =\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)\n\ngoal (1 subgoal):\n 1. g \\<sigma> \\<preceq> \\<sigma>", "using IH"], ["proof (prove)\nusing this:\n  g \\<sigma> =\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. g \\<sigma> \\<preceq> \\<sigma>", "unfolding g_simp func_le_def"], ["proof (prove)\nusing this:\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) =\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>dom (\\<lambda>y.\n                            if y = x then \\<sigma> y\n                            else g\\<^sub>X (\\<sigma> |` X) y).\n       (if xa = x then \\<sigma> xa else g\\<^sub>X (\\<sigma> |` X) xa) =\n       \\<sigma> xa", "by (auto, metis \\<open>dom (\\<sigma> |` X) = X\\<close> domI func_le_def restrict_in)"], ["proof (state)\nthis:\n  g \\<sigma> \\<preceq> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "assume overwrites: \"\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto>\n            \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "hence\n            \"\\<not> (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n               (x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n               (x := v)\\<rangle>)", "by (metis \\<open>doesnt_read c x\\<close> doesnt_read_mutually_exclusive eval\\<^sub>X)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "hence g_simp [simp]: \"g \\<sigma> = g\\<^sub>X ?\\<sigma>\\<^sub>X\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    g\\<^sub>X (\\<sigma> |` X)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "also"], ["proof (state)\nthis:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "from IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X", "have \"g\\<^sub>X ?\\<sigma>\\<^sub>X \\<preceq> ?\\<sigma>\\<^sub>X\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n\ngoal (1 subgoal):\n 1. g\\<^sub>X (\\<sigma> |` X) \\<preceq> \\<sigma> |` X", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> change_respecting.simps)"], ["proof (state)\nthis:\n  g\\<^sub>X (\\<sigma> |` X) \\<preceq> \\<sigma> |` X\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    g \\<sigma> \\<preceq> \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n  g\\<^sub>X (\\<sigma> |` X) \\<preceq> \\<sigma> |` X", "show \"g \\<sigma> \\<preceq> \\<sigma>\""], ["proof (prove)\nusing this:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n  g\\<^sub>X (\\<sigma> |` X) \\<preceq> \\<sigma> |` X\n\ngoal (1 subgoal):\n 1. g \\<sigma> \\<preceq> \\<sigma>", "unfolding func_le_def"], ["proof (prove)\nusing this:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n  \\<forall>x\\<in>dom (g\\<^sub>X (\\<sigma> |` X)).\n     g\\<^sub>X (\\<sigma> |` X) x = (\\<sigma> |` X) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>dom (g \\<sigma>). g \\<sigma> x = \\<sigma> x", "by (auto, metis \\<open>dom (\\<sigma> |` X) = X\\<close> domI restrict_in)"], ["proof (state)\nthis:\n  g \\<sigma> \\<preceq> \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<sigma> \\<preceq> \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "next \\<comment> \\<open>This part proves that the domain of the family is unique\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "fix \\<sigma>' :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "assume \"dom \\<sigma>' = insert x X\""], ["proof (state)\nthis:\n  dom \\<sigma>' = insert x X\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "let ?\\<sigma>'\\<^sub>X = \"\\<sigma>' |` X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "have \"dom ?\\<sigma>'\\<^sub>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<sigma>' |` X) = X", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> \\<open>dom \\<sigma>' = insert x X\\<close> dom_restrict)\n        \\<comment> \\<open>We first show, that we are always in the same case of the no read assumption:\\<close>"], ["proof (state)\nthis:\n  dom (\\<sigma>' |` X) = X\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "have same_case:\n          \"((\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>) \\<and>\n            (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle>))\n           \\<or>\n           ((\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>) \\<and>\n            (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X]\\<rangle>))\"\n          (is \"(?N \\<and> ?N') \\<or> (?O \\<and> ?O')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "proof -\n          \\<comment> \\<open>By deriving a contradiction under the assumption that we are in different cases:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "have not_different:\n            \"\\<And> h h'. \\<lbrakk> dom h = insert x X; dom h' = insert x X;\n                        \\<forall> v. \\<langle>c, mds, mem [\\<mapsto> h |` X] (x := v)\\<rangle> \\<leadsto>\n                             \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X (h |` X)] (x := v)\\<rangle>;\n                        \\<forall> v. \\<langle>c, mds, mem [\\<mapsto> h' |` X] (x := v)\\<rangle> \\<leadsto>\n                             \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X (h' |` X)]\\<rangle> \\<rbrakk>\n                      \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "proof -\n            \\<comment> \\<open>Introduce new names to avoid clashes with functions in the outer scope.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "fix h h' :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "assume doms: \"dom h = insert x X\" \"dom h' = insert x X\""], ["proof (state)\nthis:\n  dom h = insert x X\n  dom h' = insert x X\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "assume nowrite: \"\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> h |` X] (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X (h |` X)] (x := v)\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')(x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "assume overwrite: \"\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> h' |` X] (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X (h' |` X)]\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?h\\<^sub>X = \"h |` X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?h'\\<^sub>X = \"h' |` X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"dom ?h\\<^sub>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (h |` X) = X", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> dom_restrict doms(1))"], ["proof (state)\nthis:\n  dom (h |` X) = X\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"dom ?h'\\<^sub>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (h' |` X) = X", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> dom_restrict doms(2))"], ["proof (state)\nthis:\n  dom (h' |` X) = X\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "with IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom (h' |` X) = X", "have eval\\<^sub>X': \"\\<langle>c, mds, mem [\\<mapsto> ?h'\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?h'\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom (h' |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>)\n  dom (h' |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>doesnt_read c x\\<close>"], ["proof (chain)\npicking this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "have noread\\<^sub>x':\n             \"(\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?h'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?h'\\<^sub>X] (x := v)\\<rangle>) \\<or>\n              (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?h'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?h'\\<^sub>X]\\<rangle>)\""], ["proof (prove)\nusing this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>)", "unfolding doesnt_read_def"], ["proof (prove)\nusing this:\n  \\<forall>mds mem c' mds' mem'.\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'(x := v)\\<rangle>) \\<or>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'\\<rangle>)\n  \\<langle>c, mds, subst (h' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "from overwrite"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "obtain v where\n              \"\\<not> (\\<langle>c, mds, mem [\\<mapsto> h' |` X] (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X (h' |` X)] (x := v)\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle>,\n         \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')\n         (x := v)\\<rangle>)\n        \\<notin> eval \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>doesnt_read c x\\<close> doesnt_read_mutually_exclusive fun_upd_triv)"], ["proof (state)\nthis:\n  (\\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle>,\n   \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')(x := v)\\<rangle>)\n  \\<notin> eval\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (\\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle>,\n   \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')(x := v)\\<rangle>)\n  \\<notin> eval\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x \\<notin> dom (?h'\\<^sub>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (h' |` X)", "by (metis \\<open>dom (h' |` X) = X\\<close> insert(2))"], ["proof (state)\nthis:\n  x \\<notin> dom (h' |` X)\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "with IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  x \\<notin> dom (h' |` X)", "have \"x \\<notin> dom (g\\<^sub>X ?h'\\<^sub>X)\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  x \\<notin> dom (h' |` X)\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (g\\<^sub>X (h' |` X))", "by (metis \\<open>dom (h' |` X) = X\\<close> change_respecting.simps func_le_dom rev_subsetD)"], ["proof (state)\nthis:\n  x \\<notin> dom (g\\<^sub>X (h' |` X))\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle>,\n   \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')(x := v)\\<rangle>)\n  \\<notin> eval\n  x \\<notin> dom (g\\<^sub>X (h' |` X))", "have \"mem' x \\<noteq> v\""], ["proof (prove)\nusing this:\n  (\\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle>,\n   \\<langle>c', mds', (subst (g\\<^sub>X (h' |` X)) mem')(x := v)\\<rangle>)\n  \\<notin> eval\n  x \\<notin> dom (g\\<^sub>X (h' |` X))\n\ngoal (1 subgoal):\n 1. mem' x \\<noteq> v", "by (metis fun_upd_triv overwrite subst_not_in_dom)"], ["proof (state)\nthis:\n  mem' x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?mem\\<^sub>v = \"mem (x := v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "obtain mem\\<^sub>v' where \"\\<langle>c, mds, ?mem\\<^sub>v\\<rangle> \\<leadsto> \\<langle>c', mds', mem\\<^sub>v'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mem\\<^sub>v'.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert \\<open>doesnt_read c x\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read c a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read c a\n  doesnt_read c x\n\ngoal (1 subgoal):\n 1. (\\<And>mem\\<^sub>v'.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding doesnt_read_def"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X.\n      \\<forall>mds mem c' mds' mem'.\n         \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n         (\\<forall>v.\n             \\<langle>c, mds, mem(a := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'(a := v)\\<rangle>) \\<or>\n         (\\<forall>v.\n             \\<langle>c, mds, mem(a := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'\\<rangle>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a.\n                       change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                        \\<langle>c', mds', ?mem'5\\<rangle> X a\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X.\n     \\<forall>mds mem c' mds' mem'.\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n        (\\<forall>v.\n            \\<langle>c, mds, mem(a := v)\\<rangle> \\<leadsto>\n            \\<langle>c', mds', mem'(a := v)\\<rangle>) \\<or>\n        (\\<forall>v.\n            \\<langle>c, mds, mem(a := v)\\<rangle> \\<leadsto>\n            \\<langle>c', mds', mem'\\<rangle>)\n  \\<forall>mds mem c' mds' mem'.\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'(x := v)\\<rangle>) \\<or>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<And>mem\\<^sub>v'.\n        \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto, metis)"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<forall> x \\<in> X. doesnt_read c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. doesnt_read c x", "by (metis insert(5) insert_iff)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. doesnt_read c x\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem\\<^sub>v'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read c x", "obtain g\\<^sub>v where\n              IH\\<^sub>v: \"change_respecting \\<langle>c, mds, ?mem\\<^sub>v\\<rangle> \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X g\\<^sub>v\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem\\<^sub>v'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read c x\n\ngoal (1 subgoal):\n 1. (\\<And>g\\<^sub>v.\n        change_respecting \\<langle>c, mds, mem(x := v)\\<rangle>\n         \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X\n         g\\<^sub>v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis insert(3))"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem(x := v)\\<rangle>\n   \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X g\\<^sub>v\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "hence eval\\<^sub>v: \"\\<langle>c, mds, ?mem\\<^sub>v [\\<mapsto> ?h\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h\\<^sub>X]\\<rangle>\"\n                         \"\\<langle>c, mds, ?mem\\<^sub>v [\\<mapsto> ?h'\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h'\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem(x := v)\\<rangle>\n   \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X g\\<^sub>v\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X)) mem\\<^sub>v'\\<rangle> &&&\n    \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>", "apply (metis \\<open>dom (h |` X) = X\\<close> change_respecting.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>", "by (metis IH\\<^sub>v \\<open>dom (h' |` X) = X\\<close> change_respecting.simps)"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h |` X)) mem\\<^sub>v'\\<rangle>\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "from eval\\<^sub>v(1)"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h |` X)) mem\\<^sub>v'\\<rangle>", "have \"mem\\<^sub>v' x = v\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>v' x = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "assume \"\\<langle>c, mds, mem (x := v) [\\<mapsto> ?h\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h\\<^sub>X]\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "have \"?mem\\<^sub>v [\\<mapsto> ?h\\<^sub>X] = mem [\\<mapsto> ?h\\<^sub>X] (x := v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (h |` X) (mem(x := v)) = (subst (h |` X) mem)(x := v)", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       subst (h |` X) (mem(x := v)) y = ((subst (h |` X) mem)(x := v)) y", "apply (case_tac \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y = x \\<Longrightarrow>\n       subst (h |` X) (mem(x := v)) y = ((subst (h |` X) mem)(x := v)) y\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       subst (h |` X) (mem(x := v)) y = ((subst (h |` X) mem)(x := v)) y", "apply (auto simp: subst_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case (h |` X) x of None \\<Rightarrow> (mem(x := v)) x\n     | Some v \\<Rightarrow> v) =\n    v\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (h |` X) y of None \\<Rightarrow> (mem(x := v)) y\n        | Some v \\<Rightarrow> v) =\n       (case (h |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "apply (metis (full_types) \\<open>dom (h |` X) = X\\<close> fun_upd_def\n                  insert(2) subst_def subst_not_in_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (h |` X) y of None \\<Rightarrow> (mem(x := v)) y\n        | Some v \\<Rightarrow> v) =\n       (case (h |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "by (metis fun_upd_other)"], ["proof (state)\nthis:\n  subst (h |` X) (mem(x := v)) = (subst (h |` X) mem)(x := v)\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "with nowrite"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')(x := v)\\<rangle>\n  subst (h |` X) (mem(x := v)) = (subst (h |` X) mem)(x := v)", "have \"mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h\\<^sub>X] = mem' [\\<mapsto> g\\<^sub>X ?h\\<^sub>X] (x := v)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')(x := v)\\<rangle>\n  subst (h |` X) (mem(x := v)) = (subst (h |` X) mem)(x := v)\n\ngoal (1 subgoal):\n 1. subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' =\n    (subst (g\\<^sub>X (h |` X)) mem')(x := v)", "using deterministic"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')(x := v)\\<rangle>\n  subst (h |` X) (mem(x := v)) = (subst (h |` X) mem)(x := v)\n  \\<lbrakk>?lc \\<leadsto> ?lc'; ?lc \\<leadsto> ?lc''\\<rbrakk>\n  \\<Longrightarrow> ?lc' = ?lc''\n\ngoal (1 subgoal):\n 1. subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' =\n    (subst (g\\<^sub>X (h |` X)) mem')(x := v)", "by (erule_tac x = v in allE, auto, metis eval\\<^sub>v(1))"], ["proof (state)\nthis:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' =\n  (subst (g\\<^sub>X (h |` X)) mem')(x := v)\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "hence \"mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h\\<^sub>X] x = v\""], ["proof (prove)\nusing this:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' =\n  (subst (g\\<^sub>X (h |` X)) mem')(x := v)\n\ngoal (1 subgoal):\n 1. subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' x = v", "by simp"], ["proof (state)\nthis:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' x = v\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "also"], ["proof (state)\nthis:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' x = v\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "have \"x \\<notin> dom (g\\<^sub>v ?h\\<^sub>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (g\\<^sub>v (h |` X))", "using IH\\<^sub>v \\<open>dom ?h\\<^sub>X = X\\<close> change_respecting_dom"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem(x := v)\\<rangle>\n   \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X g\\<^sub>v\n  dom (h |` X) = X\n  \\<lbrakk>change_respecting (?cms, ?mem) (?cms', ?mem') ?X ?g;\n   dom ?\\<sigma> = ?X\\<rbrakk>\n  \\<Longrightarrow> dom (?g ?\\<sigma>) \\<subseteq> ?X\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (g\\<^sub>v (h |` X))", "by (metis func_le_dom insert(2) rev_subsetD)"], ["proof (state)\nthis:\n  x \\<notin> dom (g\\<^sub>v (h |` X))\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = v", "ultimately"], ["proof (chain)\npicking this:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' x = v\n  x \\<notin> dom (g\\<^sub>v (h |` X))", "show \"mem\\<^sub>v' x = v\""], ["proof (prove)\nusing this:\n  subst (g\\<^sub>v (h |` X)) mem\\<^sub>v' x = v\n  x \\<notin> dom (g\\<^sub>v (h |` X))\n\ngoal (1 subgoal):\n 1. mem\\<^sub>v' x = v", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  mem\\<^sub>v' x = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>v' x = v\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  mem\\<^sub>v' x = v\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "from eval\\<^sub>v(2)"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>", "have \"mem\\<^sub>v' x = mem' x\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>v' x = mem' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "assume \"\\<langle>c, mds, ?mem\\<^sub>v [\\<mapsto> ?h'\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h'\\<^sub>X]\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "moreover"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "from overwrite"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "have\n                \"\\<langle>c, mds, mem [\\<mapsto> ?h'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?h'\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "moreover"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "have \"?mem\\<^sub>v [\\<mapsto> ?h'\\<^sub>X] = mem [\\<mapsto> ?h'\\<^sub>X] (x := v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (h' |` X) (mem(x := v)) = (subst (h' |` X) mem)(x := v)", "apply (rule ext, rename_tac \"y\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       subst (h' |` X) (mem(x := v)) y = ((subst (h' |` X) mem)(x := v)) y", "apply (case_tac \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y = x \\<Longrightarrow>\n       subst (h' |` X) (mem(x := v)) y = ((subst (h' |` X) mem)(x := v)) y\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       subst (h' |` X) (mem(x := v)) y = ((subst (h' |` X) mem)(x := v)) y", "apply (metis \\<open>x \\<notin> dom (h' |` X)\\<close> fun_upd_apply subst_not_in_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       subst (h' |` X) (mem(x := v)) y = ((subst (h' |` X) mem)(x := v)) y", "apply (auto simp: subst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (h' |` X) y of None \\<Rightarrow> (mem(x := v)) y\n        | Some v \\<Rightarrow> v) =\n       (case (h' |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "by (metis fun_upd_other)"], ["proof (state)\nthis:\n  subst (h' |` X) (mem(x := v)) = (subst (h' |` X) mem)(x := v)\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n  \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n  subst (h' |` X) (mem(x := v)) = (subst (h' |` X) mem)(x := v)", "have \"mem' [\\<mapsto> g\\<^sub>X ?h'\\<^sub>X] = mem\\<^sub>v' [\\<mapsto> g\\<^sub>v ?h'\\<^sub>X]\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n  \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n  subst (h' |` X) (mem(x := v)) = (subst (h' |` X) mem)(x := v)\n\ngoal (1 subgoal):\n 1. subst (g\\<^sub>X (h' |` X)) mem' =\n    subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'", "using deterministic"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\\<rangle>\n  \\<langle>c, mds, (subst (h' |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (h' |` X)) mem'\\<rangle>\n  subst (h' |` X) (mem(x := v)) = (subst (h' |` X) mem)(x := v)\n  \\<lbrakk>?lc \\<leadsto> ?lc'; ?lc \\<leadsto> ?lc''\\<rbrakk>\n  \\<Longrightarrow> ?lc' = ?lc''\n\ngoal (1 subgoal):\n 1. subst (g\\<^sub>X (h' |` X)) mem' =\n    subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'", "by auto"], ["proof (state)\nthis:\n  subst (g\\<^sub>X (h' |` X)) mem' =\n  subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "also"], ["proof (state)\nthis:\n  subst (g\\<^sub>X (h' |` X)) mem' =\n  subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "have \"x \\<notin> dom (g\\<^sub>v ?h'\\<^sub>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom (g\\<^sub>v (h' |` X))", "using IH\\<^sub>v \\<open>dom ?h'\\<^sub>X = X\\<close> change_respecting_dom"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem(x := v)\\<rangle>\n   \\<langle>c', mds', mem\\<^sub>v'\\<rangle> X g\\<^sub>v\n  dom (h' |` X) = X\n  \\<lbrakk>change_respecting (?cms, ?mem) (?cms', ?mem') ?X ?g;\n   dom ?\\<sigma> = ?X\\<rbrakk>\n  \\<Longrightarrow> dom (?g ?\\<sigma>) \\<subseteq> ?X\n\ngoal (1 subgoal):\n 1. x \\<notin> dom (g\\<^sub>v (h' |` X))", "by (metis func_le_dom insert(2) subsetD)"], ["proof (state)\nthis:\n  x \\<notin> dom (g\\<^sub>v (h' |` X))\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (h' |` X) (mem(x := v))\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>v (h' |` X))\n                        mem\\<^sub>v'\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>v' x = mem' x", "ultimately"], ["proof (chain)\npicking this:\n  subst (g\\<^sub>X (h' |` X)) mem' =\n  subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\n  x \\<notin> dom (g\\<^sub>v (h' |` X))", "show \"mem\\<^sub>v' x = mem' x\""], ["proof (prove)\nusing this:\n  subst (g\\<^sub>X (h' |` X)) mem' =\n  subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\n  x \\<notin> dom (g\\<^sub>v (h' |` X))\n\ngoal (1 subgoal):\n 1. mem\\<^sub>v' x = mem' x", "using \\<open>x \\<notin> dom (g\\<^sub>X ?h'\\<^sub>X)\\<close>"], ["proof (prove)\nusing this:\n  subst (g\\<^sub>X (h' |` X)) mem' =\n  subst (g\\<^sub>v (h' |` X)) mem\\<^sub>v'\n  x \\<notin> dom (g\\<^sub>v (h' |` X))\n  x \\<notin> dom (g\\<^sub>X (h' |` X))\n\ngoal (1 subgoal):\n 1. mem\\<^sub>v' x = mem' x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  mem\\<^sub>v' x = mem' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>v' x = mem' x\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>dom h = insert x X; dom h' = insert x X;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h |` X) mem)(x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', (subst (g\\<^sub>X (h |` X)) mem')\n           (x := v)\\<rangle>;\n        \\<forall>v.\n           \\<langle>c, mds, (subst (h' |` X) mem)\n           (x := v)\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X (h' |` X))\n                               mem'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  mem\\<^sub>v' x = v\n  mem\\<^sub>v' x = mem' x", "show False"], ["proof (prove)\nusing this:\n  mem\\<^sub>v' x = v\n  mem\\<^sub>v' x = mem' x\n\ngoal (1 subgoal):\n 1. False", "using \\<open>mem' x \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  mem\\<^sub>v' x = v\n  mem\\<^sub>v' x = mem' x\n  mem' x \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "have \"dom ?\\<sigma>'\\<^sub>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<sigma>' |` X) = X", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> \\<open>dom \\<sigma>' = insert x X\\<close> dom_restrict)"], ["proof (state)\nthis:\n  dom (\\<sigma>' |` X) = X\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "with IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom (\\<sigma>' |` X) = X", "have eval\\<^sub>X': \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom (\\<sigma>' |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>)\n  dom (\\<sigma>' |` X) = X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "with \\<open>doesnt_read c x\\<close>"], ["proof (chain)\npicking this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>", "have noread\\<^sub>x':\n             \"(\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle>)\n              \\<or>\n              (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X]\\<rangle>)\""], ["proof (prove)\nusing this:\n  doesnt_read c x\n  \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "unfolding doesnt_read_def"], ["proof (prove)\nusing this:\n  \\<forall>mds mem c' mds' mem'.\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'(x := v)\\<rangle>) \\<or>\n     (\\<forall>v.\n         \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n         \\<langle>c', mds', mem'\\<rangle>)\n  \\<langle>c, mds, subst (\\<sigma>' |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "using noread\\<^sub>x not_different \\<open>dom \\<sigma> = insert x X\\<close> \\<open>dom \\<sigma>' = insert x X\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)\n  \\<lbrakk>dom ?h5 = insert x X; dom ?h'5 = insert x X;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (?h5 |` X)) mem')\n      (x := v)\\<rangle>;\n   \\<forall>v.\n      \\<langle>c, mds, (subst (?h'5 |` X) mem)(x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (?h'5 |` X))\n                          mem'\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> False\n  dom \\<sigma> = insert x X\n  dom \\<sigma>' = insert x X\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<or>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                          mem'\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                          mem'\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "hence \"dom (g \\<sigma>) = dom (g \\<sigma>')\""], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                          mem'\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "assume\n            \"(\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>) \\<and>\n            (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle>)\""], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>)\n\ngoal (2 subgoals):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "hence g_simp [simp]: \"g \\<sigma> = (\\<lambda> y. if y = x then \\<sigma> y else g\\<^sub>X ?\\<sigma>\\<^sub>X y) \\<and>\n                                g \\<sigma>' = (\\<lambda> y. if y = x then \\<sigma>' y else g\\<^sub>X ?\\<sigma>'\\<^sub>X y)\""], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. g \\<sigma> =\n    (\\<lambda>y.\n        if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n    g \\<sigma>' =\n    (\\<lambda>y.\n        if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)", "unfolding g_def"], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n      (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    (\\<lambda>y.\n        if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n    (let \\<sigma>'' = \\<sigma>' |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>'' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>'') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y.\n                if x = y then \\<sigma>' y else g\\<^sub>X \\<sigma>'' y\n        else g\\<^sub>X \\<sigma>'') =\n    (\\<lambda>y.\n        if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)", "by auto"], ["proof (state)\nthis:\n  g \\<sigma> =\n  (\\<lambda>y.\n      if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n  g \\<sigma>' =\n  (\\<lambda>y. if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)\n\ngoal (2 subgoals):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n        (x := v)\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n        (x := v)\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "thus ?thesis"], ["proof (prove)\nusing this:\n  g \\<sigma> =\n  (\\<lambda>y.\n      if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n  g \\<sigma>' =\n  (\\<lambda>y. if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "using IH \\<open>dom \\<sigma> = insert x X\\<close> \\<open>dom \\<sigma>' = insert x X\\<close>"], ["proof (prove)\nusing this:\n  g \\<sigma> =\n  (\\<lambda>y.\n      if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n  g \\<sigma>' =\n  (\\<lambda>y. if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  dom \\<sigma> = insert x X\n  dom \\<sigma>' = insert x X\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  g \\<sigma> =\n  (\\<lambda>y.\n      if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y) \\<and>\n  g \\<sigma>' =\n  (\\<lambda>y. if y = x then \\<sigma>' y else g\\<^sub>X (\\<sigma>' |` X) y)\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>)\n  dom \\<sigma> = insert x X\n  dom \\<sigma>' = insert x X\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "apply (auto simp: domD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>dom \\<sigma> = insert x X; dom \\<sigma>' = insert x X;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>;\n        \\<forall>\\<sigma> \\<sigma>'.\n           dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n           dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>');\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>;\n        g\\<^sub>X (\\<sigma> |` X) xa = Some y; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. g\\<^sub>X (\\<sigma>' |` X) xa = Some y\n 2. \\<And>xa y.\n       \\<lbrakk>dom \\<sigma> = insert x X; dom \\<sigma>' = insert x X;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>;\n        \\<forall>\\<sigma> \\<sigma>'.\n           dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n           dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>');\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>;\n        g\\<^sub>X (\\<sigma>' |` X) xa = Some y; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. g\\<^sub>X (\\<sigma> |` X) xa = Some y", "apply (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom (\\<sigma>' |` X) = X\\<close> domD domI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>dom \\<sigma> = insert x X; dom \\<sigma>' = insert x X;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>;\n        \\<forall>\\<sigma> \\<sigma>'.\n           dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n           dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>');\n        \\<forall>\\<sigma>.\n           dom \\<sigma> = X \\<longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>;\n        g\\<^sub>X (\\<sigma>' |` X) xa = Some y; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. g\\<^sub>X (\\<sigma> |` X) xa = Some y", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom (\\<sigma>' |` X) = X\\<close> domD domI)"], ["proof (state)\nthis:\n  dom (g \\<sigma>) = dom (g \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "assume\n            \"(\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>) \\<and>\n            (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X]\\<rangle>)\""], ["proof (state)\nthis:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                          mem'\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "hence\n            \"\\<not> (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>)\n            \\<and>\n            \\<not> (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>'\\<^sub>X] (x := v)\\<rangle>)\""], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                          mem'\\<rangle>) \\<and>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n               (x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n               (x := v)\\<rangle>) \\<and>\n    \\<not> (\\<forall>v.\n               \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n               (x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n               (x := v)\\<rangle>)", "by (metis \\<open>doesnt_read c x\\<close> doesnt_read_mutually_exclusive' fun_upd_triv)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>) \\<and>\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "hence g_simp [simp]: \"g \\<sigma> = g\\<^sub>X ?\\<sigma>\\<^sub>X \\<and> g \\<sigma>' = g\\<^sub>X ?\\<sigma>'\\<^sub>X\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>) \\<and>\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. g \\<sigma> = g\\<^sub>X (\\<sigma> |` X) \\<and>\n    g \\<sigma>' = g\\<^sub>X (\\<sigma>' |` X)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>) \\<and>\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma>' |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    g\\<^sub>X (\\<sigma> |` X) \\<and>\n    (let \\<sigma>'' = \\<sigma>' |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>'' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>'') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y.\n                if x = y then \\<sigma>' y else g\\<^sub>X \\<sigma>'' y\n        else g\\<^sub>X \\<sigma>'') =\n    g\\<^sub>X (\\<sigma>' |` X)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X) \\<and>\n  g \\<sigma>' = g\\<^sub>X (\\<sigma>' |` X)\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                            mem'\\<rangle>) \\<and>\n    (\\<forall>v.\n        \\<langle>c, mds, (subst (\\<sigma>' |` X) mem)\n        (x := v)\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma>' |` X))\n                            mem'\\<rangle>) \\<Longrightarrow>\n    dom (g \\<sigma>) = dom (g \\<sigma>')", "with IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X) \\<and>\n  g \\<sigma>' = g\\<^sub>X (\\<sigma>' |` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X g\\<^sub>X\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X) \\<and>\n  g \\<sigma>' = g\\<^sub>X (\\<sigma>' |` X)\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g\\<^sub>X \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g\\<^sub>X \\<sigma>) = dom (g\\<^sub>X \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X \\<sigma>) mem'\\<rangle>)\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X) \\<and>\n  g \\<sigma>' = g\\<^sub>X (\\<sigma>' |` X)\n\ngoal (1 subgoal):\n 1. dom (g \\<sigma>) = dom (g \\<sigma>')", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom (\\<sigma>' |` X) = X\\<close>)"], ["proof (state)\nthis:\n  dom (g \\<sigma>) = dom (g \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (g \\<sigma>) = dom (g \\<sigma>')\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "}"], ["proof (state)\nthis:\n  dom ?\\<sigma>'7 = insert x X \\<Longrightarrow>\n  dom (g \\<sigma>) = dom (g ?\\<sigma>'7)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')\n 2. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "thus \"\\<forall> \\<sigma>'. dom \\<sigma>' = insert x X \\<longrightarrow> dom (g \\<sigma>) = dom (g \\<sigma>')\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>'7 = insert x X \\<Longrightarrow>\n  dom (g \\<sigma>) = dom (g ?\\<sigma>'7)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>'.\n       dom \\<sigma>' = insert x X \\<longrightarrow>\n       dom (g \\<sigma>) = dom (g \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>'.\n     dom \\<sigma>' = insert x X \\<longrightarrow>\n     dom (g \\<sigma>) = dom (g \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "(* Do a case distinction on the no-read statement: *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "from noread\\<^sub>x"], ["proof (chain)\npicking this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)", "show \"\\<langle>c, mds, mem [\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g \\<sigma>]\\<rangle>\""], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n      (x := v)\\<rangle>) \\<or>\n  (\\<forall>v.\n      \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n      (x := v)\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "assume nowrite:\n          \"\\<forall> v. \\<langle>c, mds, mem[\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>", "have g_simp [simp]: \"g \\<sigma> = (\\<lambda> y. if y = x then \\<sigma> y else g\\<^sub>X ?\\<sigma>\\<^sub>X y)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. g \\<sigma> =\n    (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)", "by auto"], ["proof (state)\nthis:\n  g \\<sigma> =\n  (\\<lambda>y. if y = x then \\<sigma> y else g\\<^sub>X (\\<sigma> |` X) y)\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>dom \\<sigma> = insert x X\\<close> domD insertI1)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "from nowrite"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>", "have\n          \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n     (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n    (x := v)\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n  (x := v)\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n  (x := v)\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "have \"mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v) = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y", "apply (case_tac \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y = x \\<Longrightarrow>\n       ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y", "apply (auto simp: subst_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v =\n    (case \\<sigma> x of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v)\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (\\<sigma> |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v) =\n       (case \\<sigma> y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "apply (metis \\<open>\\<sigma> x = Some v\\<close> option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (\\<sigma> |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v) =\n       (case \\<sigma> y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> insertE\n            restrict_in subst_def subst_not_in_dom)"], ["proof (state)\nthis:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "have \"mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v) = mem' [\\<mapsto> g \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v) =\n    subst (g \\<sigma>) mem'", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v)) y =\n       subst (g \\<sigma>) mem' y", "apply (case_tac \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y = x \\<Longrightarrow>\n       ((subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v)) y =\n       subst (g \\<sigma>) mem' y\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       ((subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v)) y =\n       subst (g \\<sigma>) mem' y", "by (auto simp: subst_def option.simps \\<open>\\<sigma> x = Some v\\<close>)"], ["proof (state)\nthis:\n  (subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v) = subst (g \\<sigma>) mem'\n\ngoal (2 subgoals):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n       (x := v)\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n 2. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n  (x := v)\\<rangle>\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n  (subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v) = subst (g \\<sigma>) mem'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n  (x := v)\\<rangle>\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n  (subst (g\\<^sub>X (\\<sigma> |` X)) mem')(x := v) = subst (g \\<sigma>) mem'\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "assume overwrites:\n          \"\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X]\\<rangle>\""], ["proof (state)\nthis:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "hence\n          \"\\<not> (\\<forall> v. \\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g\\<^sub>X ?\\<sigma>\\<^sub>X] (x := v)\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>v.\n               \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n               (x := v)\\<rangle> \\<leadsto>\n               \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n               (x := v)\\<rangle>)", "by (metis \\<open>doesnt_read c x\\<close> doesnt_read_mutually_exclusive' eval\\<^sub>X)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "hence g_simp [simp]: \"g \\<sigma> = g\\<^sub>X ?\\<sigma>\\<^sub>X\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>v.\n             \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n             (x := v)\\<rangle> \\<leadsto>\n             \\<langle>c', mds', (subst (g\\<^sub>X (\\<sigma> |` X)) mem')\n             (x := v)\\<rangle>)\n\ngoal (1 subgoal):\n 1. (let \\<sigma>' = \\<sigma> |` X\n     in if \\<forall>v.\n              \\<langle>c, mds, (subst \\<sigma>' mem)\n              (x := v)\\<rangle> \\<leadsto>\n              \\<langle>c', mds', (subst (g\\<^sub>X \\<sigma>') mem')\n              (x := v)\\<rangle>\n        then \\<lambda>y. if x = y then \\<sigma> y else g\\<^sub>X \\<sigma>' y\n        else g\\<^sub>X \\<sigma>') =\n    g\\<^sub>X (\\<sigma> |` X)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  g \\<sigma> = g\\<^sub>X (\\<sigma> |` X)\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>dom \\<sigma> = insert x X\\<close> domD insertI1)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "have \"mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v) = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y", "apply (case_tac \"y = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y = x \\<Longrightarrow>\n       ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       ((subst (\\<sigma> |` X) mem)(x := v)) y = subst \\<sigma> mem y", "apply (auto simp: subst_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v =\n    (case \\<sigma> x of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v)\n 2. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (\\<sigma> |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v) =\n       (case \\<sigma> y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "apply (metis \\<open>\\<sigma> x = Some v\\<close> option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<noteq> x \\<Longrightarrow>\n       (case (\\<sigma> |` X) y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v) =\n       (case \\<sigma> y of None \\<Rightarrow> mem y\n        | Some v \\<Rightarrow> v)", "by (metis \\<open>dom (\\<sigma> |` X) = X\\<close> \\<open>dom \\<sigma> = insert x X\\<close> insertE\n            restrict_in subst_def subst_not_in_dom)"], ["proof (state)\nthis:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "from overwrites"], ["proof (chain)\npicking this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>", "have \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] (x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g \\<sigma>]\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n     (x := v)\\<rangle> \\<leadsto>\n     \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X)) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "by (metis g_simp)"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       \\<langle>c, mds, (subst (\\<sigma> |` X) mem)\n       (x := v)\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst (g\\<^sub>X (\\<sigma> |` X))\n                           mem'\\<rangle> \\<Longrightarrow>\n    \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "show \"\\<langle>c, mds, mem [\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> g \\<sigma>]\\<rangle>\""], ["proof (prove)\nusing this:\n  (subst (\\<sigma> |` X) mem)(x := v) = subst \\<sigma> mem\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(x := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<sigma> \\<preceq> \\<sigma> \\<and>\n  (\\<forall>\\<sigma>'.\n      dom \\<sigma>' = insert x X \\<longrightarrow>\n      dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (g \\<sigma>) mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> (insert x X) g\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read c)\\<rbrakk>\n           \\<Longrightarrow> Ex (change_respecting\n                                  \\<langle>c, mds, mem\\<rangle>\n                                  \\<langle>c', mds', mem'\\<rangle> F);\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read c)\\<rbrakk>\n       \\<Longrightarrow> Ex (change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> (insert x F))", "thus \"\\<exists> g. change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> (insert x X) g\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> (insert x X) g\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       change_respecting \\<langle>c, mds, mem\\<rangle>\n        \\<langle>c', mds', mem'\\<rangle> (insert x X) g", "by metis"], ["proof (state)\nthis:\n  \\<exists>g.\n     change_respecting \\<langle>c, mds, mem\\<rangle>\n      \\<langle>c', mds', mem'\\<rangle> (insert x X) g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g.\n     change_respecting \\<langle>c, mds, mem\\<rangle>\n      \\<langle>c', mds', mem'\\<rangle> X g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_neg: \"x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n    fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x", "by (simp add: differing_vars_lists_def differing_vars_def)"], ["", "lemma differing_vars_neg_intro:\n  \"\\<lbrakk> mem\\<^sub>1 x = fst (mems ! i) x;\n  mem\\<^sub>2 x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = fst (mems ! i) x;\n     mem\\<^sub>2 x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                  mem\\<^sub>2 mems i", "by (auto simp: differing_vars_lists_def differing_vars_def)"], ["", "lemma differing_vars_elim [elim]:\n  \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x \\<noteq> mem\\<^sub>1 x) \\<or> (snd (mems ! i) x \\<noteq> mem\\<^sub>2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             i \\<Longrightarrow>\n    fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n    snd (mems ! i) x \\<noteq> mem\\<^sub>2 x", "by (auto simp: differing_vars_lists_def differing_vars_def)"], ["", "lemma subst_overrides: \"dom \\<sigma> = dom \\<tau> \\<Longrightarrow> mem [\\<mapsto> \\<tau>] [\\<mapsto> \\<sigma>] = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = dom \\<tau> \\<Longrightarrow>\n    subst \\<sigma> (subst \\<tau> mem) = subst \\<sigma> mem", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = dom \\<tau> \\<Longrightarrow>\n    (\\<lambda>x.\n        case \\<sigma> x of\n        None \\<Rightarrow>\n          case \\<tau> x of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v\n        | Some v \\<Rightarrow> v) =\n    (\\<lambda>x.\n        case \\<sigma> x of None \\<Rightarrow> mem x\n        | Some v \\<Rightarrow> v)", "by (metis domIff option.exhaust option.simps(4) option.simps(5))"], ["", "lemma dom_restrict_total: \"dom (to_partial f |` X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial f |` X) = X", "unfolding to_partial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<lambda>x. Some (f x)) |` X) = X", "by (metis Int_UNIV_left dom_const dom_restrict)"], ["", "lemma update_nth_eq:\n  \"\\<lbrakk> xs = ys; n < length xs \\<rbrakk> \\<Longrightarrow> xs = ys [n := xs ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys; n \\<sqsubset> length xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys[n := xs ! n]", "by (metis list_update_id)"], ["", "text \\<open>This property is obvious,\n  so an unreadable apply-style proof is acceptable here:\\<close>"], ["", "lemma mm_equiv_step:\n  assumes bisim: \"(cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes modes_eq: \"snd cms\\<^sub>1 = snd cms\\<^sub>2\"\n  assumes step: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle> \\<and>\n  (cms\\<^sub>1', mem\\<^sub>1') \\<approx> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "using assms mm_equiv_strong_low_bisim"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\n  snd cms\\<^sub>1 = snd cms\\<^sub>2\n  (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\n  strong_low_bisim_mm mm_equiv\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "unfolding strong_low_bisim_mm_def"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\n  snd cms\\<^sub>1 = snd cms\\<^sub>2\n  (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\n  sym mm_equiv \\<and>\n  closed_glob_consistent mm_equiv \\<and>\n  (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n      \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n      \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n      mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n      (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n          \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n          \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n          (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n              \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply (erule_tac x = \"fst cms\\<^sub>1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>fst cms\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>fst cms\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply (erule_tac x = \"snd cms\\<^sub>1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>fst cms\\<^sub>1, snd cms\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, snd cms\\<^sub>1, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>snd cms\\<^sub>1\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>fst cms\\<^sub>1, snd\n cms\\<^sub>1, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, snd cms\\<^sub>1, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "by (metis surjective_pairing)"], ["", "lemma change_respecting_doesnt_modify:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X g\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes domf: \"dom f = X\"\n  assumes x_in_dom: \"x \\<in> dom (g f)\"\n  assumes noread: \"doesnt_read (fst cms) x\"\n  shows \"mem x = mem' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem x = mem' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem x = mem' x", "let ?f' = \"to_partial mem |` X\""], ["proof (state)\ngoal (1 subgoal):\n 1. mem x = mem' x", "have domf': \"dom ?f' = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial mem |` X) = X", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom (to_partial mem |` X) = X\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "from cr and eval"], ["proof (chain)\npicking this:\n  change_respecting (cms, mem) (cms', mem') X g\n  (cms, mem) \\<leadsto> (cms', mem')", "have \"\\<forall> f. dom f = X \\<longrightarrow> (cms, mem [\\<mapsto> f]) \\<leadsto> (cms', mem' [\\<mapsto> g f])\""], ["proof (prove)\nusing this:\n  change_respecting (cms, mem) (cms', mem') X g\n  (cms, mem) \\<leadsto> (cms', mem')\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       dom f = X \\<longrightarrow>\n       (cms, subst f mem) \\<leadsto> (cms', subst (g f) mem')", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  (cms, mem) \\<leadsto> (cms', mem') \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      g \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> = X \\<and> dom \\<sigma>' = X \\<longrightarrow>\n      dom (g \\<sigma>) = dom (g \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = X \\<longrightarrow>\n      (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst (g \\<sigma>) mem'))\n  (cms, mem) \\<leadsto> (cms', mem')\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       dom f = X \\<longrightarrow>\n       (cms, subst f mem) \\<leadsto> (cms', subst (g f) mem')", "by metis"], ["proof (state)\nthis:\n  \\<forall>f.\n     dom f = X \\<longrightarrow>\n     (cms, subst f mem) \\<leadsto> (cms', subst (g f) mem')\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence eval': \"(cms, mem [\\<mapsto> ?f']) \\<leadsto> (cms', mem' [\\<mapsto> g ?f'])\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     dom f = X \\<longrightarrow>\n     (cms, subst f mem) \\<leadsto> (cms', subst (g f) mem')\n\ngoal (1 subgoal):\n 1. (cms, subst (to_partial mem |` X) mem) \\<leadsto>\n    (cms', subst (g (to_partial mem |` X)) mem')", "by (metis domf')"], ["proof (state)\nthis:\n  (cms, subst (to_partial mem |` X) mem) \\<leadsto>\n  (cms', subst (g (to_partial mem |` X)) mem')\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "have mem_eq: \"mem [\\<mapsto> ?f'] = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (to_partial mem |` X) mem = mem", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst (to_partial mem |` X) mem x = mem x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst (to_partial mem |` X) mem x = mem x", "show \"mem [\\<mapsto> ?f'] x = mem x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (to_partial mem |` X) mem x = mem x", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (to_partial mem |` X) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "apply (cases \"x \\<in> X\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow>\n    (case (to_partial mem |` X) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x\n 2. x \\<notin> X \\<Longrightarrow>\n    (case (to_partial mem |` X) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "apply (metis option.simps(5) restrict_in to_partial_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> X \\<Longrightarrow>\n    (case (to_partial mem |` X) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "by (metis domf' subst_def subst_not_in_dom)"], ["proof (state)\nthis:\n  subst (to_partial mem |` X) mem x = mem x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst (to_partial mem |` X) mem = mem\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "then"], ["proof (chain)\npicking this:\n  subst (to_partial mem |` X) mem = mem", "have mem'_eq: \"mem' [\\<mapsto> g ?f'] = mem'\""], ["proof (prove)\nusing this:\n  subst (to_partial mem |` X) mem = mem\n\ngoal (1 subgoal):\n 1. subst (g (to_partial mem |` X)) mem' = mem'", "using eval eval' deterministic"], ["proof (prove)\nusing this:\n  subst (to_partial mem |` X) mem = mem\n  (cms, mem) \\<leadsto> (cms', mem')\n  (cms, subst (to_partial mem |` X) mem) \\<leadsto>\n  (cms', subst (g (to_partial mem |` X)) mem')\n  \\<lbrakk>?lc \\<leadsto> ?lc'; ?lc \\<leadsto> ?lc''\\<rbrakk>\n  \\<Longrightarrow> ?lc' = ?lc''\n\ngoal (1 subgoal):\n 1. subst (g (to_partial mem |` X)) mem' = mem'", "by (metis Pair_inject)"], ["proof (state)\nthis:\n  subst (g (to_partial mem |` X)) mem' = mem'\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "moreover"], ["proof (state)\nthis:\n  subst (g (to_partial mem |` X)) mem' = mem'\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "have \"dom (g ?f') = dom (g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (g (to_partial mem |` X)) = dom (g f)", "by (metis change_respecting.simps cr domf domf')"], ["proof (state)\nthis:\n  dom (g (to_partial mem |` X)) = dom (g f)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence x_in_dom': \"x \\<in> dom (g ?f')\""], ["proof (prove)\nusing this:\n  dom (g (to_partial mem |` X)) = dom (g f)\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g (to_partial mem |` X))", "by (metis x_in_dom)"], ["proof (state)\nthis:\n  x \\<in> dom (g (to_partial mem |` X))\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "have \"x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X", "by (metis change_respecting.simps cr domf func_le_dom in_mono x_in_dom)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"?f' x = Some (mem x)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (to_partial mem |` X) x = Some (mem x)", "by (metis restrict_in to_partial_def)"], ["proof (state)\nthis:\n  (to_partial mem |` X) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"g ?f' x = Some (mem x)\""], ["proof (prove)\nusing this:\n  (to_partial mem |` X) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. g (to_partial mem |` X) x = Some (mem x)", "using cr func_le_def"], ["proof (prove)\nusing this:\n  (to_partial mem |` X) x = Some (mem x)\n  change_respecting (cms, mem) (cms', mem') X g\n  ?f \\<preceq> ?g = (\\<forall>x\\<in>dom ?f. ?f x = ?g x)\n\ngoal (1 subgoal):\n 1. g (to_partial mem |` X) x = Some (mem x)", "by (metis change_respecting.simps domf' x_in_dom')"], ["proof (state)\nthis:\n  g (to_partial mem |` X) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"mem' [\\<mapsto> g ?f'] x = mem x\""], ["proof (prove)\nusing this:\n  g (to_partial mem |` X) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. subst (g (to_partial mem |` X)) mem' x = mem x", "using subst_def x_in_dom'"], ["proof (prove)\nusing this:\n  g (to_partial mem |` X) x = Some (mem x)\n  subst ?f ?mem =\n  (\\<lambda>x.\n      case ?f x of None \\<Rightarrow> ?mem x | Some v \\<Rightarrow> v)\n  x \\<in> dom (g (to_partial mem |` X))\n\ngoal (1 subgoal):\n 1. subst (g (to_partial mem |` X)) mem' x = mem x", "by (metis option.simps(5))"], ["proof (state)\nthis:\n  subst (g (to_partial mem |` X)) mem' x = mem x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "thus \"mem x = mem' x\""], ["proof (prove)\nusing this:\n  subst (g (to_partial mem |` X)) mem' x = mem x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "by (metis mem'_eq)"], ["proof (state)\nthis:\n  mem x = mem' x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Some machinery for making use of closedness under globally consistent changes:\n   - We introduce the notion of an \"adaptation\" that replaces (finitely many)\n     variables in two memory states with (possibly different) other values.\n   - We then define a function to apply adaptations to memory states\n*)"], ["", "type_synonym ('var, 'val) adaptation = \"'var \\<rightharpoonup> ('val \\<times> 'val)\""], ["", "definition apply_adaptation ::\n  \"bool \\<Rightarrow> ('Var, 'Val) Mem \\<Rightarrow> ('Var, 'Val) adaptation \\<Rightarrow> ('Var, 'Val) Mem\"\n  where \"apply_adaptation first mem A =\n         (\\<lambda> x. case (A x) of\n               Some (v\\<^sub>1, v\\<^sub>2) \\<Rightarrow> if first then v\\<^sub>1 else v\\<^sub>2\n             | None \\<Rightarrow> mem x)\""], ["", "abbreviation apply_adaptation\\<^sub>1 ::\n  \"('Var, 'Val) Mem \\<Rightarrow> ('Var, 'Val) adaptation \\<Rightarrow> ('Var, 'Val) Mem\"\n  (\"_ [\\<parallel>\\<^sub>1 _]\" [900, 0] 1000)\n  where \"mem [\\<parallel>\\<^sub>1 A] \\<equiv> apply_adaptation True mem A\""], ["", "abbreviation apply_adaptation\\<^sub>2 ::\n  \"('Var, 'Val) Mem \\<Rightarrow> ('Var, 'Val) adaptation \\<Rightarrow> ('Var, 'Val) Mem\"\n  (\"_ [\\<parallel>\\<^sub>2 _]\" [900, 0] 1000)\n  where \"mem [\\<parallel>\\<^sub>2 A] \\<equiv> apply_adaptation False mem A\""], ["", "definition restrict_total :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a set \\<Rightarrow> 'a \\<rightharpoonup> 'b\" (*infix \"|'\" 60*)\n  where \"restrict_total f A = to_partial f |` A\""], ["", "lemma differing_empty_eq:\n  \"\\<lbrakk> differing_vars mem mem' = {} \\<rbrakk> \\<Longrightarrow> mem = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars mem mem' = {} \\<Longrightarrow> mem = mem'", "unfolding differing_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. mem x \\<noteq> mem' x} = {} \\<Longrightarrow> mem = mem'", "by auto"], ["", "definition globally_consistent_var :: \"('Var, 'Val) adaptation \\<Rightarrow> 'Var Mds \\<Rightarrow> 'Var \\<Rightarrow> bool\"\n  where \"globally_consistent_var A mds x \\<equiv>\n  (case A x of\n     Some (v, v') \\<Rightarrow> x \\<notin> mds AsmNoWrite \\<and> (dma x = Low \\<longrightarrow> v = v')\n   | None \\<Rightarrow> True)\""], ["", "definition globally_consistent  :: \"('Var, 'Val) adaptation \\<Rightarrow> 'Var Mds \\<Rightarrow> bool\"\n  where \"globally_consistent A mds \\<equiv> finite (dom A) \\<and>\n  (\\<forall> x \\<in> dom A. globally_consistent_var A mds x)\""], ["", "definition gc2 :: \"('Var, 'Val) adaptation \\<Rightarrow> 'Var Mds \\<Rightarrow> bool\"\n  where \"gc2 A mds = (\\<forall> x \\<in> dom A. globally_consistent_var A mds x)\""], ["", "lemma globally_consistent_dom:\n  \"\\<lbrakk> globally_consistent A mds; X \\<subseteq> dom A \\<rbrakk> \\<Longrightarrow> globally_consistent (A |` X) mds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>globally_consistent A mds; X \\<subseteq> dom A\\<rbrakk>\n    \\<Longrightarrow> globally_consistent (A |` X) mds", "unfolding globally_consistent_def globally_consistent_var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (dom A) \\<and>\n             (\\<forall>x\\<in>dom A.\n                 case A x of None \\<Rightarrow> True\n                 | Some (v, v') \\<Rightarrow>\n                     x \\<notin> mds AsmNoWrite \\<and>\n                     (dma x = Low \\<longrightarrow> v = v'));\n     X \\<subseteq> dom A\\<rbrakk>\n    \\<Longrightarrow> finite (dom (A |` X)) \\<and>\n                      (\\<forall>x\\<in>dom (A |` X).\n                          case (A |` X) x of None \\<Rightarrow> True\n                          | Some (v, v') \\<Rightarrow>\n                              x \\<notin> mds AsmNoWrite \\<and>\n                              (dma x = Low \\<longrightarrow> v = v'))", "by (metis (no_types) IntE dom_restrict inf_absorb2 restrict_in rev_finite_subset)"], ["", "lemma globally_consistent_writable:\n  \"\\<lbrakk> x \\<in> dom A; globally_consistent A mds \\<rbrakk> \\<Longrightarrow> x \\<notin> mds AsmNoWrite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom A; globally_consistent A mds\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> mds AsmNoWrite", "unfolding globally_consistent_def globally_consistent_var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom A;\n     finite (dom A) \\<and>\n     (\\<forall>x\\<in>dom A.\n         case A x of None \\<Rightarrow> True\n         | Some (v, v') \\<Rightarrow>\n             x \\<notin> mds AsmNoWrite \\<and>\n             (dma x = Low \\<longrightarrow> v = v'))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> mds AsmNoWrite", "by (metis (no_types) domD option.simps(5) split_part)"], ["", "lemma globally_consistent_loweq:\n  assumes globally_consistent: \"globally_consistent A mds\"\n  assumes some: \"A x = Some (v, v')\"\n  assumes low: \"dma x = Low\"\n  shows \"v = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = v'", "from some"], ["proof (chain)\npicking this:\n  A x = Some (v, v')", "have \"x \\<in> dom A\""], ["proof (prove)\nusing this:\n  A x = Some (v, v')\n\ngoal (1 subgoal):\n 1. x \\<in> dom A", "by (metis domI)"], ["proof (state)\nthis:\n  x \\<in> dom A\n\ngoal (1 subgoal):\n 1. v = v'", "hence \"case A x of None \\<Rightarrow> True | Some (v, v') \\<Rightarrow> (dma x = Low \\<longrightarrow> v = v')\""], ["proof (prove)\nusing this:\n  x \\<in> dom A\n\ngoal (1 subgoal):\n 1. case A x of None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'", "using globally_consistent"], ["proof (prove)\nusing this:\n  x \\<in> dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. case A x of None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'", "unfolding globally_consistent_def globally_consistent_var_def"], ["proof (prove)\nusing this:\n  x \\<in> dom A\n  finite (dom A) \\<and>\n  (\\<forall>x\\<in>dom A.\n      case A x of None \\<Rightarrow> True\n      | Some (v, v') \\<Rightarrow>\n          x \\<notin> mds AsmNoWrite \\<and>\n          (dma x = Low \\<longrightarrow> v = v'))\n\ngoal (1 subgoal):\n 1. case A x of None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'", "by (metis option.simps(5) some split_part)"], ["proof (state)\nthis:\n  case A x of None \\<Rightarrow> True\n  | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'\n\ngoal (1 subgoal):\n 1. v = v'", "with \\<open>dma x = Low\\<close>"], ["proof (chain)\npicking this:\n  dma x = Low\n  case A x of None \\<Rightarrow> True\n  | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  dma x = Low\n  case A x of None \\<Rightarrow> True\n  | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'\n\ngoal (1 subgoal):\n 1. v = v'", "unfolding some"], ["proof (prove)\nusing this:\n  dma x = Low\n  case Some (v, v') of None \\<Rightarrow> True\n  | Some (v, v') \\<Rightarrow> dma x = Low \\<longrightarrow> v = v'\n\ngoal (1 subgoal):\n 1. v = v'", "by auto"], ["proof (state)\nthis:\n  v = v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma globally_consistent_adapt_bisim:\n  assumes bisim: \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\"\n  assumes globally_consistent: \"globally_consistent A mds\"\n  shows \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "from globally_consistent"], ["proof (chain)\npicking this:\n  globally_consistent A mds", "have \"finite (dom A)\""], ["proof (prove)\nusing this:\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. finite (dom A)", "by (auto simp: globally_consistent_def)"], ["proof (state)\nthis:\n  finite (dom A)\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (dom A)\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "using globally_consistent"], ["proof (prove)\nusing this:\n  finite (dom A)\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "proof (induct \"dom A\" arbitrary: A rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>{} = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "case empty"], ["proof (state)\nthis:\n  {} = dom A\n  globally_consistent A mds\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>{} = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "hence \"\\<And> x. A x = None\""], ["proof (prove)\nusing this:\n  {} = dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. \\<And>x. A x = None", "by auto"], ["proof (state)\nthis:\n  A ?x5 = None\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>{} = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "hence \"mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] = mem\\<^sub>1\" and \"mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] = mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  A ?x5 = None\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] = mem\\<^sub>1 &&&\n    mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] = mem\\<^sub>2", "unfolding apply_adaptation_def"], ["proof (prove)\nusing this:\n  A ?x5 = None\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case A x of None \\<Rightarrow> mem\\<^sub>1 x\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n    mem\\<^sub>1 &&&\n    (\\<lambda>x.\n        case A x of None \\<Rightarrow> mem\\<^sub>2 x\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n    mem\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] = mem\\<^sub>1\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] = mem\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>{} = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "with bisim"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] = mem\\<^sub>1\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] = mem\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] = mem\\<^sub>1\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] = mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "case (insert x X)"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "define A' where \"A' = A |` X\""], ["proof (state)\nthis:\n  A' = A |` X\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "hence \"dom A' = X\""], ["proof (prove)\nusing this:\n  A' = A |` X\n\ngoal (1 subgoal):\n 1. dom A' = X", "by (metis Int_insert_left_if0 dom_restrict inf_absorb2 insert(2) insert(4) order_refl)"], ["proof (state)\nthis:\n  dom A' = X\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "moreover"], ["proof (state)\nthis:\n  dom A' = X\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "from insert"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds", "have \"globally_consistent A' mds\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. globally_consistent A' mds", "by (metis A'_def globally_consistent_dom subset_insertI)"], ["proof (state)\nthis:\n  globally_consistent A' mds\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  dom A' = X\n  globally_consistent A' mds", "have bisim': \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>\""], ["proof (prove)\nusing this:\n  dom A' = X\n  globally_consistent A' mds\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>", "using insert"], ["proof (prove)\nusing this:\n  dom A' = X\n  globally_consistent A' mds\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>", "by metis"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "with insert"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>", "have writable: \"x \\<notin> mds AsmNoWrite\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<notin> mds AsmNoWrite", "by (metis globally_consistent_writable insertI1)"], ["proof (state)\nthis:\n  x \\<notin> mds AsmNoWrite\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "from insert"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds", "obtain v v' where \"A x = Some (v, v')\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5; globally_consistent ?A5 mds\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  globally_consistent A mds\n\ngoal (1 subgoal):\n 1. (\\<And>v v'.\n        A x = Some (v, v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding globally_consistent_def globally_consistent_var_def"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>X = dom ?A5;\n   finite (dom ?A5) \\<and>\n   (\\<forall>x\\<in>dom ?A5.\n       case ?A5 x of None \\<Rightarrow> True\n       | Some (v, v') \\<Rightarrow>\n           x \\<notin> mds AsmNoWrite \\<and>\n           (dma x = Low \\<longrightarrow> v = v'))\\<rbrakk>\n  \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 ?A5]\\<rangle> \\<approx>\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 ?A5]\\<rangle>\n  insert x X = dom A\n  finite (dom A) \\<and>\n  (\\<forall>x\\<in>dom A.\n      case A x of None \\<Rightarrow> True\n      | Some (v, v') \\<Rightarrow>\n          x \\<notin> mds AsmNoWrite \\<and>\n          (dma x = Low \\<longrightarrow> v = v'))\n\ngoal (1 subgoal):\n 1. (\\<And>v v'.\n        A x = Some (v, v') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) domD insert_iff option.simps(5) case_prodE)"], ["proof (state)\nthis:\n  A x = Some (v, v')\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "have A_A': \"\\<And> y. y \\<noteq> x \\<Longrightarrow> A y = A' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<noteq> x \\<Longrightarrow> A y = A' y", "unfolding A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<noteq> x \\<Longrightarrow> A y = (A |` X) y", "by (metis domIff insert(4) insert_iff restrict_in restrict_out)"], ["proof (state)\nthis:\n  ?y5 \\<noteq> x \\<Longrightarrow> A ?y5 = A' ?y5\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "(* The following equalities may have more elegant proofs, but\n        this should suffice, since the propositions are\n        quite obvious. *)"], ["proof (state)\nthis:\n  ?y5 \\<noteq> x \\<Longrightarrow> A ?y5 = A' ?y5\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "have eq\\<^sub>1: \"mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'] (x := v) = mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'](x := v) =\n    mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]", "unfolding apply_adaptation_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case (A |` X) x of None \\<Rightarrow> mem\\<^sub>1 x\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n    (x := v) =\n    (\\<lambda>x.\n        case A x of None \\<Rightarrow> mem\\<^sub>1 x\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>1 x\n            | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n        (x := v))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)", "apply (case_tac \"x = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       x = y \\<Longrightarrow>\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>1 x\n            | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n        (x := v))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n 2. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>1 x\n            | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n        (x := v))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. v =\n    (case A x of None \\<Rightarrow> mem\\<^sub>1 x\n     | Some (xa, xb) \\<Rightarrow> if True then xa else xb)\n 2. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       (case (A |` X) y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n       (case A y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)", "apply (metis \\<open>A x = Some (v, v')\\<close> option.simps(5) split_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       (case (A |` X) y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n       (case A y of None \\<Rightarrow> mem\\<^sub>1 y\n        | Some (xa, xb) \\<Rightarrow> if True then xa else xb)", "by (metis A'_def A_A')"], ["proof (state)\nthis:\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'](x := v) =\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "have eq\\<^sub>2: \"mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'] (x := v') = mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'](x := v') =\n    mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]", "unfolding apply_adaptation_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case (A |` X) x of None \\<Rightarrow> mem\\<^sub>2 x\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n    (x := v') =\n    (\\<lambda>x.\n        case A x of None \\<Rightarrow> mem\\<^sub>2 x\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)", "apply (rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>2 x\n            | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n        (x := v'))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)", "apply (case_tac \"x = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       x = y \\<Longrightarrow>\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>2 x\n            | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n        (x := v'))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n 2. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       ((\\<lambda>x.\n            case (A |` X) x of None \\<Rightarrow> mem\\<^sub>2 x\n            | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n        (x := v'))\n        y =\n       (case A y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. v' =\n    (case A x of None \\<Rightarrow> mem\\<^sub>2 x\n     | Some (xa, xb) \\<Rightarrow> if False then xa else xb)\n 2. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       (case (A |` X) y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n       (case A y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)", "apply (metis \\<open>A x = Some (v, v')\\<close> option.simps(5) split_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       x \\<noteq> y \\<Longrightarrow>\n       (case (A |` X) y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n       (case A y of None \\<Rightarrow> mem\\<^sub>2 y\n        | Some (xa, xb) \\<Rightarrow> if False then xa else xb)", "by (metis A'_def A_A')"], ["proof (state)\nthis:\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'](x := v') =\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\n\ngoal (1 subgoal):\n 1. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>F = dom A; globally_consistent A mds\\<rbrakk>\n           \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>;\n        insert x F = dom A; globally_consistent A mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "proof (cases \"dma x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "assume \"dma x = High\""], ["proof (state)\nthis:\n  dma x = High\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "hence \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'] (x := v)\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'] (x := v')\\<rangle>\""], ["proof (prove)\nusing this:\n  dma x = High\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v')\\<rangle>", "using mm_equiv_glob_consistent"], ["proof (prove)\nusing this:\n  dma x = High\n  closed_glob_consistent mm_equiv\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v')\\<rangle>", "unfolding closed_glob_consistent_def"], ["proof (prove)\nusing this:\n  dma x = High\n  \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n     \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n     \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n     (\\<forall>x.\n         (dma x = High \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n          (\\<forall>v\\<^sub>1 v\\<^sub>2.\n              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n              (x := v\\<^sub>1)\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n              (x := v\\<^sub>2)\\<rangle>)) \\<and>\n         (dma x = Low \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n          (\\<forall>v.\n              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n              (x := v)\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2(x := v)\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v')\\<rangle>", "by (metis bisim' \\<open>x \\<notin> mds AsmNoWrite\\<close>)"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v')\\<rangle>\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n 2. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "using eq\\<^sub>1 eq\\<^sub>2"], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v')\\<rangle>\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'](x := v) =\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'](x := v') =\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "assume \"dma x = Low\""], ["proof (state)\nthis:\n  dma x = Low\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "hence \"v = v'\""], ["proof (prove)\nusing this:\n  dma x = Low\n\ngoal (1 subgoal):\n 1. v = v'", "by (metis \\<open>A x = Some (v, v')\\<close> globally_consistent_loweq insert.prems)"], ["proof (state)\nthis:\n  v = v'\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "moreover"], ["proof (state)\nthis:\n  v = v'\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "from writable and bisim"], ["proof (chain)\npicking this:\n  x \\<notin> mds AsmNoWrite\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>", "have\n        \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'] (x := v)\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'] (x := v)\\<rangle>\""], ["proof (prove)\nusing this:\n  x \\<notin> mds AsmNoWrite\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v)\\<rangle>", "using mm_equiv_glob_consistent"], ["proof (prove)\nusing this:\n  x \\<notin> mds AsmNoWrite\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n  closed_glob_consistent mm_equiv\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v)\\<rangle>", "unfolding closed_glob_consistent_def"], ["proof (prove)\nusing this:\n  x \\<notin> mds AsmNoWrite\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n  \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n     \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n     \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n     (\\<forall>x.\n         (dma x = High \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n          (\\<forall>v\\<^sub>1 v\\<^sub>2.\n              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n              (x := v\\<^sub>1)\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n              (x := v\\<^sub>2)\\<rangle>)) \\<and>\n         (dma x = Low \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n          (\\<forall>v.\n              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n              (x := v)\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2(x := v)\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n    (x := v)\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n    (x := v)\\<rangle>", "by (metis \\<open>dma x = Low\\<close> bisim')"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  v = v'\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v)\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  v = v'\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "using eq\\<^sub>1 eq\\<^sub>2"], ["proof (prove)\nusing this:\n  v = v'\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A']\n  (x := v)\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A']\n  (x := v)\\<rangle>\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A'](x := v) =\n  mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A'](x := v') =\n  mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This is the central lemma. Unfortunately, I didn't find\n   a nice partitioning into several easier lemmas: *)"], ["", "lemma makes_compatible_invariant:\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                      \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\"\n  obtains cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?X = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from sound_modes compat modes_eq"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2", "have\n    a: \"\\<forall> i < length cms\\<^sub>1. \\<forall> x \\<in> (?X i). doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n                                          doesnt_read (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms\\<^sub>1.\n       \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n          doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n          doesnt_read (fst (cms\\<^sub>2 ! i)) x", "by (metis compatible_different_no_read)"], ["proof (state)\nthis:\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read (fst (cms\\<^sub>2 ! i)) x\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from eval"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')", "obtain k where\n    b: \"k < length cms\\<^sub>1 \\<and> (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n        cms\\<^sub>1' = cms\\<^sub>1 [k := cms\\<^sub>1' ! k]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<sqsubset> length cms\\<^sub>1 \\<and>\n        (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n        (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n        cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis meval_elim nth_list_update_eq)"], ["proof (state)\nthis:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from modes_eq"], ["proof (chain)\npicking this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2", "have equal_size: \"length cms\\<^sub>1 = length cms\\<^sub>2\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = length cms\\<^sub>2", "by (metis length_map)"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?mds\\<^sub>k = \"snd (cms\\<^sub>1 ! k)\" and\n      ?mds\\<^sub>k' = \"snd (cms\\<^sub>1' ! k)\" and\n      ?mems\\<^sub>1k = \"fst (mems ! k)\" and\n      ?mems\\<^sub>2k = \"snd (mems ! k)\" and\n      ?n = \"length cms\\<^sub>1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite (?X k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "by (metis differing_lists_finite)"], ["proof (state)\nthis:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "(* Obtaining cms' and mem\\<^sub>2' is not in a proof block, since we\n     need some of the following statements later: *)"], ["proof (state)\nthis:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "obtain g1 where\n    c: \"change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1) (cms\\<^sub>1' ! k, mem\\<^sub>1') (?X k) g1\""], ["proof (prove)\nusing this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>g1.\n        change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n         (cms\\<^sub>1' ! k, mem\\<^sub>1')\n         (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n         g1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using noread_exists_change_respecting b a"], ["proof (prove)\nusing this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n  \\<lbrakk>finite ?X;\n   \\<langle>?c, ?mds, ?mem\\<rangle> \\<leadsto>\n   \\<langle>?c', ?mds', ?mem'\\<rangle>;\n   \\<forall>x\\<in>?X. doesnt_read ?c x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g.\n                       change_respecting \\<langle>?c, ?mds, ?mem\\<rangle>\n                        \\<langle>?c', ?mds', ?mem'\\<rangle> ?X g\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read (fst (cms\\<^sub>2 ! i)) x\n\ngoal (1 subgoal):\n 1. (\\<And>g1.\n        change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n         (cms\\<^sub>1' ! k, mem\\<^sub>1')\n         (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n         g1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> ?mems\\<^sub>1k [\\<mapsto> \\<sigma>] = mem\\<^sub>1 [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! k)) = subst \\<sigma> mem\\<^sub>1", "by (metis (no_types) Un_upper1 differing_vars_lists_def differing_vars_subst)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  subst ?\\<sigma>5 (fst (mems ! k)) = subst ?\\<sigma>5 mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with b and c"], ["proof (chain)\npicking this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  subst ?\\<sigma>5 (fst (mems ! k)) = subst ?\\<sigma>5 mem\\<^sub>1", "have\n    eval\\<^sub>\\<sigma>: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> (cms\\<^sub>1 ! k, ?mems\\<^sub>1k [\\<mapsto> \\<sigma>]) \\<leadsto> (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>])\""], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  subst ?\\<sigma>5 (fst (mems ! k)) = subst ?\\<sigma>5 mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>1 ! k, subst \\<sigma> (fst (mems ! k))) \\<leadsto>\n       (cms\\<^sub>1' ! k, subst (g1 \\<sigma>) mem\\<^sub>1')", "by auto"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with b and compat"], ["proof (chain)\npicking this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')", "have\n    bisim\\<^sub>\\<sigma>: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> (cms\\<^sub>1 ! k, ?mems\\<^sub>1k [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>1 ! k, subst \\<sigma> (fst (mems ! k))) \\<approx>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k)))", "by auto"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "by (metis b equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "have d: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> \\<exists> c\\<^sub>f' mem\\<^sub>f'.\n    (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>f', ?mds\\<^sub>k', mem\\<^sub>f' \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>]) \\<approx> \\<langle> c\\<^sub>f', ?mds\\<^sub>k', mem\\<^sub>f' \\<rangle>\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1')\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n          (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n          \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                                    k), mem\\<^sub>f'\\<rangle> \\<and>\n          (cms\\<^sub>1' ! k, subst (g1 \\<sigma>) mem\\<^sub>1') \\<approx>\n          \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>", "by (metis mm_equiv_step)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain h :: \"'Var \\<rightharpoonup> 'Val\" where domh: \"dom h = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        dom h =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "obtain c\\<^sub>h mem\\<^sub>h where h_prop:\n    \"(cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> g1 h]) \\<approx> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle>\""], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>h mem\\<^sub>h.\n        (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<and>\n        (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using d"], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>h mem\\<^sub>h.\n        (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<and>\n        (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>", "obtain g2 where e:\n    \"change_respecting (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h]) \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle> (?X k) g2\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>g2.\n        change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n         \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n         (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n         g2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a b noread_exists_change_respecting"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read (fst (cms\\<^sub>2 ! i)) x\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  \\<lbrakk>finite ?X;\n   \\<langle>?c, ?mds, ?mem\\<rangle> \\<leadsto>\n   \\<langle>?c', ?mds', ?mem'\\<rangle>;\n   \\<forall>x\\<in>?X. doesnt_read ?c x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g.\n                       change_respecting \\<langle>?c, ?mds, ?mem\\<rangle>\n                        \\<langle>?c', ?mds', ?mem'\\<rangle> ?X g\n\ngoal (1 subgoal):\n 1. (\\<And>g2.\n        change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n         \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n         (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n         g2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis differing_lists_finite surjective_pairing)\n\n  \\<comment> \\<open>The following statements are universally quantified\n      since they are reused later:\\<close>"], ["proof (state)\nthis:\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with h_prop"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2", "have\n    \"\\<forall> \\<sigma>. dom \\<sigma> = ?X k \\<longrightarrow>\n      (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> g2 \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n       (cms\\<^sub>2 ! k,\n        subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      g2 \\<sigma> \\<preceq> \\<sigma>) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<and>\n      dom \\<sigma>' =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      dom (g2 \\<sigma>) = dom (g2 \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      (cms\\<^sub>2 ! k,\n       subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n      \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                               k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n       (cms\\<^sub>2 ! k,\n        subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with domh"], ["proof (chain)\npicking this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "have f:\n    \"\\<forall> \\<sigma>. dom \\<sigma> = ?X k \\<longrightarrow>\n      (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> g2 \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "by (auto simp: subst_overrides)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from d and f"], ["proof (chain)\npicking this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "have g: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow>\n    (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> g2 \\<sigma>] \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>]) \\<approx> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> g2 \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>)\n                                     mem\\<^sub>h\\<rangle> \\<and>\n       (cms\\<^sub>1' ! k, subst (g1 \\<sigma>) mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "using h_prop"], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 h) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>)\n                                     mem\\<^sub>h\\<rangle> \\<and>\n       (cms\\<^sub>1' ! k, subst (g1 \\<sigma>) mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>", "by (metis deterministic)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst (g2 ?\\<sigma>5)\n                                mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst (g2 ?\\<sigma>5) mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?\\<sigma>_mem\\<^sub>2 = \"to_partial mem\\<^sub>2 |` ?X k\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define mem\\<^sub>2' where \"mem\\<^sub>2' = mem\\<^sub>h [\\<mapsto> g2 ?\\<sigma>_mem\\<^sub>2]\""], ["proof (state)\nthis:\n  mem\\<^sub>2' =\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define c\\<^sub>2' where \"c\\<^sub>2' = c\\<^sub>h\""], ["proof (state)\nthis:\n  c\\<^sub>2' = c\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have dom\\<sigma>_mem\\<^sub>2: \"dom ?\\<sigma>_mem\\<^sub>2 = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"mem\\<^sub>2 = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>2 =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k))", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>2 x =\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        (snd (mems ! k)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>2 x =\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        (snd (mems ! k)) x", "show \"mem\\<^sub>2 x = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k)) x", "using dom\\<sigma>_mem\\<^sub>2"], ["proof (prove)\nusing this:\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k)) x", "unfolding to_partial_def subst_def"], ["proof (prove)\nusing this:\n  dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n           differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n           x of\n     None \\<Rightarrow> snd (mems ! k) x | Some v \\<Rightarrow> v)", "apply (cases \"x \\<in> ?X k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 x =\n                      (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k)\n                             x of\n                       None \\<Rightarrow> snd (mems ! k) x\n                       | Some v \\<Rightarrow> v)\n 2. \\<lbrakk>dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 x =\n                      (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k)\n                             x of\n                       None \\<Rightarrow> snd (mems ! k) x\n                       | Some v \\<Rightarrow> v)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    mem\\<^sub>2 x = snd (mems ! k) x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  mem\\<^sub>2 x =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with f dom\\<sigma>_mem\\<^sub>2"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))", "have i: \"(cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', ?mds\\<^sub>k', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n    \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>", "unfolding mem\\<^sub>2'_def c\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n    \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                             k), subst\n                                  (g2 (to_partial mem\\<^sub>2 |`\n differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n                                  mem\\<^sub>h\\<rangle>", "by metis"], ["proof (state)\nthis:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define cms\\<^sub>2' where \"cms\\<^sub>2' = cms\\<^sub>2 [k := (c\\<^sub>2', ?mds\\<^sub>k')]\""], ["proof (state)\nthis:\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with i b equal_size"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  length cms\\<^sub>1 = length cms\\<^sub>2\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]", "have \"(cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  length cms\\<^sub>1 = length cms\\<^sub>2\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')", "by (metis meval_intro)"], ["proof (state)\nthis:\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from equal_size"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1 = length cms\\<^sub>2", "have new_length: \"length cms\\<^sub>1' = length cms\\<^sub>2'\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2'", "unfolding cms\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' =\n    length (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])", "by (metis eval length_list_update meval_elim)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with modes_eq"], ["proof (chain)\npicking this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' = length cms\\<^sub>2'", "have \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. map snd cms\\<^sub>1' = map snd cms\\<^sub>2'", "unfolding cms\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' =\n  length (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])\n\ngoal (1 subgoal):\n 1. map snd cms\\<^sub>1' =\n    map snd (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])", "by (metis b map_update snd_conv)"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from c and e"], ["proof (chain)\npicking this:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2", "obtain dom_g1 dom_g2 where\n    dom_uniq: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> dom_g1 = dom (g1 \\<sigma>)\"\n              \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> dom_g2 = dom (g2 \\<sigma>)\""], ["proof (prove)\nusing this:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n\ngoal (1 subgoal):\n 1. (\\<And>dom_g1 dom_g2.\n        \\<lbrakk>\\<And>\\<sigma>.\n                    dom \\<sigma> =\n                    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                     k \\<Longrightarrow>\n                    dom_g1 = dom (g1 \\<sigma>);\n         \\<And>\\<sigma>.\n            dom \\<sigma> =\n            differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n            dom_g2 = dom (g2 \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis change_respecting.simps domh)\n\n  \\<comment> \\<open>This is the complicated part of the proof.\\<close>"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g1 = dom (g1 ?\\<sigma>5)\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g2 = dom (g2 ?\\<sigma>5)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain mems' where \"makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'_k\n      where \"mems'_k x =\n      (if x \\<notin> ?X k\n       then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n       else if (x \\<notin> dom_g1) \\<or> (x \\<notin> dom_g2)\n       then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n       else (?mems\\<^sub>1k x, ?mems\\<^sub>2k x))\" for x\n    \\<comment> \\<open>This is used in two of the following cases, so we prove it beforehand:\\<close>"], ["proof (state)\nthis:\n  mems'_k ?x =\n  (if ?x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n   else if ?x \\<notin> dom_g1 \\<or> ?x \\<notin> dom_g2\n        then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n        else (fst (mems ! k) ?x, snd (mems ! k) ?x))\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have x_unchanged: \"\\<And> x. \\<lbrakk> x \\<in> ?X k; x \\<in> dom_g1; x \\<in> dom_g2 \\<rbrakk> \\<Longrightarrow>\n      mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>1' x \\<and>\n                         mem\\<^sub>2 x = mem\\<^sub>2' x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "assume \"x \\<in> ?X k\" and \"x \\<in> dom_g1\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "thus \"mem\\<^sub>1 x = mem\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g1\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x", "using a b c"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g1\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read (fst (cms\\<^sub>2 ! i)) x\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x", "by (metis change_respecting_doesnt_modify dom_uniq(1) domh)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "assume \"x \\<in> ?X k\" and \"x \\<in> dom_g2\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "hence eq_mem\\<^sub>2: \"?\\<sigma>_mem\\<^sub>2 x = Some (mem\\<^sub>2 x)\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g2\n\ngoal (1 subgoal):\n 1. (to_partial mem\\<^sub>2 |`\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     x =\n    Some (mem\\<^sub>2 x)", "by (metis restrict_in to_partial_def)"], ["proof (state)\nthis:\n  (to_partial mem\\<^sub>2 |`\n   differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "hence \"?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  (to_partial mem\\<^sub>2 |`\n   differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (subst h (snd (mems ! k))) x =\n    mem\\<^sub>2 x", "by (auto simp: subst_def)"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "moreover"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "from \\<open>x \\<in> dom_g2\\<close> dom_uniq e"], ["proof (chain)\npicking this:\n  x \\<in> dom_g2\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g1 = dom (g1 ?\\<sigma>5)\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g2 = dom (g2 ?\\<sigma>5)\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2", "have g_eq: \"g2 ?\\<sigma>_mem\\<^sub>2 x = Some (mem\\<^sub>2 x)\""], ["proof (prove)\nusing this:\n  x \\<in> dom_g2\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g1 = dom (g1 ?\\<sigma>5)\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g2 = dom (g2 ?\\<sigma>5)\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n\ngoal (1 subgoal):\n 1. g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     x =\n    Some (mem\\<^sub>2 x)", "unfolding change_respecting.simps func_le_def"], ["proof (prove)\nusing this:\n  x \\<in> dom_g2\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g1 = dom (g1 ?\\<sigma>5)\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g2 = dom (g2 ?\\<sigma>5)\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      (\\<forall>x\\<in>dom (g2 \\<sigma>). g2 \\<sigma> x = \\<sigma> x)) \\<and>\n  (\\<forall>\\<sigma> \\<sigma>'.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<and>\n      dom \\<sigma>' =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      dom (g2 \\<sigma>) = dom (g2 \\<sigma>')) \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> =\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n      (cms\\<^sub>2 ! k,\n       subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n      \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                               k), subst (g2 \\<sigma>) mem\\<^sub>h\\<rangle>)\n\ngoal (1 subgoal):\n 1. g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     x =\n    Some (mem\\<^sub>2 x)", "by (metis dom_restrict_total eq_mem\\<^sub>2)"], ["proof (state)\nthis:\n  g2 (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "hence \"mem\\<^sub>h [\\<mapsto> g2 ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  g2 (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (1 subgoal):\n 1. subst\n     (g2 (to_partial mem\\<^sub>2 |`\n          differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n     mem\\<^sub>h x =\n    mem\\<^sub>2 x", "by (auto simp: subst_def)"], ["proof (state)\nthis:\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "ultimately"], ["proof (chain)\npicking this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x", "have \"?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>h [\\<mapsto> g2 ?\\<sigma>_mem\\<^sub>2] x\""], ["proof (prove)\nusing this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (subst h (snd (mems ! k))) x =\n    subst\n     (g2 (to_partial mem\\<^sub>2 |`\n          differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n     mem\\<^sub>h x", "by auto"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>2 x = mem\\<^sub>2' x", "thus \"mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x = mem\\<^sub>2' x", "by (metis \\<open>mem\\<^sub>2 = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2]\\<close> dom\\<sigma>_mem\\<^sub>2 domh mem\\<^sub>2'_def subst_overrides)"], ["proof (state)\nthis:\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<in> dom_g1; ?x5 \\<in> dom_g2\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'_i\n      where \"mems'_i i x =\n       (if ((mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n          (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High))\n         then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n         else if ((mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                  (mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low))\n              then (some_val, some_val)\n              else (fst (mems ! i) x, snd (mems ! i) x))\" for i x"], ["proof (state)\nthis:\n  mems'_i ?i ?x =\n  (if (mem\\<^sub>1 ?x \\<noteq> mem\\<^sub>1' ?x \\<or>\n       mem\\<^sub>2 ?x \\<noteq> mem\\<^sub>2' ?x) \\<and>\n      (mem\\<^sub>1' ?x = mem\\<^sub>2' ?x \\<or> dma ?x = High)\n   then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n   else if (mem\\<^sub>1 ?x \\<noteq> mem\\<^sub>1' ?x \\<or>\n            mem\\<^sub>2 ?x \\<noteq> mem\\<^sub>2' ?x) \\<and>\n           mem\\<^sub>1' ?x \\<noteq> mem\\<^sub>2' ?x \\<and> dma ?x = Low\n        then (some_val, some_val)\n        else (fst (mems ! ?i) ?x, snd (mems ! ?i) ?x))\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'\n      where \"mems' =\n       map (\\<lambda> i.\n            if i = k\n            then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n            else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n      [0..< length cms\\<^sub>1]\""], ["proof (state)\nthis:\n  mems' =\n  map (\\<lambda>i.\n          if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n          else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n   [0..<length cms\\<^sub>1]\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "from b"], ["proof (chain)\npicking this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]", "have mems'_k_simp: \"mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\""], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)", "unfolding mems'_def"], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n            else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n     [0..<length cms\\<^sub>1] !\n    k =\n    (fst \\<circ> mems'_k, snd \\<circ> mems'_k)", "by auto"], ["proof (state)\nthis:\n  mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_simp2: \"\\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1 \\<rbrakk> \\<Longrightarrow>\n      mems' ! i = (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> mems' ! i =\n                      (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "unfolding mems'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>i.\n                              if i = k\n                              then (fst \\<circ> mems'_k,\n                                    snd \\<circ> mems'_k)\n                              else (fst \\<circ> mems'_i i,\n                                    snd \\<circ> mems'_i i))\n                       [0..<length cms\\<^sub>1] !\n                      i =\n                      (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> mems' ! i =\n                    (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "(* Some auxiliary statements to allow reasoning about these definitions as if they were given\n       by cases instead of nested if clauses. *)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> mems' ! i =\n                    (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_1 [simp]: \"\\<And> x. \\<lbrakk> x \\<notin> ?X k \\<rbrakk> \\<Longrightarrow>\n      fst (mems' ! k) x = mem\\<^sub>1' x \\<and> snd (mems' ! k) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                   k \\<Longrightarrow>\n       fst (mems' ! k) x = mem\\<^sub>1' x \\<and>\n       snd (mems' ! k) x = mem\\<^sub>2' x", "unfolding mems'_k_simp mems'_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                   k \\<Longrightarrow>\n       fst (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else if x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n                     then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                     else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else if x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n                     then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                     else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       mem\\<^sub>1' x \\<and>\n       snd (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else if x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n                     then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                     else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else if x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n                     then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                     else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  ?x5\n  \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n            k \\<Longrightarrow>\n  fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n  snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_2 [simp]: \"\\<And> x. \\<lbrakk> x \\<in> ?X k; x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2 \\<rbrakk> \\<Longrightarrow>\n      fst (mems' ! k) x = mem\\<^sub>1' x \\<and> snd (mems' ! k) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! k) x = mem\\<^sub>1' x \\<and>\n                         snd (mems' ! k) x = mem\\<^sub>2' x", "unfolding mems'_k_simp mems'_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)))\n                          x =\n                         mem\\<^sub>1' x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)))\n                          x =\n                         mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<notin> dom_g1 \\<or> ?x5 \\<notin> dom_g2\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_3 [simp]: \"\\<And> x. \\<lbrakk> x \\<in> ?X k; x \\<in> dom_g1; x \\<in> dom_g2 \\<rbrakk> \\<Longrightarrow>\n      fst (mems' ! k) x = fst (mems ! k) x \\<and> snd (mems' ! k) x = snd (mems ! k) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! k) x = fst (mems ! k) x \\<and>\n                         snd (mems' ! k) x = snd (mems ! k) x", "unfolding mems'_k_simp mems'_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> dom_g1; x \\<in> dom_g2\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)))\n                          x =\n                         fst (mems ! k) x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if x \\<notin> differing_vars_lists\n           mem\\<^sub>1 mem\\<^sub>2 mems k\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if x \\<notin> dom_g1 \\<or>\n    x \\<notin> dom_g2\n then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n else (fst (mems ! k) x, snd (mems ! k) x)))\n                          x =\n                         snd (mems ! k) x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<in> dom_g1; ?x5 \\<in> dom_g2\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! k) ?x5 = fst (mems ! k) ?x5 \\<and>\n                    snd (mems' ! k) ?x5 = snd (mems ! k) ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_cases:\n      \"\\<And> P x.\n        \\<lbrakk>\n         \\<lbrakk> x \\<notin> ?X k \\<or> x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2;\n           fst (mems' ! k) x = mem\\<^sub>1' x;\n           snd (mems' ! k) x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow> P x;\n         \\<lbrakk> x \\<in> ?X k; x \\<in> dom_g1; x \\<in> dom_g2;\n           fst (mems' ! k) x = fst (mems ! k) x;\n           snd (mems' ! k) x = snd (mems ! k) x \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k \\<or>\n                         x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         x \\<in> dom_g1; x \\<in> dom_g2;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "using mems'_k_1 mems'_k_2 mems'_k_3"], ["proof (prove)\nusing this:\n  ?x5\n  \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n            k \\<Longrightarrow>\n  fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n  snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<notin> dom_g1 \\<or> ?x5 \\<notin> dom_g2\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<in> dom_g1; ?x5 \\<in> dom_g2\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! k) ?x5 = fst (mems ! k) ?x5 \\<and>\n                    snd (mems' ! k) ?x5 = snd (mems ! k) ?x5\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k \\<or>\n                         x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         x \\<in> dom_g1; x \\<in> dom_g2;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>?x5\n                    \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k \\<or>\n                    ?x5 \\<notin> dom_g1 \\<or> ?x5 \\<notin> dom_g2;\n            fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5;\n            snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n           \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n    ?x5 \\<in> dom_g1; ?x5 \\<in> dom_g2;\n    fst (mems' ! k) ?x5 = fst (mems ! k) ?x5;\n    snd (mems' ! k) ?x5 = snd (mems ! k) ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5\\<rbrakk>\n  \\<Longrightarrow> ?P5 ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_simp:\n      \"\\<And> i. \\<lbrakk> i < length cms\\<^sub>1; i \\<noteq> k \\<rbrakk> \\<Longrightarrow> mems' ! i = (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> mems' ! i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "unfolding mems'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i.\n                                 if i = k\n                                 then (fst \\<circ> mems'_k,\n snd \\<circ> mems'_k)\n                                 else (fst \\<circ> mems'_i i,\n snd \\<circ> mems'_i i))\n                          [0..<length cms\\<^sub>1] !\n                         i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<sqsubset> length cms\\<^sub>1; ?i5 \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> mems' ! ?i5 =\n                    (fst \\<circ> mems'_i ?i5, snd \\<circ> mems'_i ?i5)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_1 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n                 mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High \\<rbrakk> \\<Longrightarrow>\n               fst (mems' ! i) x = mem\\<^sub>1' x \\<and> snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n                         snd (mems' ! i) x = mem\\<^sub>2' x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         mem\\<^sub>1' x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or> dma ?x5 = High\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_2 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n                 mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = some_val \\<and> snd (mems' ! i) x = some_val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = some_val \\<and>\n                         snd (mems' ! i) x = some_val", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         some_val \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         some_val", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5; dma ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = some_val \\<and>\n                    snd (mems' ! ?i5) ?x5 = some_val\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_3 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = fst (mems ! i) x \\<and> snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = fst (mems ! i) x \\<and>\n                         snd (mems' ! i) x = snd (mems ! i) x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         fst (mems ! i) x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n then (some_val, some_val) else (fst (mems ! i) x, snd (mems ! i) x)))\n                          x =\n                         snd (mems ! i) x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n   mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "(* This may look complicated, but is actually a rather\n       mechanical definition, as it merely spells out the cases\n       of the definition: *)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n   mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_cases:\n      \"\\<And> P i x.\n         \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n           \\<lbrakk> mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n             mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n             fst (mems' ! i) x = mem\\<^sub>1' x; snd (mems' ! i) x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq>  mem\\<^sub>2' x; dma x = Low;\n        fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        fst (mems' ! i) x = fst (mems ! i) x; snd (mems' ! i) x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk>\n      \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n         fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n         fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x;\n         fst (mems' ! i) x = fst (mems ! i) x;\n         snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "using mems'_i_1 mems'_i_2 mems'_i_3"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or> dma ?x5 = High\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5; dma ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = some_val \\<and>\n                    snd (mems' ! ?i5) ?x5 = some_val\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n   mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. \\<And>P i x.\n       \\<lbrakk>i \\<noteq> k; i \\<sqsubset> length cms\\<^sub>1;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n         fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n         fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x;\n         fst (mems' ! i) x = fst (mems ! i) x;\n         snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "by (metis (full_types) Sec.exhaust)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   \\<lbrakk>mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n            mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n    mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or> dma ?x5 = High;\n    fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5;\n    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n            mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n    mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5; dma ?x5 = Low;\n    fst (mems' ! ?i5) ?x5 = some_val;\n    snd (mems' ! ?i5) ?x5 = some_val\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n    mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n    fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5;\n    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5\\<rbrakk>\n  \\<Longrightarrow> ?P5 ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "let ?X' = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "show \"makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 3. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 4. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "have \"length cms\\<^sub>1' = length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>1", "by (metis cms\\<^sub>2'_def equal_size length_list_update new_length)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (4 subgoals):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 3. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 4. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "then"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1' = length cms\\<^sub>1", "show \"length cms\\<^sub>1' = length cms\\<^sub>2' \\<and> length cms\\<^sub>1' = length mems'\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'", "using compat new_length"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'", "unfolding mems'_def"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' =\n    length\n     (map (\\<lambda>i.\n              if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n              else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n       [0..<length cms\\<^sub>1])", "by auto"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n  length cms\\<^sub>1' = length mems'\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>1'i = \"fst (mems' ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>2'i = \"snd (mems' ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume i_le: \"i < length cms\\<^sub>1'\""], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1'\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume dom\\<sigma>: \"dom \\<sigma> = ?X' i\""], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "show \"(cms\\<^sub>1' ! i, (fst (mems' ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2' ! i, (snd (mems' ! i)) [\\<mapsto> \\<sigma>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "assume [simp]: \"i = k\"\n        \\<comment> \\<open>We define another  function from this and reuse the universally quantified statements\n          from the first part of the proof.\\<close>"], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define \\<sigma>'\n          where \"\\<sigma>' x =\n              (if x \\<in> ?X k\n                then if x \\<in> ?X' k\n                     then \\<sigma> x\n                     else if (x \\<in> dom (g1 h))\n                             then Some (?mems\\<^sub>1'i x)\n                             else if (x \\<in> dom (g2 h))\n                                  then Some (?mems\\<^sub>2'i x)\n                                  else Some some_val\n                else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> ?x\n        else if ?x \\<in> dom (g1 h) then Some (fst (mems' ! i) ?x)\n             else if ?x \\<in> dom (g2 h) then Some (snd (mems' ! i) ?x)\n                  else Some some_val\n   else None)\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "then"], ["proof (chain)\npicking this:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> ?x\n        else if ?x \\<in> dom (g1 h) then Some (fst (mems' ! i) ?x)\n             else if ?x \\<in> dom (g2 h) then Some (snd (mems' ! i) ?x)\n                  else Some some_val\n   else None)", "have dom\\<sigma>': \"dom \\<sigma>' = ?X k\""], ["proof (prove)\nusing this:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> ?x\n        else if ?x \\<in> dom (g1 h) then Some (fst (mems' ! i) ?x)\n             else if ?x \\<in> dom (g2 h) then Some (snd (mems' ! i) ?x)\n                  else Some some_val\n   else None)\n\ngoal (1 subgoal):\n 1. dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by (auto, metis domI domIff, metis \\<open>i = k\\<close> domD dom\\<sigma>)"], ["proof (state)\nthis:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have diff_vars_impl [simp]: \"\\<And>x. x \\<in> ?X' k \\<Longrightarrow> x \\<in> ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<notin> ?X k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"mem\\<^sub>1 x = ?mems\\<^sub>1k x \\<and> mem\\<^sub>2 x = ?mems\\<^sub>2k x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = fst (mems ! k) x \\<and> mem\\<^sub>2 x = snd (mems ! k) x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = fst (mems ! k) x \\<and> mem\\<^sub>2 x = snd (mems ! k) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>x \\<notin> ?X k\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"mem\\<^sub>1' x \\<noteq> ?mems\\<^sub>1'i x \\<or> mem\\<^sub>2' x \\<noteq> ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n    mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x", "by (metis \\<open>i = k\\<close> differing_vars_elim)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x", "show False"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5\n  \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n         k \\<Longrightarrow>\n  ?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have differing_in_dom: \"\\<And>x. \\<lbrakk> x \\<in> ?X k; x \\<in> ?X' k \\<rbrakk> \\<Longrightarrow> x \\<in> dom_g1 \\<and> x \\<in> dom_g2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 k\\<rbrakk>\n       \\<Longrightarrow> x \\<in> dom_g1 \\<and> x \\<in> dom_g2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\""], ["proof (state)\nthis:\n  \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "hence not_in_dom: \"x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2", "by auto"], ["proof (state)\nthis:\n  x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"?mems\\<^sub>1'i x = mem\\<^sub>1' x\" \"?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x &&&\n    snd (mems' ! i) x = mem\\<^sub>2' x", "using \\<open>i = k\\<close> \\<open>x \\<in> ?X k\\<close> mems'_k_2"], ["proof (prove)\nusing this:\n  x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\n  i = k\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<notin> dom_g1 \\<or> ?x5 \\<notin> dom_g2\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x &&&\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k;\n        \\<not> (x \\<in> dom_g1 \\<and> x \\<in> dom_g2)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "show False"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>i = k\\<close> differing_vars_elim)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\\<rbrakk>\n  \\<Longrightarrow> ?x5 \\<in> dom_g1 \\<and> ?x5 \\<in> dom_g2\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* We now show that we can reuse the earlier statements\n           by showing the following equality: *)"], ["proof (state)\nthis:\n  \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n   ?x5 \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\\<rbrakk>\n  \\<Longrightarrow> ?x5 \\<in> dom_g1 \\<and> ?x5 \\<in> dom_g2\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] = mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x =\n       subst (g1 \\<sigma>') mem\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x =\n       subst (g1 \\<sigma>') mem\\<^sub>1' x", "show \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "proof (cases \"x \\<in> ?X' k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "assume x_in_X'k: \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dom\\<sigma> domD \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v", "using \\<open>x \\<in> ?X' k\\<close> dom\\<sigma>"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v", "by (auto simp: subst_def)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "from c"], ["proof (chain)\npicking this:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1", "have le: \"g1 \\<sigma>' \\<preceq> \\<sigma>'\""], ["proof (prove)\nusing this:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n\ngoal (1 subgoal):\n 1. g1 \\<sigma>' \\<preceq> \\<sigma>'", "using dom\\<sigma>'"], ["proof (prove)\nusing this:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. g1 \\<sigma>' \\<preceq> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  g1 \\<sigma>' \\<preceq> \\<sigma>'\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "from dom\\<sigma>' and \\<open>x \\<in> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have \"x \\<in> dom (g1 \\<sigma>')\""], ["proof (prove)\nusing this:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g1 \\<sigma>')", "by (metis diff_vars_impl differing_in_dom dom_uniq(1))"], ["proof (state)\nthis:\n  x \\<in> dom (g1 \\<sigma>')\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>'] x = v\""], ["proof (prove)\nusing this:\n  x \\<in> dom (g1 \\<sigma>')\n\ngoal (1 subgoal):\n 1. subst (g1 \\<sigma>') mem\\<^sub>1' x = v", "using dom\\<sigma>' c le"], ["proof (prove)\nusing this:\n  x \\<in> dom (g1 \\<sigma>')\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  g1 \\<sigma>' \\<preceq> \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst (g1 \\<sigma>') mem\\<^sub>1' x = v", "unfolding func_le_def subst_def"], ["proof (prove)\nusing this:\n  x \\<in> dom (g1 \\<sigma>')\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  \\<forall>x\\<in>dom (g1 \\<sigma>'). g1 \\<sigma>' x = \\<sigma>' x\n\ngoal (1 subgoal):\n 1. (case g1 \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>1' x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis \\<sigma>'_def \\<open>\\<sigma> x = Some v\\<close> diff_vars_impl option.simps(5) x_in_X'k)"], ["proof (state)\nthis:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = v", "show \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>'] x\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", ".."], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "assume \"x \\<notin> ?X' k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x", "by (metis \\<open>i = k\\<close> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "proof (cases \"x \\<in> dom_g1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "assume \"x \\<in> dom_g1\""], ["proof (state)\nthis:\n  x \\<in> dom_g1\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"x \\<in> dom (g1 \\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in> dom_g1\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g1 \\<sigma>')", "using dom\\<sigma>' dom_uniq"], ["proof (prove)\nusing this:\n  x \\<in> dom_g1\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g1 = dom (g1 ?\\<sigma>5)\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  dom_g2 = dom (g2 ?\\<sigma>5)\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g1 \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom (g1 \\<sigma>')\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"g1 \\<sigma>' x = \\<sigma>' x\""], ["proof (prove)\nusing this:\n  x \\<in> dom (g1 \\<sigma>')\n\ngoal (1 subgoal):\n 1. g1 \\<sigma>' x = \\<sigma>' x", "using c dom\\<sigma>'"], ["proof (prove)\nusing this:\n  x \\<in> dom (g1 \\<sigma>')\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. g1 \\<sigma>' x = \\<sigma>' x", "by (metis change_respecting.simps func_le_def)"], ["proof (state)\nthis:\n  g1 \\<sigma>' x = \\<sigma>' x\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  g1 \\<sigma>' x = \\<sigma>' x", "have \"\\<sigma>' x = Some (?mems\\<^sub>1'i x)\""], ["proof (prove)\nusing this:\n  g1 \\<sigma>' x = \\<sigma>' x\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = Some (fst (mems' ! i) x)", "unfolding \\<sigma>'_def"], ["proof (prove)\nusing this:\n  g1 (\\<lambda>x.\n         if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n         then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' k\n              then \\<sigma> x\n              else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n                   else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                        else Some some_val\n         else None)\n   x =\n  (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> x\n        else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n             else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                  else Some some_val\n   else None)\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x\n          else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n               else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                    else Some some_val\n     else None) =\n    Some (fst (mems' ! i) x)", "using dom\\<sigma>' domh"], ["proof (prove)\nusing this:\n  g1 (\\<lambda>x.\n         if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n         then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' k\n              then \\<sigma> x\n              else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n                   else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                        else Some some_val\n         else None)\n   x =\n  (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> x\n        else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n             else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                  else Some some_val\n   else None)\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x\n          else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n               else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                    else Some some_val\n     else None) =\n    Some (fst (mems' ! i) x)", "by (metis \\<open>g1 \\<sigma>' x = \\<sigma>' x\\<close> \\<open>x \\<in> dom (g1 \\<sigma>')\\<close> \\<open>x \\<notin> ?X' k\\<close> domIff dom_uniq(1))"], ["proof (state)\nthis:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "hence \"mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>'] x = ?mems\\<^sub>1'i x\""], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. subst (g1 \\<sigma>') mem\\<^sub>1' x = fst (mems' ! i) x", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. (case g1 \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>1' x\n     | Some v \\<Rightarrow> v) =\n    fst (mems' ! i) x", "by (metis \\<open>g1 \\<sigma>' x = \\<sigma>' x\\<close> option.simps(5))"], ["proof (state)\nthis:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n 2. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "by (metis \\<open>?mems\\<^sub>1'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>1'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "assume \"x \\<notin> dom_g1\""], ["proof (state)\nthis:\n  x \\<notin> dom_g1\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> dom_g1", "have \"mem\\<^sub>1' [\\<mapsto> g1 \\<sigma>'] x = mem\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom_g1\n\ngoal (1 subgoal):\n 1. subst (g1 \\<sigma>') mem\\<^sub>1' x = mem\\<^sub>1' x", "by (metis dom\\<sigma>' dom_uniq(1) subst_not_in_dom)"], ["proof (state)\nthis:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "moreover"], ["proof (state)\nthis:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x", "by (metis \\<open>i = k\\<close> \\<open>x \\<notin> ?X' k\\<close> differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g1 \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "ultimately"], ["proof (chain)\npicking this:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = mem\\<^sub>1' x\n  fst (mems' ! i) x = mem\\<^sub>1' x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst (g1 \\<sigma>') mem\\<^sub>1' x = mem\\<^sub>1' x\n  fst (mems' ! i) x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x", "by (metis \\<open>?mems\\<^sub>1'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>1'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst (g1 \\<sigma>') mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* And the same for the second memories: *)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] = mem\\<^sub>h [\\<mapsto> g2 \\<sigma>']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) = subst (g2 \\<sigma>') mem\\<^sub>h", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (snd (mems' ! i)) x =\n       subst (g2 \\<sigma>') mem\\<^sub>h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (snd (mems' ! i)) x =\n       subst (g2 \\<sigma>') mem\\<^sub>h x", "show \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>h [\\<mapsto> g2 \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "proof (cases \"x \\<in> ?X' k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "assume \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis domD \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = v", "using \\<open>x \\<in> ?X' k\\<close> dom\\<sigma>"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis option.simps(5))"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "from e"], ["proof (chain)\npicking this:\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2", "have le: \"g2 \\<sigma>' \\<preceq> \\<sigma>'\""], ["proof (prove)\nusing this:\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n\ngoal (1 subgoal):\n 1. g2 \\<sigma>' \\<preceq> \\<sigma>'", "using dom\\<sigma>'"], ["proof (prove)\nusing this:\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. g2 \\<sigma>' \\<preceq> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  g2 \\<sigma>' \\<preceq> \\<sigma>'\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "from \\<open>x \\<in> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have \"x \\<in> ?X k\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by auto"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"x \\<in> dom (g2 \\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g2 \\<sigma>')", "by (metis differing_in_dom dom\\<sigma>' dom_uniq(2) \\<open>x \\<in> ?X' k\\<close>)"], ["proof (state)\nthis:\n  x \\<in> dom (g2 \\<sigma>')\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"mem\\<^sub>2' [\\<mapsto> g2 \\<sigma>'] x = v\""], ["proof (prove)\nusing this:\n  x \\<in> dom (g2 \\<sigma>')\n\ngoal (1 subgoal):\n 1. subst (g2 \\<sigma>') mem\\<^sub>2' x = v", "using dom\\<sigma>' c le"], ["proof (prove)\nusing this:\n  x \\<in> dom (g2 \\<sigma>')\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  g2 \\<sigma>' \\<preceq> \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst (g2 \\<sigma>') mem\\<^sub>2' x = v", "unfolding func_le_def subst_def"], ["proof (prove)\nusing this:\n  x \\<in> dom (g2 \\<sigma>')\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g1\n  \\<forall>x\\<in>dom (g2 \\<sigma>'). g2 \\<sigma>' x = \\<sigma>' x\n\ngoal (1 subgoal):\n 1. (case g2 \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>2' x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis \\<sigma>'_def \\<open>\\<sigma> x = Some v\\<close> diff_vars_impl option.simps(5) \\<open>x \\<in> ?X' k\\<close>)"], ["proof (state)\nthis:\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = v", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "by (metis dom\\<sigma>' dom_restrict_total dom_uniq(2) mem\\<^sub>2'_def subst_overrides)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "assume \"x \\<notin> ?X' k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "by (metis \\<open>i = k\\<close> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "proof (cases \"x \\<in> dom_g2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "assume \"x \\<in> dom_g2\""], ["proof (state)\nthis:\n  x \\<in> dom_g2\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"x \\<in> dom (g2 \\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in> dom_g2\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g2 \\<sigma>')", "using dom\\<sigma>'"], ["proof (prove)\nusing this:\n  x \\<in> dom_g2\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<in> dom (g2 \\<sigma>')", "by (metis dom_uniq)"], ["proof (state)\nthis:\n  x \\<in> dom (g2 \\<sigma>')\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"g2 \\<sigma>' x = \\<sigma>' x\""], ["proof (prove)\nusing this:\n  x \\<in> dom (g2 \\<sigma>')\n\ngoal (1 subgoal):\n 1. g2 \\<sigma>' x = \\<sigma>' x", "using e dom\\<sigma>'"], ["proof (prove)\nusing this:\n  x \\<in> dom (g2 \\<sigma>')\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) g2\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. g2 \\<sigma>' x = \\<sigma>' x", "by (metis change_respecting.simps func_le_def)"], ["proof (state)\nthis:\n  g2 \\<sigma>' x = \\<sigma>' x\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "then"], ["proof (chain)\npicking this:\n  g2 \\<sigma>' x = \\<sigma>' x", "have \"\\<sigma>' x = Some (?mems\\<^sub>2'i x)\""], ["proof (prove)\nusing this:\n  g2 \\<sigma>' x = \\<sigma>' x\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = Some (snd (mems' ! i) x)", "proof (cases \"x \\<in> dom_g1\")\n                \\<comment> \\<open>This can't happen, so derive a contradiction.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<in> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)\n 2. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "assume \"x \\<in> dom_g1\""], ["proof (state)\nthis:\n  x \\<in> dom_g1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<in> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)\n 2. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "have \"x \\<notin> ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "assume \"\\<not> (x \\<notin> ?X k)\""], ["proof (state)\nthis:\n  \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "hence \"x \\<in> ?X k\""], ["proof (prove)\nusing this:\n  \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by auto"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "have \"mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x", "by (metis \\<sigma>'_def \\<open>g2 \\<sigma>' x = \\<sigma>' x\\<close> \\<open>x \\<in> dom (g2 \\<sigma>')\\<close>\n                      \\<open>x \\<in> dom_g1\\<close> \\<open>x \\<in> dom_g2\\<close> domIff x_unchanged)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "from \\<open>x \\<notin> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have\n                    \"?mems\\<^sub>1'i x = ?mems\\<^sub>1k x \\<and> ?mems\\<^sub>2'i x = ?mems\\<^sub>2k x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! k) x \\<and>\n    snd (mems' ! i) x = snd (mems ! k) x", "using \\<open>x \\<in> ?X k\\<close> \\<open>x \\<in> dom_g1\\<close> \\<open>x \\<in> dom_g2\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> dom_g1\n  x \\<in> dom_g2\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! k) x \\<and>\n    snd (mems' ! i) x = snd (mems ! k) x", "by auto"], ["proof (state)\nthis:\n  fst (mems' ! i) x = fst (mems ! k) x \\<and>\n  snd (mems' ! i) x = snd (mems ! k) x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                       k \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! k) x \\<and>\n  snd (mems' ! i) x = snd (mems ! k) x", "show False"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! k) x \\<and>\n  snd (mems' ! i) x = snd (mems ! k) x\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<in> ?X k\\<close> \\<open>x \\<notin> ?X' k\\<close>"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! k) x \\<and>\n  snd (mems' ! i) x = snd (mems ! k) x\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>i = k\\<close> differing_vars_elim differing_vars_neg)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<in> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)\n 2. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "hence False"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<sigma>'_def \\<open>g2 \\<sigma>' x = \\<sigma>' x\\<close> \\<open>x \\<in> dom (g2 \\<sigma>')\\<close> domIff)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<in> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)\n 2. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = Some (snd (mems' ! i) x)", "by blast"], ["proof (state)\nthis:\n  \\<sigma>' x = Some (snd (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "assume \"x \\<notin> dom_g1\""], ["proof (state)\nthis:\n  x \\<notin> dom_g1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g2 \\<sigma>' x = \\<sigma>' x; x \\<notin> dom_g1\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' x = Some (snd (mems' ! i) x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> dom_g1\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = Some (snd (mems' ! i) x)", "unfolding \\<sigma>'_def"], ["proof (prove)\nusing this:\n  x \\<notin> dom_g1\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x\n          else if x \\<in> dom (g1 h) then Some (fst (mems' ! i) x)\n               else if x \\<in> dom (g2 h) then Some (snd (mems' ! i) x)\n                    else Some some_val\n     else None) =\n    Some (snd (mems' ! i) x)", "by (metis \\<open>g2 \\<sigma>' x = \\<sigma>' x\\<close> \\<open>x \\<in> dom (g2 \\<sigma>')\\<close> \\<open>x \\<notin> ?X' k\\<close> \n                    domIff dom\\<sigma>' dom_uniq domh)"], ["proof (state)\nthis:\n  \\<sigma>' x = Some (snd (mems' ! i) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>' x = Some (snd (mems' ! i) x)\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"mem\\<^sub>2' [\\<mapsto> g2 \\<sigma>'] x = ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (snd (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. subst (g2 \\<sigma>') mem\\<^sub>2' x = snd (mems' ! i) x", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (snd (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. (case g2 \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>2' x\n     | Some v \\<Rightarrow> v) =\n    snd (mems' ! i) x", "by (metis \\<open>g2 \\<sigma>' x = \\<sigma>' x\\<close> option.simps(5))"], ["proof (state)\nthis:\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = snd (mems' ! i) x\n\ngoal (2 subgoals):\n 1. x \\<in> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n 2. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "using \\<open>x \\<notin> ?X' k\\<close> dom\\<sigma> dom\\<sigma>'"], ["proof (prove)\nusing this:\n  subst (g2 \\<sigma>') mem\\<^sub>2' x = snd (mems' ! i) x\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "by (metis \\<open>i = k\\<close> dom_restrict_total dom_uniq(2)\n                  mem\\<^sub>2'_def subst_not_in_dom subst_overrides)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "assume \"x \\<notin> dom_g2\""], ["proof (state)\nthis:\n  x \\<notin> dom_g2\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> dom_g2", "have \"mem\\<^sub>h [\\<mapsto> g2 \\<sigma>'] x = mem\\<^sub>h x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom_g2\n\ngoal (1 subgoal):\n 1. subst (g2 \\<sigma>') mem\\<^sub>h x = mem\\<^sub>h x", "by (metis dom\\<sigma>' dom_uniq(2) subst_not_in_dom)"], ["proof (state)\nthis:\n  subst (g2 \\<sigma>') mem\\<^sub>h x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  subst (g2 \\<sigma>') mem\\<^sub>h x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "have \"?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis \\<open>i = k\\<close> \\<open>x \\<notin> dom_g2\\<close> mems'_k_1 mems'_k_2)"], ["proof (state)\nthis:\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i x = mem\\<^sub>h x\""], ["proof (prove)\nusing this:\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>h x", "unfolding mem\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  snd (mems' ! i) x =\n  subst\n   (g2 (to_partial mem\\<^sub>2 |`\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k))\n   mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>h x", "by (metis \\<open>x \\<notin> dom_g2\\<close> dom\\<sigma>_mem\\<^sub>2 dom_uniq(2) subst_not_in_dom)"], ["proof (state)\nthis:\n  snd (mems' ! i) x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom_g2 \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "ultimately"], ["proof (chain)\npicking this:\n  subst (g2 \\<sigma>') mem\\<^sub>h x = mem\\<^sub>h x\n  snd (mems' ! i) x = mem\\<^sub>h x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst (g2 \\<sigma>') mem\\<^sub>h x = mem\\<^sub>h x\n  snd (mems' ! i) x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x", "by (metis \\<open>?mems\\<^sub>2'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>2'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst (g2 \\<sigma>') mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) = subst (g2 \\<sigma>') mem\\<^sub>h\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst (g2 \\<sigma>') mem\\<^sub>h", "show\n          \"(cms\\<^sub>1' ! i, (fst (mems' ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2' ! i, (snd (mems' ! i)) [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst (g2 \\<sigma>') mem\\<^sub>h\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "using dom\\<sigma> dom\\<sigma>' g b \\<open>i = k\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) = subst (g1 \\<sigma>') mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst (g2 \\<sigma>') mem\\<^sub>h\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst (g2 ?\\<sigma>5)\n                                mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst (g1 ?\\<sigma>5) mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst (g2 ?\\<sigma>5) mem\\<^sub>h\\<rangle>\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i = k\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "by (metis c\\<^sub>2'_def cms\\<^sub>2'_def equal_size nth_list_update_eq)"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define \\<sigma>'\n          where \"\\<sigma>' x = (if x \\<in> ?X i\n                         then if x \\<in> ?X' i\n                              then \\<sigma> x\n                              else Some (mem\\<^sub>1' x)\n                         else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n        then \\<sigma> ?x else Some (mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "let ?mems\\<^sub>1i = \"fst (mems ! i)\" and\n            ?mems\\<^sub>2i = \"snd (mems ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"dom \\<sigma>' = ?X i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "unfolding \\<sigma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n            then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                             mems' i\n                 then \\<sigma> x else Some (mem\\<^sub>1' x)\n            else None) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n        then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         i\n             then \\<sigma> x else Some (mem\\<^sub>1' x)\n        else None) =\n       Some y \\<Longrightarrow>\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<sigma> x = Some y", "apply (metis option.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<sigma> x = Some y", "by (metis domD dom\\<sigma>)"], ["proof (state)\nthis:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have o: \"\\<And> x.\n                 (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                  ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x)\n                 \\<longrightarrow> (mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "assume eq_mem: \"mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "hence mems'_simp [simp]: \"?mems\\<^sub>1'i x = ?mems\\<^sub>1i x \\<and> ?mems\\<^sub>2'i x = ?mems\\<^sub>2i x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x \\<and>\n    snd (mems' ! i) x = snd (mems ! i) x", "using mems'_i_3"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n   mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x \\<and>\n    snd (mems' ! i) x = snd (mems ! i) x", "by (metis \\<open>i \\<noteq> k\\<close> b i_le length_list_update)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "have\n              \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "proof (cases \"x \\<in> ?X' i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"?mems\\<^sub>1'i x \\<noteq> mem\\<^sub>1' x \\<or> ?mems\\<^sub>2'i x \\<noteq> mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n    snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x", "by (metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"x \\<in> ?X i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using eq_mem mems'_simp"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"\\<sigma>' x = \\<sigma> x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma> x", "by (metis \\<sigma>'_def \\<open>x \\<in> ?X' i\\<close>)"], ["proof (state)\nthis:\n  \\<sigma>' x = \\<sigma> x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' x = \\<sigma> x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "apply (auto simp: subst_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<sigma>' x = \\<sigma> x \\<Longrightarrow>\n    (case \\<sigma> x of None \\<Rightarrow> fst (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    (case \\<sigma> x of None \\<Rightarrow> fst (mems ! i) x\n     | Some v \\<Rightarrow> v)\n 2. \\<sigma>' x = \\<sigma> x \\<Longrightarrow>\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems ! i) x\n     | Some v \\<Rightarrow> v)", "apply (metis mems'_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma> x \\<Longrightarrow>\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems ! i) x\n     | Some v \\<Rightarrow> v)", "by (metis mems'_simp)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using eq_mem mems'_simp"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (auto simp: differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "by (metis \\<open>dom \\<sigma>' = ?X i\\<close> \\<open>x \\<notin> ?X' i\\<close> dom\\<sigma> mems'_simp subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "}"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n  mem\\<^sub>2' x = mem\\<^sub>2 x \\<Longrightarrow>\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "thus \"?thesis x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n  mem\\<^sub>2' x = mem\\<^sub>2 x \\<Longrightarrow>\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (fst (mems ! i)) x \\<or>\n    subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n    mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "by blast"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x \\<longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "from o"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5", "have\n          p: \"\\<And> x. \\<lbrakk> ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                      ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x \\<rbrakk> \\<Longrightarrow>\n          x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (fst (mems ! i)) x \\<or>\n       subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n       subst \\<sigma>' (snd (mems ! i)) x \\<Longrightarrow>\n       x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "assume mems_neq:\n            \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "hence modified:\n            \"\\<not> (doesnt_modify (fst (cms\\<^sub>1 ! k)) x) \\<or> \\<not> (doesnt_modify (fst (cms\\<^sub>2 ! k)) x)\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x", "using b i o"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x", "unfolding doesnt_modify_def"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>mds mem c' mds' mem'.\n               \\<langle>fst (cms\\<^sub>1 ! k), mds, mem\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n               mem x = mem' x) \\<or>\n    \\<not> (\\<forall>mds mem c' mds' mem'.\n               \\<langle>fst (cms\\<^sub>2 ! k), mds, mem\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n               mem x = mem' x)", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "moreover"], ["proof (state)\nthis:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)", "have loc_modes:\n            \"locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n             locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n    locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem\\<^sub>1))\n   cms\\<^sub>1 \\<and>\n  globally_sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem\\<^sub>2))\n   cms\\<^sub>2 \\<and>\n  globally_sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n    locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)", "by (metis b equal_size list_all_length)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "moreover"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "have \"snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "by (metis b equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "have \"(cms\\<^sub>1 ! k, mem\\<^sub>1) \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! k, mem\\<^sub>1)\n    \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)", "by (metis loc_reach.refl prod.collapse)"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "hence guars:\n                \"x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n                 x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow> doesnt_modify (fst (cms\\<^sub>1 ! k)) x\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x", "using loc_modes"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x", "unfolding locally_sound_mode_use_def \\<open>snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\\<close>"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle>\n      \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoRead \\<longrightarrow>\n           doesnt_read c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n           doesnt_modify c' x))) \\<and>\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle>\n      \\<in> loc_reach (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoRead \\<longrightarrow>\n           doesnt_read c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x", "by (metis loc_reach.refl surjective_pairing)"], ["proof (state)\nthis:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "hence \"x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\""], ["proof (prove)\nusing this:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite", "using modified loc_modes locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  locally_sound_mode_use ?lc =\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach ?lc \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoRead \\<longrightarrow>\n           doesnt_read c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite", "by (metis \\<open>snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\\<close> loc_reach.refl prod.collapse)"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "moreover"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)", "have \"compatible_modes (map snd cms\\<^sub>1)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms\\<^sub>1)", "by (metis globally_sound_modes_compatible sound_mode_use.simps)"], ["proof (state)\nthis:\n  compatible_modes (map snd cms\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n 2. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n  compatible_modes (map snd cms\\<^sub>1)", "show \"x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\""], ["proof (prove)\nusing this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n  compatible_modes (map snd cms\\<^sub>1)\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "unfolding compatible_modes_def"], ["proof (prove)\nusing this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n  \\<forall>i x.\n     i \\<sqsubset> length (map snd cms\\<^sub>1) \\<longrightarrow>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoRead \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoRead)) \\<and>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoWrite))\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "using \\<open>i \\<noteq> k\\<close> i_le"], ["proof (prove)\nusing this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite\n  \\<forall>i x.\n     i \\<sqsubset> length (map snd cms\\<^sub>1) \\<longrightarrow>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoRead \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoRead)) \\<and>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoWrite))\n  i \\<noteq> k\n  i \\<sqsubset> length cms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "by (metis (no_types) b length_list_update length_map nth_map)"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n        subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) (?x6 x) \\<longrightarrow>\n        mem\\<^sub>1' (?x6 x) \\<noteq> mem\\<^sub>1 (?x6 x) \\<or>\n        mem\\<^sub>2' (?x6 x) \\<noteq> mem\\<^sub>2 (?x6 x)\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (fst (mems ! i)) (?x6 x) \\<or>\n                         subst \\<sigma> (snd (mems' ! i)) (?x6 x) \\<noteq>\n                         subst \\<sigma>' (snd (mems ! i)) (?x6 x)", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have q:\n          \"\\<And> x. \\<lbrakk> dma x = Low;\n                   ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                   ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x;\n                   x \\<notin> ?X' i \\<rbrakk> \\<Longrightarrow>\n                 mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "by (metis \\<open>i \\<noteq> k\\<close> b compat_different_vars i_le length_list_update mems'_i_2 o)"], ["proof (state)\nthis:\n  \\<lbrakk>dma ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"i < length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sqsubset> length cms\\<^sub>1", "by (metis cms\\<^sub>2'_def equal_size i_le length_list_update new_length)"], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "with compat and \\<open>dom \\<sigma>' = ?X i\\<close>"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  i \\<sqsubset> length cms\\<^sub>1", "have\n          bisim: \"(cms\\<^sub>1 ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) \\<approx> (cms\\<^sub>2 ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  i \\<sqsubset> length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n    (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "let ?\\<Delta> = \"differing_vars (?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) \\<union>\n                  differing_vars (?mems\\<^sub>2i [\\<mapsto> \\<sigma>']) (?mems\\<^sub>2'i [\\<mapsto> \\<sigma>])\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \\<Delta>_finite: \"finite ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (differing_vars (subst \\<sigma>' (fst (mems ! i)))\n       (subst \\<sigma> (fst (mems' ! i))) \\<union>\n      differing_vars (subst \\<sigma>' (snd (mems ! i)))\n       (subst \\<sigma> (snd (mems' ! i))))", "by (metis (no_types) differing_finite finite_UnI)\n        \\<comment> \\<open>We first define the adaptation, then prove that it does the right thing.\\<close>"], ["proof (state)\nthis:\n  finite\n   (differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define A where \"A x =\n                     (if x \\<in> ?\\<Delta>\n                      then if dma x = High\n                           then Some (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x, ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x)\n                           else if x \\<in> ?X' i\n                                then (case \\<sigma> x of\n                                        Some v \\<Rightarrow> Some (v, v)\n                                      | None \\<Rightarrow> None)\n                                else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n                      else None)\" for x"], ["proof (state)\nthis:\n  A ?x =\n  (if ?x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i)))\n   then if dma ?x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) ?x,\n               subst \\<sigma> (snd (mems' ! i)) ?x)\n        else if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' i\n             then case \\<sigma> ?x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' ?x, mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have domA: \"dom A = ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom A =\n    differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n 2. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "show \"dom A \\<subseteq> ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))", "using A_def"], ["proof (prove)\nusing this:\n  A ?x =\n  (if ?x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i)))\n   then if dma ?x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) ?x,\n               subst \\<sigma> (snd (mems' ! i)) ?x)\n        else if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' i\n             then case \\<sigma> ?x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' ?x, mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))", "apply (auto simp: domD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>\\<And>x.\n                   A x =\n                   (if x \\<in> differing_vars\n                                (subst \\<sigma>' (fst (mems ! i)))\n                                (subst \\<sigma> (fst (mems' ! i))) \\<or>\n                       x \\<in> differing_vars\n                                (subst \\<sigma>' (snd (mems ! i)))\n                                (subst \\<sigma> (snd (mems' ! i)))\n                    then if dma x = High\n                         then Some\n                               (subst \\<sigma> (fst (mems' ! i)) x,\n                                subst \\<sigma> (snd (mems' ! i)) x)\n                         else if x \\<in> differing_vars_lists mem\\<^sub>1'\n    mem\\<^sub>2' mems' i\n                              then case \\<sigma> x of\n                                   None \\<Rightarrow> None\n                                   | Some v \\<Rightarrow> Some (v, v)\n                              else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n                    else None);\n        x \\<notin> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                    (subst \\<sigma> (snd (mems' ! i)));\n        (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                     (subst \\<sigma> (fst (mems' ! i)))\n         then if dma x = High\n              then Some\n                    (subst \\<sigma> (fst (mems' ! i)) x,\n                     subst \\<sigma> (snd (mems' ! i)) x)\n              else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                               mems' i\n                   then case \\<sigma> x of None \\<Rightarrow> None\n                        | Some v \\<Rightarrow> Some (v, v)\n                   else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n         else None) =\n        Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> differing_vars\n                                  (subst \\<sigma>' (fst (mems ! i)))\n                                  (subst \\<sigma> (fst (mems' ! i)))", "by (metis option.simps(2))"], ["proof (state)\nthis:\n  dom A\n  \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n               (subst \\<sigma> (fst (mems' ! i))) \\<union>\n              differing_vars (subst \\<sigma>' (snd (mems ! i)))\n               (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "show \"?\\<Delta> \\<subseteq> dom A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom (\\<lambda>x.\n                        if x \\<in> differing_vars\n                                    (subst \\<sigma>' (fst (mems ! i)))\n                                    (subst \\<sigma>\n(fst (mems' ! i))) \\<union>\n                                   differing_vars\n                                    (subst \\<sigma>' (snd (mems ! i)))\n                                    (subst \\<sigma> (snd (mems' ! i)))\n                        then if dma x = High\n                             then Some\n                                   (subst \\<sigma> (fst (mems' ! i)) x,\n                                    subst \\<sigma> (snd (mems' ! i)) x)\n                             else if x \\<in> differing_vars_lists\n        mem\\<^sub>1' mem\\<^sub>2' mems' i\n                                  then case \\<sigma> x of\n None \\<Rightarrow> None | Some v \\<Rightarrow> Some (v, v)\n                                  else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n                        else None)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                         (subst \\<sigma> (fst (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                         (subst \\<sigma> (snd (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)", "apply (metis (no_types) domIff dom\\<sigma> option.exhaust option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                         (subst \\<sigma> (snd (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)", "by (metis (no_types) domIff dom\\<sigma> option.exhaust option.simps(5))"], ["proof (state)\nthis:\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n  \\<subseteq> dom A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom A =\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have A_correct:\n              \"\\<And> x.\n               globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n               ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] x = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<and>\n               ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] x = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "show \"?thesis x\"\n            (is \"?A \\<and> ?Eq\\<^sub>1 \\<and> ?Eq\\<^sub>2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"x \\<in> ?\\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<in> ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence diff:\n              \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (fst (mems ! i)) x \\<or>\n    subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (snd (mems ! i)) x", "by (auto simp: differing_vars_def)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from p and diff"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x", "have writable: \"x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n  subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "by auto"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"dma x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"dma x = High\""], ["proof (state)\nthis:\n  dma x = High\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>dma x = High\\<close>"], ["proof (chain)\npicking this:\n  dma x = High", "have A_simp [simp]:\n                \"A x = Some (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x, ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x)\""], ["proof (prove)\nusing this:\n  dma x = High\n\ngoal (1 subgoal):\n 1. A x =\n    Some\n     (subst \\<sigma> (fst (mems' ! i)) x,\n      subst \\<sigma> (snd (mems' ! i)) x)", "unfolding A_def"], ["proof (prove)\nusing this:\n  dma x = High\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some\n     (subst \\<sigma> (fst (mems' ! i)) x,\n      subst \\<sigma> (snd (mems' ! i)) x)", "by (metis \\<open>x \\<in> ?\\<Delta>\\<close>)"], ["proof (state)\nthis:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from writable"], ["proof (chain)\npicking this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite", "have \"?A\""], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x", "unfolding globally_consistent_var_def A_simp"], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n\ngoal (1 subgoal):\n 1. case Some\n          (subst \\<sigma> (fst (mems' ! i)) x,\n           subst \\<sigma> (snd (mems' ! i)) x) of\n    None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow>\n        x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<and>\n        (dma x = Low \\<longrightarrow> v = v')", "using \\<open>dma x = High\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  dma x = High\n\ngoal (1 subgoal):\n 1. case Some\n          (subst \\<sigma> (fst (mems' ! i)) x,\n           subst \\<sigma> (snd (mems' ! i)) x) of\n    None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow>\n        x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<and>\n        (dma x = Low \\<longrightarrow> v = v')", "by auto"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from A_simp"], ["proof (chain)\npicking this:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)", "have ?Eq\\<^sub>1 ?Eq\\<^sub>2"], ["proof (prove)\nusing this:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x &&&\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "unfolding A_def apply_adaptation_def"], ["proof (prove)\nusing this:\n  (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n               (subst \\<sigma> (fst (mems' ! i))) \\<union>\n              differing_vars (subst \\<sigma>' (snd (mems ! i)))\n               (subst \\<sigma> (snd (mems' ! i)))\n   then if dma x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) x,\n               subst \\<sigma> (snd (mems' ! i)) x)\n        else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         i\n             then case \\<sigma> x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n   else None) =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (1 subgoal):\n 1. (case if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                      (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                     differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                      (subst \\<sigma> (snd (mems' ! i)))\n          then if dma x = High\n               then Some\n                     (subst \\<sigma> (fst (mems' ! i)) x,\n                      subst \\<sigma> (snd (mems' ! i)) x)\n               else if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                mem\\<^sub>2' mems' i\n                    then case \\<sigma> x of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, v)\n                    else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n          else None of\n     None \\<Rightarrow> subst \\<sigma>' (fst (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n    subst \\<sigma> (fst (mems' ! i)) x &&&\n    (case if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                      (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                     differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                      (subst \\<sigma> (snd (mems' ! i)))\n          then if dma x = High\n               then Some\n                     (subst \\<sigma> (fst (mems' ! i)) x,\n                      subst \\<sigma> (snd (mems' ! i)) x)\n               else if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                mem\\<^sub>2' mems' i\n                    then case \\<sigma> x of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, v)\n                    else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n          else None of\n     None \\<Rightarrow> subst \\<sigma>' (snd (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (2 subgoals):\n 1. dma x = High \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"dma x = Low\""], ["proof (state)\nthis:\n  dma x = Low\n\ngoal (1 subgoal):\n 1. dma x = Low \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"x \\<in> ?X' i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis domD dom\\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence eq: \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = v \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> fst (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v \\<and>\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<in> ?X' i\\<close> and \\<open>dma x = Low\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma x = Low", "have A_simp [simp]:\n                  \"A x = (case \\<sigma> x of\n                            Some v \\<Rightarrow> Some (v, v)\n                          | None \\<Rightarrow> None)\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma x = Low\n\ngoal (1 subgoal):\n 1. A x =\n    (case \\<sigma> x of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> Some (v, v))", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma x = Low\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    (case \\<sigma> x of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> Some (v, v))", "by (metis Sec.simps(1) \\<open>x \\<in> ?\\<Delta>\\<close>)"], ["proof (state)\nthis:\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "with writable eq \\<open>\\<sigma> x = Some v\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  \\<sigma> x = Some v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))", "have \"?A\""], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  \\<sigma> x = Some v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x", "unfolding globally_consistent_var_def"], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  \\<sigma> x = Some v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n\ngoal (1 subgoal):\n 1. case A x of None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow>\n        x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<and>\n        (dma x = Low \\<longrightarrow> v = v')", "by auto"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using domA \\<open>x \\<in> ?\\<Delta>\\<close> \\<open>\\<sigma> x = Some v\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  dom A =\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by (auto simp: apply_adaptation_def)"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence A_simp [simp]: \"A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "using \\<open>x \\<in> ?\\<Delta>\\<close> \\<open>dma x = Low\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n  dma x = Low\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "by auto"], ["proof (state)\nthis:\n  A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from q"], ["proof (chain)\npicking this:\n  \\<lbrakk>dma ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5", "have \"mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dma ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = mem\\<^sub>2' x", "by (metis \\<open>dma x = Low\\<close> diff \\<open>x \\<notin> ?X' i\\<close>)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "with writable"], ["proof (chain)\npicking this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  mem\\<^sub>1' x = mem\\<^sub>2' x", "have ?A"], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x", "unfolding globally_consistent_var_def"], ["proof (prove)\nusing this:\n  x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. case A x of None \\<Rightarrow> True\n    | Some (v, v') \\<Rightarrow>\n        x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<and>\n        (dma x = Low \\<longrightarrow> v = v')", "by auto"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have\n                  \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1'i x \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "by (metis dom\\<sigma> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x", "show ?thesis"], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using \\<open>mem\\<^sub>1' x = mem\\<^sub>2' x\\<close>"], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by (auto simp: apply_adaptation_def)"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<notin> ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence \"A x = None\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. A x = None", "by (metis domA domIff)"], ["proof (state)\nthis:\n  A x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence \"globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\""], ["proof (prove)\nusing this:\n  A x = None\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x", "by (auto simp: globally_consistent_var_def)"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>A x = None\\<close>"], ["proof (chain)\npicking this:\n  A x = None", "have \"x \\<notin> dom A\""], ["proof (prove)\nusing this:\n  A x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> dom A", "by (metis domIff)"], ["proof (state)\nthis:\n  x \\<notin> dom A\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?\\<Delta>\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] x = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<and>\n                                 ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] x = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using \\<open>A x = None\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n  A x = None\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "unfolding differing_vars_def apply_adaptation_def"], ["proof (prove)\nusing this:\n  x \\<notin> {x. subst \\<sigma>' (fst (mems ! i)) x \\<noteq>\n                 subst \\<sigma> (fst (mems' ! i)) x} \\<union>\n             {x. subst \\<sigma>' (snd (mems ! i)) x \\<noteq>\n                 subst \\<sigma> (snd (mems' ! i)) x}\n  A x = None\n\ngoal (1 subgoal):\n 1. (case A x of None \\<Rightarrow> subst \\<sigma>' (fst (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    (case A x of None \\<Rightarrow> subst \\<sigma>' (snd (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) x \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) ?x5 \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "hence \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] \\<and>\n               ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) ?x5 \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n    subst \\<sigma> (fst (mems' ! i)) \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n    subst \\<sigma> (snd (mems' ! i))", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "from A_correct"], ["proof (chain)\npicking this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) ?x5 \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5", "have \"globally_consistent A (snd (cms\\<^sub>1 ! i))\""], ["proof (prove)\nusing this:\n  globally_consistent_var A (snd (cms\\<^sub>1 ! i)) ?x5 \\<and>\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5\n\ngoal (1 subgoal):\n 1. globally_consistent A (snd (cms\\<^sub>1 ! i))", "by (metis \\<Delta>_finite globally_consistent_def domA)"], ["proof (state)\nthis:\n  globally_consistent A (snd (cms\\<^sub>1 ! i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)", "by (metis \\<open>i < length cms\\<^sub>1\\<close> equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "with bisim"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)", "have \"(cms\\<^sub>1 ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A]) \\<approx> (cms\\<^sub>2 ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A])\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i,\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n    (cms\\<^sub>2 ! i,\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "using \\<open>globally_consistent A (snd (cms\\<^sub>1 ! i))\\<close>"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n  globally_consistent A (snd (cms\\<^sub>1 ! i))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i,\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n    (cms\\<^sub>2 ! i,\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "apply (subst surjective_pairing[of \"cms\\<^sub>1 ! i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n             (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)));\n     snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i);\n     globally_consistent A (snd (cms\\<^sub>1 ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fst (cms\\<^sub>1 !\n                                    i), snd\n   (cms\\<^sub>1 !\n    i), subst \\<sigma>'\n         (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                      (cms\\<^sub>2 ! i,\n                       subst \\<sigma>'\n                        (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "apply (subst surjective_pairing[of \"cms\\<^sub>2 ! i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n             (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)));\n     snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i);\n     globally_consistent A (snd (cms\\<^sub>1 ! i))\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fst (cms\\<^sub>1 !\n                                    i), snd\n   (cms\\<^sub>1 !\n    i), subst \\<sigma>'\n         (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                      \\<langle>fst (cms\\<^sub>2 !\n                                    i), snd\n   (cms\\<^sub>2 !\n    i), subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A]\\<rangle>", "by (metis surjective_pairing globally_consistent_adapt_bisim)"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "by (metis \\<open>i \\<noteq> k\\<close> b cms\\<^sub>2'_def nth_list_update_neq)"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix i x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>1'i = \"fst (mems' ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>2'i = \"snd (mems' ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume i_le: \"i < length cms\\<^sub>1'\""], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1'\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume mem_eq: \"mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset> length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "show \"x \\<notin> ?X' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "apply (cases \"x \\<notin> ?X k \\<or> x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i = k;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<or>\n     x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i = k;\n     \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                         k \\<or>\n             x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply (metis differing_vars_neg_intro mems'_k_1 mems'_k_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = k;\n     \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                         k \\<or>\n             x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "by (metis Sec.simps(2) b compat compat_different mem_eq x_unchanged)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (rule mems'_i_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. i \\<sqsubset> length cms\\<^sub>1\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "from b i_le"], ["proof (chain)\npicking this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i \\<sqsubset> length cms\\<^sub>1'", "show \"i < length cms\\<^sub>1\""], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i \\<sqsubset> length cms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. i \\<sqsubset> length cms\\<^sub>1", "by (metis length_list_update)"], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"fst (mems' ! i) x = mem\\<^sub>1' x\"\n            \"snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\"\n            \"mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\" and \"dma x = Low\"\n          \\<comment> \\<open>In this case, for example, the values of (mems' ! i) are not needed.\\<close>"], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\n  dma x = Low\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\n  dma x = Low\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis Sec.simps(2) mem_eq)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume case3: \"mem\\<^sub>1 x = mem\\<^sub>1' x\" \"mem\\<^sub>2 x = mem\\<^sub>2' x\"\n            \"fst (mems' ! i) x = fst (mems ! i) x\"\n            \"snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "have \"x \\<in> ?X' i \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "from case3 and \\<open>x \\<in> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<in> ?X i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (metis differing_vars_neg differing_vars_elim)"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "with case3"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "show ?thesis"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "by (metis b compat compat_different i_le length_list_update)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "with \\<open>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\\<close>"], ["proof (chain)\npicking this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low", "show \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma x = High\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma x = Low\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by auto"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "have \"\\<exists> i < length cms\\<^sub>1. x \\<notin> ?X' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume var_changed: \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\""], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<notin> ?X' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "apply (rule mems'_k_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                         k \\<or>\n             x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2;\n     fst (mems' ! k) x = mem\\<^sub>1' x;\n     snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k\n 2. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> dom_g1; x \\<in> dom_g2; fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "apply (metis differing_vars_neg_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> dom_g1; x \\<in> dom_g2; fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "by (metis var_changed x_unchanged)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis b)"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"\\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x)\""], ["proof (state)\nthis:\n  \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n          mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x)\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "hence assms: \"mem\\<^sub>1 x = mem\\<^sub>1' x\" \"mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n          mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x &&& mem\\<^sub>2 x = mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"length cms\\<^sub>1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 \\<noteq> 0", "using b"], ["proof (prove)\nusing this:\n  k \\<sqsubset> length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 \\<noteq> 0", "by (metis less_zeroE)"], ["proof (state)\nthis:\n  length cms\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "then"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1 \\<noteq> 0", "obtain i where i_prop: \"i < length cms\\<^sub>1 \\<and> x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<sqsubset> length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using compat"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 \\<noteq> 0\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<sqsubset> length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto, blast)"], ["proof (state)\nthis:\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<notin> ?X' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "apply (rule mems'_k_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                         k \\<or>\n             x \\<notin> dom_g1 \\<or> x \\<notin> dom_g2;\n     fst (mems' ! k) x = mem\\<^sub>1' x;\n     snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k\n 2. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> dom_g1; x \\<in> dom_g2; fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "apply (metis differing_vars_neg_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> dom_g1; x \\<in> dom_g2; fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "by (metis i_prop \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis b)"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "hence \"fst (mems' ! i) x = fst (mems ! i) x\"\n                  \"snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x &&&\n    snd (mems' ! i) x = snd (mems ! i) x", "using i_prop assms mems'_i_3"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 \\<sqsubset> length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n   mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x &&&\n    snd (mems' ! i) x = snd (mems ! i) x", "by auto"], ["proof (state)\nthis:\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "with i_prop"], ["proof (chain)\npicking this:\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x", "have \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis assms differing_vars_neg differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "with i_prop"], ["proof (chain)\npicking this:\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "}"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     ?x7 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "thus \"(length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2') \\<or> (\\<forall> x. \\<exists> i < length cms\\<^sub>1'. x \\<notin> ?X' i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length cms\\<^sub>1.\n     ?x7 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "by (metis cms\\<^sub>2'_def equal_size length_list_update new_length)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n  (\\<forall>x.\n      \\<exists>i<length cms\\<^sub>1'.\n         x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'", "show ?thesis"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  map snd cms\\<^sub>1' = map snd ?cms\\<^sub>2'5 \\<and>\n  (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\n  (?cms\\<^sub>2'5, ?mem\\<^sub>2'5) \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n   (?cms\\<^sub>2'5, ?mem\\<^sub>2'5) ?mems'5 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The Isar proof language provides a readable\nway of specifying assumptions while also giving them names for subsequent\nusage.\\<close>"], ["", "lemma compat_low_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes x_low: \"dma x = Low\"\n  assumes x_readable: \"\\<forall> i < length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoRead\"\n  shows \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "let ?X = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have \"(length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n                    (\\<forall> x. \\<exists> j. j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j)\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>j<length cms\\<^sub>1.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)", "by auto"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>j<length cms\\<^sub>1.\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "thus \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>j<length cms\\<^sub>1.\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length cms\\<^sub>1 = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\n 2. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\""], ["proof (state)\nthis:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (2 subgoals):\n 1. length cms\\<^sub>1 = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\n 2. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "with x_low"], ["proof (chain)\npicking this:\n  dma x = Low\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  dma x = Low\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (simp add: low_eq_def)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"\\<forall> x. \\<exists> j. j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j\""], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "obtain j where j_prop: \"j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j \\<sqsubset> length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "let ?mems\\<^sub>1j = \"fst (mems ! j)\" and\n        ?mems\\<^sub>2j = \"snd (mems ! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "obtain \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\" where \"dom \\<sigma> = ?X j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "with compat and j_prop"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have \"(cms\\<^sub>1 ! j, ?mems\\<^sub>1j [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! j, ?mems\\<^sub>2j [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n    (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "have \"snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "using modes_eq"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "by (metis j_prop length_map nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "have \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l ?mems\\<^sub>2j [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "using modes_eq j_prop"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "by (metis prod.collapse mm_equiv_low_eq)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "hence \"?mems\\<^sub>1j x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "using x_low x_readable j_prop \\<open>dom \\<sigma> = ?X j\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n  dma x = Low\n  \\<forall>i<length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoRead\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "unfolding low_mds_eq_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     dma x = Low \\<and>\n     x \\<notin> snd (cms\\<^sub>1 ! j) AsmNoRead \\<longrightarrow>\n     subst \\<sigma> (fst (mems ! j)) x = subst \\<sigma> (snd (mems ! j)) x\n  dma x = Low\n  \\<forall>i<length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoRead\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "using j_prop"], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n  j \\<sqsubset> length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (metis compat_different_vars)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_reach_subset:\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"loc_reach \\<langle>c', mds', mem'\\<rangle> \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c', mds', mem'\\<rangle>\n    \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "fix c'' mds'' mem''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "from eval"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>", "have \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis loc_reach.refl loc_reach.step surjective_pairing)"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "assume \"\\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "thus \"\\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c'', mds'', mem''\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply induct"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c', mds', mem'\\<rangle>), snd\n                    (fst \\<langle>c', mds', mem'\\<rangle>), snd\n                       \\<langle>c', mds', mem'\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 2. \\<And>c'a mds'a mem'a c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 3. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x\\<in>mds'a AsmNoWrite. mem'a x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply (metis \\<open>\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\\<close> surjective_pairing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c'a mds'a mem'a c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 2. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x\\<in>mds'a AsmNoWrite. mem'a x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply (metis loc_reach.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x\\<in>mds'a AsmNoWrite. mem'a x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis loc_reach.mem_diff)"], ["proof (state)\nthis:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locally_sound_modes_invariant:\n  assumes sound_modes: \"locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "from eval"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>", "have \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis fst_conv loc_reach.refl loc_reach.step snd_conv)"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "using sound_modes"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n  locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n  \\<forall>c' mds' mem'.\n     \\<langle>c', mds', mem'\\<rangle>\n     \\<in> loc_reach \\<langle>c, mds, mem\\<rangle> \\<longrightarrow>\n     (\\<forall>x.\n         (x \\<in> mds' GuarNoRead \\<longrightarrow> doesnt_read c' x) \\<and>\n         (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n\ngoal (1 subgoal):\n 1. \\<forall>c'a mds'a mem'a.\n       \\<langle>c'a, mds'a, mem'a\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n       (\\<forall>x.\n           (x \\<in> mds'a GuarNoRead \\<longrightarrow>\n            doesnt_read c'a x) \\<and>\n           (x \\<in> mds'a GuarNoWrite \\<longrightarrow>\n            doesnt_modify c'a x))", "by (metis (no_types) Collect_empty_eq eval loc_reach_subset subsetD)"], ["proof (state)\nthis:\n  locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_modes_subset:\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"reachable_mode_states (cms', mem') \\<subseteq> reachable_mode_states (cms, mem)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_mode_states (cms', mem')\n    \\<subseteq> reachable_mode_states (cms, mem)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "fix mdss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "assume \"mdss \\<in> reachable_mode_states (cms', mem')\""], ["proof (state)\nthis:\n  mdss \\<in> reachable_mode_states (cms', mem')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "thus \"mdss \\<in> reachable_mode_states (cms, mem)\""], ["proof (prove)\nusing this:\n  mdss \\<in> reachable_mode_states (cms', mem')\n\ngoal (1 subgoal):\n 1. mdss \\<in> reachable_mode_states (cms, mem)", "using reachable_mode_states_def"], ["proof (prove)\nusing this:\n  mdss \\<in> reachable_mode_states (cms', mem')\n  reachable_mode_states ?gc =\n  {mdss.\n   \\<exists>cms' mem'.\n      ?gc \\<rightarrow>\\<^sup>* (cms', mem') \\<and> map snd cms' = mdss}\n\ngoal (1 subgoal):\n 1. mdss \\<in> reachable_mode_states (cms, mem)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cms'a mem'a.\n       \\<lbrakk>\\<And>a b.\n                   reachable_mode_states (a, b) =\n                   {mdss.\n                    \\<exists>cms'.\n                       (\\<exists>mem'.\n                           (a, b) \\<rightarrow>\\<^sup>* (cms', mem')) \\<and>\n                       map snd cms' = mdss};\n        mdss = map snd cms'a;\n        (cms', mem') \\<rightarrow>\\<^sup>* (cms'a, mem'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms'.\n                            (\\<exists>mem'.\n                                (cms, mem) \\<rightarrow>\\<^sup>*\n                                (cms', mem')) \\<and>\n                            map snd cms' = map snd cms'a", "by (metis (hide_lams, no_types) assms converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  mdss \\<in> reachable_mode_states (cms, mem)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma globally_sound_modes_invariant:\n  assumes globally_sound: \"globally_sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"globally_sound_mode_use (cms', mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "using assms reachable_modes_subset"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms, mem)\n  (cms, mem) \\<rightarrow> (cms', mem')\n  (?cms, ?mem) \\<rightarrow> (?cms', ?mem') \\<Longrightarrow>\n  reachable_mode_states (?cms', ?mem')\n  \\<subseteq> reachable_mode_states (?cms, ?mem)\n\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "unfolding globally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  \\<forall>mdss.\n     mdss \\<in> reachable_mode_states (cms, mem) \\<longrightarrow>\n     compatible_modes mdss\n  (cms, mem) \\<rightarrow> (cms', mem')\n  (?cms, ?mem) \\<rightarrow> (?cms', ?mem') \\<Longrightarrow>\n  reachable_mode_states (?cms', ?mem')\n  \\<subseteq> reachable_mode_states (?cms, ?mem)\n\ngoal (1 subgoal):\n 1. \\<forall>mdss.\n       mdss \\<in> reachable_mode_states (cms', mem') \\<longrightarrow>\n       compatible_modes mdss", "by (metis (no_types) subsetD)"], ["", "lemma loc_reach_mem_diff_subset:\n  assumes mem_diff: \"\\<forall> x. x \\<in> mds AsmNoWrite \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x\"\n  shows \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "let ?lc = \"\\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "assume \"?lc \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "proof (induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 3. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 3. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis fst_conv loc_reach.mem_diff loc_reach.refl mem_diff snd_conv)"], ["proof (state)\nthis:\n  \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                       (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                               \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case step"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle> \\<leadsto>\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle> \\<leadsto>\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c''_, mds''_, mem''_\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis loc_reach.step)"], ["proof (state)\nthis:\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case mem_diff"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<forall>x\\<in>mds'_ AsmNoWrite. mem'_ x = mem''_ x\n\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x\\<in>mds' AsmNoWrite. mem' x = mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<forall>x\\<in>mds'_ AsmNoWrite. mem'_ x = mem''_ x\n\ngoal (1 subgoal):\n 1. \\<langle>c'_, mds'_, mem''_\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis loc_reach.mem_diff)"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem''_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_reach_mem_diff_eq:\n  assumes mem_diff: \"\\<forall> x. x \\<in> mds AsmNoWrite \\<longrightarrow> mem' x = mem x\"\n  shows \"loc_reach \\<langle>c, mds, mem\\<rangle> = loc_reach \\<langle>c, mds, mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c, mds, mem\\<rangle> =\n    loc_reach \\<langle>c, mds, mem'\\<rangle>", "using assms loc_reach_mem_diff_subset"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> mds AsmNoWrite \\<longrightarrow> mem' x = mem x\n  \\<lbrakk>\\<forall>x.\n              x \\<in> ?mds AsmNoWrite \\<longrightarrow>\n              ?mem\\<^sub>1 x = ?mem\\<^sub>2 x;\n   \\<langle>?c', ?mds', ?mem'\\<rangle>\n   \\<in> loc_reach \\<langle>?c, ?mds, ?mem\\<^sub>1\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?c', ?mds', ?mem'\\<rangle>\n                    \\<in> loc_reach \\<langle>?c, ?mds, ?mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c, mds, mem\\<rangle> =\n    loc_reach \\<langle>c, mds, mem'\\<rangle>", "by (auto, metis)"], ["", "lemma sound_modes_invariant:\n  assumes sound_modes: \"sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<rightarrow> (cms', mem')\"\n  shows \"sound_mode_use (cms', mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from sound_modes and eval"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)\n  (cms, mem) \\<rightarrow> (cms', mem')", "have \"globally_sound_mode_use (cms', mem')\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n  (cms, mem) \\<rightarrow> (cms', mem')\n\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "by (metis globally_sound_modes_invariant sound_mode_use.simps)"], ["proof (state)\nthis:\n  globally_sound_mode_use (cms', mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "moreover"], ["proof (state)\nthis:\n  globally_sound_mode_use (cms', mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)", "have loc_sound: \"\\<forall> i < length cms. locally_sound_mode_use (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)", "unfolding sound_mode_use_def"], ["proof (prove)\nusing this:\n  case (cms, mem) of\n  (cms, mem) \\<Rightarrow>\n    list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n    globally_sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)", "by simp (metis list_all_length)"], ["proof (state)\nthis:\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from eval"], ["proof (chain)\npicking this:\n  (cms, mem) \\<rightarrow> (cms', mem')", "obtain k cms\\<^sub>k' where\n    ev: \"(cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and> k < length cms \\<and> cms' = cms [k := cms\\<^sub>k']\""], ["proof (prove)\nusing this:\n  (cms, mem) \\<rightarrow> (cms', mem')\n\ngoal (1 subgoal):\n 1. (\\<And>k cms\\<^sub>k'.\n        (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n        k \\<sqsubset> length cms \\<and>\n        cms' = cms[k := cms\\<^sub>k'] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis meval_elim)"], ["proof (state)\nthis:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k \\<sqsubset> length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "hence \"length cms = length cms'\""], ["proof (prove)\nusing this:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k \\<sqsubset> length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n\ngoal (1 subgoal):\n 1. length cms = length cms'", "by auto"], ["proof (state)\nthis:\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "have \"\\<And> i. i < length cms' \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<sqsubset> length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<sqsubset> length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<sqsubset> length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "assume i_le: \"i < length cms'\""], ["proof (state)\nthis:\n  i \\<sqsubset> length cms'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<sqsubset> length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "thus \"?thesis i\""], ["proof (prove)\nusing this:\n  i \\<sqsubset> length cms'\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i = k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\n 2. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i = k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\n 2. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "using i_le ev loc_sound"], ["proof (prove)\nusing this:\n  i = k\n  i \\<sqsubset> length cms'\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k \\<sqsubset> length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "by (metis (hide_lams, no_types) locally_sound_modes_invariant nth_list_update surj_pair)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"cms' ! i = cms ! i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. cms' ! i = cms ! i", "by (metis ev nth_list_update_neq)"], ["proof (state)\nthis:\n  cms' ! i = cms ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)", "have \"compatible_modes (map snd cms)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms)", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n  globally_sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms)", "by (metis globally_sound_modes_compatible)"], ["proof (state)\nthis:\n  compatible_modes (map snd cms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"\\<And> x. x \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow> x \\<in> snd (cms ! k) GuarNoWrite\""], ["proof (prove)\nusing this:\n  compatible_modes (map snd cms)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n       x \\<in> snd (cms ! k) GuarNoWrite", "unfolding compatible_modes_def"], ["proof (prove)\nusing this:\n  \\<forall>i x.\n     i \\<sqsubset> length (map snd cms) \\<longrightarrow>\n     (x \\<in> (map snd cms ! i) AsmNoRead \\<longrightarrow>\n      (\\<forall>j<length (map snd cms).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms ! j) GuarNoRead)) \\<and>\n     (x \\<in> (map snd cms ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms ! j) GuarNoWrite))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n       x \\<in> snd (cms ! k) GuarNoWrite", "by (metis (no_types) \\<open>i \\<noteq> k\\<close> \\<open>length cms = length cms'\\<close> ev i_le length_map nth_map)"], ["proof (state)\nthis:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"\\<And> x. x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> doesnt_modify (fst (cms ! k)) x\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "using ev loc_sound"], ["proof (prove)\nusing this:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k \\<sqsubset> length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k \\<sqsubset> length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms.\n     \\<forall>c' mds' mem'.\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach (cms ! i, mem) \\<longrightarrow>\n        (\\<forall>x.\n            (x \\<in> mds' GuarNoRead \\<longrightarrow>\n             doesnt_read c' x) \\<and>\n            (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "by (metis loc_reach.refl surjective_pairing)"], ["proof (state)\nthis:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "with eval"], ["proof (chain)\npicking this:\n  (cms, mem) \\<rightarrow> (cms', mem')\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5", "have \"\\<And> x. x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> mem x = mem' x\""], ["proof (prove)\nusing this:\n  (cms, mem) \\<rightarrow> (cms', mem')\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> mem x = mem' x", "by (metis (no_types) doesnt_modify_def ev prod.collapse)"], ["proof (state)\nthis:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> mem ?x5 = mem' ?x5\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "then"], ["proof (chain)\npicking this:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> mem ?x5 = mem' ?x5", "have \"loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> snd (cms ! i) AsmNoWrite \\<longrightarrow> mem ?x5 = mem' ?x5\n\ngoal (1 subgoal):\n 1. loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)", "by (metis loc_reach_mem_diff_eq prod.collapse)"], ["proof (state)\nthis:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<sqsubset> length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "thus ?thesis"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "using loc_sound i_le \\<open>length cms = length cms'\\<close>"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n  i \\<sqsubset> length cms'\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n  \\<forall>i<length cms.\n     \\<forall>c' mds' mem'.\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach (cms ! i, mem) \\<longrightarrow>\n        (\\<forall>x.\n            (x \\<in> mds' GuarNoRead \\<longrightarrow>\n             doesnt_read c' x) \\<and>\n            (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n  i \\<sqsubset> length cms'\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. \\<forall>c' mds' mem'a.\n       \\<langle>c', mds', mem'a\\<rangle>\n       \\<in> loc_reach (cms' ! i, mem') \\<longrightarrow>\n       (\\<forall>x.\n           (x \\<in> mds' GuarNoRead \\<longrightarrow>\n            doesnt_read c' x) \\<and>\n           (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))", "by (metis \\<open>cms' ! i = cms ! i\\<close>)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i5 \\<sqsubset> length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "ultimately"], ["proof (chain)\npicking this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 \\<sqsubset> length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')", "show ?thesis"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 \\<sqsubset> length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 \\<sqsubset> length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem')) cms' \\<and>\n    globally_sound_mode_use (cms', mem')", "by (metis (no_types) list_all_length)"], ["proof (state)\nthis:\n  sound_mode_use (cms', mem')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma makes_compatible_eval_k:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\" \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> cms\\<^sub>2' mem\\<^sub>2' mems'. sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                              sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                              (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "(* cms\\<^sub>1' and mem\\<^sub>1' need to be arbitrary so\n     that the induction hypothesis is sufficiently general. *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "from eval"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", "show ?thesis"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof (induct \"k\" arbitrary: cms\\<^sub>1' mem\\<^sub>1')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>1',\n               mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>2',\n                  mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "case 0"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>1',\n               mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>2',\n                  mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "hence \"cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1", "by (metis prod.inject meval_k.simps(1))"], ["proof (state)\nthis:\n  cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>1',\n               mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>2',\n                  mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "thus ?case"], ["proof (prove)\nusing this:\n  cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "by (metis compat meval_k.simps(1) modes_eq sound_modes)"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>0\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "case (Suc k)"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (?cms\\<^sub>1'5,\n          ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "then"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (?cms\\<^sub>1'5,\n          ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')", "obtain cms\\<^sub>1'' mem\\<^sub>1'' where eval'':\n      \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (?cms\\<^sub>1'5,\n          ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>1''' mem\\<^sub>1'''.\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1''',\n                mem\\<^sub>1''') \\<and>\n        (cms\\<^sub>1''', mem\\<^sub>1''') \\<rightarrow>\n        (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis meval_k.simps(2) prod_cases3 snd_conv)"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'',\n          mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "hence \"(cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'',\n          mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow>\n    (cms\\<^sub>1', mem\\<^sub>1')", ".."], ["proof (state)\nthis:\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "from eval''"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'',\n          mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')", "obtain cms\\<^sub>2'' mem\\<^sub>2'' mems'' where IH:\n      \"sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n       sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n       map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n       makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'') (cms\\<^sub>2'', mem\\<^sub>2'') mems''\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'',\n          mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2'' mem\\<^sub>2'' mems''.\n        sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n        sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n        map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n                mem\\<^sub>2'') \\<and>\n        makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n         (cms\\<^sub>2'', mem\\<^sub>2'') mems'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Suc"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1'',\n          mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (?cms\\<^sub>1'5,\n          ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2'' mem\\<^sub>2'' mems''.\n        sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n        sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n        map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n                mem\\<^sub>2'') \\<and>\n        makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n         (cms\\<^sub>2'', mem\\<^sub>2'') mems'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n          mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n          mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''", "obtain cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2'', mem\\<^sub>2'') \\<rightarrow> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n          mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2'', mem\\<^sub>2'') \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using makes_compatible_invariant"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2'',\n          mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n  \\<lbrakk>sound_mode_use (?cms\\<^sub>1, ?mem\\<^sub>1);\n   sound_mode_use (?cms\\<^sub>2, ?mem\\<^sub>2);\n   makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n    (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2;\n   (?cms\\<^sub>1, ?mem\\<^sub>1) \\<rightarrow>\n   (?cms\\<^sub>1', ?mem\\<^sub>1');\n   \\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n      map snd ?cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n      (?cms\\<^sub>2, ?mem\\<^sub>2) \\<rightarrow>\n      (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n      makes_compatible (?cms\\<^sub>1', ?mem\\<^sub>1')\n       (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2'', mem\\<^sub>2'') \\<rightarrow>\n        (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cms\\<^sub>2'', mem\\<^sub>2'') \\<rightarrow>\n  (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<And>k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                           mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                              mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "thus ?case"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cms\\<^sub>2'', mem\\<^sub>2'') \\<rightarrow>\n  (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "by (metis IH eval'' meval_k.simps(2) sound_modes_invariant)"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>Suc k\\<^esub> (cms\\<^sub>2',\n                 mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_initially_empty:\n  \"i < n \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sqsubset> n \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i", "unfolding differing_vars_lists_def differing_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sqsubset> n \\<Longrightarrow>\n    x \\<notin> {x. mem\\<^sub>1 x \\<noteq>\n                   fst (zip (replicate n mem\\<^sub>1)\n                         (replicate n mem\\<^sub>2) !\n                        i)\n                    x} \\<union>\n               {x. mem\\<^sub>2 x \\<noteq>\n                   snd (zip (replicate n mem\\<^sub>1)\n                         (replicate n mem\\<^sub>2) !\n                        i)\n                    x}", "by auto"], ["", "lemma compatible_refl:\n  assumes coms_secure: \"list_all com_sifum_secure cmds\"\n  assumes low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\"\n  shows \"makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n                          (add_initial_modes cmds, mem\\<^sub>2)\n                          (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?n = \"length cmds\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?mems = \"replicate ?n (mem\\<^sub>1, mem\\<^sub>2)\" and\n      ?mdss = \"replicate ?n mds\\<^sub>s\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?X = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 ?mems\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "have diff_empty: \"\\<forall> i < ?n. ?X i = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length cmds.\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n        (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n       {}", "by (metis differing_vars_initially_empty ex_in_conv min.idem zip_replicate)"], ["proof (state)\nthis:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "unfolding add_initial_modes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible\n     (zip cmds (replicate (length cmds) mds\\<^sub>s), mem\\<^sub>1)\n     (zip cmds (replicate (length cmds) mds\\<^sub>s), mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n    length (zip cmds (replicate (length cmds) mds\\<^sub>s)) \\<and>\n    length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n    length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 3. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 4. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "show \"length (zip cmds ?mdss) = length (zip cmds ?mdss) \\<and> length (zip cmds ?mdss) = length ?mems\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n    length (zip cmds (replicate (length cmds) mds\\<^sub>s)) \\<and>\n    length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n    length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n  length (zip cmds (replicate (length cmds) mds\\<^sub>s)) \\<and>\n  length (zip cmds (replicate (length cmds) mds\\<^sub>s)) =\n  length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "fix i \\<sigma>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "let ?mems\\<^sub>1i = \"fst (?mems ! i)\" and ?mems\\<^sub>2i = \"snd (?mems ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "assume i: \"i < length (zip cmds ?mdss)\""], ["proof (state)\nthis:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with coms_secure"], ["proof (chain)\npicking this:\n  list_all com_sifum_secure cmds\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))", "have \"com_sifum_secure (cmds ! i)\""], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n\ngoal (1 subgoal):\n 1. com_sifum_secure (cmds ! i)", "using coms_secure"], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n  list_all com_sifum_secure cmds\n\ngoal (1 subgoal):\n 1. com_sifum_secure (cmds ! i)", "by (metis length_map length_replicate list_all_length map_snd_zip)"], ["proof (state)\nthis:\n  com_sifum_secure (cmds ! i)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with i"], ["proof (chain)\npicking this:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n  com_sifum_secure (cmds ! i)", "have \"\\<And> mem\\<^sub>1 mem\\<^sub>2. mem\\<^sub>1 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n      (zip cmds (replicate ?n mds\\<^sub>s) ! i, mem\\<^sub>1) \\<approx> (zip cmds (replicate ?n mds\\<^sub>s) ! i, mem\\<^sub>2)\""], ["proof (prove)\nusing this:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n  com_sifum_secure (cmds ! i)\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       mem\\<^sub>1 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n       (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n        mem\\<^sub>1) \\<approx>\n       (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, mem\\<^sub>2)", "using com_sifum_secure_def low_indistinguishable_def"], ["proof (prove)\nusing this:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n  com_sifum_secure (cmds ! i)\n  com_sifum_secure ?c = ?c \\<sim>\\<^bsub>mds\\<^sub>s\\<^esub> ?c\n  ?c\\<^sub>1 \\<sim>\\<^bsub>?mds\\<^esub> ?c\\<^sub>2 =\n  (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n      mem\\<^sub>1 =\\<^bsub>?mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n      \\<langle>?c\\<^sub>1, ?mds, mem\\<^sub>1\\<rangle> \\<approx>\n      \\<langle>?c\\<^sub>2, ?mds, mem\\<^sub>2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       mem\\<^sub>1 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n       (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n        mem\\<^sub>1) \\<approx>\n       (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, mem\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  ?mem\\<^sub>15 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   ?mem\\<^sub>15) \\<approx>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, ?mem\\<^sub>25)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "moreover"], ["proof (state)\nthis:\n  ?mem\\<^sub>15 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   ?mem\\<^sub>15) \\<approx>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, ?mem\\<^sub>25)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "from i"], ["proof (chain)\npicking this:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))", "have \"?mems\\<^sub>1i = mem\\<^sub>1\" \"?mems\\<^sub>2i = mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n\ngoal (1 subgoal):\n 1. fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>1 &&&\n    snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with low_eq"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2", "have \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>] =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l ?mems\\<^sub>2i [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n           i)) =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l subst \\<sigma>\n               (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n                     i))", "by (auto simp: subst_def mds\\<^sub>s_def low_mds_eq_def low_eq_def, case_tac \"\\<sigma> x\", auto)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l subst \\<sigma>\n             (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i))\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (zip cmds (replicate (length cmds) mds\\<^sub>s) !\n                          i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "ultimately"], ["proof (chain)\npicking this:\n  ?mem\\<^sub>15 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   ?mem\\<^sub>15) \\<approx>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, ?mem\\<^sub>25)\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l subst \\<sigma>\n             (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i))", "show \"(zip cmds ?mdss ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>]) \\<approx> (zip cmds ?mdss ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  ?mem\\<^sub>15 =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   ?mem\\<^sub>15) \\<approx>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i, ?mem\\<^sub>25)\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>mds\\<^sub>s\\<^esub>\\<^sup>l subst \\<sigma>\n             (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i))\n\ngoal (1 subgoal):\n 1. (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n     subst \\<sigma>\n      (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n            i))) \\<approx>\n    (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n     subst \\<sigma>\n      (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i)))", "by simp"], ["proof (state)\nthis:\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   subst \\<sigma>\n    (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n          i))) \\<approx>\n  (zip cmds (replicate (length cmds) mds\\<^sub>s) ! i,\n   subst \\<sigma>\n    (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i)))\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "fix i x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "assume \"i < length (zip cmds ?mdss)\""], ["proof (state)\nthis:\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<sqsubset>\n                length (zip cmds (replicate (length cmds) mds\\<^sub>s));\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma x = High\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with diff_empty"], ["proof (chain)\npicking this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))", "show \"x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n  i \\<sqsubset> length (zip cmds (replicate (length cmds) mds\\<^sub>s))\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i", "by auto"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n              (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\n\ngoal (1 subgoal):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "show \"(length (zip cmds ?mdss) = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or> (\\<forall> x. \\<exists> i < length (zip cmds ?mdss). x \\<notin> ?X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "using diff_empty"], ["proof (prove)\nusing this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n\ngoal (1 subgoal):\n 1. length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "by (metis bot_less bot_nat_def empty_iff length_zip low_eq min_0L)"], ["proof (state)\nthis:\n  length (zip cmds (replicate (length cmds) mds\\<^sub>s)) = 0 \\<and>\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>i<length (zip cmds (replicate (length cmds) mds\\<^sub>s)).\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sifum_compositionality:\n  assumes com_secure: \"list_all com_sifum_secure cmds\"\n  assumes no_assms: \"no_assumptions_on_termination cmds\"\n  assumes sound_modes: \"\\<forall> mem. sound_mode_use (add_initial_modes cmds, mem)\"\n  shows \"prog_sifum_secure cmds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_sifum_secure cmds", "unfolding prog_sifum_secure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_assumptions_on_termination cmds \\<and>\n    (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n        (\\<forall>k cms\\<^sub>1' mem\\<^sub>1'.\n            (add_initial_modes cmds,\n             mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1') \\<longrightarrow>\n            (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                (add_initial_modes cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                        mem\\<^sub>2') \\<and>\n                map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                (\\<forall>x.\n                    dma x = Low \\<and>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoRead) \\<longrightarrow>\n                    mem\\<^sub>1' x = mem\\<^sub>2' x))))", "using assms"], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  no_assumptions_on_termination cmds\n  \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem)\n\ngoal (1 subgoal):\n 1. no_assumptions_on_termination cmds \\<and>\n    (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n        (\\<forall>k cms\\<^sub>1' mem\\<^sub>1'.\n            (add_initial_modes cmds,\n             mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1') \\<longrightarrow>\n            (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                (add_initial_modes cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                        mem\\<^sub>2') \\<and>\n                map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                (\\<forall>x.\n                    dma x = Low \\<and>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoRead) \\<longrightarrow>\n                    mem\\<^sub>1' x = mem\\<^sub>2' x))))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "fix mem\\<^sub>1 mem\\<^sub>2 :: \"'Var \\<Rightarrow> 'Val\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "fix k cms\\<^sub>1' mem\\<^sub>1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "let ?n = \"length cmds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "let ?mems = \"zip (replicate ?n mem\\<^sub>1) (replicate ?n mem\\<^sub>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "assume low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\""], ["proof (state)\nthis:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "with com_secure"], ["proof (chain)\npicking this:\n  list_all com_sifum_secure cmds\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2", "have compat:\n    \"makes_compatible (add_initial_modes cmds, mem\\<^sub>1) (add_initial_modes cmds, mem\\<^sub>2) ?mems\""], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n     (add_initial_modes cmds, mem\\<^sub>2)\n     (zip (replicate (length cmds) mem\\<^sub>1)\n       (replicate (length cmds) mem\\<^sub>2))", "by (metis compatible_refl fst_conv length_replicate map_replicate snd_conv zip_eq_conv)"], ["proof (state)\nthis:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "also"], ["proof (state)\nthis:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "assume eval: \"(add_initial_modes cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (state)\nthis:\n  (add_initial_modes cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "ultimately"], ["proof (chain)\npicking this:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (add_initial_modes cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", "obtain cms\\<^sub>2' mem\\<^sub>2' mems'\n    where p: \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n             (add_initial_modes cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n             makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\nusing this:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (add_initial_modes cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (add_initial_modes cmds,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sound_modes makes_compatible_eval_k"], ["proof (prove)\nusing this:\n  makes_compatible (add_initial_modes cmds, mem\\<^sub>1)\n   (add_initial_modes cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (add_initial_modes cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem)\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2;\n   sound_mode_use (?cms\\<^sub>1, ?mem\\<^sub>1);\n   sound_mode_use (?cms\\<^sub>2, ?mem\\<^sub>2);\n   (?cms\\<^sub>1,\n    ?mem\\<^sub>1) \\<rightarrow>\\<^bsub>?k\\<^esub> (?cms\\<^sub>1',\n             ?mem\\<^sub>1')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                       sound_mode_use (?cms\\<^sub>1', ?mem\\<^sub>1') \\<and>\n                       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                       map snd ?cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                       (?cms\\<^sub>2,\n                        ?mem\\<^sub>2) \\<rightarrow>\\<^bsub>?k\\<^esub> (cms\\<^sub>2',\n                                 mem\\<^sub>2') \\<and>\n                       makes_compatible (?cms\\<^sub>1', ?mem\\<^sub>1')\n                        (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (add_initial_modes cmds,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (add_initial_modes cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n          mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 k cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        no_assumptions_on_termination cmds;\n        \\<forall>mem. sound_mode_use (add_initial_modes cmds, mem);\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (add_initial_modes cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (add_initial_modes cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n                                    mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma x = Low \\<and>\n                                (\\<forall>i<length cms\\<^sub>1'.\n                                    x \\<notin> snd (cms\\<^sub>1' ! i)\n          AsmNoRead) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "thus \"\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (add_initial_modes cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                        length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                        (\\<forall> x. dma x = Low \\<and> (\\<forall> i < length cms\\<^sub>1'. x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoRead)\n          \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x)\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (add_initial_modes cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n          mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n       (add_initial_modes cmds,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n       (\\<forall>x.\n           dma x = Low \\<and>\n           (\\<forall>i<length cms\\<^sub>1'.\n               x \\<notin> snd (cms\\<^sub>1' ! i)\n                           AsmNoRead) \\<longrightarrow>\n           mem\\<^sub>1' x = mem\\<^sub>2' x)", "using p compat_low_eq"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (add_initial_modes cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n          mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (add_initial_modes cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n          mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2; dma ?x = Low;\n   \\<forall>i<length ?cms\\<^sub>1.\n      ?x \\<notin> snd (?cms\\<^sub>1 ! i) AsmNoRead\\<rbrakk>\n  \\<Longrightarrow> ?mem\\<^sub>1 ?x = ?mem\\<^sub>2 ?x\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n       (add_initial_modes cmds,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n       (\\<forall>x.\n           dma x = Low \\<and>\n           (\\<forall>i<length cms\\<^sub>1'.\n               x \\<notin> snd (cms\\<^sub>1' ! i)\n                           AsmNoRead) \\<longrightarrow>\n           mem\\<^sub>1' x = mem\\<^sub>2' x)", "by (metis length_map)"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n     (add_initial_modes cmds,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n     (\\<forall>x.\n         dma x = Low \\<and>\n         (\\<forall>i<length cms\\<^sub>1'.\n             x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoRead) \\<longrightarrow>\n         mem\\<^sub>1' x = mem\\<^sub>2' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}