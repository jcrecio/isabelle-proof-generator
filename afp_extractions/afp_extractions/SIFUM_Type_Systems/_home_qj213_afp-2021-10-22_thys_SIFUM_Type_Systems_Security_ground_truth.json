{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems/Security.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFUM_Type_Systems", "problem_names": ["lemma [simp]: \"mem =\\<^sup>l mem' \\<Longrightarrow> mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'\"", "lemma [simp]: \"(\\<forall> mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem') \\<Longrightarrow> mem =\\<^sup>l mem'\"", "lemma mm_equiv_sym:\n  assumes equivalent: \"\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\"\n  shows \"\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx> \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\"", "lemma low_indistinguishable_sym: \"lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow> lc' \\<sim>\\<^bsub>mds\\<^esub> lc\"", "lemma mm_equiv_glob_consistent: \"closed_glob_consistent mm_equiv\"", "lemma mm_equiv_strong_low_bisim: \"strong_low_bisim_mm mm_equiv\""], "translations": [["", "lemma [simp]: \"mem =\\<^sup>l mem' \\<Longrightarrow> mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem =\\<^sup>l mem' \\<Longrightarrow>\n    mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'", "by (simp add: low_mds_eq_def low_eq_def)"], ["", "lemma [simp]: \"(\\<forall> mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem') \\<Longrightarrow> mem =\\<^sup>l mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem' \\<Longrightarrow>\n    mem =\\<^sup>l mem'", "by (auto simp: low_mds_eq_def low_eq_def)"], ["", "(* Closedness under globally consistent changes: *)"], ["", "definition closed_glob_consistent :: \"(('Com, 'Var, 'Val) LocalConf) rel \\<Rightarrow> bool\"\n  where\n  \"closed_glob_consistent \\<R> =\n  (\\<forall> c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R> \\<longrightarrow>\n   (\\<forall> x. ((dma x = High \\<and> x \\<notin> mds AsmNoWrite) \\<longrightarrow>\n           (\\<forall> v\\<^sub>1 v\\<^sub>2. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 (x := v\\<^sub>1) \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 (x := v\\<^sub>2) \\<rangle>) \\<in> \\<R>)) \\<and>\n         ((dma x = Low \\<and> x \\<notin> mds AsmNoWrite) \\<longrightarrow>\n           (\\<forall> v. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 (x := v) \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 (x := v) \\<rangle>) \\<in> \\<R>))))\""], ["", "(* Strong low bisimulations modulo modes: *)"], ["", "definition strong_low_bisim_mm :: \"(('Com, 'Var, 'Val) LocalConf) rel \\<Rightarrow> bool\"\n  where\n  \"strong_low_bisim_mm \\<R> \\<equiv>\n  sym \\<R> \\<and>\n  closed_glob_consistent \\<R> \\<and>\n  (\\<forall> c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R> \\<longrightarrow>\n   (mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<and>\n   (\\<forall> c\\<^sub>1' mds' mem\\<^sub>1'. \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<leadsto> \\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle> \\<longrightarrow>\n    (\\<exists> c\\<^sub>2' mem\\<^sub>2'. \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<leadsto> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle> \\<and>\n                  (\\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle>, \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle>) \\<in> \\<R>)))\""], ["", "inductive_set mm_equiv :: \"(('Com, 'Var, 'Val) LocalConf) rel\"\n  and mm_equiv_abv :: \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow> \n  ('Com, 'Var, 'Val) LocalConf \\<Rightarrow> bool\" (infix \"\\<approx>\" 60)\n  where\n  \"mm_equiv_abv x y \\<equiv> (x, y) \\<in> mm_equiv\" |\n  mm_equiv_intro [iff]: \"\\<lbrakk> strong_low_bisim_mm \\<R> ; (lc\\<^sub>1, lc\\<^sub>2) \\<in> \\<R> \\<rbrakk> \\<Longrightarrow> (lc\\<^sub>1, lc\\<^sub>2) \\<in> mm_equiv\""], ["", "inductive_cases mm_equiv_elim [elim]: \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["", "definition low_indistinguishable :: \"'Var Mds \\<Rightarrow> 'Com \\<Rightarrow> 'Com \\<Rightarrow> bool\"\n  (\"_ \\<sim>\\<index> _\" [100, 100] 80)\n  where \"c\\<^sub>1 \\<sim>\\<^bsub>mds\\<^esub> c\\<^sub>2 = (\\<forall> mem\\<^sub>1 mem\\<^sub>2. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n    \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>)\""], ["", "subsection \\<open>SIFUM-Security\\<close>"], ["", "(* SIFUM-security for commands: *)"], ["", "definition com_sifum_secure :: \"'Com \\<Rightarrow> bool\"\n  where \"com_sifum_secure c = c \\<sim>\\<^bsub>mds\\<^sub>s\\<^esub> c\""], ["", "definition add_initial_modes :: \"'Com list \\<Rightarrow> ('Com \\<times> 'Var Mds) list\"\n  where \"add_initial_modes cmds = zip cmds (replicate (length cmds) mds\\<^sub>s)\""], ["", "definition no_assumptions_on_termination :: \"'Com list \\<Rightarrow> bool\"\n  where \"no_assumptions_on_termination cmds =\n  (\\<forall> mem mem' cms'.\n    (add_initial_modes cmds, mem) \\<rightarrow>\\<^sup>* (cms', mem') \\<and>\n    list_all (\\<lambda> c. c = stop) (map fst cms') \\<longrightarrow>\n      (\\<forall> mds' \\<in> set (map snd cms'). mds' AsmNoRead = {} \\<and> mds' AsmNoWrite = {}))\""], ["", "(* SIFUM-security for programs: *)"], ["", "definition prog_sifum_secure :: \"'Com list \\<Rightarrow> bool\"\n  where \"prog_sifum_secure cmds =\n  (no_assumptions_on_termination cmds \\<and>\n   (\\<forall> mem\\<^sub>1 mem\\<^sub>2. mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n    (\\<forall> k cms\\<^sub>1' mem\\<^sub>1'.\n     (add_initial_modes cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<longrightarrow>\n      (\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (add_initial_modes cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                      (\\<forall> x. dma x = Low \\<and> (\\<forall> i < length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoRead) \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x)))))\""], ["", "subsection \\<open>Sound Mode Use\\<close>"], ["", "definition doesnt_read :: \"'Com \\<Rightarrow> 'Var \\<Rightarrow> bool\"\n  where\n  \"doesnt_read c x = (\\<forall> mds mem c' mds' mem'.\n  \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle> \\<longrightarrow>\n  ((\\<forall> v. \\<langle> c, mds, mem (x := v) \\<rangle> \\<leadsto> \\<langle> c', mds', mem' (x := v) \\<rangle>) \\<or>\n   (\\<forall> v. \\<langle> c, mds, mem (x := v) \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>)))\""], ["", "definition doesnt_modify :: \"'Com \\<Rightarrow> 'Var \\<Rightarrow> bool\"\n  where\n  \"doesnt_modify c x = (\\<forall> mds mem c' mds' mem'. (\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>) \\<longrightarrow>\n                        mem x = mem' x)\""], ["", "(* Local reachability of local configurations: *)"], ["", "inductive_set loc_reach :: \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow> ('Com, 'Var, 'Val) LocalConf set\"\n  for lc :: \"(_, _, _) LocalConf\"\n  where\n  refl : \"\\<langle>fst (fst lc), snd (fst lc), snd lc\\<rangle> \\<in> loc_reach lc\" |\n  step : \"\\<lbrakk> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach lc;\n            \\<langle>c', mds', mem'\\<rangle> \\<leadsto> \\<langle>c'', mds'', mem''\\<rangle> \\<rbrakk> \\<Longrightarrow>\n          \\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach lc\" |\n  mem_diff : \"\\<lbrakk> \\<langle> c', mds', mem' \\<rangle> \\<in> loc_reach lc;\n                (\\<forall> x \\<in> mds' AsmNoWrite. mem' x = mem'' x) \\<rbrakk> \\<Longrightarrow>\n              \\<langle> c', mds', mem'' \\<rangle> \\<in> loc_reach lc\""], ["", "definition locally_sound_mode_use :: \"(_, _, _) LocalConf \\<Rightarrow> bool\"\n  where\n  \"locally_sound_mode_use lc =\n  (\\<forall> c' mds' mem'. \\<langle> c', mds', mem' \\<rangle> \\<in> loc_reach lc \\<longrightarrow>\n    (\\<forall> x. (x \\<in> mds' GuarNoRead \\<longrightarrow> doesnt_read c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\""], ["", "definition compatible_modes :: \"('Var Mds) list \\<Rightarrow> bool\"\n  where\n  \"compatible_modes mdss = (\\<forall> (i :: nat) x. i < length mdss \\<longrightarrow>\n    (x \\<in> (mdss ! i) AsmNoRead \\<longrightarrow>\n     (\\<forall> j < length mdss. j \\<noteq> i \\<longrightarrow> x \\<in> (mdss ! j) GuarNoRead)) \\<and>\n    (x \\<in> (mdss ! i) AsmNoWrite \\<longrightarrow>\n     (\\<forall> j < length mdss. j \\<noteq> i \\<longrightarrow> x \\<in> (mdss ! j) GuarNoWrite)))\""], ["", "definition reachable_mode_states :: \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow> (('Var Mds) list) set\"\n  where \"reachable_mode_states gc =\n  {mdss. (\\<exists> cms' mem'. gc \\<rightarrow>\\<^sup>* (cms', mem') \\<and> map snd cms' = mdss)}\""], ["", "definition globally_sound_mode_use :: \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow> bool\"\n  where \"globally_sound_mode_use gc =\n  (\\<forall> mdss. mdss \\<in> reachable_mode_states gc \\<longrightarrow> compatible_modes mdss)\""], ["", "primrec sound_mode_use :: \"(_, _, _) GlobalConf \\<Rightarrow> bool\"\n  where\n  \"sound_mode_use (cms, mem) =\n     (list_all (\\<lambda> cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n      globally_sound_mode_use (cms, mem))\""], ["", "(* We now show that mm_equiv itself forms a strong low bisimulation modulo modes: *)"], ["", "lemma mm_equiv_sym:\n  assumes equivalent: \"\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\"\n  shows \"\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx> \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "from equivalent"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>", "obtain \\<R>\n    where \\<R>_bisim: \"strong_low_bisim_mm \\<R> \\<and> (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>, \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mm_equiv.simps)"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "hence \"sym \\<R>\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. sym \\<R>", "by (auto simp: strong_low_bisim_mm_def)"], ["proof (state)\nthis:\n  sym \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "hence \"(\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>, \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  sym \\<R>\n\ngoal (1 subgoal):\n 1. (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n     \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n    \\<in> \\<R>", "by (metis \\<R>_bisim symE)"], ["proof (state)\nthis:\n  (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n   \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n   \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "by (metis \\<R>_bisim mm_equiv.intros)"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma low_indistinguishable_sym: \"lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow> lc' \\<sim>\\<^bsub>mds\\<^esub> lc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow>\n    lc' \\<sim>\\<^bsub>mds\\<^esub> lc", "by (auto simp: mm_equiv_sym low_indistinguishable_def low_mds_eq_def)"], ["", "lemma mm_equiv_glob_consistent: \"closed_glob_consistent mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_glob_consistent mm_equiv", "unfolding closed_glob_consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n       (\\<forall>x.\n           (dma x = High \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n            (\\<forall>v\\<^sub>1 v\\<^sub>2.\n                \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n                (x := v\\<^sub>1)\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n                (x := v\\<^sub>2)\\<rangle>)) \\<and>\n           (dma x = Low \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n            (\\<forall>v.\n                \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n                (x := v)\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2(x := v)\\<rangle>)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 x.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       (dma x = High \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n        (\\<forall>v\\<^sub>1 v\\<^sub>2.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n            (x := v\\<^sub>1)\\<rangle> \\<approx>\n            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n            (x := v\\<^sub>2)\\<rangle>)) \\<and>\n       (dma x = Low \\<and> x \\<notin> mds AsmNoWrite \\<longrightarrow>\n        (\\<forall>v.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1(x := v)\\<rangle> \\<approx>\n            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2(x := v)\\<rangle>))", "apply (erule mm_equiv_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 x \\<R>.\n       \\<lbrakk>strong_low_bisim_mm \\<R>;\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R>\\<rbrakk>\n       \\<Longrightarrow> (dma x = High \\<and>\n                          x \\<notin> mds AsmNoWrite \\<longrightarrow>\n                          (\\<forall>v\\<^sub>1 v\\<^sub>2.\n                              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n                              (x := v\\<^sub>1)\\<rangle> \\<approx>\n                              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n                              (x := v\\<^sub>2)\\<rangle>)) \\<and>\n                         (dma x = Low \\<and>\n                          x \\<notin> mds AsmNoWrite \\<longrightarrow>\n                          (\\<forall>v.\n                              \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\n                              (x := v)\\<rangle> \\<approx>\n                              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\n                              (x := v)\\<rangle>))", "by (auto simp: strong_low_bisim_mm_def closed_glob_consistent_def)"], ["", "lemma mm_equiv_strong_low_bisim: \"strong_low_bisim_mm mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strong_low_bisim_mm mm_equiv", "unfolding strong_low_bisim_mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym mm_equiv \\<and>\n    closed_glob_consistent mm_equiv \\<and>\n    (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)))", "proof (auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. sym mm_equiv\n 2. closed_glob_consistent mm_equiv\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 4. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "show \"closed_glob_consistent mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_glob_consistent mm_equiv", "by (rule mm_equiv_glob_consistent)"], ["proof (state)\nthis:\n  closed_glob_consistent mm_equiv\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 x"], ["proof (state)\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>", "obtain \\<R> where\n    \"strong_low_bisim_mm \\<R> \\<and> (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "thus \"mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "by (auto simp: strong_low_bisim_mm_def)"], ["proof (state)\nthis:\n  mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix c\\<^sub>1 :: 'Com"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds' mem\\<^sub>1'"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "let ?lc\\<^sub>1 = \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>\" and\n      ?lc\\<^sub>1' = \"\\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle>\" and\n      ?lc\\<^sub>2 = \"\\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"?lc\\<^sub>1 \\<approx> ?lc\\<^sub>2\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>", "obtain \\<R> where \"strong_low_bisim_mm \\<R> \\<and> (?lc\\<^sub>1, ?lc\\<^sub>2) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule mm_equiv_elim, blast)"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"?lc\\<^sub>1 \\<leadsto> ?lc\\<^sub>1'\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>", "show \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. ?lc\\<^sub>2 \\<leadsto> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle> \\<and> ?lc\\<^sub>1' \\<approx> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n       \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n       \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "by (simp add: strong_low_bisim_mm_def mm_equiv_sym, blast)"], ["proof (state)\nthis:\n  \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n     \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n     \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. sym mm_equiv", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sym mm_equiv", "show \"sym mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym mm_equiv", "by (auto simp: sym_def mm_equiv_sym)"], ["proof (state)\nthis:\n  sym mm_equiv\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}