{"file_name": "/home/qj213/afp-2021-10-22/thys/Green/CircExample.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Green", "problem_names": ["lemma circle_cube_nice:\n  shows \"circle_cube = (\\<lambda>(x,y). (d * x_coord x, (2 * y - 1) * d * circle_y (x_coord x)))\"", "lemma x_coord_inv_1: \"x_coord_inv (x_coord (x::real)) = x\"", "lemma x_coord_inv_2: \"x_coord (x_coord_inv (x::real)) = x\"", "lemma circle_y_bounds:\n  assumes \"-1/2 \\<le> (x::real) \\<and> x \\<le> 1/2\"\n  shows \"0 \\<le> circle_y x\" \"circle_y x \\<le> 1/2\"", "lemma circle_y_x_coord_bounds:\n  assumes \"0 \\<le> (x::real)\" \"x \\<le> 1\"\n  shows \"0 \\<le> circle_y (x_coord x) \\<and> circle_y (x_coord x) \\<le> 1/2\"", "lemma rot_x_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\"  \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_x'' x y \\<and> rot_x'' x y \\<le> 1\"", "lemma rot_y_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_y'' x y \\<and> rot_y'' x y \\<le> 1\"", "lemma circle_eq_rot_circle:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(circle_cube (x, y)) = (rot_circle_cube (rot_y'' x y, rot_x'' x y))\"", "lemma rot_circle_eq_circle:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(rot_circle_cube (x, y)) = (circle_cube (rot_x'' y x, rot_y'' y x))\"", "lemma rot_img_eq:\n  assumes \"0 < d\"\n  shows \"(cubeImage (circle_cube )) = (cubeImage (rot_circle_cube))\"", "lemma rot_circle_div_circle:\n  assumes \"0 < (d::real)\"\n  shows \"gen_division (cubeImage circle_cube) (cubeImage ` {rot_circle_cube})\"", "lemma circle_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary circle_cube\"\n  shows \"valid_path \\<gamma>\"", "lemma rot_circle_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary rot_circle_cube\"\n  shows \"valid_path \\<gamma>\"", "lemma diff_divide_cancel: \n  fixes z::real shows  \"z \\<noteq> 0  \\<Longrightarrow> (a * z - a * (b * z)) / z = (a - a * b)\"", "lemma circle_cube_is_type_I:\n  assumes \"0 < d\"\n  shows \"typeI_twoCube circle_cube\"", "lemma rot_circle_cube_is_type_II:\n  shows \"typeII_twoCube rot_circle_cube\"", "lemma circle_cube_boundary_explicit:\n    \"boundary circle_cube = {circle_left_edge,circle_right_edge,circle_bot_edge,circle_top_edge}\"", "lemma rot_circle_cube_boundary_explicit:\n    \"boundary (rot_circle_cube) =\n           {rot_circle_top_edge,rot_circle_bot_edge,rot_circle_right_edge,rot_circle_left_edge}\"", "lemma rot_circle_cube_vertical_boundary_explicit:\n    \"vertical_boundary rot_circle_cube = {rot_circle_right_edge,rot_circle_left_edge}\"", "lemma circ_left_edge_neq_top:\n   \"(- 1::int, \\<lambda>y::real. (- (d/2), 0)) \\<noteq> (- 1, \\<lambda>x. ((x - 1/2) * d, d * sqrt (1/4 - (x - 1/2) * (x - 1/2))))\"", "lemma circle_cube_valid_two_cube: \"valid_two_cube (circle_cube)\"", "lemma rot_circle_cube_valid_two_cube:\n  shows \"valid_two_cube rot_circle_cube\"", "lemma circle_top_bot_edges_neq' [simp]: \n  shows \"circle_top_edge \\<noteq> circle_bot_edge\"", "lemma rot_circle_top_left_edges_neq [simp]: \"rot_circle_top_edge \\<noteq> rot_circle_left_edge\"", "lemma rot_circle_bot_left_edges_neq [simp]: \"rot_circle_bot_edge \\<noteq> rot_circle_left_edge\"", "lemma rot_circle_top_right_edges_neq [simp]: \"rot_circle_top_edge \\<noteq> rot_circle_right_edge\"", "lemma rot_circle_bot_right_edges_neq [simp]: \"rot_circle_bot_edge \\<noteq> rot_circle_right_edge\"", "lemma rot_circle_right_top_edges_neq' [simp]: \"rot_circle_right_edge \\<noteq> rot_circle_left_edge\"", "lemma rot_circle_left_bot_edges_neq [simp]: \"rot_circle_left_edge \\<noteq> rot_circle_top_edge\"", "lemma circle_right_top_edges_neq [simp]: \"circle_right_edge \\<noteq> circle_top_edge\"", "lemma circle_left_bot_edges_neq [simp]: \"circle_left_edge \\<noteq> circle_bot_edge\"", "lemma circle_left_top_edges_neq [simp]: \"circle_left_edge \\<noteq> circle_top_edge\"", "lemma circle_right_bot_edges_neq [simp]: \"circle_right_edge \\<noteq> circle_bot_edge\"", "lemma circle_polar_smooth: \"(circle_polar) C1_differentiable_on {0..1}\"", "lemma cont_custom_arccos: \n  assumes \"S \\<subseteq> {-1..1}\"\n  shows \"continuous_on S custom_arccos\"", "lemma custom_arccos_has_deriv: \n  assumes \"- 1 < x\" \"x < 1\"\n  shows \"DERIV custom_arccos x :> inverse (- sqrt (1 - x\\<^sup>2))\"", "lemma circle_boundary_reparams:\n  shows rot_circ_left_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(rot_circle_left_edge)]) (rec_join [(subcube (1/4) (1/2) (1, circle_polar)), (subcube (1/2) (3/4) (1, circle_polar))])\"\n    (is ?P1)\n    and circ_top_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(circle_top_edge)]) (rec_join [(subcube 0 (1/4) (1, circle_polar)), (subcube (1/4) (1/2) (1, circle_polar))])\"\n    (is ?P2)\n    and circ_bot_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(circle_bot_edge)]) (rec_join [(subcube (1/2) (3/4) (1, circle_polar)), (subcube (3/4) 1 (1, circle_polar))])\"\n    (is ?P3)\n    and rot_circ_right_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(rot_circle_right_edge)]) (rec_join [(subcube (3/4) 1 (1, circle_polar)), (subcube 0 (1/4) (1, circle_polar))])\"\n    (is ?P4)", "lemma circle_arcs_neq:\n  assumes \"0 \\<le> k\" \"k \\<le> 1\" \"0 \\<le> n\" \"n \\<le> 1\" \"n < k\" \"k + n < 1\"\n  shows \"subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)\"", "lemma circle_arcs_neq_2:\n  assumes \"0 \\<le> k\" \"k \\<le> 1\" \"0 \\<le> n\" \"n \\<le> 1\" \"n < k\" \"0 < n\" and kn12: \"1/2 < k + n\" and \"k + n < 3/2\"\n  shows \"subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)\"", "lemma circle_cube_is_only_horizontal_div_of_rot:\n  shows \"only_horizontal_division (boundary (circle_cube)) {rot_circle_cube}\"", "lemma GreenThm_cirlce:\n  assumes \"\\<forall>twoC\\<in>{circle_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\"\n    \"\\<forall>twoC\\<in>{rot_circle_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\"\n  shows \"integral (cubeImage (circle_cube)) (\\<lambda>x. partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x - partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n                     one_chain_line_integral F {i, j} (boundary (circle_cube))\""], "translations": [["", "lemma circle_cube_nice:\n  shows \"circle_cube = (\\<lambda>(x,y). (d * x_coord x, (2 * y - 1) * d * circle_y (x_coord x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_cube =\n    (\\<lambda>(x, y).\n        (d * x_coord x, (2 * y - 1) * d * circle_y (x_coord x)))", "by (auto simp add: circle_cube_def circle_y_def x_coord_def)"], ["", "definition rot_circle_cube where\n  \"rot_circle_cube = prod.swap \\<circ> (circle_cube) \\<circ> prod.swap\""], ["", "abbreviation \"rot_y t1 t2 \\<equiv> ((t1-1/2)/(2* circle_y (x_coord (rot_x t1 t2))) +1/2::real)\""], ["", "definition \"x_coord_inv (x::real) = (1/2) + x\""], ["", "lemma x_coord_inv_1: \"x_coord_inv (x_coord (x::real)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord_inv (x_coord x) = x", "by (auto simp add: x_coord_inv_def x_coord_def)"], ["", "lemma x_coord_inv_2: \"x_coord (x_coord_inv (x::real)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord (x_coord_inv x) = x", "by (auto simp add: x_coord_inv_def x_coord_def)"], ["", "definition \"circle_y_inv = circle_y\""], ["", "abbreviation \"rot_x'' (x::real) (y::real) \\<equiv> (x_coord_inv ((2 * y - 1) * circle_y (x_coord x)))\""], ["", "lemma circle_y_bounds:\n  assumes \"-1/2 \\<le> (x::real) \\<and> x \\<le> 1/2\"\n  shows \"0 \\<le> circle_y x\" \"circle_y x \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y x &&& circle_y x \\<le> 1 / 2", "unfolding circle_y_def real_sqrt_ge_0_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x * x &&& sqrt (1 / 4 - x * x) \\<le> 1 / 2", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> 1 / 4 - x * x\n 2. sqrt (1 / 4 - x * x) \\<le> 1 / 2", "show \"0 \\<le> 1/4 - x * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x * x", "using assms"], ["proof (prove)\nusing this:\n  - 1 / 2 \\<le> x \\<and> x \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x * x", "by (sos \"(((A<0 * R<1) + ((A<=0 * (A<=1 * R<1)) * (R<1 * [1]^2))))\")"], ["proof (state)\nthis:\n  0 \\<le> 1 / 4 - x * x\n\ngoal (1 subgoal):\n 1. sqrt (1 / 4 - x * x) \\<le> 1 / 2", "show \"sqrt (1/4 - x * x) \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (1 / 4 - x * x) \\<le> 1 / 2", "apply (rule real_le_lsqrt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> 1 / 4 - x * x\n 2. 0 \\<le> 1 / 2\n 3. 1 / 4 - x * x \\<le> (1 / 2)\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  - 1 / 2 \\<le> x \\<and> x \\<le> 1 / 2\n\ngoal (3 subgoals):\n 1. 0 \\<le> 1 / 4 - x * x\n 2. 0 \\<le> 1 / 2\n 3. 1 / 4 - x * x \\<le> (1 / 2)\\<^sup>2", "apply(auto simp add: divide_simps algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- 1 \\<le> x * 2; x * 2 \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> x * (x * 4) \\<le> 1", "by (sos \"(((A<0 * R<1) + ((A<=0 * (A<=1 * R<1)) * (R<1 * [1]^2))))\")"], ["proof (state)\nthis:\n  sqrt (1 / 4 - x * x) \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_y_x_coord_bounds:\n  assumes \"0 \\<le> (x::real)\" \"x \\<le> 1\"\n  shows \"0 \\<le> circle_y (x_coord x) \\<and> circle_y (x_coord x) \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y (x_coord x) \\<and> circle_y (x_coord x) \\<le> 1 / 2", "using circle_y_bounds[OF x_coord_bounds[OF assms]]"], ["proof (prove)\nusing this:\n  0 \\<le> circle_y (x_coord x)\n  circle_y (x_coord x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y (x_coord x) \\<and> circle_y (x_coord x) \\<le> 1 / 2", "by auto"], ["", "lemma rot_x_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\"  \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_x'' x y \\<and> rot_x'' x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<and>\n    x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x))\n 2. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "have \"\\<And>a::real. 0 \\<le> a \\<and> a \\<le> 1/2 \\<Longrightarrow> 0 \\<le> 1/2 + (2 * y - 1) * a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       0 \\<le> a \\<and> a \\<le> 1 / 2 \\<Longrightarrow>\n       0 \\<le> 1 / 2 + (2 * y - 1) * a", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       0 \\<le> a \\<and> a \\<le> 1 / 2 \\<Longrightarrow>\n       0 \\<le> 1 / 2 + (2 * y - 1) * a", "by (sos \"(((A<0 * R<1) + (((A<=4 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=5 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=4 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  0 \\<le> 1 / 2 + (2 * y - 1) * ?a\n\ngoal (2 subgoals):\n 1. 0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x))\n 2. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  0 \\<le> 1 / 2 + (2 * y - 1) * ?a", "show \"0 \\<le> rot_x'' x y\""], ["proof (prove)\nusing this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  0 \\<le> 1 / 2 + (2 * y - 1) * ?a\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x))", "using assms circle_y_x_coord_bounds"], ["proof (prove)\nusing this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  0 \\<le> 1 / 2 + (2 * y - 1) * ?a\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x))", "by(auto simp add: x_coord_inv_def)"], ["proof (state)\nthis:\n  0 \\<le> x_coord_inv ((2 * y - 1) * circle_y (x_coord x))\n\ngoal (1 subgoal):\n 1. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "have \"\\<And>a::real. 0 \\<le> a \\<and> a \\<le> 1/2 \\<Longrightarrow> 1/2 + (2 * y - 1) * a \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       0 \\<le> a \\<and> a \\<le> 1 / 2 \\<Longrightarrow>\n       1 / 2 + (2 * y - 1) * a \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       0 \\<le> a \\<and> a \\<le> 1 / 2 \\<Longrightarrow>\n       1 / 2 + (2 * y - 1) * a \\<le> 1", "by (sos \"(((A<0 * R<1) + (((A<=5 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=4 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=5 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  1 / 2 + (2 * y - 1) * ?a \\<le> 1\n\ngoal (1 subgoal):\n 1. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  1 / 2 + (2 * y - 1) * ?a \\<le> 1", "show \"rot_x'' x y \\<le> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  1 / 2 + (2 * y - 1) * ?a \\<le> 1\n\ngoal (1 subgoal):\n 1. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "using assms circle_y_x_coord_bounds"], ["proof (prove)\nusing this:\n  0 \\<le> ?a \\<and> ?a \\<le> 1 / 2 \\<Longrightarrow>\n  1 / 2 + (2 * y - 1) * ?a \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1", "by (auto simp add: x_coord_inv_def)"], ["proof (state)\nthis:\n  x_coord_inv ((2 * y - 1) * circle_y (x_coord x)) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"rot_y'' (x::real) (y::real) \\<equiv> (x_coord x)/(2* (circle_y (x_coord (rot_x'' x y))))  + 1/2\""], ["", "lemma rot_y_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_y'' x y \\<and> rot_y'' x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2 \\<and>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "show \"0 \\<le> rot_y'' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "proof(cases \"(x_coord x) < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "case True"], ["proof (state)\nthis:\n  x_coord x < 0\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have i: \"\\<And>a b::real. a < 0 \\<Longrightarrow> 0 \\<le> a + b \\<Longrightarrow> (0 \\<le> a/(2*(b)) + 1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < 0; 0 \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> a / (2 * b) + 1 / 2", "by(auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < 0; 0 \\<le> ?a + ?b\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> ?a / (2 * ?b) + 1 / 2\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have *: \"(1/2 - x) \\<le> sqrt (x * x + (1/4 + (x * (y * 4) + x * (x * (y * (y * 4))))) - (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 - x\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "apply (rule real_le_rsqrt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2 - x)\\<^sup>2\n    \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. (1 / 2 - x)\\<^sup>2\n    \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "apply (simp add: algebra_simps power2_eq_square mult_left_le_one_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> x * (x * (y * 4)) + x * (y * (y * 4))\n                      \\<le> x * (y * 4) + x * (x * (y * (y * 4)))", "by (sos \"(((A<0 * R<1) + ((A<=0 * (A<=1 * (A<=2 * (A<=3 * R<1)))) * (R<4 * [1]^2))))\")"], ["proof (state)\nthis:\n  1 / 2 - x\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have rw: \"\\<bar>x - x * x\\<bar> = x - x * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "by (sos \"(() & (((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2)))) & ((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<bar>x - x * x\\<bar> = x - x * x\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have \"0 \\<le> x_coord x + (circle_y (x_coord (rot_x'' x y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x +\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "using *"], ["proof (prove)\nusing this:\n  1 / 2 - x\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x +\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "apply (auto simp add: x_coord_inv_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 - x\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4))))) \\<Longrightarrow>\n    0 \\<le> x_coord x + circle_y ((2 * y - 1) * circle_y (x_coord x))", "by (auto simp add: circle_y_def algebra_simps rw x_coord_def)"], ["proof (state)\nthis:\n  0 \\<le> x_coord x +\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x_coord x +\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x_coord x +\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "using True i"], ["proof (prove)\nusing this:\n  0 \\<le> x_coord x +\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n  x_coord x < 0\n  \\<lbrakk>?a < 0; 0 \\<le> ?a + ?b\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> ?a / (2 * ?b) + 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "by blast"], ["proof (state)\nthis:\n  0 \\<le> x_coord x /\n          (2 *\n           circle_y\n            (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n          1 / 2\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "case False"], ["proof (state)\nthis:\n  \\<not> x_coord x < 0\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have i: \"\\<And>a b::real. 0 \\<le> a \\<Longrightarrow> 0 \\<le> b  \\<Longrightarrow> (0 \\<le> a/(2*b) + 1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>0 \\<le> a; 0 \\<le> b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> a / (2 * b) + 1 / 2", "by(auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> ?a / (2 * ?b) + 1 / 2\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "have \"0 \\<le> circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "have rw: \"\\<bar>x - x * x\\<bar> = x - x * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "by (sos \"(() & (((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2)))) & ((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<bar>x - x * x\\<bar> = x - x * x\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "have \"\\<And>x. 0 \\<le> x \\<Longrightarrow> x \\<le> 1/2 \\<Longrightarrow> -1/2\\<le> (2 * y - 1) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * x", "by (sos \"(((A<0 * R<1) + (((A<=4 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=5 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=4 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x", "have \"- 1/2 \\<le> (2 * y - 1) * circle_y (x_coord x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)", "using circle_y_x_coord_bounds assms(1-2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)", "by auto"], ["proof (state)\nthis:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "moreover"], ["proof (state)\nthis:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "have \"\\<And>x. 0 \\<le> x \\<Longrightarrow> x \\<le> 1/2 \\<Longrightarrow> (2 * y - 1) * x \\<le> 1/2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> (2 * y - 1) * x \\<le> 1 / 2", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> (2 * y - 1) * x \\<le> 1 / 2", "by (sos \"(((A<0 * R<1) + (((A<=5 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=4 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=5 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2", "have \"(2 * y - 1) * circle_y (x_coord x) \\<le> 1/2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "using circle_y_x_coord_bounds assms(1-2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "ultimately"], ["proof (chain)\npicking this:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "show \"0 \\<le> circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\""], ["proof (prove)\nusing this:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "by (simp add: circle_y_bounds(1) x_coord_inv_2)"], ["proof (state)\nthis:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "then"], ["proof (chain)\npicking this:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "using False"], ["proof (prove)\nusing this:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n  \\<not> x_coord x < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> x_coord x /\n            (2 *\n             circle_y\n              (x_coord\n                (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n            1 / 2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x_coord x /\n          (2 *\n           circle_y\n            (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n          1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> x_coord x /\n          (2 *\n           circle_y\n            (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n          1 / 2\n\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have i: \"\\<And>a b::real. a < 0 \\<Longrightarrow> 0 \\<le> b \\<Longrightarrow> (a/(2*(b)) + 1/2) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < 0; 0 \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a / (2 * b) + 1 / 2 \\<le> 1", "by(auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < 0; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a / (2 * ?b) + 1 / 2 \\<le> 1\n\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "show \"rot_y'' x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "proof(cases \"(x_coord x) < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "case True"], ["proof (state)\nthis:\n  x_coord x < 0\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have i: \"\\<And>a b::real. a < 0 \\<Longrightarrow> 0 \\<le> b \\<Longrightarrow> (a/(2*(b)) + 1/2) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < 0; 0 \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a / (2 * b) + 1 / 2 \\<le> 1", "by(auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < 0; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a / (2 * ?b) + 1 / 2 \\<le> 1\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have \"\\<And>x. 0 \\<le> x \\<Longrightarrow> x \\<le> 1/2 \\<Longrightarrow> -1/2\\<le> (2 * y - 1) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * x", "by (sos \"(((A<0 * R<1) + (((A<=4 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=5 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=4 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x", "have \"- 1/2 \\<le> (2 * y - 1) * circle_y (x_coord x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)", "using circle_y_x_coord_bounds assms(1-2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> - 1 / 2 \\<le> (2 * y - 1) * ?x\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)", "by auto"], ["proof (state)\nthis:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "moreover"], ["proof (state)\nthis:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have \"\\<And>x. 0 \\<le> x \\<Longrightarrow> x \\<le> 1/2 \\<Longrightarrow> (2 * y - 1) * x \\<le> 1/2 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> (2 * y - 1) * x \\<le> 1 / 2", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1 / 2\\<rbrakk>\n       \\<Longrightarrow> (2 * y - 1) * x \\<le> 1 / 2", "by (sos \"(((A<0 * R<1) + (((A<=5 * R<1) * (R<1/2 * [1]^2)) + (((A<=1 * (A<=4 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=5 * R<1)) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2", "have \"(2 * y - 1) * circle_y (x_coord x) \\<le> 1/2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "using circle_y_x_coord_bounds assms(1-2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (2 * y - 1) * ?x \\<le> 1 / 2\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> circle_y (x_coord ?x) \\<and>\n                    circle_y (x_coord ?x) \\<le> 1 / 2\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "by auto"], ["proof (state)\nthis:\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2", "have \"0 \\<le> circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\""], ["proof (prove)\nusing this:\n  - 1 / 2 \\<le> (2 * y - 1) * circle_y (x_coord x)\n  (2 * y - 1) * circle_y (x_coord x) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "by (simp add: circle_y_bounds(1) x_coord_inv_2)"], ["proof (state)\nthis:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (2 subgoals):\n 1. x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1\n 2. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "by (simp add: True i)"], ["proof (state)\nthis:\n  x_coord x /\n  (2 *\n   circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n  1 / 2\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "case False"], ["proof (state)\nthis:\n  \\<not> x_coord x < 0\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have i: \"\\<And>a b::real. 0 \\<le> a \\<Longrightarrow> a \\<le> b  \\<Longrightarrow> (a/(2*b) + 1/2) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>0 \\<le> a; a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> a / (2 * b) + 1 / 2 \\<le> 1", "by(auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a / (2 * ?b) + 1 / 2 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have \"(x - 1/2) * (x - 1/2) \\<le> (x * x + (1/4 + (x * (y * 4) + x * (x * (y * (y * 4))))) - (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - 1 / 2) * (x - 1 / 2)\n    \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "using assms False"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<not> x_coord x < 0\n\ngoal (1 subgoal):\n 1. (x - 1 / 2) * (x - 1 / 2)\n    \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "apply(auto simp add: x_coord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; \\<not> x * 2 < 1\\<rbrakk>\n    \\<Longrightarrow> (x - 1 / 2) * (x - 1 / 2)\n                      \\<le> x * x +\n                            (1 / 4 +\n                             (x * (y * 4) + x * (x * (y * (y * 4))))) -\n                            (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "by (sos \"(((A<0 * R<1) + (((A<=0 * (A<=1 * (A<=2 * R<1))) * (R<2 * [1]^2)) + ((A<=0 * (A<=1 * (A<=2 * (A<=3 * R<1)))) * (R<2 * [1]^2)))))\")"], ["proof (state)\nthis:\n  (x - 1 / 2) * (x - 1 / 2)\n  \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n        (x + (x * (x * (y * 4)) + x * (y * (y * 4))))\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (x - 1 / 2) * (x - 1 / 2)\n  \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n        (x + (x * (x * (y * 4)) + x * (y * (y * 4))))", "have \"sqrt ((x - 1/2) * (x - 1/2)) \\<le> sqrt (x * x + (1/4 + (x * (y * 4) + x * (x * (y * (y * 4))))) - (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\""], ["proof (prove)\nusing this:\n  (x - 1 / 2) * (x - 1 / 2)\n  \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n        (x + (x * (x * (y * 4)) + x * (y * (y * 4))))\n\ngoal (1 subgoal):\n 1. sqrt ((x - 1 / 2) * (x - 1 / 2))\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "using real_sqrt_le_mono"], ["proof (prove)\nusing this:\n  (x - 1 / 2) * (x - 1 / 2)\n  \\<le> x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n        (x + (x * (x * (y * 4)) + x * (y * (y * 4))))\n  ?x \\<le> ?y \\<Longrightarrow> sqrt ?x \\<le> sqrt ?y\n\ngoal (1 subgoal):\n 1. sqrt ((x - 1 / 2) * (x - 1 / 2))\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "by blast"], ["proof (state)\nthis:\n  sqrt ((x - 1 / 2) * (x - 1 / 2))\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  sqrt ((x - 1 / 2) * (x - 1 / 2))\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "have *: \"(x - 1/2) \\<le> sqrt (x * x + (1/4 + (x * (y * 4) + x * (x * (y * (y * 4))))) - (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\""], ["proof (prove)\nusing this:\n  sqrt ((x - 1 / 2) * (x - 1 / 2))\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. x - 1 / 2\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "using assms False"], ["proof (prove)\nusing this:\n  sqrt ((x - 1 / 2) * (x - 1 / 2))\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<not> x_coord x < 0\n\ngoal (1 subgoal):\n 1. x - 1 / 2\n    \\<le> sqrt\n           (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n            (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))", "by(auto simp add: x_coord_def)"], ["proof (state)\nthis:\n  x - 1 / 2\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have rw: \"\\<bar>x - x * x\\<bar> = x - x * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>x - x * x\\<bar> = x - x * x", "by (sos \"(() & (((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2)))) & ((((A<0 * A<1) * R<1) + ((A<=0 * (A<=1 * (A<1 * R<1))) * (R<1 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<bar>x - x * x\\<bar> = x - x * x\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "have \"x_coord x \\<le> circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord x\n    \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "using *"], ["proof (prove)\nusing this:\n  x - 1 / 2\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. x_coord x\n    \\<le> circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "unfolding x_coord_inv_2"], ["proof (prove)\nusing this:\n  x - 1 / 2\n  \\<le> sqrt\n         (x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) -\n          (x + (x * (x * (y * 4)) + x * (y * (y * 4)))))\n\ngoal (1 subgoal):\n 1. x_coord x \\<le> circle_y ((2 * y - 1) * circle_y (x_coord x))", "by (auto simp add: circle_y_def algebra_simps rw x_coord_def)"], ["proof (state)\nthis:\n  x_coord x\n  \\<le> circle_y\n         (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. \\<not> x_coord x < 0 \\<Longrightarrow>\n    x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "then"], ["proof (chain)\npicking this:\n  x_coord x\n  \\<le> circle_y\n         (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  x_coord x\n  \\<le> circle_y\n         (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "using False i"], ["proof (prove)\nusing this:\n  x_coord x\n  \\<le> circle_y\n         (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n  \\<not> x_coord x < 0\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a / (2 * ?b) + 1 / 2 \\<le> 1\n\ngoal (1 subgoal):\n 1. x_coord x /\n    (2 *\n     circle_y\n      (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n    1 / 2\n    \\<le> 1", "by auto"], ["proof (state)\nthis:\n  x_coord x /\n  (2 *\n   circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n  1 / 2\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x_coord x /\n  (2 *\n   circle_y (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n  1 / 2\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_eq_rot_circle:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(circle_cube (x, y)) = (rot_circle_cube (rot_y'' x y, rot_x'' x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_cube (x, y) =\n    rot_circle_cube\n     (x_coord x /\n      (2 *\n       circle_y\n        (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n      1 / 2,\n      x_coord_inv ((2 * y - 1) * circle_y (x_coord x)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (circle_cube (x, y)) =\n    fst (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n 2. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "have rw:  \"\\<bar>1/4 - x_coord x * x_coord x\\<bar> = 1/4 - x_coord x * x_coord x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>1 / 4 - x_coord x * x_coord x\\<bar> =\n    1 / 4 - x_coord x * x_coord x", "apply(rule abs_of_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x_coord x * x_coord x", "using assms mult_left_le"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<lbrakk>?c \\<le> (1::?'a); (0::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x_coord x * x_coord x", "by (auto simp add: x_coord_def divide_simps algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>1 / 4 - x_coord x * x_coord x\\<bar> = 1 / 4 - x_coord x * x_coord x\n\ngoal (2 subgoals):\n 1. fst (circle_cube (x, y)) =\n    fst (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n 2. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show \"fst (circle_cube (x, y)) = fst (rot_circle_cube (rot_y'' x y, rot_x'' x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (circle_cube (x, y)) =\n    fst (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "using assms d_gt_0"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  0 < d\n\ngoal (1 subgoal):\n 1. fst (circle_cube (x, y)) =\n    fst (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "apply(simp add: circle_cube_nice rot_circle_cube_def x_coord_inv_2 circle_y_def algebra_simps rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y \\<le> 1; 0 < d\\<rbrakk>\n    \\<Longrightarrow> y +\n                      (x_coord x * x_coord x +\n                       y * (y * (x_coord x * (x_coord x * 4)))) =\n                      y * y +\n                      y * (x_coord x * (x_coord x * 4)) \\<longrightarrow>\n                      x_coord x = 0", "apply(auto simp add: x_coord_def algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y \\<le> 1; 0 < d;\n     x * x + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) =\n     x + (x * (x * (y * 4)) + x * (y * (y * 4)))\\<rbrakk>\n    \\<Longrightarrow> x * 2 = 1", "by (sos \"(((((A<0 * A<1) * ((A<0 * A<1) * R<1)) + (([~4*d^2] * A=0) + (((A<=1 * (A<=2 * (A<=3 * R<1))) * (R<8 * [d]^2)) + ((A<=1 * (A<=2 * (A<=3 * (A<1 * R<1)))) * (R<8 * [d]^2)))))) & ((((A<0 * A<1) * ((A<0 * A<1) * R<1)) + (([~4*d^2] * A=0) + (((A<=0 * (A<=2 * (A<=3 * R<1))) * (R<8 * [d]^2)) + ((A<=0 * (A<=2 * (A<=3 * (A<1 * R<1)))) * (R<8 * [d]^2)))))))\")"], ["proof (state)\nthis:\n  fst (circle_cube (x, y)) =\n  fst (rot_circle_cube\n        (x_coord x /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n         1 / 2,\n         x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "(*Be patient: it takes a bit of time, still better than creeping its proof manually.*)"], ["proof (state)\nthis:\n  fst (circle_cube (x, y)) =\n  fst (rot_circle_cube\n        (x_coord x /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n         1 / 2,\n         x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal (1 subgoal):\n 1. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "show \"snd (circle_cube (x, y)) = snd (rot_circle_cube (rot_y'' x y, rot_x'' x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. snd (circle_cube (x, y)) =\n    snd (rot_circle_cube\n          (x_coord x /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n           1 / 2,\n           x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))", "by(auto simp add: circle_cube_def rot_circle_cube_def x_coord_inv_def circle_y_def x_coord_def)"], ["proof (state)\nthis:\n  snd (circle_cube (x, y)) =\n  snd (rot_circle_cube\n        (x_coord x /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))) +\n         1 / 2,\n         x_coord_inv ((2 * y - 1) * circle_y (x_coord x))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_circle_eq_circle:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(rot_circle_cube (x, y)) = (circle_cube (rot_x'' y x, rot_y'' y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_cube (x, y) =\n    circle_cube\n     (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n      x_coord y /\n      (2 *\n       circle_y\n        (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n      1 / 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (rot_circle_cube (x, y)) =\n    fst (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))\n 2. snd (rot_circle_cube (x, y)) =\n    snd (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "show \"fst (rot_circle_cube (x, y)) = fst (circle_cube (rot_x'' y x, rot_y'' y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (rot_circle_cube (x, y)) =\n    fst (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. fst (rot_circle_cube (x, y)) =\n    fst (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "by(auto simp add: circle_cube_def rot_circle_cube_def x_coord_inv_def circle_y_def x_coord_def)"], ["proof (state)\nthis:\n  fst (rot_circle_cube (x, y)) =\n  fst (circle_cube\n        (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n         x_coord y /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n         1 / 2))\n\ngoal (1 subgoal):\n 1. snd (rot_circle_cube (x, y)) =\n    snd (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "have rw:  \"\\<bar>1/4 - x_coord y * x_coord y\\<bar> =  1/4 - x_coord y * x_coord y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>1 / 4 - x_coord y * x_coord y\\<bar> =\n    1 / 4 - x_coord y * x_coord y", "apply(rule abs_of_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x_coord y * x_coord y", "using assms mult_left_le"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  \\<lbrakk>?c \\<le> (1::?'a); (0::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / 4 - x_coord y * x_coord y", "by (auto simp add: x_coord_def divide_simps algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>1 / 4 - x_coord y * x_coord y\\<bar> = 1 / 4 - x_coord y * x_coord y\n\ngoal (1 subgoal):\n 1. snd (rot_circle_cube (x, y)) =\n    snd (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "show \"snd (rot_circle_cube (x, y)) = snd (circle_cube (rot_x'' y x, rot_y'' y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rot_circle_cube (x, y)) =\n    snd (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "using assms d_gt_0"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  0 < d\n\ngoal (1 subgoal):\n 1. snd (rot_circle_cube (x, y)) =\n    snd (circle_cube\n          (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n           x_coord y /\n           (2 *\n            circle_y\n             (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n           1 / 2))", "apply(simp add: circle_cube_nice rot_circle_cube_def x_coord_inv_2 circle_y_def algebra_simps rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y \\<le> 1; 0 < d\\<rbrakk>\n    \\<Longrightarrow> x +\n                      (x_coord y * x_coord y +\n                       x * (x * (x_coord y * (x_coord y * 4)))) =\n                      x * x +\n                      x * (x_coord y * (x_coord y * 4)) \\<longrightarrow>\n                      x_coord y = 0", "apply(auto simp add: x_coord_def algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y \\<le> 1; 0 < d;\n     y * y + (1 / 4 + (x * (y * 4) + x * (x * (y * (y * 4))))) =\n     y + (x * (x * (y * 4)) + x * (y * (y * 4)))\\<rbrakk>\n    \\<Longrightarrow> y * 2 = 1", "by (sos \"(((((A<0 * A<1) * ((A<0 * A<1) * R<1)) + (([~4*d^2] * A=0) + (((A<=0 * (A<=1 * (A<=3 * R<1))) * (R<8 * [d]^2)) + ((A<=0 * (A<=1 * (A<=3 * (A<1 * R<1)))) * (R<8 * [d]^2)))))) & ((((A<0 * A<1) * ((A<0 * A<1) * R<1)) + (([~4*d^2] * A=0) + (((A<=0 * (A<=1 * (A<=2 * R<1))) * (R<8 * [d]^2)) + ((A<=0 * (A<=1 * (A<=2 * (A<1 * R<1)))) * (R<8 * [d]^2)))))))\")"], ["proof (state)\nthis:\n  snd (rot_circle_cube (x, y)) =\n  snd (circle_cube\n        (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n         x_coord y /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n         1 / 2))\n\ngoal:\nNo subgoals!", "(*Be patient: it takes a bit of time, still better than creeping its proof manually.*)"], ["proof (state)\nthis:\n  snd (rot_circle_cube (x, y)) =\n  snd (circle_cube\n        (x_coord_inv ((2 * x - 1) * circle_y (x_coord y)),\n         x_coord y /\n         (2 *\n          circle_y\n           (x_coord (x_coord_inv ((2 * x - 1) * circle_y (x_coord y))))) +\n         1 / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_img_eq:\n  assumes \"0 < d\"\n  shows \"(cubeImage (circle_cube )) = (cubeImage (rot_circle_cube))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cubeImage circle_cube = cubeImage rot_circle_cube", "apply(auto simp add: cubeImage_def image_def cbox_def real_pair_basis)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>0 \\<le> aa; aa \\<le> 1; 0 \\<le> ba; ba \\<le> 1;\n        (a, b) = circle_cube (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<ge>0.\n                            a \\<le> 1 \\<and>\n                            (\\<exists>b\\<ge>0.\n                                b \\<le> 1 \\<and>\n                                circle_cube (aa, ba) =\n                                rot_circle_cube (a, b))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>0 \\<le> aa; aa \\<le> 1; 0 \\<le> ba; ba \\<le> 1;\n        (a, b) = rot_circle_cube (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<ge>0.\n                            a \\<le> 1 \\<and>\n                            (\\<exists>b\\<ge>0.\n                                b \\<le> 1 \\<and>\n                                rot_circle_cube (aa, ba) =\n                                circle_cube (a, b))", "by (meson rot_y_ivl rot_x_ivl assms circle_eq_rot_circle rot_circle_eq_circle)+"], ["", "lemma rot_circle_div_circle:\n  assumes \"0 < (d::real)\"\n  shows \"gen_division (cubeImage circle_cube) (cubeImage ` {rot_circle_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage circle_cube) (cubeImage ` {rot_circle_cube})", "using rot_img_eq[OF assms]"], ["proof (prove)\nusing this:\n  cubeImage circle_cube = cubeImage rot_circle_cube\n\ngoal (1 subgoal):\n 1. gen_division (cubeImage circle_cube) (cubeImage ` {rot_circle_cube})", "by(auto simp add: gen_division_def)"], ["", "lemma circle_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary circle_cube\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "have f01: \"finite{0,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'a, 1::'a}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'a1, 1::?'a1}\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> boundary circle_cube\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "unfolding boundary_def horizontal_boundary_def vertical_boundary_def circle_cube_def valid_path_def piecewise_C1_differentiable_on_def"], ["proof (prove)\nusing this:\n  (k, \\<gamma>)\n  \\<in> {(1, \\<lambda>x.\n                case (x, 0) of\n                (x, y) \\<Rightarrow>\n                  ((x - 1 / 2) * d,\n                   (2 * y - 1) * d *\n                   sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))),\n         (- 1,\n          \\<lambda>x.\n             case (x, 1) of\n             (x, y) \\<Rightarrow>\n               ((x - 1 / 2) * d,\n                (2 * y - 1) * d *\n                sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} \\<union>\n        {(- 1,\n          \\<lambda>y.\n             case (0, y) of\n             (x, y) \\<Rightarrow>\n               ((x - 1 / 2) * d,\n                (2 * y - 1) * d *\n                sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))),\n         (1, \\<lambda>y.\n                case (1, y) of\n                (x, y) \\<Rightarrow>\n                  ((x - 1 / 2) * d,\n                   (2 * y - 1) * d *\n                   sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))}\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<gamma> \\<and>\n    (\\<exists>S. finite S \\<and> \\<gamma> C1_differentiable_on {0..1} - S)", "by safe (rule derivative_intros continuous_intros f01 exI ballI conjI refl | force simp add: field_simps)+"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_circle_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary rot_circle_cube\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using assms swap_valid_boundaries circle_cube_boundary_valid"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> boundary rot_circle_cube\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>boundary ?C. valid_path \\<gamma>;\n   (?k, ?\\<gamma>)\n   \\<in> boundary (prod.swap \\<circ> ?C \\<circ> prod.swap)\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  (?k, ?\\<gamma>) \\<in> boundary circle_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by (fastforce simp add: rot_circle_cube_def)"], ["", "lemma diff_divide_cancel: \n  fixes z::real shows  \"z \\<noteq> 0  \\<Longrightarrow> (a * z - a * (b * z)) / z = (a - a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> (a * z - a * (b * z)) / z = a - a * b", "by (auto simp: field_simps)"], ["", "lemma circle_cube_is_type_I:\n  assumes \"0 < d\"\n  shows \"typeI_twoCube circle_cube\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeI_twoCube circle_cube", "unfolding typeI_twoCube_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b g1 g2.\n       a < b \\<and>\n       (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n       circle_cube =\n       (\\<lambda>(x, y).\n           ((1 - x) * a + x * b,\n            (1 - y) * g2 ((1 - x) * a + x * b) +\n            y * g1 ((1 - x) * a + x * b))) \\<and>\n       g1 piecewise_C1_differentiable_on {a..b} \\<and>\n       g2 piecewise_C1_differentiable_on {a..b}", "proof (intro exI conjI ballI)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?a < ?b1\n 2. \\<And>x. x \\<in> {?a..?b1} \\<Longrightarrow> ?g2.3 x \\<le> ?g1.2 x\n 3. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * ?a + x * ?b1,\n         (1 - y) * ?g2.3 ((1 - x) * ?a + x * ?b1) +\n         y * ?g1.2 ((1 - x) * ?a + x * ?b1)))\n 4. ?g1.2 piecewise_C1_differentiable_on {?a..?b1}\n 5. ?g2.3 piecewise_C1_differentiable_on {?a..?b1}", "have f01: \"finite{-d/2,d/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {- d / 2, d / 2}", "by simp"], ["proof (state)\nthis:\n  finite {- d / 2, d / 2}\n\ngoal (5 subgoals):\n 1. ?a < ?b1\n 2. \\<And>x. x \\<in> {?a..?b1} \\<Longrightarrow> ?g2.3 x \\<le> ?g1.2 x\n 3. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * ?a + x * ?b1,\n         (1 - y) * ?g2.3 ((1 - x) * ?a + x * ?b1) +\n         y * ?g1.2 ((1 - x) * ?a + x * ?b1)))\n 4. ?g1.2 piecewise_C1_differentiable_on {?a..?b1}\n 5. ?g2.3 piecewise_C1_differentiable_on {?a..?b1}", "show \"-d/2 < d/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - d / 2 < d / 2", "using assms"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. - d / 2 < d / 2", "by simp"], ["proof (state)\nthis:\n  - d / 2 < d / 2\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow> ?g2.3 x \\<le> ?g1.2 x\n 2. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * ?g2.3 ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * ?g1.2 ((1 - x) * (- d / 2) + x * (d / 2))))\n 3. ?g1.2 piecewise_C1_differentiable_on {- d / 2..d / 2}\n 4. ?g2.3 piecewise_C1_differentiable_on {- d / 2..d / 2}", "show \"(\\<lambda>x. d * sqrt (1/4 - (x/d) * (x/d))) piecewise_C1_differentiable_on {- d/2..d/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "using assms"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "unfolding piecewise_C1_differentiable_on_def"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. d * sqrt (1 / 4 - x / d * (x / d))) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>x.\n            d * sqrt (1 / 4 - x / d * (x / d))) C1_differentiable_on\n        {- d / 2..d / 2} - S)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. d * sqrt (1 / 4 - x / d * (x / d)))\n 2. 0 < d \\<Longrightarrow> finite ?S2\n 3. 0 < d \\<Longrightarrow>\n    (\\<lambda>x. d * sqrt (1 / 4 - x / d * (x / d))) C1_differentiable_on\n    {- d / 2..d / 2} - ?S2", "apply (rule ballI refl f01 derivative_intros continuous_intros | simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    (\\<lambda>x. 1 / 4 - x * x / (d * d)) `\n    ({- (d / 2)..d / 2} - {- (d / 2), d / 2})\n    \\<subseteq> {0<..}", "apply (auto simp: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<not> xa * (xa * 4) < d * d; xa * 2 \\<noteq> - d;\n        - d \\<le> xa * 2; xa * 2 \\<le> d\\<rbrakk>\n       \\<Longrightarrow> xa * 2 = d", "by sos"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n  {- d / 2..d / 2}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n       ?g2.3 x \\<le> d * sqrt (1 / 4 - x / d * (x / d))\n 2. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * ?g2.3 ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y *\n         (d *\n          sqrt\n           (1 / 4 -\n            ((1 - x) * (- d / 2) + x * (d / 2)) / d *\n            (((1 - x) * (- d / 2) + x * (d / 2)) / d)))))\n 3. ?g2.3 piecewise_C1_differentiable_on {- d / 2..d / 2}", "show \"(\\<lambda>x. -d * sqrt (1/4 - (x/d) * (x/d))) piecewise_C1_differentiable_on {- d/2..d/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        - d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "using assms"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        - d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "unfolding piecewise_C1_differentiable_on_def"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. - d * sqrt (1 / 4 - x / d * (x / d))) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>x.\n            - d * sqrt (1 / 4 - x / d * (x / d))) C1_differentiable_on\n        {- d / 2..d / 2} - S)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < d \\<Longrightarrow>\n    continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. - d * sqrt (1 / 4 - x / d * (x / d)))\n 2. 0 < d \\<Longrightarrow> finite ?S2\n 3. 0 < d \\<Longrightarrow>\n    (\\<lambda>x. - d * sqrt (1 / 4 - x / d * (x / d))) C1_differentiable_on\n    {- d / 2..d / 2} - ?S2", "apply (rule ballI refl f01 derivative_intros continuous_intros | simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d \\<Longrightarrow>\n    (\\<lambda>x. 1 / 4 - x * x / (d * d)) `\n    ({- (d / 2)..d / 2} - {- (d / 2), d / 2})\n    \\<subseteq> {0<..}", "apply (auto simp: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<not> xa * (xa * 4) < d * d; xa * 2 \\<noteq> - d;\n        - d \\<le> xa * 2; xa * 2 \\<le> d\\<rbrakk>\n       \\<Longrightarrow> xa * 2 = d", "by sos"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      - d * sqrt (1 / 4 - x / d * (x / d))) piecewise_C1_differentiable_on\n  {- d / 2..d / 2}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n       - d * sqrt (1 / 4 - x / d * (x / d))\n       \\<le> d * sqrt (1 / 4 - x / d * (x / d))\n 2. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) *\n         (- d *\n          sqrt\n           (1 / 4 -\n            ((1 - x) * (- d / 2) + x * (d / 2)) / d *\n            (((1 - x) * (- d / 2) + x * (d / 2)) / d))) +\n         y *\n         (d *\n          sqrt\n           (1 / 4 -\n            ((1 - x) * (- d / 2) + x * (d / 2)) / d *\n            (((1 - x) * (- d / 2) + x * (d / 2)) / d)))))", "show \"- d * sqrt (1/4 - x / d * (x / d)) \\<le> d * sqrt (1/4 - x / d * (x / d))\"\n    if \"x \\<in> {- d/2..d/2}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. - d * sqrt (1 / 4 - x / d * (x / d))\n    \\<le> d * sqrt (1 / 4 - x / d * (x / d))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - d * sqrt (1 / 4 - x / d * (x / d))\n    \\<le> d * sqrt (1 / 4 - x / d * (x / d))", "have *: \"x^2 \\<le> (d/2)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 \\<le> (d / 2)\\<^sup>2", "using real_sqrt_le_iff that"], ["proof (prove)\nusing this:\n  (sqrt ?x \\<le> sqrt ?y) = (?x \\<le> ?y)\n  x \\<in> {- d / 2..d / 2}\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 \\<le> (d / 2)\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  x\\<^sup>2 \\<le> (d / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. - d * sqrt (1 / 4 - x / d * (x / d))\n    \\<le> d * sqrt (1 / 4 - x / d * (x / d))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. - d * sqrt (1 / 4 - x / d * (x / d))\n    \\<le> d * sqrt (1 / 4 - x / d * (x / d))", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - d \\<le> d\n 2. 0 \\<le> sqrt (1 / 4 - x / d * (x / d))", "using assms *"], ["proof (prove)\nusing this:\n  0 < d\n  x\\<^sup>2 \\<le> (d / 2)\\<^sup>2\n\ngoal (2 subgoals):\n 1. - d \\<le> d\n 2. 0 \\<le> sqrt (1 / 4 - x / d * (x / d))", "apply (simp_all add: divide_simps power2_eq_square)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - d * sqrt (1 / 4 - x / d * (x / d))\n  \\<le> d * sqrt (1 / 4 - x / d * (x / d))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n  - d * sqrt (1 / 4 - ?x / d * (?x / d))\n  \\<le> d * sqrt (1 / 4 - ?x / d * (?x / d))\n\ngoal (1 subgoal):\n 1. circle_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) *\n         (- d *\n          sqrt\n           (1 / 4 -\n            ((1 - x) * (- d / 2) + x * (d / 2)) / d *\n            (((1 - x) * (- d / 2) + x * (d / 2)) / d))) +\n         y *\n         (d *\n          sqrt\n           (1 / 4 -\n            ((1 - x) * (- d / 2) + x * (d / 2)) / d *\n            (((1 - x) * (- d / 2) + x * (d / 2)) / d)))))", "qed (auto simp add: circle_cube_def divide_simps algebra_simps diff_divide_cancel)"], ["", "lemma rot_circle_cube_is_type_II:\n  shows \"typeII_twoCube rot_circle_cube\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeII_twoCube rot_circle_cube", "using d_gt_0 swap_typeI_is_typeII circle_cube_is_type_I"], ["proof (prove)\nusing this:\n  0 < d\n  typeI_twoCube ?C \\<Longrightarrow>\n  typeII_twoCube (prod.swap \\<circ> ?C \\<circ> prod.swap)\n  0 < d \\<Longrightarrow> typeI_twoCube circle_cube\n\ngoal (1 subgoal):\n 1. typeII_twoCube rot_circle_cube", "by (auto simp add: rot_circle_cube_def)"], ["", "definition circle_bot_edge where\n  \"circle_bot_edge = (1::int, \\<lambda>t. (x_coord t * d, - d * circle_y (x_coord t)))\""], ["", "definition circle_top_edge where\n  \"circle_top_edge = (- 1::int, \\<lambda>t. (x_coord t * d, d * circle_y (x_coord t)))\""], ["", "definition circle_right_edge where\n  \"circle_right_edge = (1::int, \\<lambda>y. (d/2, 0))\""], ["", "definition circle_left_edge where\n  \"circle_left_edge = (- 1::int, \\<lambda>y. (- (d/2), 0))\""], ["", "lemma circle_cube_boundary_explicit:\n    \"boundary circle_cube = {circle_left_edge,circle_right_edge,circle_bot_edge,circle_top_edge}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary circle_cube =\n    {circle_left_edge, circle_right_edge, circle_bot_edge, circle_top_edge}", "by (auto simp add: valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def circle_cube_def \n      circle_top_edge_def circle_bot_edge_def circle_cube_nice x_coord_def circle_y_def\n      circle_left_edge_def circle_right_edge_def)"], ["", "definition rot_circle_right_edge where\n  \"rot_circle_right_edge = (1::int, \\<lambda>t. (d * circle_y (x_coord t), x_coord t * d))\""], ["", "definition rot_circle_left_edge where\n  \"rot_circle_left_edge = (- 1::int, \\<lambda>t. (- d * circle_y (x_coord t), x_coord t * d))\""], ["", "definition rot_circle_top_edge where\n  \"rot_circle_top_edge = (- 1::int, \\<lambda>y. (0, d/2))\""], ["", "definition rot_circle_bot_edge where\n  \"rot_circle_bot_edge = (1::int, \\<lambda>y. (0, - (d/2)))\""], ["", "lemma rot_circle_cube_boundary_explicit:\n    \"boundary (rot_circle_cube) =\n           {rot_circle_top_edge,rot_circle_bot_edge,rot_circle_right_edge,rot_circle_left_edge}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary rot_circle_cube =\n    {rot_circle_top_edge, rot_circle_bot_edge, rot_circle_right_edge,\n     rot_circle_left_edge}", "by (auto simp add: rot_circle_cube_def valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def circle_cube_def\n      rot_circle_right_edge_def rot_circle_left_edge_def x_coord_def circle_y_def rot_circle_top_edge_def rot_circle_bot_edge_def)"], ["", "lemma rot_circle_cube_vertical_boundary_explicit:\n    \"vertical_boundary rot_circle_cube = {rot_circle_right_edge,rot_circle_left_edge}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_boundary rot_circle_cube =\n    {rot_circle_right_edge, rot_circle_left_edge}", "by (auto simp add: rot_circle_cube_def valid_two_cube_def vertical_boundary_def circle_cube_def\n      rot_circle_right_edge_def rot_circle_left_edge_def x_coord_def circle_y_def)"], ["", "lemma circ_left_edge_neq_top:\n   \"(- 1::int, \\<lambda>y::real. (- (d/2), 0)) \\<noteq> (- 1, \\<lambda>x. ((x - 1/2) * d, d * sqrt (1/4 - (x - 1/2) * (x - 1/2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1, \\<lambda>y. (- (d / 2), 0)) \\<noteq>\n    (- 1,\n     \\<lambda>x.\n        ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))", "by (metis (no_types, lifting) add_diff_cancel_right' d_gt_0 mult.commute mult_cancel_left order_less_irrefl prod.inject)"], ["", "lemma circle_cube_valid_two_cube: \"valid_two_cube (circle_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_cube circle_cube", "proof (auto simp add: valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def circle_cube_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n      (1, \\<lambda>x.\n             ((x - 1 / 2) * d,\n              - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n      (- 1,\n       \\<lambda>x.\n          ((x - 1 / 2) * d,\n           d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n    4", "have iv: \"(- 1::int, \\<lambda>y::real. (- (d/2), 0)) \\<noteq> (- 1, \\<lambda>x. ((x - 1/2) * d, d * sqrt (1/4 - (x - 1/2) * (x - 1/2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1, \\<lambda>y. (- (d / 2), 0)) \\<noteq>\n    (- 1,\n     \\<lambda>x.\n        ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (- 1, \\<lambda>y. (- (d / 2), 0)) \\<noteq>\n    (- 1,\n     \\<lambda>x.\n        ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d;\n     (\\<lambda>y. (- (d / 2), 0)) =\n     (\\<lambda>x. (x * d - d / 2, d * sqrt (x - x * x)))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (no_types, hide_lams) add_diff_cancel_right' add_uminus_conv_diff cancel_comm_monoid_add_class.diff_cancel less_eq_real_def linorder_not_le mult.left_neutral prod.simps(1))"], ["proof (state)\nthis:\n  (- 1, \\<lambda>y. (- (d / 2), 0)) \\<noteq>\n  (- 1,\n   \\<lambda>x.\n      ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))\n\ngoal (1 subgoal):\n 1. card\n     {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n      (1, \\<lambda>x.\n             ((x - 1 / 2) * d,\n              - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n      (- 1,\n       \\<lambda>x.\n          ((x - 1 / 2) * d,\n           d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n    4", "have v: \"(1::int, \\<lambda>y. (d/2, 0)) \\<noteq> (1, \\<lambda>x. ((x - 1/2) * d, - (d * sqrt (1/4 - (x - 1/2) * (x - 1/2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, \\<lambda>y. (d / 2, 0)) \\<noteq>\n    (1, \\<lambda>x.\n           ((x - 1 / 2) * d,\n            - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (1, \\<lambda>y. (d / 2, 0)) \\<noteq>\n    (1, \\<lambda>x.\n           ((x - 1 / 2) * d,\n            - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))))", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d;\n     (\\<lambda>y. (d / 2, 0)) =\n     (\\<lambda>x. (x * d - d / 2, - (d * sqrt (x - x * x))))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (no_types, hide_lams) diff_0 equal_neg_zero mult_zero_left nonzero_mult_div_cancel_left order_less_irrefl prod.sel(1) times_divide_eq_right zero_neq_numeral)"], ["proof (state)\nthis:\n  (1, \\<lambda>y. (d / 2, 0)) \\<noteq>\n  (1, \\<lambda>x.\n         ((x - 1 / 2) * d,\n          - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))))\n\ngoal (1 subgoal):\n 1. card\n     {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n      (1, \\<lambda>x.\n             ((x - 1 / 2) * d,\n              - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n      (- 1,\n       \\<lambda>x.\n          ((x - 1 / 2) * d,\n           d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n    4", "show \" card {(- 1::int, \\<lambda>y. (- (d/2), 0)), (1, \\<lambda>y. (d/2, 0)), (1, \\<lambda>x. ((x - 1/2) * d, - (d * sqrt (1/4 - (x - 1/2) * (x - 1/2))))),\n                   (- 1, \\<lambda>x. ((x - 1/2) * d, d * sqrt (1/4 - (x - 1/2) * (x - 1/2))))} = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n      (1, \\<lambda>x.\n             ((x - 1 / 2) * d,\n              - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n      (- 1,\n       \\<lambda>x.\n          ((x - 1 / 2) * d,\n           d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n    4", "using iv v"], ["proof (prove)\nusing this:\n  (- 1, \\<lambda>y. (- (d / 2), 0)) \\<noteq>\n  (- 1,\n   \\<lambda>x.\n      ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))\n  (1, \\<lambda>y. (d / 2, 0)) \\<noteq>\n  (1, \\<lambda>x.\n         ((x - 1 / 2) * d,\n          - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2)))))\n\ngoal (1 subgoal):\n 1. card\n     {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n      (1, \\<lambda>x.\n             ((x - 1 / 2) * d,\n              - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n      (- 1,\n       \\<lambda>x.\n          ((x - 1 / 2) * d,\n           d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n    4", "by auto"], ["proof (state)\nthis:\n  card\n   {(- 1, \\<lambda>y. (- (d / 2), 0)), (1, \\<lambda>y. (d / 2, 0)),\n    (1, \\<lambda>x.\n           ((x - 1 / 2) * d,\n            - (d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))),\n    (- 1,\n     \\<lambda>x.\n        ((x - 1 / 2) * d, d * sqrt (1 / 4 - (x - 1 / 2) * (x - 1 / 2))))} =\n  4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_circle_cube_valid_two_cube:\n  shows \"valid_two_cube rot_circle_cube\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_cube rot_circle_cube", "using valid_cube_valid_swap circle_cube_valid_two_cube d_gt_0 rot_circle_cube_def"], ["proof (prove)\nusing this:\n  valid_two_cube ?C \\<Longrightarrow>\n  valid_two_cube (prod.swap \\<circ> ?C \\<circ> prod.swap)\n  valid_two_cube circle_cube\n  0 < d\n  rot_circle_cube = prod.swap \\<circ> circle_cube \\<circ> prod.swap\n\ngoal (1 subgoal):\n 1. valid_two_cube rot_circle_cube", "by force"], ["", "definition circle_arc_0 where \"circle_arc_0 = (1, \\<lambda>t::real. (0,0))\""], ["", "lemma circle_top_bot_edges_neq' [simp]: \n  shows \"circle_top_edge \\<noteq> circle_bot_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_top_edge \\<noteq> circle_bot_edge", "by (simp add: circle_top_edge_def circle_bot_edge_def)"], ["", "lemma rot_circle_top_left_edges_neq [simp]: \"rot_circle_top_edge \\<noteq> rot_circle_left_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_top_edge \\<noteq> rot_circle_left_edge", "apply (simp add: rot_circle_left_edge_def rot_circle_top_edge_def x_coord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. (0, d / 2)) \\<noteq>\n    (\\<lambda>t. (- (d * circle_y (t - 1 / 2)), (t - 1 / 2) * d))", "by (metis (mono_tags, hide_lams) cancel_comm_monoid_add_class.diff_cancel d_gt_0 divide_eq_0_iff mult_zero_left order_less_irrefl prod.sel(2) zero_neq_numeral)"], ["", "lemma rot_circle_bot_left_edges_neq [simp]: \"rot_circle_bot_edge \\<noteq> rot_circle_left_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_bot_edge \\<noteq> rot_circle_left_edge", "by (simp add: rot_circle_left_edge_def rot_circle_bot_edge_def x_coord_def)"], ["", "lemma rot_circle_top_right_edges_neq [simp]: \"rot_circle_top_edge \\<noteq> rot_circle_right_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_top_edge \\<noteq> rot_circle_right_edge", "by (simp add: rot_circle_right_edge_def rot_circle_top_edge_def x_coord_def)"], ["", "lemma rot_circle_bot_right_edges_neq [simp]: \"rot_circle_bot_edge \\<noteq> rot_circle_right_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_bot_edge \\<noteq> rot_circle_right_edge", "apply (simp add: rot_circle_right_edge_def rot_circle_bot_edge_def x_coord_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. (0, - (d / 2))) \\<noteq>\n    (\\<lambda>t. (d * circle_y (t - 1 / 2), (t - 1 / 2) * d))", "by (metis (mono_tags, hide_lams) cancel_comm_monoid_add_class.diff_cancel d_gt_0 divide_eq_0_iff mult_zero_left neg_0_equal_iff_equal order_less_irrefl prod.sel(2) zero_neq_numeral)"], ["", "lemma rot_circle_right_top_edges_neq' [simp]: \"rot_circle_right_edge \\<noteq> rot_circle_left_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_right_edge \\<noteq> rot_circle_left_edge", "by (simp add: rot_circle_left_edge_def rot_circle_right_edge_def)"], ["", "lemma rot_circle_left_bot_edges_neq [simp]: \"rot_circle_left_edge \\<noteq> rot_circle_top_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_circle_left_edge \\<noteq> rot_circle_top_edge", "apply (simp add: rot_circle_top_edge_def rot_circle_left_edge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. (- (d * circle_y (x_coord t)), x_coord t * d)) \\<noteq>\n    (\\<lambda>y. (0, d / 2))", "by (metis (no_types, hide_lams) cancel_comm_monoid_add_class.diff_cancel d_gt_0 mult.commute mult_zero_right nonzero_mult_div_cancel_left order_less_irrefl prod.sel(2) times_divide_eq_right x_coord_def zero_neq_numeral)"], ["", "lemma circle_right_top_edges_neq [simp]: \"circle_right_edge \\<noteq> circle_top_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_top_edge", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_top_edge", "have \"circle_right_edge = (1, (\\<lambda>r::real. (d / 2, 0::real)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_right_edge = (1, \\<lambda>r. (d / 2, 0))", "using circle.circle_right_edge_def circle_axioms"], ["proof (prove)\nusing this:\n  circle ?i ?j ?d \\<Longrightarrow>\n  circle.circle_right_edge ?d = (1, \\<lambda>y. (?d / 2, 0::?'b))\n  circle i j d\n\ngoal (1 subgoal):\n 1. circle_right_edge = (1, \\<lambda>r. (d / 2, 0))", "by blast"], ["proof (state)\nthis:\n  circle_right_edge = (1, \\<lambda>r. (d / 2, 0))\n\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_top_edge", "then"], ["proof (chain)\npicking this:\n  circle_right_edge = (1, \\<lambda>r. (d / 2, 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  circle_right_edge = (1, \\<lambda>r. (d / 2, 0))\n\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_top_edge", "using circle.circle_top_edge_def circle_axioms"], ["proof (prove)\nusing this:\n  circle_right_edge = (1, \\<lambda>r. (d / 2, 0))\n  circle ?i ?j ?d \\<Longrightarrow>\n  circle.circle_top_edge ?d =\n  (- 1, \\<lambda>t. (x_coord t * ?d, ?d * circle_y (x_coord t)))\n  circle i j d\n\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_top_edge", "by auto"], ["proof (state)\nthis:\n  circle_right_edge \\<noteq> circle_top_edge\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_left_bot_edges_neq [simp]: \"circle_left_edge \\<noteq> circle_bot_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_bot_edge", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_bot_edge", "have \"circle_bot_edge = (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_bot_edge =\n    (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))", "using circle.circle_bot_edge_def circle_axioms"], ["proof (prove)\nusing this:\n  circle ?i ?j ?d \\<Longrightarrow>\n  circle.circle_bot_edge ?d =\n  (1, \\<lambda>t. (x_coord t * ?d, - ?d * circle_y (x_coord t)))\n  circle i j d\n\ngoal (1 subgoal):\n 1. circle_bot_edge =\n    (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))", "by blast"], ["proof (state)\nthis:\n  circle_bot_edge =\n  (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_bot_edge", "then"], ["proof (chain)\npicking this:\n  circle_bot_edge =\n  (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))", "show ?thesis"], ["proof (prove)\nusing this:\n  circle_bot_edge =\n  (1, \\<lambda>r. (x_coord r * d, - d * circle_y (x_coord r)))\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_bot_edge", "by (simp add: circle_left_edge_def)"], ["proof (state)\nthis:\n  circle_left_edge \\<noteq> circle_bot_edge\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_left_top_edges_neq [simp]: \"circle_left_edge \\<noteq> circle_top_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "have \"\\<exists>r. ((r - 1 / 2) * d, d * sqrt (1 / 4 - (r - 1 / 2) * (r - 1 / 2))) \\<noteq> (- (d / 2), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       ((r - 1 / 2) * d,\n        d * sqrt (1 / 4 - (r - 1 / 2) * (r - 1 / 2))) \\<noteq>\n       (- (d / 2), 0)", "by (metis circ_left_edge_neq_top)"], ["proof (state)\nthis:\n  \\<exists>r.\n     ((r - 1 / 2) * d,\n      d * sqrt (1 / 4 - (r - 1 / 2) * (r - 1 / 2))) \\<noteq>\n     (- (d / 2), 0)\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     ((r - 1 / 2) * d,\n      d * sqrt (1 / 4 - (r - 1 / 2) * (r - 1 / 2))) \\<noteq>\n     (- (d / 2), 0)", "have \"(\\<exists>r. d * r \\<noteq> - (d / 2)) \\<or> (\\<exists>r ra. (x_coord (x_coord_inv r) * d, d * circle_y (x_coord (x_coord_inv r))) = (x_coord ra * d, d * circle_y (x_coord ra)) \\<and> d * circle_y r \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     ((r - 1 / 2) * d,\n      d * sqrt (1 / 4 - (r - 1 / 2) * (r - 1 / 2))) \\<noteq>\n     (- (d / 2), 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>r. d * r \\<noteq> - (d / 2)) \\<or>\n    (\\<exists>r ra.\n        (x_coord (x_coord_inv r) * d,\n         d * circle_y (x_coord (x_coord_inv r))) =\n        (x_coord ra * d, d * circle_y (x_coord ra)) \\<and>\n        d * circle_y r \\<noteq> 0)", "by (metis mult.commute)"], ["proof (state)\nthis:\n  (\\<exists>r. d * r \\<noteq> - (d / 2)) \\<or>\n  (\\<exists>r ra.\n      (x_coord (x_coord_inv r) * d,\n       d * circle_y (x_coord (x_coord_inv r))) =\n      (x_coord ra * d, d * circle_y (x_coord ra)) \\<and>\n      d * circle_y r \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "then"], ["proof (chain)\npicking this:\n  (\\<exists>r. d * r \\<noteq> - (d / 2)) \\<or>\n  (\\<exists>r ra.\n      (x_coord (x_coord_inv r) * d,\n       d * circle_y (x_coord (x_coord_inv r))) =\n      (x_coord ra * d, d * circle_y (x_coord ra)) \\<and>\n      d * circle_y r \\<noteq> 0)", "have \"(\\<lambda>r. (x_coord r * d, d * circle_y (x_coord r))) \\<noteq> (\\<lambda>r. (- (d / 2), 0))\""], ["proof (prove)\nusing this:\n  (\\<exists>r. d * r \\<noteq> - (d / 2)) \\<or>\n  (\\<exists>r ra.\n      (x_coord (x_coord_inv r) * d,\n       d * circle_y (x_coord (x_coord_inv r))) =\n      (x_coord ra * d, d * circle_y (x_coord ra)) \\<and>\n      d * circle_y r \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>r. (x_coord r * d, d * circle_y (x_coord r))) \\<noteq>\n    (\\<lambda>r. (- (d / 2), 0))", "by (metis mult.commute prod.simps(1) x_coord_inv_2)"], ["proof (state)\nthis:\n  (\\<lambda>r. (x_coord r * d, d * circle_y (x_coord r))) \\<noteq>\n  (\\<lambda>r. (- (d / 2), 0))\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>r. (x_coord r * d, d * circle_y (x_coord r))) \\<noteq>\n  (\\<lambda>r. (- (d / 2), 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>r. (x_coord r * d, d * circle_y (x_coord r))) \\<noteq>\n  (\\<lambda>r. (- (d / 2), 0))\n\ngoal (1 subgoal):\n 1. circle_left_edge \\<noteq> circle_top_edge", "by (simp add: circle_left_edge_def circle_top_edge_def)"], ["proof (state)\nthis:\n  circle_left_edge \\<noteq> circle_top_edge\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_right_bot_edges_neq [simp]: \"circle_right_edge \\<noteq> circle_bot_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_right_edge \\<noteq> circle_bot_edge", "by (smt Pair_inject circle_bot_edge_def d_gt_0 circle.circle_right_edge_def circle_axioms mult_le_cancel_iff1 x_coord_def)"], ["", "definition circle_polar where\n  \"circle_polar t = ((d/2)  * cos (2 * pi * t), (d/2) * sin (2 * pi * t))\""], ["", "lemma circle_polar_smooth: \"(circle_polar) C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "have \"inj ((*) (2 * pi))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*) (2 * pi))", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj ((*) (2 * pi))\n\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "then"], ["proof (chain)\npicking this:\n  inj ((*) (2 * pi))", "have *: \"\\<And>x. finite ({0..1} \\<inter> (*) (2 * pi) -` {x})\""], ["proof (prove)\nusing this:\n  inj ((*) (2 * pi))\n\ngoal (1 subgoal):\n 1. \\<And>x. finite ({0..1} \\<inter> (*) (2 * pi) -` {x})", "by (simp add: finite_vimageI)"], ["proof (state)\nthis:\n  finite ({0..1} \\<inter> (*) (2 * pi) -` {?x4})\n\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "have \"(\\<lambda>t. ((d/2)  * cos (2 * pi * t), (d/2) * sin (2 * pi * t))) C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        (d / 2 * cos (2 * pi * t),\n         d / 2 * sin (2 * pi * t))) C1_differentiable_on\n    {0..1}", "by (rule * derivative_intros)+"], ["proof (state)\nthis:\n  (\\<lambda>t.\n      (d / 2 * cos (2 * pi * t),\n       d / 2 * sin (2 * pi * t))) C1_differentiable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>t.\n      (d / 2 * cos (2 * pi * t),\n       d / 2 * sin (2 * pi * t))) C1_differentiable_on\n  {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>t.\n      (d / 2 * cos (2 * pi * t),\n       d / 2 * sin (2 * pi * t))) C1_differentiable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. circle_polar C1_differentiable_on {0..1}", "apply (rule eq_smooth_gen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (d / 2 * cos (2 * pi * x), d / 2 * sin (2 * pi * x)) = circle_polar x", "by(simp add: circle_polar_def)"], ["proof (state)\nthis:\n  circle_polar C1_differentiable_on {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"custom_arccos \\<equiv> (\\<lambda>x. (if -1 \\<le> x \\<and> x \\<le> 1 then arccos x else (if x < -1 then -x + pi else 1 -x )))\""], ["", "lemma cont_custom_arccos: \n  assumes \"S \\<subseteq> {-1..1}\"\n  shows \"continuous_on S custom_arccos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on S\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on S\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "have \"continuous_on ({-1..1} \\<union> {}) custom_arccos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({- 1..1} \\<union> {})\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "by (auto intro!: continuous_on_cases continuous_intros)"], ["proof (state)\nthis:\n  continuous_on ({- 1..1} \\<union> {})\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)\n\ngoal (1 subgoal):\n 1. continuous_on S\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "with assms"], ["proof (chain)\npicking this:\n  S \\<subseteq> {- 1..1}\n  continuous_on ({- 1..1} \\<union> {})\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<subseteq> {- 1..1}\n  continuous_on ({- 1..1} \\<union> {})\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)\n\ngoal (1 subgoal):\n 1. continuous_on S\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "using continuous_on_subset"], ["proof (prove)\nusing this:\n  S \\<subseteq> {- 1..1}\n  continuous_on ({- 1..1} \\<union> {})\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)\n  \\<lbrakk>continuous_on ?s ?f; ?t \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?t ?f\n\ngoal (1 subgoal):\n 1. continuous_on S\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)", "by auto"], ["proof (state)\nthis:\n  continuous_on S\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma custom_arccos_has_deriv: \n  assumes \"- 1 < x\" \"x < 1\"\n  shows \"DERIV custom_arccos x :> inverse (- sqrt (1 - x\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) has_real_derivative\n     inverse (- sqrt (1 - x\\<^sup>2)))\n     (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) has_real_derivative\n     inverse (- sqrt (1 - x\\<^sup>2)))\n     (at x)", "have x1: \"\\<bar>x\\<bar>\\<^sup>2 < 1\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\\<^sup>2 < 1\\<^sup>2", "by (simp add: abs_less_iff abs_square_less_1 assms)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\\<^sup>2 < 1\\<^sup>2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) has_real_derivative\n     inverse (- sqrt (1 - x\\<^sup>2)))\n     (at x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) has_real_derivative\n     inverse (- sqrt (1 - x\\<^sup>2)))\n     (at x)", "apply (rule DERIV_inverse_function [where f=cos and a=\"-1\" and b=1])"], ["proof (prove)\ngoal (6 subgoals):\n 1. (cos has_real_derivative - sqrt (1 - x\\<^sup>2))\n     (at (if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x))\n 2. - sqrt (1 - x\\<^sup>2) \\<noteq> 0\n 3. - 1 < x\n 4. x < 1\n 5. \\<And>y.\n       \\<lbrakk>- 1 < y; y < 1\\<rbrakk>\n       \\<Longrightarrow> cos (if - 1 \\<le> y \\<and> y \\<le> 1 then arccos y\n                              else if y < - 1 then - y + pi else 1 - y) =\n                         y\n 6. isCont\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)\n     x", "apply (rule x1 derivative_eq_intros | simp add: sin_arccos)+"], ["proof (prove)\ngoal (6 subgoals):\n 1. (x < - 1 \\<longrightarrow> sin x = sqrt (1 - x\\<^sup>2)) \\<and>\n    (\\<not> x < - 1 \\<longrightarrow>\n     \\<not> x \\<le> 1 \\<longrightarrow> sin (1 - x) = sqrt (1 - x\\<^sup>2))\n 2. - sqrt (1 - x\\<^sup>2) \\<noteq> 0\n 3. - 1 < x\n 4. x < 1\n 5. \\<And>y.\n       \\<lbrakk>- 1 < y; y < 1\\<rbrakk>\n       \\<Longrightarrow> cos (if - 1 \\<le> y \\<and> y \\<le> 1 then arccos y\n                              else if y < - 1 then - y + pi else 1 - y) =\n                         y\n 6. isCont\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)\n     x", "using assms x1 cont_custom_arccos [of \"{-1<..<1}\"]"], ["proof (prove)\nusing this:\n  - 1 < x\n  x < 1\n  \\<bar>x\\<bar>\\<^sup>2 < 1\\<^sup>2\n  {- 1<..<1} \\<subseteq> {- 1..1} \\<Longrightarrow>\n  continuous_on {- 1<..<1}\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x)\n\ngoal (6 subgoals):\n 1. (x < - 1 \\<longrightarrow> sin x = sqrt (1 - x\\<^sup>2)) \\<and>\n    (\\<not> x < - 1 \\<longrightarrow>\n     \\<not> x \\<le> 1 \\<longrightarrow> sin (1 - x) = sqrt (1 - x\\<^sup>2))\n 2. - sqrt (1 - x\\<^sup>2) \\<noteq> 0\n 3. - 1 < x\n 4. x < 1\n 5. \\<And>y.\n       \\<lbrakk>- 1 < y; y < 1\\<rbrakk>\n       \\<Longrightarrow> cos (if - 1 \\<le> y \\<and> y \\<le> 1 then arccos y\n                              else if y < - 1 then - y + pi else 1 - y) =\n                         y\n 6. isCont\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x)\n     x", "apply (auto simp: continuous_on_eq_continuous_at greaterThanLessThan_subseteq_atLeastAtMost_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) has_real_derivative\n   inverse (- sqrt (1 - x\\<^sup>2)))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare \n  custom_arccos_has_deriv[THEN DERIV_chain2, derivative_intros]\n  custom_arccos_has_deriv[THEN DERIV_chain2, unfolded has_field_derivative_def, derivative_intros]"], ["", "lemma circle_boundary_reparams:\n  shows rot_circ_left_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(rot_circle_left_edge)]) (rec_join [(subcube (1/4) (1/2) (1, circle_polar)), (subcube (1/2) (3/4) (1, circle_polar))])\"\n    (is ?P1)\n    and circ_top_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(circle_top_edge)]) (rec_join [(subcube 0 (1/4) (1, circle_polar)), (subcube (1/4) (1/2) (1, circle_polar))])\"\n    (is ?P2)\n    and circ_bot_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(circle_bot_edge)]) (rec_join [(subcube (1/2) (3/4) (1, circle_polar)), (subcube (3/4) 1 (1, circle_polar))])\"\n    (is ?P3)\n    and rot_circ_right_edge_reparam_polar_circ_split:\n    \"reparam (rec_join [(rot_circle_right_edge)]) (rec_join [(subcube (3/4) 1 (1, circle_polar)), (subcube 0 (1/4) (1, circle_polar))])\"\n    (is ?P4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (reparam (rec_join [rot_circle_left_edge])\n      (rec_join\n        [subcube (1 / 4) (1 / 2) (1, circle_polar),\n         subcube (1 / 2) (3 / 4) (1, circle_polar)]) &&&\n     reparam (rec_join [circle_top_edge])\n      (rec_join\n        [subcube 0 (1 / 4) (1, circle_polar),\n         subcube (1 / 4) (1 / 2) (1, circle_polar)])) &&&\n    reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)]) &&&\n    reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?\\<phi> = \"((*) (1/pi) \\<circ> custom_arccos \\<circ> (\\<lambda>t. 2 * x_coord (1 - t)))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?LHS1 = \"(\\<lambda>x. (- (d * sqrt (1/4 - x_coord (1 - x) * x_coord (1 - x))), x_coord (1 - x) * d))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?RHS1 = \"((\\<lambda>x. if x * 2 \\<le> 1 then (d * cos (2 * pi * (2 * x/4 + 1/4))/2, d * sin (2 * pi * (2 * x/4 + 1/4))/2)\n                        else (d * cos (2 * pi * ((2 * x - 1)/4 + 1/2))/2, d * sin (2 * pi * ((2 * x - 1)/4 + 1/2))/2)) \\<circ> ?\\<phi>)\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?LHS2 = \"\\<lambda>x. ((x_coord (1 - x) * d, d * sqrt (1/4 - x_coord (1 - x) * x_coord (1 - x))))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?RHS2 = \"((\\<lambda>x. if x * 2 \\<le> 1 then (d * cos (2 * x * pi/2)/2, d * sin (2 * x * pi/2)/2) else (d * cos (2 * pi * ((2 * x - 1)/4 + 1/4))/2, d * sin (2 * pi * ((2 * x - 1)/4 + 1/4))/2)) \\<circ> ?\\<phi>)\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?LHS3 = \"\\<lambda>x. (x_coord x * d, - (d * sqrt (1/4 - x_coord x * x_coord x)))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?RHS3 = \"(\\<lambda>x. if x * 2 \\<le> 1 then (d * cos (2 * pi * (2 * x/4 + 1/2))/2, d * sin (2 * pi * (2 * x/4 + 1/2))/2) \n                  else (d * cos (2 * pi * ((2 * x - 1)/4 + 3/4))/2, d * sin (2 * pi * ((2 * x - 1)/4 + 3/4))/2))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?LHS4 = \"\\<lambda>x. (d * sqrt (1/4 - x_coord x * x_coord x), x_coord x * d)\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "let ?RHS4 = \"(\\<lambda>x. if x * 2 \\<le> 1 then (d * cos (2 * pi * (2 * x/4 + 3/4))/2, d * sin (2 * pi * (2 * x/4 + 3/4))/2) \n                 else (d * cos ((2 * x - 1) * pi/2)/2, d * sin ((2 * x - 1) * pi/2)/2))\""], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have phi_diff: \"?\\<phi> piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t)) piecewise_C1_differentiable_on\n    {0..1}", "unfolding piecewise_C1_differentiable_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (*) (1 / pi) \\<circ>\n        (\\<lambda>x.\n            if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n            else if x < - 1 then - x + pi else 1 - x) \\<circ>\n        (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n        {0..1} - S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous_on {0..1}\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t)))\n 2. \\<exists>S.\n       finite S \\<and>\n       (*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n       {0..1} - S", "show \"continuous_on {0..1} ?\\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t)))", "unfolding x_coord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * (1 - t - 1 / 2)))", "by (intro continuous_on_compose cont_custom_arccos continuous_intros) auto"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t)))\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n       {0..1} - S", "have \"?\\<phi> C1_differentiable_on {0..1} - {0,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n    {0..1} - {0, 1}", "unfolding x_coord_def piecewise_C1_differentiable_on_def C1_differentiable_on_def valid_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D.\n       (\\<forall>x\\<in>{0..1} - {0, 1}.\n           ((*) (1 / pi) \\<circ>\n            (\\<lambda>x.\n                if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                else if x < - 1 then - x + pi else 1 - x) \\<circ>\n            (\\<lambda>t. 2 * (1 - t - 1 / 2)) has_vector_derivative\n            D x)\n            (at x)) \\<and>\n       continuous_on ({0..1} - {0, 1}) D", "by (simp | rule has_vector_derivative_pair_within DERIV_image_chain derivative_eq_intros continuous_intros exI ballI conjI \n          | force simp add: field_simps | sos)+"], ["proof (state)\nthis:\n  (*) (1 / pi) \\<circ>\n  (\\<lambda>x.\n      if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n      else if x < - 1 then - x + pi else 1 - x) \\<circ>\n  (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n  {0..1} - {0, 1}\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n       {0..1} - S", "then"], ["proof (chain)\npicking this:\n  (*) (1 / pi) \\<circ>\n  (\\<lambda>x.\n      if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n      else if x < - 1 then - x + pi else 1 - x) \\<circ>\n  (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n  {0..1} - {0, 1}", "show \"\\<exists>s. finite s \\<and> ?\\<phi> C1_differentiable_on {0..1} - s\""], ["proof (prove)\nusing this:\n  (*) (1 / pi) \\<circ>\n  (\\<lambda>x.\n      if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n      else if x < - 1 then - x + pi else 1 - x) \\<circ>\n  (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n  {0..1} - {0, 1}\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       finite s \\<and>\n       (*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n       {0..1} - s", "by force"], ["proof (state)\nthis:\n  \\<exists>s.\n     finite s \\<and>\n     (*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t)) C1_differentiable_on\n     {0..1} - s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (*) (1 / pi) \\<circ>\n  (\\<lambda>x.\n      if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n      else if x < - 1 then - x + pi else 1 - x) \\<circ>\n  (\\<lambda>t. 2 * x_coord (1 - t)) piecewise_C1_differentiable_on\n  {0..1}\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have inj: \"inj ?\\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*) (1 / pi) \\<circ>\n         (\\<lambda>x.\n             if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n             else if x < - 1 then - x + pi else 1 - x) \\<circ>\n         (\\<lambda>t. 2 * x_coord (1 - t)))", "apply (intro comp_inj_on inj_on_cases inj_on_arccos)"], ["proof (prove)\ngoal (7 subgoals):\n 1. inj (\\<lambda>t. 2 * x_coord (1 - t))\n 2. {x. - 1 \\<le> x \\<and> x \\<le> 1} \\<inter>\n    range (\\<lambda>t. 2 * x_coord (1 - t))\n    \\<subseteq> {- 1..1}\n 3. inj_on (\\<lambda>x. - x + pi)\n     ({x. x < - 1} \\<inter>\n      (Collect\n        (Not \\<circ> (\\<lambda>x. - 1 \\<le> x \\<and> x \\<le> 1)) \\<inter>\n       range (\\<lambda>t. 2 * x_coord (1 - t))))\n 4. inj_on ((-) 1)\n     (Collect (Not \\<circ> (\\<lambda>x. x < - 1)) \\<inter>\n      (Collect\n        (Not \\<circ> (\\<lambda>x. - 1 \\<le> x \\<and> x \\<le> 1)) \\<inter>\n       range (\\<lambda>t. 2 * x_coord (1 - t))))\n 5. (\\<lambda>x. - x + pi) `\n    ({x. x < - 1} \\<inter>\n     (Collect\n       (Not \\<circ> (\\<lambda>x. - 1 \\<le> x \\<and> x \\<le> 1)) \\<inter>\n      range (\\<lambda>t. 2 * x_coord (1 - t)))) \\<inter>\n    (-) 1 `\n    (Collect (Not \\<circ> (\\<lambda>x. x < - 1)) \\<inter>\n     (Collect\n       (Not \\<circ> (\\<lambda>x. - 1 \\<le> x \\<and> x \\<le> 1)) \\<inter>\n      range (\\<lambda>t. 2 * x_coord (1 - t)))) =\n    {}\n 6. arccos `\n    ({x. - 1 \\<le> x \\<and> x \\<le> 1} \\<inter>\n     range (\\<lambda>t. 2 * x_coord (1 - t))) \\<inter>\n    (\\<lambda>x. if x < - 1 then - x + pi else 1 - x) `\n    (Collect\n      (Not \\<circ> (\\<lambda>x. - 1 \\<le> x \\<and> x \\<le> 1)) \\<inter>\n     range (\\<lambda>t. 2 * x_coord (1 - t))) =\n    {}\n 7. inj_on ((*) (1 / pi))\n     ((\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) `\n      range (\\<lambda>t. 2 * x_coord (1 - t)))", "apply (auto simp add: inj_on_def x_coord_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xc xd.\n       \\<lbrakk>pi - (1 - 2 * xc) = 2 * xd; 1 < xc;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb;\n        arccos (1 - 2 * xb) = pi - (1 - 2 * xd); 1 < xd\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb; arccos (1 - 2 * xb) = 2 * xd;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False", "using pi_ge_zero"], ["proof (prove)\nusing this:\n  0 \\<le> pi\n\ngoal (3 subgoals):\n 1. \\<And>xc xd.\n       \\<lbrakk>pi - (1 - 2 * xc) = 2 * xd; 1 < xc;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb;\n        arccos (1 - 2 * xb) = pi - (1 - 2 * xd); 1 < xd\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb; arccos (1 - 2 * xb) = 2 * xd;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb;\n        arccos (1 - 2 * xb) = pi - (1 - 2 * xd); 1 < xd\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb; arccos (1 - 2 * xb) = 2 * xd;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False", "apply (smt arccos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb xd.\n       \\<lbrakk>xb \\<le> 1; 0 \\<le> xb; arccos (1 - 2 * xb) = 2 * xd;\n        \\<not> 0 \\<le> xd\\<rbrakk>\n       \\<Longrightarrow> False", "by (smt arccos_lbound)"], ["proof (state)\nthis:\n  inj ((*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "then"], ["proof (chain)\npicking this:\n  inj ((*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)))", "have fin: \"\\<And>x. \\<lbrakk>0 \\<le> x; x \\<le> 1\\<rbrakk> \\<Longrightarrow> finite (?\\<phi> -` {x})\""], ["proof (prove)\nusing this:\n  inj ((*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (((*) (1 / pi) \\<circ>\n                            (\\<lambda>x.\n                                if - 1 \\<le> x \\<and> x \\<le> 1\n                                then arccos x\n                                else if x < - 1 then - x + pi\n                                     else 1 - x) \\<circ>\n                            (\\<lambda>t. 2 * x_coord (1 - t))) -`\n                           {x})", "by (simp add: finite_vimageI)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x4; ?x4 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (((*) (1 / pi) \\<circ>\n                       (\\<lambda>x.\n                           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                       (\\<lambda>t. 2 * x_coord (1 - t))) -`\n                      {?x4})\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"?\\<phi> ` {0..1} = {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) `\n    {0..1} =\n    {0..1}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) `\n    {0..1}\n    \\<subseteq> {0..1}\n 2. {0..1}\n    \\<subseteq> ((*) (1 / pi) \\<circ>\n                 (\\<lambda>x.\n                     if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                     else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                 (\\<lambda>t. 2 * x_coord (1 - t))) `\n                {0..1}", "show \"?\\<phi> ` {0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) `\n    {0..1}\n    \\<subseteq> {0..1}", "by (auto simp add: x_coord_def divide_simps arccos_lbound arccos_bounded)"], ["proof (state)\nthis:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1}\n  \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. {0..1}\n    \\<subseteq> ((*) (1 / pi) \\<circ>\n                 (\\<lambda>x.\n                     if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                     else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                 (\\<lambda>t. 2 * x_coord (1 - t))) `\n                {0..1}", "have \"arccos (1 - 2 * ((1 - cos (x * pi))/2)) = x * pi\" if \"0 \\<le> x\" \"x \\<le> 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. arccos (1 - 2 * ((1 - cos (x * pi)) / 2)) = x * pi", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. arccos (1 - 2 * ((1 - cos (x * pi)) / 2)) = x * pi", "by (simp add: field_simps arccos_cos)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x4; ?x4 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> arccos (1 - 2 * ((1 - cos (?x4 * pi)) / 2)) = ?x4 * pi\n\ngoal (1 subgoal):\n 1. {0..1}\n    \\<subseteq> ((*) (1 / pi) \\<circ>\n                 (\\<lambda>x.\n                     if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                     else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                 (\\<lambda>t. 2 * x_coord (1 - t))) `\n                {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?x4; ?x4 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> arccos (1 - 2 * ((1 - cos (?x4 * pi)) / 2)) = ?x4 * pi", "show \"{0..1} \\<subseteq> ?\\<phi> ` {0..1}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x4; ?x4 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> arccos (1 - 2 * ((1 - cos (?x4 * pi)) / 2)) = ?x4 * pi\n\ngoal (1 subgoal):\n 1. {0..1}\n    \\<subseteq> ((*) (1 / pi) \\<circ>\n                 (\\<lambda>x.\n                     if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                     else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                 (\\<lambda>t. 2 * x_coord (1 - t))) `\n                {0..1}", "apply (auto simp: x_coord_def o_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 \\<le> x; x \\<le> 1\\<rbrakk>\n                   \\<Longrightarrow> arccos\n(1 - (2 - 2 * cos (x * pi)) / 2) =\n                                     x * pi;\n        0 \\<le> x; x \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>{0..1}.\n                            x = arccos (1 - 2 * xa) / pi", "by (rule_tac x=\"(1 - cos (x * pi))/2\" in bexI) auto"], ["proof (state)\nthis:\n  {0..1}\n  \\<subseteq> ((*) (1 / pi) \\<circ>\n               (\\<lambda>x.\n                   if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                   else if x < - 1 then - x + pi else 1 - x) \\<circ>\n               (\\<lambda>t. 2 * x_coord (1 - t))) `\n              {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1} =\n  {0..1}\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "then"], ["proof (chain)\npicking this:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1} =\n  {0..1}", "have bij_phi: \"bij_betw ?\\<phi> {0..1} {0..1}\""], ["proof (prove)\nusing this:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1} =\n  {0..1}\n\ngoal (1 subgoal):\n 1. bij_betw\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t)))\n     {0..1} {0..1}", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1} =\n  {0..1}\n\ngoal (1 subgoal):\n 1. inj_on\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t)))\n     {0..1} \\<and>\n    ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) `\n    {0..1} =\n    {0..1}", "using inj inj_on_subset"], ["proof (prove)\nusing this:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) `\n  {0..1} =\n  {0..1}\n  inj ((*) (1 / pi) \\<circ>\n       (\\<lambda>x.\n           if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n           else if x < - 1 then - x + pi else 1 - x) \\<circ>\n       (\\<lambda>t. 2 * x_coord (1 - t)))\n  \\<lbrakk>inj_on ?f ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?B\n\ngoal (1 subgoal):\n 1. inj_on\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t)))\n     {0..1} \\<and>\n    ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) `\n    {0..1} =\n    {0..1}", "by blast"], ["proof (state)\nthis:\n  bij_betw\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t)))\n   {0..1} {0..1}\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have phi01: \"?\\<phi> -` {0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((*) (1 / pi) \\<circ>\n     (\\<lambda>x.\n         if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n         else if x < - 1 then - x + pi else 1 - x) \\<circ>\n     (\\<lambda>t. 2 * x_coord (1 - t))) -`\n    {0..1}\n    \\<subseteq> {0..1}", "by (auto simp add: subset_iff x_coord_def divide_simps)"], ["proof (state)\nthis:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) -`\n  {0..1}\n  \\<subseteq> {0..1}\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "{"], ["proof (state)\nthis:\n  ((*) (1 / pi) \\<circ>\n   (\\<lambda>x.\n       if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n       else if x < - 1 then - x + pi else 1 - x) \\<circ>\n   (\\<lambda>t. 2 * x_coord (1 - t))) -`\n  {0..1}\n  \\<subseteq> {0..1}\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "fix x::real"], ["proof (state)\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "assume x: \"0 \\<le> x\" \"x \\<le> 1\""], ["proof (state)\nthis:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x \\<le> 1", "have i: \"- 1 \\<le> (2 * x - 1)\" \"(2 * x - 1) \\<le> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. - 1 \\<le> 2 * x - 1 &&& 2 * x - 1 \\<le> 1", "by auto"], ["proof (state)\nthis:\n  - 1 \\<le> 2 * x - 1\n  2 * x - 1 \\<le> 1\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have ii: \"cos (pi / 2 + arccos (1 - x * 2)) = -sin (arccos (1 - x * 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (pi / 2 + arccos (1 - x * 2)) = - sin (arccos (1 - x * 2))", "using minus_sin_cos_eq[symmetric, where ?x = \"arccos (1 - x * 2)\"]"], ["proof (prove)\nusing this:\n  cos (arccos (1 - x * 2) + of_real pi / 2) = - sin (arccos (1 - x * 2))\n\ngoal (1 subgoal):\n 1. cos (pi / 2 + arccos (1 - x * 2)) = - sin (arccos (1 - x * 2))", "by (auto simp add: add.commute)"], ["proof (state)\nthis:\n  cos (pi / 2 + arccos (1 - x * 2)) = - sin (arccos (1 - x * 2))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"2 * sqrt (x - x * x) = sqrt (4*x - 4*x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sqrt (x - x * x) = sqrt (4 * x - 4 * x * x)", "by (metis mult.assoc real_sqrt_four real_sqrt_mult right_diff_distrib)"], ["proof (state)\nthis:\n  2 * sqrt (x - x * x) = sqrt (4 * x - 4 * x * x)\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "also"], ["proof (state)\nthis:\n  2 * sqrt (x - x * x) = sqrt (4 * x - 4 * x * x)\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"... = sqrt (1  - (2 * x - 1) * (2 * x - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (4 * x - 4 * x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  sqrt (4 * x - 4 * x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "finally"], ["proof (chain)\npicking this:\n  2 * sqrt (x - x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))", "have iii: \"2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and> 2 * sqrt (x - x * x) =  sin (arccos (1 - 2 * x))\""], ["proof (prove)\nusing this:\n  2 * sqrt (x - x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))\n\ngoal (1 subgoal):\n 1. 2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n    2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))", "using arccos_minus[OF i]"], ["proof (prove)\nusing this:\n  2 * sqrt (x - x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))\n  arccos (- (2 * x - 1)) = pi - arccos (2 * x - 1)\n\ngoal (1 subgoal):\n 1. 2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n    2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))", "unfolding minus_diff_eq sin_pi_minus"], ["proof (prove)\nusing this:\n  2 * sqrt (x - x * x) = sqrt (1 - (2 * x - 1) * (2 * x - 1))\n  arccos (1 - 2 * x) = pi - arccos (2 * x - 1)\n\ngoal (1 subgoal):\n 1. 2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n    2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))", "by (simp add: cos_arcsin i power2_eq_square sin_arccos)"], ["proof (state)\nthis:\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "then"], ["proof (chain)\npicking this:\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))", "have 1: \"?LHS1 x = ?RHS1 x\""], ["proof (prove)\nusing this:\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))\n\ngoal (1 subgoal):\n 1. (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n     x_coord (1 - x) * d) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "using d_gt_0 i x"], ["proof (prove)\nusing this:\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))\n  0 < d\n  - 1 \\<le> 2 * x - 1\n  2 * x - 1 \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n     x_coord (1 - x) * d) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "apply (simp add: x_coord_def field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1)) \\<and>\n             2 * sqrt (x - x * x) = sin (arccos (1 - x * 2));\n     0 < d; 0 \\<le> x; x \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> - (d * (2 * sqrt ((x * 4 - x * (x * 4)) / 4))) =\n                      d *\n                      cos ((pi * (pi * 2) +\n                            pi * (4 * arccos ((2 - x * 4) / 2))) /\n                           (pi * 4)) \\<and>\n                      d * 2 =\n                      d * (x * 4) +\n                      d *\n                      (2 *\n                       sin ((pi * (pi * 2) +\n                             pi * (4 * arccos ((2 - x * 4) / 2))) /\n                            (pi * 4)))", "apply (auto simp add: diff_divide_distrib add_divide_distrib right_diff_distrib mult.commute ii)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1))\\<rbrakk>\n    \\<Longrightarrow> d * 2 =\n                      d * (x * 4) +\n                      d * (2 * sin (pi / 2 + arccos (1 - x * 2)))", "using cos_sin_eq[where ?x = \"- arccos (1 - x * 2)\"]"], ["proof (prove)\nusing this:\n  cos (- arccos (1 - x * 2)) = sin (of_real pi / 2 - - arccos (1 - x * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1))\\<rbrakk>\n    \\<Longrightarrow> d * 2 =\n                      d * (x * 4) +\n                      d * (2 * sin (pi / 2 + arccos (1 - x * 2)))", "by (simp add: cos_sin_eq[where ?x = \"- arccos (1 - x * 2)\"] right_diff_distrib)"], ["proof (state)\nthis:\n  (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n   x_coord (1 - x) * d) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have 2: \"?LHS2 x = ?RHS2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_coord (1 - x) * d,\n     d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * x * pi / 2) / 2, d * sin (2 * x * pi / 2) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "using x d_gt_0 iii"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 < d\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))\n\ngoal (1 subgoal):\n 1. (x_coord (1 - x) * d,\n     d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * x * pi / 2) / 2, d * sin (2 * x * pi / 2) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "by (auto simp add: x_coord_def diff_divide_distrib algebra_simps)"], ["proof (state)\nthis:\n  (x_coord (1 - x) * d,\n   d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * x * pi / 2) / 2, d * sin (2 * x * pi / 2) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have a: \"cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2))", "by (smt arccos_minus arccos_cos2 arccos_lbound cos_arccos cos_ge_minus_one cos_le_one i(1) i(2) pi_def pi_half)"], ["proof (state)\nthis:\n  cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have b: \"cos (arccos (1 - x * 2) + pi * 3 / 2) = cos ((pi / 2 - arccos (x * 2 - 1)) + 2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arccos (1 - x * 2) + pi * 3 / 2) =\n    cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)", "using arccos_minus[OF i]"], ["proof (prove)\nusing this:\n  arccos (- (2 * x - 1)) = pi - arccos (2 * x - 1)\n\ngoal (1 subgoal):\n 1. cos (arccos (1 - x * 2) + pi * 3 / 2) =\n    cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)", "by(auto simp add: mult.commute add.commute)"], ["proof (state)\nthis:\n  cos (arccos (1 - x * 2) + pi * 3 / 2) =\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "then"], ["proof (chain)\npicking this:\n  cos (arccos (1 - x * 2) + pi * 3 / 2) =\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)", "have c: \"... = cos (pi / 2 - arccos (x * 2 - 1))\""], ["proof (prove)\nusing this:\n  cos (arccos (1 - x * 2) + pi * 3 / 2) =\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)\n\ngoal (1 subgoal):\n 1. cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi) =\n    cos (pi / 2 - arccos (x * 2 - 1))", "using cos_periodic"], ["proof (prove)\nusing this:\n  cos (arccos (1 - x * 2) + pi * 3 / 2) =\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)\n  cos (?x + 2 * pi) = cos ?x\n\ngoal (1 subgoal):\n 1. cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi) =\n    cos (pi / 2 - arccos (x * 2 - 1))", "by blast"], ["proof (state)\nthis:\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi) =\n  cos (pi / 2 - arccos (x * 2 - 1))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))", "by (auto simp add: minus_add[where b = \"pi\" and a = \"arccos (1 - x * 2)\", symmetric])"], ["proof (state)\nthis:\n  cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "moreover"], ["proof (state)\nthis:\n  cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"... = cos ((pi + arccos (1 - x * 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))", "using cos_minus"], ["proof (prove)\nusing this:\n  cos (- ?x) = cos ?x\n\ngoal (1 subgoal):\n 1. cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))", "by blast"], ["proof (state)\nthis:\n  cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "moreover"], ["proof (state)\nthis:\n  cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"... = cos (2*pi - arccos (x * 2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))", "using arccos_minus[OF i]"], ["proof (prove)\nusing this:\n  arccos (- (2 * x - 1)) = pi - arccos (2 * x - 1)\n\ngoal (1 subgoal):\n 1. cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))", "by (auto simp add: mult.commute add.commute)"], ["proof (state)\nthis:\n  cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "moreover"], ["proof (state)\nthis:\n  cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have \"... = cos (arccos (x * 2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))", "using cos_2pi_minus"], ["proof (prove)\nusing this:\n  cos (2 * pi - ?x) = cos ?x\n\ngoal (1 subgoal):\n 1. cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))", "by auto"], ["proof (state)\nthis:\n  cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "ultimately"], ["proof (chain)\npicking this:\n  cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\n  cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))\n  cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))\n  cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))", "have d: \"cos (- pi - arccos (1 - x * 2)) = (x * 2 - 1)\""], ["proof (prove)\nusing this:\n  cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\n  cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))\n  cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))\n  cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))\n\ngoal (1 subgoal):\n 1. cos (- pi - arccos (1 - x * 2)) = x * 2 - 1", "using cos_arccos[OF i] mult.commute"], ["proof (prove)\nusing this:\n  cos (- pi - arccos (1 - x * 2)) = cos (- (pi + arccos (1 - x * 2)))\n  cos (- (pi + arccos (1 - x * 2))) = cos (pi + arccos (1 - x * 2))\n  cos (pi + arccos (1 - x * 2)) = cos (2 * pi - arccos (x * 2 - 1))\n  cos (2 * pi - arccos (x * 2 - 1)) = cos (arccos (x * 2 - 1))\n  cos (arccos (2 * x - 1)) = 2 * x - 1\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. cos (- pi - arccos (1 - x * 2)) = x * 2 - 1", "by metis"], ["proof (state)\nthis:\n  cos (- pi - arccos (1 - x * 2)) = x * 2 - 1\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have cosm: \"\\<And>x. cos (x - pi*2) = cos x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cos (x - pi * 2) = cos x", "by (metis cos_periodic eq_diff_eq' mult.commute)"], ["proof (state)\nthis:\n  cos (?x4 - pi * 2) = cos ?x4\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "have 34: \"?LHS3 x = (?RHS3  \\<circ> ?\\<phi>) x\"  \"?LHS4 x = (?RHS4 \\<circ> ?\\<phi>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_coord x * d, - (d * sqrt (1 / 4 - x_coord x * x_coord x))) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x &&&\n    (d * sqrt (1 / 4 - x_coord x * x_coord x), x_coord x * d) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n         else (d * cos ((2 * x - 1) * pi / 2) / 2,\n               d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "using d_gt_0 x a b c iii cos_periodic [of \"pi / 2 - arccos (x * 2 - 1)\"]"], ["proof (prove)\nusing this:\n  0 < d\n  0 \\<le> x\n  x \\<le> 1\n  cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2))\n  cos (arccos (1 - x * 2) + pi * 3 / 2) =\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi)\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi) =\n  cos (pi / 2 - arccos (x * 2 - 1))\n  2 * sqrt (x - x * x) = cos (arcsin (2 * x - 1)) \\<and>\n  2 * sqrt (x - x * x) = sin (arccos (1 - 2 * x))\n  cos (pi / 2 - arccos (x * 2 - 1) + 2 * pi) =\n  cos (pi / 2 - arccos (x * 2 - 1))\n\ngoal (1 subgoal):\n 1. (x_coord x * d, - (d * sqrt (1 / 4 - x_coord x * x_coord x))) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x &&&\n    (d * sqrt (1 / 4 - x_coord x * x_coord x), x_coord x * d) =\n    ((\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n         else (d * cos ((2 * x - 1) * pi / 2) / 2,\n               d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n     ((*) (1 / pi) \\<circ>\n      (\\<lambda>x.\n          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n      (\\<lambda>t. 2 * x_coord (1 - t))))\n     x", "apply (auto simp add: x_coord_def algebra_simps diff_divide_distrib power2_eq_square)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> cos (arcsin (x * 2 - 1)) =\n                      cos (pi / 2 - arccos (1 - x * 2))\n 2. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) =\n                      d + d * sin (arccos (1 - x * 2) + pi * 3 / 2)\n 3. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> cos (arcsin (x * 2 - 1)) =\n                      cos (arccos (1 - x * 2) - pi / 2)\n 4. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (pi / 2 - arccos (1 - x * 2));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) =\n     cos (pi / 2 - arccos (1 - x * 2));\n     sin (arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) =\n                      d + d * sin (arccos (1 - x * 2) - pi / 2)", "apply (auto simp add: sin_cos_eq cosm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) = d + d * cos (- pi - arccos (1 - x * 2))\n 2. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> cos (arcsin (x * 2 - 1)) =\n                      cos (arccos (1 - x * 2) - pi / 2)\n 3. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) = d + d * (x * 2 - 1)", "using d"], ["proof (prove)\nusing this:\n  cos (- pi - arccos (1 - x * 2)) = x * 2 - 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) = d + d * cos (- pi - arccos (1 - x * 2))\n 2. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> cos (arcsin (x * 2 - 1)) =\n                      cos (arccos (1 - x * 2) - pi / 2)\n 3. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi\\<rbrakk>\n    \\<Longrightarrow> d * (x * 2) = d + d * (x * 2 - 1)", "apply (auto simp add: right_diff_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d; 0 \\<le> x; x \\<le> 1;\n     cos (pi / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (arccos (1 - x * 2) + pi * 3 / 2) = cos (arcsin (x * 2 - 1));\n     cos (pi * 5 / 2 - arccos (x * 2 - 1)) = cos (arcsin (x * 2 - 1));\n     cos (pi / 2 - arccos (1 - x * 2)) = cos (arcsin (x * 2 - 1));\n     2 * sqrt (x - x * x) = cos (arcsin (x * 2 - 1));\n     \\<not> 2 * arccos (1 - x * 2) \\<le> pi;\n     cos (- pi - arccos (1 - x * 2)) = x * 2 - 1\\<rbrakk>\n    \\<Longrightarrow> cos (arcsin (x * 2 - 1)) =\n                      cos (arccos (1 - x * 2) - pi / 2)", "by (smt cos_minus)"], ["proof (state)\nthis:\n  (x_coord x * d, - (d * sqrt (1 / 4 - x_coord x * x_coord x))) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n  (d * sqrt (1 / 4 - x_coord x * x_coord x), x_coord x * d) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n       else (d * cos ((2 * x - 1) * pi / 2) / 2,\n             d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "note 1 2 34"], ["proof (state)\nthis:\n  (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n   x_coord (1 - x) * d) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n  (x_coord (1 - x) * d,\n   d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * x * pi / 2) / 2, d * sin (2 * x * pi / 2) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n  (x_coord x * d, - (d * sqrt (1 / 4 - x_coord x * x_coord x))) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n       else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n             d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n  (d * sqrt (1 / 4 - x_coord x * x_coord x), x_coord x * d) =\n  ((\\<lambda>x.\n       if x * 2 \\<le> 1\n       then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n             d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n       else (d * cos ((2 * x - 1) * pi / 2) / 2,\n             d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n   ((*) (1 / pi) \\<circ>\n    (\\<lambda>x.\n        if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n        else if x < - 1 then - x + pi else 1 - x) \\<circ>\n    (\\<lambda>t. 2 * x_coord (1 - t))))\n   x\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (- (d *\n                        sqrt\n                         (1 / 4 - x_coord (1 - ?x6) * x_coord (1 - ?x6))),\n                     x_coord (1 - ?x6) * d) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (x_coord (1 - ?x6) * d,\n                     d *\n                     sqrt (1 / 4 - x_coord (1 - ?x6) * x_coord (1 - ?x6))) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * x * pi / 2) / 2,\n                               d * sin (2 * x * pi / 2) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (x_coord ?x6 * d,\n                     - (d * sqrt (1 / 4 - x_coord ?x6 * x_coord ?x6))) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (d * sqrt (1 / 4 - x_coord ?x6 * x_coord ?x6),\n                     x_coord ?x6 * d) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n                         else (d * cos ((2 * x - 1) * pi / 2) / 2,\n                               d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (- (d *\n                        sqrt\n                         (1 / 4 - x_coord (1 - ?x6) * x_coord (1 - ?x6))),\n                     x_coord (1 - ?x6) * d) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (x_coord (1 - ?x6) * d,\n                     d *\n                     sqrt (1 / 4 - x_coord (1 - ?x6) * x_coord (1 - ?x6))) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * x * pi / 2) / 2,\n                               d * sin (2 * x * pi / 2) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (x_coord ?x6 * d,\n                     - (d * sqrt (1 / 4 - x_coord ?x6 * x_coord ?x6))) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n                         else (d *\n                               cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) /\n                               2,\n                               d *\n                               sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) /\n                               2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n  \\<lbrakk>0 \\<le> ?x6; ?x6 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> (d * sqrt (1 / 4 - x_coord ?x6 * x_coord ?x6),\n                     x_coord ?x6 * d) =\n                    ((\\<lambda>x.\n                         if x * 2 \\<le> 1\n                         then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n                               d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n                         else (d * cos ((2 * x - 1) * pi / 2) / 2,\n                               d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n                     ((*) (1 / pi) \\<circ>\n                      (\\<lambda>x.\n                          if - 1 \\<le> x \\<and> x \\<le> 1 then arccos x\n                          else if x < - 1 then - x + pi else 1 - x) \\<circ>\n                      (\\<lambda>t. 2 * x_coord (1 - t))))\n                     ?x6\n\ngoal (4 subgoals):\n 1. reparam (rec_join [rot_circle_left_edge])\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 2. reparam (rec_join [circle_top_edge])\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 3. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])\n 4. reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "show ?P1 ?P2 ?P3 ?P4"], ["proof (prove)\ngoal (1 subgoal):\n 1. (reparam (rec_join [rot_circle_left_edge])\n      (rec_join\n        [subcube (1 / 4) (1 / 2) (1, circle_polar),\n         subcube (1 / 2) (3 / 4) (1, circle_polar)]) &&&\n     reparam (rec_join [circle_top_edge])\n      (rec_join\n        [subcube 0 (1 / 4) (1, circle_polar),\n         subcube (1 / 4) (1 / 2) (1, circle_polar)])) &&&\n    reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)]) &&&\n    reparam (rec_join [rot_circle_right_edge])\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "apply (auto simp add: subcube_def circle_bot_edge_def circle_top_edge_def circle_polar_def reversepath_def \n               subpath_def joinpaths_def circle_y_def rot_circle_left_edge_def rot_circle_right_edge_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. reparam\n     (\\<lambda>x.\n         (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n          x_coord (1 - x) * d))\n     (\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2))\n 2. reparam\n     (\\<lambda>x.\n         (x_coord (1 - x) * d,\n          d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))))\n     (\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * x * pi / 2) / 2, d * sin (2 * x * pi / 2) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2))\n 3. reparam\n     (\\<lambda>t.\n         (x_coord t * d, - (d * sqrt (1 / 4 - x_coord t * x_coord t))))\n     (\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n         else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2))\n 4. reparam\n     (\\<lambda>t. (d * sqrt (1 / 4 - x_coord t * x_coord t), x_coord t * d))\n     (\\<lambda>x.\n         if x * 2 \\<le> 1\n         then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n               d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n         else (d * cos ((2 * x - 1) * pi / 2) / 2,\n               d * sin ((2 * x - 1) * pi / 2) / 2))", "unfolding reparam_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<exists>\\<phi>.\n       (\\<forall>x\\<in>{0..1}.\n           (- (d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))),\n            x_coord (1 - x) * d) =\n           ((\\<lambda>x.\n                if x * 2 \\<le> 1\n                then (d * cos (2 * pi * (2 * x / 4 + 1 / 4)) / 2,\n                      d * sin (2 * pi * (2 * x / 4 + 1 / 4)) / 2)\n                else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) / 2,\n                      d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 2)) /\n                      2)) \\<circ>\n            \\<phi>)\n            x) \\<and>\n       \\<phi> piecewise_C1_differentiable_on {0..1} \\<and>\n       \\<phi> 0 = 0 \\<and>\n       \\<phi> 1 = 1 \\<and>\n       bij_betw \\<phi> {0..1} {0..1} \\<and>\n       \\<phi> -` {0..1} \\<subseteq> {0..1} \\<and>\n       (\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}))\n 2. \\<exists>\\<phi>.\n       (\\<forall>x\\<in>{0..1}.\n           (x_coord (1 - x) * d,\n            d * sqrt (1 / 4 - x_coord (1 - x) * x_coord (1 - x))) =\n           ((\\<lambda>x.\n                if x * 2 \\<le> 1\n                then (d * cos (2 * x * pi / 2) / 2,\n                      d * sin (2 * x * pi / 2) / 2)\n                else (d * cos (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) / 2,\n                      d * sin (2 * pi * ((2 * x - 1) / 4 + 1 / 4)) /\n                      2)) \\<circ>\n            \\<phi>)\n            x) \\<and>\n       \\<phi> piecewise_C1_differentiable_on {0..1} \\<and>\n       \\<phi> 0 = 0 \\<and>\n       \\<phi> 1 = 1 \\<and>\n       bij_betw \\<phi> {0..1} {0..1} \\<and>\n       \\<phi> -` {0..1} \\<subseteq> {0..1} \\<and>\n       (\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}))\n 3. \\<exists>\\<phi>.\n       (\\<forall>x\\<in>{0..1}.\n           (x_coord x * d, - (d * sqrt (1 / 4 - x_coord x * x_coord x))) =\n           ((\\<lambda>x.\n                if x * 2 \\<le> 1\n                then (d * cos (2 * pi * (2 * x / 4 + 1 / 2)) / 2,\n                      d * sin (2 * pi * (2 * x / 4 + 1 / 2)) / 2)\n                else (d * cos (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) / 2,\n                      d * sin (2 * pi * ((2 * x - 1) / 4 + 3 / 4)) /\n                      2)) \\<circ>\n            \\<phi>)\n            x) \\<and>\n       \\<phi> piecewise_C1_differentiable_on {0..1} \\<and>\n       \\<phi> 0 = 0 \\<and>\n       \\<phi> 1 = 1 \\<and>\n       bij_betw \\<phi> {0..1} {0..1} \\<and>\n       \\<phi> -` {0..1} \\<subseteq> {0..1} \\<and>\n       (\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}))\n 4. \\<exists>\\<phi>.\n       (\\<forall>x\\<in>{0..1}.\n           (d * sqrt (1 / 4 - x_coord x * x_coord x), x_coord x * d) =\n           ((\\<lambda>x.\n                if x * 2 \\<le> 1\n                then (d * cos (2 * pi * (2 * x / 4 + 3 / 4)) / 2,\n                      d * sin (2 * pi * (2 * x / 4 + 3 / 4)) / 2)\n                else (d * cos ((2 * x - 1) * pi / 2) / 2,\n                      d * sin ((2 * x - 1) * pi / 2) / 2)) \\<circ>\n            \\<phi>)\n            x) \\<and>\n       \\<phi> piecewise_C1_differentiable_on {0..1} \\<and>\n       \\<phi> 0 = 0 \\<and>\n       \\<phi> 1 = 1 \\<and>\n       bij_betw \\<phi> {0..1} {0..1} \\<and>\n       \\<phi> -` {0..1} \\<subseteq> {0..1} \\<and>\n       (\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}))", "by (rule ballI exI conjI impI phi_diff bij_phi phi01 fin * | force simp add: x_coord_def)+"], ["proof (state)\nthis:\n  reparam (rec_join [rot_circle_left_edge])\n   (rec_join\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)])\n  reparam (rec_join [circle_top_edge])\n   (rec_join\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)])\n  reparam (rec_join [circle_bot_edge])\n   (rec_join\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)])\n  reparam (rec_join [rot_circle_right_edge])\n   (rec_join\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)])\n\ngoal:\nNo subgoals!", "qed"], ["", "definition circle_cube_boundary_to_polarcircle where\n  \"circle_cube_boundary_to_polarcircle \\<gamma> \\<equiv>\n     if (\\<gamma> = (circle_top_edge)) then\n           {subcube 0 (1/4) (1, circle_polar), subcube (1/4) (1/2) (1, circle_polar)}\n     else if (\\<gamma> = (circle_bot_edge)) then\n           {subcube (1/2) (3/4) (1, circle_polar), subcube (3/4) 1 (1, circle_polar)}\n     else {}\""], ["", "definition rot_circle_cube_boundary_to_polarcircle where\n  \"rot_circle_cube_boundary_to_polarcircle \\<gamma> \\<equiv>\n     if (\\<gamma> = (rot_circle_left_edge )) then\n           {subcube (1/4)  (1/2) (1, circle_polar), subcube (1/2) (3/4) (1, circle_polar)}\n     else if (\\<gamma> = (rot_circle_right_edge)) then\n           {subcube (3/4) 1 (1, circle_polar), subcube 0 (1/4) (1, circle_polar)}\n     else {}\""], ["", "lemma circle_arcs_neq:\n  assumes \"0 \\<le> k\" \"k \\<le> 1\" \"0 \\<le> n\" \"n \\<le> 1\" \"n < k\" \"k + n < 1\"\n  shows \"subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)", "proof (simp add: subcube_def subpath_def circle_polar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "have \"cos (2 * pi * k) \\<noteq> cos(2 * pi * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (2 * pi * k) \\<noteq> cos (2 * pi * n)", "unfolding cos_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>na\\<in>\\<int>.\n               2 * pi * k = 2 * pi * n + 2 * na * pi \\<or>\n               2 * pi * k = - (2 * pi * n) + 2 * na * pi)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = 2 * pi * n + 2 * na * pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = - (2 * pi * n) + 2 * na * pi\\<rbrakk>\n       \\<Longrightarrow> False", "show False if \"2 * pi * k = 2 * pi * n + 2 * m * pi\" \"m \\<in> \\<int>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"2 * pi * (k - n ) = 2 * m * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * (k - n) = 2 * m * pi", "using distrib_left that"], ["proof (prove)\nusing this:\n  ?a * (?b + ?c) = ?a * ?b + ?a * ?c\n  2 * pi * k = 2 * pi * n + 2 * m * pi\n  m \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 2 * pi * (k - n) = 2 * m * pi", "by (simp add: left_diff_distrib mult.commute)"], ["proof (state)\nthis:\n  2 * pi * (k - n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  2 * pi * (k - n) = 2 * m * pi", "have a: \"m = (k - n)\""], ["proof (prove)\nusing this:\n  2 * pi * (k - n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. m = k - n", "by auto"], ["proof (state)\nthis:\n  m = k - n\n\ngoal (1 subgoal):\n 1. False", "have \"\\<lfloor>k - n\\<rfloor> = 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>k - n\\<rfloor> = 0", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  k + n < 1\n\ngoal (1 subgoal):\n 1. \\<lfloor>k - n\\<rfloor> = 0", "by (simp add: floor_eq_iff)"], ["proof (state)\nthis:\n  \\<lfloor>k - n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<lfloor>k - n\\<rfloor> = 0", "have \"k - n \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  \\<lfloor>k - n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. k - n \\<notin> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  \\<lfloor>k - n\\<rfloor> = 0\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  k + n < 1\n\ngoal (1 subgoal):\n 1. k - n \\<notin> \\<int>", "by (auto simp only: frac_eq_0_iff[symmetric] frac_def)"], ["proof (state)\nthis:\n  k - n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  k - n \\<notin> \\<int>", "show False"], ["proof (prove)\nusing this:\n  k - n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "using that a"], ["proof (prove)\nusing this:\n  k - n \\<notin> \\<int>\n  2 * pi * k = 2 * pi * n + 2 * m * pi\n  m \\<in> \\<int>\n  m = k - n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>2 * pi * k = 2 * pi * n + 2 * ?m4 * pi; ?m4 \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = - (2 * pi * n) + 2 * na * pi\\<rbrakk>\n       \\<Longrightarrow> False", "show False if \"2 * pi * k = - (2 * pi * n) + 2 * m * pi\" \"m \\<in> \\<int>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"2 * pi * (k + n ) = 2 * m * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * (k + n) = 2 * m * pi", "using that"], ["proof (prove)\nusing this:\n  2 * pi * k = - (2 * pi * n) + 2 * m * pi\n  m \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 2 * pi * (k + n) = 2 * m * pi", "by (auto simp add: distrib_left)"], ["proof (state)\nthis:\n  2 * pi * (k + n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  2 * pi * (k + n) = 2 * m * pi", "have a: \"m = (k + n)\""], ["proof (prove)\nusing this:\n  2 * pi * (k + n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. m = k + n", "by auto"], ["proof (state)\nthis:\n  m = k + n\n\ngoal (1 subgoal):\n 1. False", "have \"\\<lfloor>k + n\\<rfloor> = 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>k + n\\<rfloor> = 0", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  k + n < 1\n\ngoal (1 subgoal):\n 1. \\<lfloor>k + n\\<rfloor> = 0", "by (simp add: floor_eq_iff)"], ["proof (state)\nthis:\n  \\<lfloor>k + n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<lfloor>k + n\\<rfloor> = 0", "have \"k + n \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  \\<lfloor>k + n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. k + n \\<notin> \\<int>", "using Ints_def assms"], ["proof (prove)\nusing this:\n  \\<lfloor>k + n\\<rfloor> = 0\n  \\<int> = range of_int\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  k + n < 1\n\ngoal (1 subgoal):\n 1. k + n \\<notin> \\<int>", "by force"], ["proof (state)\nthis:\n  k + n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  k + n \\<notin> \\<int>", "show False"], ["proof (prove)\nusing this:\n  k + n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "using that a"], ["proof (prove)\nusing this:\n  k + n \\<notin> \\<int>\n  2 * pi * k = - (2 * pi * n) + 2 * m * pi\n  m \\<in> \\<int>\n  m = k + n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>2 * pi * k = - (2 * pi * n) + 2 * ?m4 * pi;\n   ?m4 \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos (2 * pi * k) \\<noteq> cos (2 * pi * n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "then"], ["proof (chain)\npicking this:\n  cos (2 * pi * k) \\<noteq> cos (2 * pi * n)", "have \"(\\<lambda>x. (d * cos (2 * pi * ((m - k) * x + k))/2, d * sin (2 * pi * ((m - k) * x + k))/2)) 0  \\<noteq> (\\<lambda>x. (d * cos (2 * pi * ((q - n) * x + n))/2, d * sin (2 * pi * ((q - n) * x + n))/2)) 0\""], ["proof (prove)\nusing this:\n  cos (2 * pi * k) \\<noteq> cos (2 * pi * n)\n\ngoal (1 subgoal):\n 1. (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n     d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n    (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n     d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "using d_gt_0"], ["proof (prove)\nusing this:\n  cos (2 * pi * k) \\<noteq> cos (2 * pi * n)\n  0 < d\n\ngoal (1 subgoal):\n 1. (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n     d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n    (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n     d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "by auto"], ["proof (state)\nthis:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "then"], ["proof (chain)\npicking this:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "show \"(\\<lambda>x. (d * cos (2 * pi * ((m - k) * x + k))/2, d * sin (2 * pi * ((m - k) * x + k))/2)) \\<noteq> (\\<lambda>x. (d * cos (2 * pi * ((q - n) * x + n))/2, d * sin (2 * pi * ((q - n) * x + n))/2))\""], ["proof (prove)\nusing this:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n       d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n  (\\<lambda>x.\n      (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n       d * sin (2 * pi * ((q - n) * x + n)) / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_arcs_neq_2:\n  assumes \"0 \\<le> k\" \"k \\<le> 1\" \"0 \\<le> n\" \"n \\<le> 1\" \"n < k\" \"0 < n\" and kn12: \"1/2 < k + n\" and \"k + n < 3/2\"\n  shows \"subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube k m (1, circle_polar) \\<noteq> subcube n q (1, circle_polar)", "proof (simp add: subcube_def subpath_def circle_polar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "have \"sin (2 * pi * k) \\<noteq> sin(2 * pi * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (2 * pi * k) \\<noteq> sin (2 * pi * n)", "unfolding sin_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>na\\<in>\\<int>.\n               2 * pi * k = 2 * pi * n + 2 * na * pi \\<or>\n               2 * pi * k = - (2 * pi * n) + (2 * na + 1) * pi)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = 2 * pi * n + 2 * na * pi\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = - (2 * pi * n) + (2 * na + 1) * pi\\<rbrakk>\n       \\<Longrightarrow> False", "show False if \"m \\<in> \\<int>\" \"2 * pi * k = 2 * pi * n + 2 * m * pi\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"2 * pi * (k - n) = 2 * m * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * (k - n) = 2 * m * pi", "using that"], ["proof (prove)\nusing this:\n  m \\<in> \\<int>\n  2 * pi * k = 2 * pi * n + 2 * m * pi\n\ngoal (1 subgoal):\n 1. 2 * pi * (k - n) = 2 * m * pi", "by (simp add: left_diff_distrib mult.commute)"], ["proof (state)\nthis:\n  2 * pi * (k - n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  2 * pi * (k - n) = 2 * m * pi", "have a: \"m = (k - n)\""], ["proof (prove)\nusing this:\n  2 * pi * (k - n) = 2 * m * pi\n\ngoal (1 subgoal):\n 1. m = k - n", "by auto"], ["proof (state)\nthis:\n  m = k - n\n\ngoal (1 subgoal):\n 1. False", "have \"\\<lfloor>k - n\\<rfloor> = 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>k - n\\<rfloor> = 0", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  0 < n\n  1 / 2 < k + n\n  k + n < 3 / 2\n\ngoal (1 subgoal):\n 1. \\<lfloor>k - n\\<rfloor> = 0", "by (simp add: floor_eq_iff)"], ["proof (state)\nthis:\n  \\<lfloor>k - n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<lfloor>k - n\\<rfloor> = 0", "have \"k - n \\<notin>  \\<int>\""], ["proof (prove)\nusing this:\n  \\<lfloor>k - n\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. k - n \\<notin> \\<int>", "using assms"], ["proof (prove)\nusing this:\n  \\<lfloor>k - n\\<rfloor> = 0\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  0 < n\n  1 / 2 < k + n\n  k + n < 3 / 2\n\ngoal (1 subgoal):\n 1. k - n \\<notin> \\<int>", "by (auto simp only: frac_eq_0_iff[symmetric] frac_def )"], ["proof (state)\nthis:\n  k - n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  k - n \\<notin> \\<int>", "show False"], ["proof (prove)\nusing this:\n  k - n \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "using that a"], ["proof (prove)\nusing this:\n  k - n \\<notin> \\<int>\n  m \\<in> \\<int>\n  2 * pi * k = 2 * pi * n + 2 * m * pi\n  m = k - n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m4 \\<in> \\<int>; 2 * pi * k = 2 * pi * n + 2 * ?m4 * pi\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>na \\<in> \\<int>;\n        2 * pi * k = - (2 * pi * n) + (2 * na + 1) * pi\\<rbrakk>\n       \\<Longrightarrow> False", "show False if \"2 * pi * k = - (2 * pi * n) + (2 * m + 1) * pi\" \"m \\<in> \\<int>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have i: \"\\<And>pi. 0 < pi \\<Longrightarrow> 2 * pi * (k + n ) = 2 * m * pi + pi \\<Longrightarrow> m = (k + n) - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pi.\n       \\<lbrakk>0 < pi; 2 * pi * (k + n) = 2 * m * pi + pi\\<rbrakk>\n       \\<Longrightarrow> m = k + n - 1 / 2", "by (sos \"(((((A<0 * A<1) * R<1) + ([1/2] * A=0))) & ((((A<0 * A<1) * R<1) + ([~1/2] * A=0))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?pi4; 2 * ?pi4 * (k + n) = 2 * m * ?pi4 + ?pi4\\<rbrakk>\n  \\<Longrightarrow> m = k + n - 1 / 2\n\ngoal (1 subgoal):\n 1. False", "have \"2 * pi * (k + n) = 2 * m * pi + pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * (k + n) = 2 * m * pi + pi", "using that"], ["proof (prove)\nusing this:\n  2 * pi * k = - (2 * pi * n) + (2 * m + 1) * pi\n  m \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 2 * pi * (k + n) = 2 * m * pi + pi", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * pi * (k + n) = 2 * m * pi + pi\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  2 * pi * (k + n) = 2 * m * pi + pi", "have a: \"m = (k + n) - 1/2\""], ["proof (prove)\nusing this:\n  2 * pi * (k + n) = 2 * m * pi + pi\n\ngoal (1 subgoal):\n 1. m = k + n - 1 / 2", "using i[OF pi_gt_zero]"], ["proof (prove)\nusing this:\n  2 * pi * (k + n) = 2 * m * pi + pi\n  2 * pi * (k + n) = 2 * m * pi + pi \\<Longrightarrow> m = k + n - 1 / 2\n\ngoal (1 subgoal):\n 1. m = k + n - 1 / 2", "by fastforce"], ["proof (state)\nthis:\n  m = k + n - 1 / 2\n\ngoal (1 subgoal):\n 1. False", "have \"\\<lfloor>k + n - 1/2\\<rfloor> = 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>k + n - 1 / 2\\<rfloor> = 0", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> k\n  k \\<le> 1\n  0 \\<le> n\n  n \\<le> 1\n  n < k\n  0 < n\n  1 / 2 < k + n\n  k + n < 3 / 2\n\ngoal (1 subgoal):\n 1. \\<lfloor>k + n - 1 / 2\\<rfloor> = 0", "by (auto simp add: floor_eq_iff)"], ["proof (state)\nthis:\n  \\<lfloor>k + n - 1 / 2\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<lfloor>k + n - 1 / 2\\<rfloor> = 0", "have \"k + n - 1/2 \\<notin> \\<int>\""], ["proof (prove)\nusing this:\n  \\<lfloor>k + n - 1 / 2\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. k + n - 1 / 2 \\<notin> \\<int>", "by (metis Ints_cases add.commute add.left_neutral add_diff_cancel_left' add_diff_eq kn12 floor_of_int of_int_0 order_less_irrefl)"], ["proof (state)\nthis:\n  k + n - 1 / 2 \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  k + n - 1 / 2 \\<notin> \\<int>", "show False"], ["proof (prove)\nusing this:\n  k + n - 1 / 2 \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. False", "using that a"], ["proof (prove)\nusing this:\n  k + n - 1 / 2 \\<notin> \\<int>\n  2 * pi * k = - (2 * pi * n) + (2 * m + 1) * pi\n  m \\<in> \\<int>\n  m = k + n - 1 / 2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>2 * pi * k = - (2 * pi * n) + (2 * ?m4 + 1) * pi;\n   ?m4 \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sin (2 * pi * k) \\<noteq> sin (2 * pi * n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "then"], ["proof (chain)\npicking this:\n  sin (2 * pi * k) \\<noteq> sin (2 * pi * n)", "have \"(\\<lambda>x. (d * cos (2 * pi * ((m - k) * x + k))/2, d * sin (2 * pi * ((m - k) * x + k))/2)) 0  \\<noteq> (\\<lambda>x. (d * cos (2 * pi * ((q - n) * x + n))/2, d * sin (2 * pi * ((q - n) * x + n))/2)) 0\""], ["proof (prove)\nusing this:\n  sin (2 * pi * k) \\<noteq> sin (2 * pi * n)\n\ngoal (1 subgoal):\n 1. (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n     d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n    (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n     d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "using d_gt_0"], ["proof (prove)\nusing this:\n  sin (2 * pi * k) \\<noteq> sin (2 * pi * n)\n  0 < d\n\ngoal (1 subgoal):\n 1. (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n     d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n    (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n     d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "by auto"], ["proof (state)\nthis:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "then"], ["proof (chain)\npicking this:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)", "show \"(\\<lambda>x. (d * cos (2 * pi * ((m - k) * x + k))/2, d * sin (2 * pi * ((m - k) * x + k))/2)) \\<noteq> (\\<lambda>x. (d * cos (2 * pi * ((q - n) * x + n))/2, d * sin (2 * pi * ((q - n) * x + n))/2))\""], ["proof (prove)\nusing this:\n  (d * cos (2 * pi * ((m - k) * 0 + k)) / 2,\n   d * sin (2 * pi * ((m - k) * 0 + k)) / 2) \\<noteq>\n  (d * cos (2 * pi * ((q - n) * 0 + n)) / 2,\n   d * sin (2 * pi * ((q - n) * 0 + n)) / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n         d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n    (\\<lambda>x.\n        (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n         d * sin (2 * pi * ((q - n) * x + n)) / 2))", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (d * cos (2 * pi * ((m - k) * x + k)) / 2,\n       d * sin (2 * pi * ((m - k) * x + k)) / 2)) \\<noteq>\n  (\\<lambda>x.\n      (d * cos (2 * pi * ((q - n) * x + n)) / 2,\n       d * sin (2 * pi * ((q - n) * x + n)) / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_cube_is_only_horizontal_div_of_rot:\n  shows \"only_horizontal_division (boundary (circle_cube)) {rot_circle_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. only_horizontal_division (boundary circle_cube) {rot_circle_cube}", "unfolding only_horizontal_division_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<H> \\<V>.\n       finite \\<H> \\<and>\n       finite \\<V> \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>\\<H>.\n           \\<exists>(k', \\<gamma>')\n                    \\<in>two_chain_horizontal_boundary {rot_circle_cube}.\n              \\<exists>a\\<in>{0..1}.\n                 \\<exists>b\\<in>{0..1}.\n                    a \\<le> b \\<and>\n                    subpath a b \\<gamma>' = \\<gamma>) \\<and>\n       (common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n         \\<V> \\<or>\n        common_reparam_exists \\<V>\n         (two_chain_vertical_boundary {rot_circle_cube})) \\<and>\n       boundary_chain \\<V> \\<and>\n       boundary circle_cube = \\<H> \\<union> \\<V> \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>\\<V>. valid_path \\<gamma>)", "proof (rule exI [of _ \"{}\"], simp, intro conjI ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (boundary circle_cube)\n 2. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})\n 3. boundary_chain (boundary circle_cube)\n 4. \\<And>x.\n       x \\<in> boundary circle_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"finite (boundary circle_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (boundary circle_cube)", "using circle.circle_cube_boundary_explicit circle_axioms"], ["proof (prove)\nusing this:\n  circle ?i ?j ?d \\<Longrightarrow>\n  boundary (circle.circle_cube ?d) =\n  {circle.circle_left_edge ?d, circle.circle_right_edge ?d,\n   circle.circle_bot_edge ?d, circle.circle_top_edge ?d}\n  circle i j d\n\ngoal (1 subgoal):\n 1. finite (boundary circle_cube)", "by auto"], ["proof (state)\nthis:\n  finite (boundary circle_cube)\n\ngoal (3 subgoals):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})\n 2. boundary_chain (boundary circle_cube)\n 3. \\<And>x.\n       x \\<in> boundary circle_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"boundary_chain (boundary circle_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (boundary circle_cube)", "by (simp add: two_cube_boundary_is_boundary)"], ["proof (state)\nthis:\n  boundary_chain (boundary circle_cube)\n\ngoal (2 subgoals):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})\n 2. \\<And>x.\n       x \\<in> boundary circle_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"\\<And>x. x \\<in> boundary circle_cube \\<Longrightarrow> case x of (k, x) \\<Rightarrow> valid_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> boundary circle_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "using circle_cube_boundary_valid"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary circle_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> boundary circle_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "by blast"], ["proof (state)\nthis:\n  ?x4 \\<in> boundary circle_cube \\<Longrightarrow>\n  case ?x4 of (k, x) \\<Rightarrow> valid_path x\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "let ?\\<V> = \"(boundary (circle_cube))\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "let ?pi = \"{circle_left_edge, circle_right_edge}\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "let ?pj = \"{rot_circle_top_edge, rot_circle_bot_edge}\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "let ?f = \"circle_cube_boundary_to_polarcircle\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "let ?one_chaini = \"boundary (circle_cube) - ?pi\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "have c: \"common_reparam_exists ?\\<V> (two_chain_vertical_boundary {rot_circle_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "unfolding common_reparam_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>subdiv ps1 ps2.\n       chain_reparam_chain' (boundary circle_cube - ps1) subdiv \\<and>\n       chain_reparam_chain'\n        (two_chain_vertical_boundary {rot_circle_cube} - ps2) subdiv \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>subdiv.\n           \\<gamma> C1_differentiable_on {0..1}) \\<and>\n       boundary_chain subdiv \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>)", "proof (intro exI conjI)"], ["proof (state)\ngoal (6 subgoals):\n 1. chain_reparam_chain' (boundary circle_cube - ?ps1.1) ?subdiv\n 2. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2) ?subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>?subdiv. \\<gamma> C1_differentiable_on {0..1}\n 4. boundary_chain ?subdiv\n 5. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 6. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "let ?subdiv = \"{(subcube 0 (1/4) (1, circle_polar)),\n                    (subcube (1/4) (1/2) (1, circle_polar)),\n                    (subcube (1/2) (3/4) (1, circle_polar)),\n                    (subcube (3/4) 1 (1, circle_polar))}\""], ["proof (state)\ngoal (6 subgoals):\n 1. chain_reparam_chain' (boundary circle_cube - ?ps1.1) ?subdiv\n 2. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2) ?subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>?subdiv. \\<gamma> C1_differentiable_on {0..1}\n 4. boundary_chain ?subdiv\n 5. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 6. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"(\\<forall>(k, \\<gamma>)\\<in>?subdiv. \\<gamma> C1_differentiable_on {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{subcube 0 (1 / 4) (1, circle_polar),\n                   subcube (1 / 4) (1 / 2) (1, circle_polar),\n                   subcube (1 / 2) (3 / 4) (1, circle_polar),\n                   subcube (3 / 4) 1 (1, circle_polar)}.\n       \\<gamma> C1_differentiable_on {0..1}", "using subpath_smooth[OF circle_polar_smooth]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; ?a < ?b; ?b \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> subpath ?a ?b circle_polar C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{subcube 0 (1 / 4) (1, circle_polar),\n                   subcube (1 / 4) (1 / 2) (1, circle_polar),\n                   subcube (1 / 2) (3 / 4) (1, circle_polar),\n                   subcube (3 / 4) 1 (1, circle_polar)}.\n       \\<gamma> C1_differentiable_on {0..1}", "by (auto simp add: subcube_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>{subcube 0 (1 / 4) (1, circle_polar),\n                 subcube (1 / 4) (1 / 2) (1, circle_polar),\n                 subcube (1 / 2) (3 / 4) (1, circle_polar),\n                 subcube (3 / 4) 1 (1, circle_polar)}.\n     \\<gamma> C1_differentiable_on {0..1}\n\ngoal (5 subgoals):\n 1. chain_reparam_chain' (boundary circle_cube - ?ps1.1)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 3. boundary_chain\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 4. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 5. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "have 1: \"finite ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (5 subgoals):\n 1. chain_reparam_chain' (boundary circle_cube - ?ps1.1)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 3. boundary_chain\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 4. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 5. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"boundary_chain ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}", "by (simp add: boundary_chain_def subcube_def)"], ["proof (state)\nthis:\n  boundary_chain\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (4 subgoals):\n 1. chain_reparam_chain' (boundary circle_cube - ?ps1.1)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 3. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 4. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"chain_reparam_chain' (boundary (circle_cube) - ?pi) ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_chain'\n     (boundary circle_cube - {circle_left_edge, circle_right_edge})\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}", "unfolding chain_reparam_chain'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union>\n        (f `\n         (boundary circle_cube - {circle_left_edge, circle_right_edge})) =\n       {subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n       (\\<forall>cube\n                 \\<in>boundary circle_cube -\n                      {circle_left_edge, circle_right_edge}.\n           chain_reparam_weak_path (rec_join [cube]) (f cube)) \\<and>\n       (\\<forall>p\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n           \\<forall>p'\\<in>boundary circle_cube -\n                           {circle_left_edge, circle_right_edge}.\n              p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n       (\\<forall>x\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n           finite (f x))", "proof (intro exI conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f ` (boundary circle_cube - {circle_left_edge, circle_right_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube]) (?f cube)\n 3. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (?f x)", "show \"\\<Union> (?f ` ?one_chaini) = ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (circle_cube_boundary_to_polarcircle `\n      (boundary circle_cube - {circle_left_edge, circle_right_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}", "apply (simp add: circle_cube_boundary_to_polarcircle_def circle_cube_boundary_explicit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. circle_bot_edge = circle_top_edge \\<longrightarrow>\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)} =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}", "using circle_top_bot_edges_neq'"], ["proof (prove)\nusing this:\n  circle_top_edge \\<noteq> circle_bot_edge\n\ngoal (1 subgoal):\n 1. circle_bot_edge = circle_top_edge \\<longrightarrow>\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)} =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}", "by metis"], ["proof (state)\nthis:\n  \\<Union>\n   (circle_cube_boundary_to_polarcircle `\n    (boundary circle_cube - {circle_left_edge, circle_right_edge})) =\n  {subcube 0 (1 / 4) (1, circle_polar),\n   subcube (1 / 4) (1 / 2) (1, circle_polar),\n   subcube (1 / 2) (3 / 4) (1, circle_polar),\n   subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "let ?l = \"[subcube 0 (1/4) (1, circle_polar), subcube (1/4) (1/2) (1, circle_polar)]\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "have \"chain_reparam_weak_path (coeff_cube_to_path (circle_top_edge)) {subcube 0 (1/4) (1, circle_polar), subcube (1/4) (1/2) (1, circle_polar)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (coeff_cube_to_path circle_top_edge)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)}", "unfolding chain_reparam_weak_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set l =\n       {subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)} \\<and>\n       distinct l \\<and>\n       reparam (coeff_cube_to_path circle_top_edge) (rec_join l) \\<and>\n       valid_chain_list l \\<and> l \\<noteq> []", "proof (intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. set ?l =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)}\n 2. distinct ?l\n 3. reparam (coeff_cube_to_path circle_top_edge) (rec_join ?l)\n 4. valid_chain_list ?l\n 5. ?l \\<noteq> []", "show \"valid_chain_list ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)]", "by (auto simp add: subcube_def circle_top_edge_def  x_coord_def circle_y_def pathfinish_def pathstart_def\n              reversepath_def subpath_def joinpaths_def)"], ["proof (state)\nthis:\n  valid_chain_list\n   [subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)]\n\ngoal (4 subgoals):\n 1. set [subcube 0 (1 / 4) (1, circle_polar),\n         subcube (1 / 4) (1 / 2) (1, circle_polar)] =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)}\n 2. distinct\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)]\n 3. reparam (coeff_cube_to_path circle_top_edge)\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])\n 4. [subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)] \\<noteq>\n    []", "show \"reparam (coeff_cube_to_path circle_top_edge) (rec_join ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path circle_top_edge)\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])", "using circ_top_edge_reparam_polar_circ_split"], ["proof (prove)\nusing this:\n  reparam (rec_join [circle_top_edge])\n   (rec_join\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)])\n\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path circle_top_edge)\n     (rec_join\n       [subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar)])", "by auto"], ["proof (state)\nthis:\n  reparam (coeff_cube_to_path circle_top_edge)\n   (rec_join\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)])\n\ngoal (3 subgoals):\n 1. set [subcube 0 (1 / 4) (1, circle_polar),\n         subcube (1 / 4) (1 / 2) (1, circle_polar)] =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)}\n 2. distinct\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)]\n 3. [subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)] \\<noteq>\n    []", "show \"distinct ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube 0 (1 / 4) (1, circle_polar) \\<noteq>\n    subcube (1 / 4) (1 / 2) (1, circle_polar)", "apply (subst neq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube (1 / 4) (1 / 2) (1, circle_polar) \\<noteq>\n    subcube 0 (1 / 4) (1, circle_polar)", "apply (simp add: circle_arcs_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct\n   [subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)]\n\ngoal (2 subgoals):\n 1. set [subcube 0 (1 / 4) (1, circle_polar),\n         subcube (1 / 4) (1 / 2) (1, circle_polar)] =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)}\n 2. [subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar)] \\<noteq>\n    []", "qed auto"], ["proof (state)\nthis:\n  chain_reparam_weak_path (coeff_cube_to_path circle_top_edge)\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "moreover"], ["proof (state)\nthis:\n  chain_reparam_weak_path (coeff_cube_to_path circle_top_edge)\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "have \"chain_reparam_weak_path (coeff_cube_to_path (circle_bot_edge)) {subcube (1/2) (3/4) (1, circle_polar), subcube (3/4) 1 (1, circle_polar)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (coeff_cube_to_path circle_bot_edge)\n     {subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}", "unfolding chain_reparam_weak_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set l =\n       {subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n       distinct l \\<and>\n       reparam (coeff_cube_to_path circle_bot_edge) (rec_join l) \\<and>\n       valid_chain_list l \\<and> l \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. set ?l =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct ?l \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge) (rec_join ?l) \\<and>\n    valid_chain_list ?l \\<and> ?l \\<noteq> []", "let ?l = \"[subcube (1/2) (3/4) (1, circle_polar), subcube (3/4) 1 (1, circle_polar)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. set ?l =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct ?l \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge) (rec_join ?l) \\<and>\n    valid_chain_list ?l \\<and> ?l \\<noteq> []", "have a: \"valid_chain_list ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)]", "by (auto simp add: subcube_def circle_top_edge_def  x_coord_def circle_y_def pathfinish_def pathstart_def\n              reversepath_def subpath_def joinpaths_def)"], ["proof (state)\nthis:\n  valid_chain_list\n   [subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)]\n\ngoal (1 subgoal):\n 1. set ?l =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct ?l \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge) (rec_join ?l) \\<and>\n    valid_chain_list ?l \\<and> ?l \\<noteq> []", "have b: \"reparam (rec_join [circle_bot_edge]) (rec_join ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])", "using circ_bot_edge_reparam_polar_circ_split"], ["proof (prove)\nusing this:\n  reparam (rec_join [circle_bot_edge])\n   (rec_join\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)])\n\ngoal (1 subgoal):\n 1. reparam (rec_join [circle_bot_edge])\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)])", "by auto"], ["proof (state)\nthis:\n  reparam (rec_join [circle_bot_edge])\n   (rec_join\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)])\n\ngoal (1 subgoal):\n 1. set ?l =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct ?l \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge) (rec_join ?l) \\<and>\n    valid_chain_list ?l \\<and> ?l \\<noteq> []", "have c: \"subcube (3/4) 1 (1, circle_polar) \\<noteq> subcube (1/2) (3/4) (1, circle_polar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube (3 / 4) 1 (1, circle_polar) \\<noteq>\n    subcube (1 / 2) (3 / 4) (1, circle_polar)", "apply(rule circle_arcs_neq_2)"], ["proof (prove)\ngoal (8 subgoals):\n 1. 0 \\<le> 3 / 4\n 2. 3 / 4 \\<le> 1\n 3. 0 \\<le> 1 / 2\n 4. 1 / 2 \\<le> 1\n 5. 1 / 2 < 3 / 4\n 6. 0 < 1 / 2\n 7. 1 / 2 < 3 / 4 + 1 / 2\n 8. 3 / 4 + 1 / 2 < 3 / 2", "using d_gt_0(1)"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (8 subgoals):\n 1. 0 \\<le> 3 / 4\n 2. 3 / 4 \\<le> 1\n 3. 0 \\<le> 1 / 2\n 4. 1 / 2 \\<le> 1\n 5. 1 / 2 < 3 / 4\n 6. 0 < 1 / 2\n 7. 1 / 2 < 3 / 4 + 1 / 2\n 8. 3 / 4 + 1 / 2 < 3 / 2", "by auto"], ["proof (state)\nthis:\n  subcube (3 / 4) 1 (1, circle_polar) \\<noteq>\n  subcube (1 / 2) (3 / 4) (1, circle_polar)\n\ngoal (1 subgoal):\n 1. set ?l =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct ?l \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge) (rec_join ?l) \\<and>\n    valid_chain_list ?l \\<and> ?l \\<noteq> []", "show \"set ?l = {subcube (1/2) (3/4) (1, circle_polar), subcube (3/4) 1 (1, circle_polar)} \\<and>\n                            distinct ?l \\<and> reparam (coeff_cube_to_path (circle_bot_edge)) (rec_join ?l) \\<and> valid_chain_list ?l \\<and> ?l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [subcube (1 / 2) (3 / 4) (1, circle_polar),\n         subcube (3 / 4) 1 (1, circle_polar)] =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge)\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)]) \\<and>\n    valid_chain_list\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n    [subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)] \\<noteq>\n    []", "using a b c"], ["proof (prove)\nusing this:\n  valid_chain_list\n   [subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)]\n  reparam (rec_join [circle_bot_edge])\n   (rec_join\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)])\n  subcube (3 / 4) 1 (1, circle_polar) \\<noteq>\n  subcube (1 / 2) (3 / 4) (1, circle_polar)\n\ngoal (1 subgoal):\n 1. set [subcube (1 / 2) (3 / 4) (1, circle_polar),\n         subcube (3 / 4) 1 (1, circle_polar)] =\n    {subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n    distinct\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n    reparam (coeff_cube_to_path circle_bot_edge)\n     (rec_join\n       [subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)]) \\<and>\n    valid_chain_list\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n    [subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)] \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  set [subcube (1 / 2) (3 / 4) (1, circle_polar),\n       subcube (3 / 4) 1 (1, circle_polar)] =\n  {subcube (1 / 2) (3 / 4) (1, circle_polar),\n   subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n  distinct\n   [subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n  reparam (coeff_cube_to_path circle_bot_edge)\n   (rec_join\n     [subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)]) \\<and>\n  valid_chain_list\n   [subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)] \\<and>\n  [subcube (1 / 2) (3 / 4) (1, circle_polar),\n   subcube (3 / 4) 1 (1, circle_polar)] \\<noteq>\n  []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_reparam_weak_path (coeff_cube_to_path circle_bot_edge)\n   {subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "ultimately"], ["proof (chain)\npicking this:\n  chain_reparam_weak_path (coeff_cube_to_path circle_top_edge)\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)}\n  chain_reparam_weak_path (coeff_cube_to_path circle_bot_edge)\n   {subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}", "show \"(\\<forall>cube\\<in>?one_chaini. chain_reparam_weak_path (rec_join [cube]) (?f cube))\""], ["proof (prove)\nusing this:\n  chain_reparam_weak_path (coeff_cube_to_path circle_top_edge)\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar)}\n  chain_reparam_weak_path (coeff_cube_to_path circle_bot_edge)\n   {subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (1 subgoal):\n 1. \\<forall>cube\n             \\<in>boundary circle_cube -\n                  {circle_left_edge, circle_right_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (circle_cube_boundary_to_polarcircle cube)", "by (auto simp add:  circle_cube_boundary_to_polarcircle_def UNION_eq circle_cube_boundary_explicit)"], ["proof (state)\nthis:\n  \\<forall>cube\n           \\<in>boundary circle_cube -\n                {circle_left_edge, circle_right_edge}.\n     chain_reparam_weak_path (rec_join [cube])\n      (circle_cube_boundary_to_polarcircle cube)\n\ngoal (2 subgoals):\n 1. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}\n 2. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "show \"(\\<forall>p\\<in>?one_chaini. \\<forall>p'\\<in>?one_chaini. p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}", "using circle_arcs_neq circle_arcs_neq_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?k; ?k \\<le> 1; 0 \\<le> ?n; ?n \\<le> 1; ?n < ?k;\n   ?k + ?n < 1\\<rbrakk>\n  \\<Longrightarrow> subcube ?k ?m (1, circle_polar) \\<noteq>\n                    subcube ?n ?q (1, circle_polar)\n  \\<lbrakk>0 \\<le> ?k; ?k \\<le> 1; 0 \\<le> ?n; ?n \\<le> 1; ?n < ?k; 0 < ?n;\n   1 / 2 < ?k + ?n; ?k + ?n < 3 / 2\\<rbrakk>\n  \\<Longrightarrow> subcube ?k ?m (1, circle_polar) \\<noteq>\n                    subcube ?n ?q (1, circle_polar)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       \\<forall>p'\\<in>boundary circle_cube -\n                       {circle_left_edge, circle_right_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          circle_cube_boundary_to_polarcircle p \\<inter>\n          circle_cube_boundary_to_polarcircle p' =\n          {}", "apply (auto simp add: circle_cube_boundary_to_polarcircle_def UNION_eq circle_cube_boundary_explicit neq_commute d_gt_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge = circle_top_edge\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (3 / 4) 1 (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube (1 / 4) (1 / 2) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "using circle_top_bot_edges_neq' d_gt_0"], ["proof (prove)\nusing this:\n  circle_top_edge \\<noteq> circle_bot_edge\n  0 < d\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge = circle_top_edge\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (3 / 4) 1 (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube (1 / 4) (1 / 2) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (3 / 4) 1 (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube (1 / 4) (1 / 2) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt atLeastAtMost_iff divide_less_eq_1_pos zero_less_divide_1_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (3 / 4) 1 (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube (1 / 4) (1 / 2) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt atLeastAtMost_iff divide_less_eq_1_pos zero_less_divide_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     circle_bot_edge \\<noteq> circle_top_edge;\n     subcube (1 / 4) (1 / 2) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt atLeastAtMost_iff divide_cancel_left divide_less_eq_1_pos field_sum_of_halves zero_less_divide_1_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>p\\<in>boundary circle_cube -\n                 {circle_left_edge, circle_right_edge}.\n     \\<forall>p'\\<in>boundary circle_cube -\n                     {circle_left_edge, circle_right_edge}.\n        p \\<noteq> p' \\<longrightarrow>\n        circle_cube_boundary_to_polarcircle p \\<inter>\n        circle_cube_boundary_to_polarcircle p' =\n        {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "show \"(\\<forall>x\\<in>?one_chaini. finite (?f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>boundary circle_cube -\n                   {circle_left_edge, circle_right_edge}.\n       finite (circle_cube_boundary_to_polarcircle x)", "by (auto simp add: circle_cube_boundary_to_polarcircle_def circle_cube_boundary_explicit)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>boundary circle_cube -\n                 {circle_left_edge, circle_right_edge}.\n     finite (circle_cube_boundary_to_polarcircle x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_reparam_chain'\n   (boundary circle_cube - {circle_left_edge, circle_right_edge})\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>(k, \\<gamma>)\\<in>{circle_left_edge, circle_right_edge}.\n       point_path \\<gamma>\n 3. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"(\\<forall>(k, \\<gamma>)\\<in>?pi. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>{circle_left_edge, circle_right_edge}.\n       point_path \\<gamma>", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>{circle_left_edge, circle_right_edge}.\n       point_path \\<gamma>", "by (auto simp add: point_path_def circle_left_edge_def circle_right_edge_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>{circle_left_edge, circle_right_edge}.\n     point_path \\<gamma>\n\ngoal (2 subgoals):\n 1. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "let ?f = \"rot_circle_cube_boundary_to_polarcircle\""], ["proof (state)\ngoal (2 subgoals):\n 1. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "let ?one_chain2.0 = \"two_chain_vertical_boundary {rot_circle_cube} - ?pj\""], ["proof (state)\ngoal (2 subgoals):\n 1. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} - ?ps2.2)\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"chain_reparam_chain' (two_chain_vertical_boundary {rot_circle_cube} - ?pj) ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_chain'\n     (two_chain_vertical_boundary {rot_circle_cube} -\n      {rot_circle_top_edge, rot_circle_bot_edge})\n     {subcube 0 (1 / 4) (1, circle_polar),\n      subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar),\n      subcube (3 / 4) 1 (1, circle_polar)}", "unfolding chain_reparam_chain'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union>\n        (f `\n         (two_chain_vertical_boundary {rot_circle_cube} -\n          {rot_circle_top_edge, rot_circle_bot_edge})) =\n       {subcube 0 (1 / 4) (1, circle_polar),\n        subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar),\n        subcube (3 / 4) 1 (1, circle_polar)} \\<and>\n       (\\<forall>cube\n                 \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                      {rot_circle_top_edge, rot_circle_bot_edge}.\n           chain_reparam_weak_path (rec_join [cube]) (f cube)) \\<and>\n       (\\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n           \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                           {rot_circle_top_edge, rot_circle_bot_edge}.\n              p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n       (\\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n           finite (f x))", "proof (intro exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (two_chain_vertical_boundary {rot_circle_cube} -\n       {rot_circle_top_edge, rot_circle_bot_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>cube\n             \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                  {rot_circle_top_edge, rot_circle_bot_edge}.\n       chain_reparam_weak_path (rec_join [cube]) (?f cube)\n 3. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (?f x)", "have rw: \"?one_chain2.0 = {rot_circle_left_edge, rot_circle_right_edge}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. two_chain_vertical_boundary {rot_circle_cube} -\n    {rot_circle_top_edge, rot_circle_bot_edge} =\n    {rot_circle_left_edge, rot_circle_right_edge}", "by(auto simp add: rot_circle_cube_vertical_boundary_explicit two_chain_vertical_boundary_def)"], ["proof (state)\nthis:\n  two_chain_vertical_boundary {rot_circle_cube} -\n  {rot_circle_top_edge, rot_circle_bot_edge} =\n  {rot_circle_left_edge, rot_circle_right_edge}\n\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (two_chain_vertical_boundary {rot_circle_cube} -\n       {rot_circle_top_edge, rot_circle_bot_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}\n 2. \\<forall>cube\n             \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                  {rot_circle_top_edge, rot_circle_bot_edge}.\n       chain_reparam_weak_path (rec_join [cube]) (?f cube)\n 3. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (?f x)", "show \"\\<Union> (?f ` ?one_chain2.0) = ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (rot_circle_cube_boundary_to_polarcircle `\n      (two_chain_vertical_boundary {rot_circle_cube} -\n       {rot_circle_top_edge, rot_circle_bot_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}", "using rot_circle_right_top_edges_neq'"], ["proof (prove)\nusing this:\n  rot_circle_right_edge \\<noteq> rot_circle_left_edge\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (rot_circle_cube_boundary_to_polarcircle `\n      (two_chain_vertical_boundary {rot_circle_cube} -\n       {rot_circle_top_edge, rot_circle_bot_edge})) =\n    {subcube 0 (1 / 4) (1, circle_polar),\n     subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar),\n     subcube (3 / 4) 1 (1, circle_polar)}", "by (auto simp add: rot_circle_cube_boundary_to_polarcircle_def rw)"], ["proof (state)\nthis:\n  \\<Union>\n   (rot_circle_cube_boundary_to_polarcircle `\n    (two_chain_vertical_boundary {rot_circle_cube} -\n     {rot_circle_top_edge, rot_circle_bot_edge})) =\n  {subcube 0 (1 / 4) (1, circle_polar),\n   subcube (1 / 4) (1 / 2) (1, circle_polar),\n   subcube (1 / 2) (3 / 4) (1, circle_polar),\n   subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (3 subgoals):\n 1. \\<forall>cube\n             \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                  {rot_circle_top_edge, rot_circle_bot_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (rot_circle_cube_boundary_to_polarcircle cube)\n 2. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_circle_cube_boundary_to_polarcircle p \\<inter>\n          rot_circle_cube_boundary_to_polarcircle p' =\n          {}\n 3. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (rot_circle_cube_boundary_to_polarcircle x)", "show \"(\\<forall>cube\\<in>?one_chain2.0. chain_reparam_weak_path (rec_join [cube]) (?f cube))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cube\n             \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                  {rot_circle_top_edge, rot_circle_bot_edge}.\n       chain_reparam_weak_path (rec_join [cube])\n        (rot_circle_cube_boundary_to_polarcircle cube)", "proof (clarsimp simp add: rot_circle_cube_boundary_to_polarcircle_def rw, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. chain_reparam_weak_path (coeff_cube_to_path rot_circle_left_edge)\n     {subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. chain_reparam_weak_path (coeff_cube_to_path rot_circle_right_edge)\n     {subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)}", "let ?l = \"[subcube (1/4) (1/2) (1, circle_polar), subcube (1/2) (3/4) (1, circle_polar)]\""], ["proof (state)\ngoal (2 subgoals):\n 1. chain_reparam_weak_path (coeff_cube_to_path rot_circle_left_edge)\n     {subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. chain_reparam_weak_path (coeff_cube_to_path rot_circle_right_edge)\n     {subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)}", "show \"chain_reparam_weak_path (coeff_cube_to_path (rot_circle_left_edge)) {subcube (1/4) (1/2) (1, circle_polar), subcube (1/2) (3/4) (1, circle_polar)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (coeff_cube_to_path rot_circle_left_edge)\n     {subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)}", "unfolding chain_reparam_weak_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set l =\n       {subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)} \\<and>\n       distinct l \\<and>\n       reparam (coeff_cube_to_path rot_circle_left_edge) (rec_join l) \\<and>\n       valid_chain_list l \\<and> l \\<noteq> []", "proof (intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. set ?l =\n    {subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. distinct ?l\n 3. reparam (coeff_cube_to_path rot_circle_left_edge) (rec_join ?l)\n 4. valid_chain_list ?l\n 5. ?l \\<noteq> []", "show \"valid_chain_list ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)]", "by (auto simp add: subcube_def pathfinish_def pathstart_def reversepath_def subpath_def joinpaths_def)"], ["proof (state)\nthis:\n  valid_chain_list\n   [subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar)]\n\ngoal (4 subgoals):\n 1. set [subcube (1 / 4) (1 / 2) (1, circle_polar),\n         subcube (1 / 2) (3 / 4) (1, circle_polar)] =\n    {subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. distinct\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)]\n 3. reparam (coeff_cube_to_path rot_circle_left_edge)\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])\n 4. [subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)] \\<noteq>\n    []", "show \"reparam (coeff_cube_to_path rot_circle_left_edge) (rec_join ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path rot_circle_left_edge)\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])", "using rot_circ_left_edge_reparam_polar_circ_split"], ["proof (prove)\nusing this:\n  reparam (rec_join [rot_circle_left_edge])\n   (rec_join\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)])\n\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path rot_circle_left_edge)\n     (rec_join\n       [subcube (1 / 4) (1 / 2) (1, circle_polar),\n        subcube (1 / 2) (3 / 4) (1, circle_polar)])", "by auto"], ["proof (state)\nthis:\n  reparam (coeff_cube_to_path rot_circle_left_edge)\n   (rec_join\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)])\n\ngoal (3 subgoals):\n 1. set [subcube (1 / 4) (1 / 2) (1, circle_polar),\n         subcube (1 / 2) (3 / 4) (1, circle_polar)] =\n    {subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. distinct\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)]\n 3. [subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)] \\<noteq>\n    []", "show \"distinct ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [subcube (1 / 4) (1 / 2) (1, circle_polar),\n      subcube (1 / 2) (3 / 4) (1, circle_polar)]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube (1 / 4) (1 / 2) (1, circle_polar) \\<noteq>\n    subcube (1 / 2) (3 / 4) (1, circle_polar)", "apply (subst neq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcube (1 / 2) (3 / 4) (1, circle_polar) \\<noteq>\n    subcube (1 / 4) (1 / 2) (1, circle_polar)", "apply (simp add: circle_arcs_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct\n   [subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar)]\n\ngoal (2 subgoals):\n 1. set [subcube (1 / 4) (1 / 2) (1, circle_polar),\n         subcube (1 / 2) (3 / 4) (1, circle_polar)] =\n    {subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)}\n 2. [subcube (1 / 4) (1 / 2) (1, circle_polar),\n     subcube (1 / 2) (3 / 4) (1, circle_polar)] \\<noteq>\n    []", "qed auto"], ["proof (state)\nthis:\n  chain_reparam_weak_path (coeff_cube_to_path rot_circle_left_edge)\n   {subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar)}\n\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (coeff_cube_to_path rot_circle_right_edge)\n     {subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)}", "show \"chain_reparam_weak_path (coeff_cube_to_path (rot_circle_right_edge)) {subcube (3/4) 1 (1, circle_polar), subcube 0 (1/4) (1, circle_polar)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (coeff_cube_to_path rot_circle_right_edge)\n     {subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)}", "unfolding chain_reparam_weak_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set l =\n       {subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)} \\<and>\n       distinct l \\<and>\n       reparam (coeff_cube_to_path rot_circle_right_edge)\n        (rec_join l) \\<and>\n       valid_chain_list l \\<and> l \\<noteq> []", "proof (intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. set ?l =\n    {subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)}\n 2. distinct ?l\n 3. reparam (coeff_cube_to_path rot_circle_right_edge) (rec_join ?l)\n 4. valid_chain_list ?l\n 5. ?l \\<noteq> []", "let ?l = \"[subcube (3/4) 1 (1, circle_polar), subcube 0 (1/4) (1, circle_polar)]\""], ["proof (state)\ngoal (5 subgoals):\n 1. set ?l =\n    {subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)}\n 2. distinct ?l\n 3. reparam (coeff_cube_to_path rot_circle_right_edge) (rec_join ?l)\n 4. valid_chain_list ?l\n 5. ?l \\<noteq> []", "show \"valid_chain_list ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)]", "by  (auto simp add: circle_polar_def subcube_def pathfinish_def pathstart_def\n                reversepath_def subpath_def joinpaths_def)"], ["proof (state)\nthis:\n  valid_chain_list\n   [subcube (3 / 4) 1 (1, circle_polar),\n    subcube 0 (1 / 4) (1, circle_polar)]\n\ngoal (4 subgoals):\n 1. set [subcube (3 / 4) 1 (1, circle_polar),\n         subcube 0 (1 / 4) (1, circle_polar)] =\n    {subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)}\n 2. distinct\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)]\n 3. reparam (coeff_cube_to_path rot_circle_right_edge)\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])\n 4. [subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)] \\<noteq>\n    []", "show \"reparam (coeff_cube_to_path rot_circle_right_edge) (rec_join ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path rot_circle_right_edge)\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "using rot_circ_right_edge_reparam_polar_circ_split"], ["proof (prove)\nusing this:\n  reparam (rec_join [rot_circle_right_edge])\n   (rec_join\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)])\n\ngoal (1 subgoal):\n 1. reparam (coeff_cube_to_path rot_circle_right_edge)\n     (rec_join\n       [subcube (3 / 4) 1 (1, circle_polar),\n        subcube 0 (1 / 4) (1, circle_polar)])", "by auto"], ["proof (state)\nthis:\n  reparam (coeff_cube_to_path rot_circle_right_edge)\n   (rec_join\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)])\n\ngoal (3 subgoals):\n 1. set [subcube (3 / 4) 1 (1, circle_polar),\n         subcube 0 (1 / 4) (1, circle_polar)] =\n    {subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)}\n 2. distinct\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)]\n 3. [subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)] \\<noteq>\n    []", "show \"distinct ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [subcube (3 / 4) 1 (1, circle_polar),\n      subcube 0 (1 / 4) (1, circle_polar)]", "by (simp add: circle_arcs_neq)"], ["proof (state)\nthis:\n  distinct\n   [subcube (3 / 4) 1 (1, circle_polar),\n    subcube 0 (1 / 4) (1, circle_polar)]\n\ngoal (2 subgoals):\n 1. set [subcube (3 / 4) 1 (1, circle_polar),\n         subcube 0 (1 / 4) (1, circle_polar)] =\n    {subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)}\n 2. [subcube (3 / 4) 1 (1, circle_polar),\n     subcube 0 (1 / 4) (1, circle_polar)] \\<noteq>\n    []", "qed auto"], ["proof (state)\nthis:\n  chain_reparam_weak_path (coeff_cube_to_path rot_circle_right_edge)\n   {subcube (3 / 4) 1 (1, circle_polar),\n    subcube 0 (1 / 4) (1, circle_polar)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cube\n           \\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                {rot_circle_top_edge, rot_circle_bot_edge}.\n     chain_reparam_weak_path (rec_join [cube])\n      (rot_circle_cube_boundary_to_polarcircle cube)\n\ngoal (2 subgoals):\n 1. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_circle_cube_boundary_to_polarcircle p \\<inter>\n          rot_circle_cube_boundary_to_polarcircle p' =\n          {}\n 2. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (rot_circle_cube_boundary_to_polarcircle x)", "show \"(\\<forall>p\\<in>?one_chain2.0. \\<forall>p'\\<in>?one_chain2.0. p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_circle_cube_boundary_to_polarcircle p \\<inter>\n          rot_circle_cube_boundary_to_polarcircle p' =\n          {}", "using circle_arcs_neq circle_arcs_neq_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?k; ?k \\<le> 1; 0 \\<le> ?n; ?n \\<le> 1; ?n < ?k;\n   ?k + ?n < 1\\<rbrakk>\n  \\<Longrightarrow> subcube ?k ?m (1, circle_polar) \\<noteq>\n                    subcube ?n ?q (1, circle_polar)\n  \\<lbrakk>0 \\<le> ?k; ?k \\<le> 1; 0 \\<le> ?n; ?n \\<le> 1; ?n < ?k; 0 < ?n;\n   1 / 2 < ?k + ?n; ?k + ?n < 3 / 2\\<rbrakk>\n  \\<Longrightarrow> subcube ?k ?m (1, circle_polar) \\<noteq>\n                    subcube ?n ?q (1, circle_polar)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                       {rot_circle_top_edge, rot_circle_bot_edge}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_circle_cube_boundary_to_polarcircle p \\<inter>\n          rot_circle_cube_boundary_to_polarcircle p' =\n          {}", "apply (auto simp add: rot_circle_cube_boundary_to_polarcircle_def neq_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     rot_circle_right_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_right_edge \\<noteq> rot_circle_top_edge;\n     rot_circle_left_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_left_edge \\<noteq> rot_circle_right_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 4) (1 / 2) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     rot_circle_right_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_right_edge \\<noteq> rot_circle_top_edge;\n     rot_circle_left_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_left_edge \\<noteq> rot_circle_right_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis add.right_neutral divide_less_eq_1_pos dual_order.order_iff_strict num.distinct(1) one_less_numeral_iff prod.sel(1) prod.sel(2) semiring_norm(68) subcube_def zero_less_divide_1_iff zero_less_numeral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k n m q.\n                \\<lbrakk>0 \\<le> n; n < k; k + n < 1\\<rbrakk>\n                \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                                  subcube n q (1, circle_polar);\n     \\<And>k n m q.\n        \\<lbrakk>k \\<le> 1; n < k; 0 < n; 1 < k * 2 + n * 2;\n         k * 2 + n * 2 < 3\\<rbrakk>\n        \\<Longrightarrow> subcube k m (1, circle_polar) \\<noteq>\n                          subcube n q (1, circle_polar);\n     rot_circle_right_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_right_edge \\<noteq> rot_circle_top_edge;\n     rot_circle_left_edge\n     \\<in> two_chain_vertical_boundary {rot_circle_cube};\n     rot_circle_left_edge \\<noteq> rot_circle_right_edge;\n     subcube 0 (1 / 4) (1, circle_polar) =\n     subcube (1 / 2) (3 / 4) (1, circle_polar)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt field_sum_of_halves)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>p\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                 {rot_circle_top_edge, rot_circle_bot_edge}.\n     \\<forall>p'\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                     {rot_circle_top_edge, rot_circle_bot_edge}.\n        p \\<noteq> p' \\<longrightarrow>\n        rot_circle_cube_boundary_to_polarcircle p \\<inter>\n        rot_circle_cube_boundary_to_polarcircle p' =\n        {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (rot_circle_cube_boundary_to_polarcircle x)", "show \"(\\<forall>x\\<in>?one_chain2.0. finite (?f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                   {rot_circle_top_edge, rot_circle_bot_edge}.\n       finite (rot_circle_cube_boundary_to_polarcircle x)", "by (auto simp add: rot_circle_cube_boundary_to_polarcircle_def UNION_eq rw)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>two_chain_vertical_boundary {rot_circle_cube} -\n                 {rot_circle_top_edge, rot_circle_bot_edge}.\n     finite (rot_circle_cube_boundary_to_polarcircle x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_reparam_chain'\n   (two_chain_vertical_boundary {rot_circle_cube} -\n    {rot_circle_top_edge, rot_circle_bot_edge})\n   {subcube 0 (1 / 4) (1, circle_polar),\n    subcube (1 / 4) (1 / 2) (1, circle_polar),\n    subcube (1 / 2) (3 / 4) (1, circle_polar),\n    subcube (3 / 4) 1 (1, circle_polar)}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>{rot_circle_top_edge, rot_circle_bot_edge}.\n       point_path \\<gamma>", "show \"(\\<forall>(k, \\<gamma>)\\<in>?pj. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>{rot_circle_top_edge, rot_circle_bot_edge}.\n       point_path \\<gamma>", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>{rot_circle_top_edge, rot_circle_bot_edge}.\n       point_path \\<gamma>", "by (auto simp add: point_path_def rot_circle_top_edge_def rot_circle_bot_edge_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>{rot_circle_top_edge, rot_circle_bot_edge}.\n     point_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  common_reparam_exists (boundary circle_cube)\n   (two_chain_vertical_boundary {rot_circle_cube})\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "then"], ["proof (chain)\npicking this:\n  common_reparam_exists (boundary circle_cube)\n   (two_chain_vertical_boundary {rot_circle_cube})", "show \"common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube}) (boundary circle_cube) \\<or>\n             common_reparam_exists (boundary circle_cube) (two_chain_vertical_boundary {rot_circle_cube})\""], ["proof (prove)\nusing this:\n  common_reparam_exists (boundary circle_cube)\n   (two_chain_vertical_boundary {rot_circle_cube})\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n     (boundary circle_cube) \\<or>\n    common_reparam_exists (boundary circle_cube)\n     (two_chain_vertical_boundary {rot_circle_cube})", "by blast"], ["proof (state)\nthis:\n  common_sudiv_exists (two_chain_vertical_boundary {rot_circle_cube})\n   (boundary circle_cube) \\<or>\n  common_reparam_exists (boundary circle_cube)\n   (two_chain_vertical_boundary {rot_circle_cube})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma GreenThm_cirlce:\n  assumes \"\\<forall>twoC\\<in>{circle_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\"\n    \"\\<forall>twoC\\<in>{rot_circle_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\"\n  shows \"integral (cubeImage (circle_cube)) (\\<lambda>x. partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x - partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n                     one_chain_line_integral F {i, j} (boundary (circle_cube))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral (cubeImage circle_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary circle_cube)", "proof(rule green_typeI_typeII_chain.GreenThm_typeI_typeII_divisible_region_finite_holes[of \"(cubeImage (circle_cube))\" i j F \"{circle_cube}\" \"{rot_circle_cube}\",\n                            OF _ _ _ circle_cube_is_only_horizontal_div_of_rot _], auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube}\n     {rot_circle_cube}\n 2. \\<And>a b.\n       (a, b) \\<in> boundary circle_cube \\<Longrightarrow> valid_path b\n 3. only_vertical_division (boundary circle_cube) {circle_cube}", "show \"\\<And> a b. (a, b) \\<in> boundary circle_cube \\<Longrightarrow> valid_path b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> boundary circle_cube \\<Longrightarrow> valid_path b", "using circle_cube_boundary_valid"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary circle_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> boundary circle_cube \\<Longrightarrow> valid_path b", "by auto"], ["proof (state)\nthis:\n  (?a4, ?b4) \\<in> boundary circle_cube \\<Longrightarrow> valid_path ?b4\n\ngoal (2 subgoals):\n 1. green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube}\n     {rot_circle_cube}\n 2. only_vertical_division (boundary circle_cube) {circle_cube}", "show \"green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube} {rot_circle_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube}\n     {rot_circle_cube}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>twoC\\<in>{circle_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n  \\<forall>twoC\\<in>{rot_circle_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\n\ngoal (1 subgoal):\n 1. green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube}\n     {rot_circle_cube}", "proof(auto simp add: green_typeI_typeII_chain_def green_typeI_chain_def green_typeII_chain_def green_typeI_chain_axioms_def green_typeII_chain_axioms_def\n               intro!: circle_cube_is_type_I rot_circle_cube_is_type_II d_gt_0 R2_axioms)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> gen_division (cubeImage circle_cube)\n                       {cubeImage circle_cube}\n 2. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {circle_cube}\n 3. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> gen_division (cubeImage circle_cube)\n                       {cubeImage rot_circle_cube}\n 4. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {rot_circle_cube}", "show \"gen_division (cubeImage circle_cube) {cubeImage circle_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage circle_cube) {cubeImage circle_cube}", "by (simp add: gen_division_def)"], ["proof (state)\nthis:\n  gen_division (cubeImage circle_cube) {cubeImage circle_cube}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {circle_cube}\n 2. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> gen_division (cubeImage circle_cube)\n                       {cubeImage rot_circle_cube}\n 3. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {rot_circle_cube}", "show \"gen_division (cubeImage (circle_cube)) ({cubeImage rot_circle_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage circle_cube) {cubeImage rot_circle_cube}", "using rot_circle_div_circle d_gt_0"], ["proof (prove)\nusing this:\n  0 < d \\<Longrightarrow>\n  gen_division (cubeImage circle_cube) (cubeImage ` {rot_circle_cube})\n  0 < d\n\ngoal (1 subgoal):\n 1. gen_division (cubeImage circle_cube) {cubeImage rot_circle_cube}", "by auto"], ["proof (state)\nthis:\n  gen_division (cubeImage circle_cube) {cubeImage rot_circle_cube}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {circle_cube}\n 2. \\<lbrakk>analytically_valid (cubeImage circle_cube)\n              (\\<lambda>x. F x \\<bullet> i) j;\n     analytically_valid (cubeImage rot_circle_cube)\n      (\\<lambda>x. F x \\<bullet> j) i\\<rbrakk>\n    \\<Longrightarrow> valid_two_chain {rot_circle_cube}", "show \"valid_two_chain {rot_circle_cube}\" \"valid_two_chain {circle_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_chain {rot_circle_cube} &&& valid_two_chain {circle_cube}", "apply (auto simp add: valid_two_chain_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_two_cube rot_circle_cube\n 2. valid_two_cube circle_cube", "using rot_circle_cube_valid_two_cube circle_cube_valid_two_cube assms(1)"], ["proof (prove)\nusing this:\n  valid_two_cube rot_circle_cube\n  valid_two_cube circle_cube\n  \\<forall>twoC\\<in>{circle_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n\ngoal (2 subgoals):\n 1. valid_two_cube rot_circle_cube\n 2. valid_two_cube circle_cube", "by auto"], ["proof (state)\nthis:\n  valid_two_chain {rot_circle_cube}\n  valid_two_chain {circle_cube}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  green_typeI_typeII_chain (cubeImage circle_cube) i j F {circle_cube}\n   {rot_circle_cube}\n\ngoal (1 subgoal):\n 1. only_vertical_division (boundary circle_cube) {circle_cube}", "show \"only_vertical_division (boundary (circle_cube)) {circle_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. only_vertical_division (boundary circle_cube) {circle_cube}", "using twoChainVertDiv_of_itself[of \"{circle_cube}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {circle_cube};\n   \\<forall>(k, \\<gamma>)\\<in>two_chain_boundary {circle_cube}.\n      valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> only_vertical_division\n                     (two_chain_boundary {circle_cube}) {circle_cube}\n\ngoal (1 subgoal):\n 1. only_vertical_division (boundary circle_cube) {circle_cube}", "apply(simp add: two_chain_boundary_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>boundary circle_cube.\n        case x of (k, x) \\<Rightarrow> valid_path x \\<Longrightarrow>\n     only_vertical_division (boundary circle_cube)\n      {circle_cube}) \\<Longrightarrow>\n    only_vertical_division (boundary circle_cube) {circle_cube}", "using circle_cube_boundary_valid"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary circle_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>boundary circle_cube.\n        case x of (k, x) \\<Rightarrow> valid_path x \\<Longrightarrow>\n     only_vertical_division (boundary circle_cube)\n      {circle_cube}) \\<Longrightarrow>\n    only_vertical_division (boundary circle_cube) {circle_cube}", "by auto"], ["proof (state)\nthis:\n  only_vertical_division (boundary circle_cube) {circle_cube}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}