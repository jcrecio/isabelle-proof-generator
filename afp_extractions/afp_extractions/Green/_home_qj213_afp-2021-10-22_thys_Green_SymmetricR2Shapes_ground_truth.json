{"file_name": "/home/qj213/afp-2021-10-22/thys/Green/SymmetricR2Shapes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Green", "problem_names": ["lemma valid_path_valid_swap:\n  assumes \"valid_path (\\<lambda>x::real. ((f x)::real, (g x)::real))\"\n  shows \"valid_path (prod.swap o (\\<lambda>x. (f x, g x)))\"", "lemma pair_fun_components: \"C = (\\<lambda>x. (C x \\<bullet> i, C x \\<bullet> j))\"", "lemma swap_pair_fun: \"(\\<lambda>y. prod.swap (C (y, 0))) =  (\\<lambda>x. (C (x, 0) \\<bullet> j, C (x, 0) \\<bullet> i))\"", "lemma swap_pair_fun': \"(\\<lambda>y. prod.swap (C (y, 1))) =  (\\<lambda>x. (C (x, 1) \\<bullet> j, C (x, 1) \\<bullet> i))\"", "lemma swap_pair_fun'': \"(\\<lambda>y. prod.swap (C (0, y))) =  (\\<lambda>x. (C (0,x) \\<bullet> j, C (0,x) \\<bullet> i))\"", "lemma swap_pair_fun''': \"(\\<lambda>y. prod.swap (C (1, y))) =  (\\<lambda>x. (C (1,x) \\<bullet> j, C (1,x) \\<bullet> i))\"", "lemma swap_valid_boundaries:\n  assumes \"\\<forall>(k,\\<gamma>)\\<in>boundary C. valid_path \\<gamma>\"\n  assumes \"(k,\\<gamma>)\\<in>boundary (prod.swap o C o prod.swap)\"\n  shows \"valid_path \\<gamma>\"", "lemma prod_comp_eq: \n  assumes \"f = prod.swap o g\"\n  shows \"prod.swap o f  = g\"", "lemma swap_typeI_is_typeII:\n  assumes \"typeI_twoCube C\"\n  shows \"typeII_twoCube (prod.swap o C o prod.swap)\"", "lemma valid_cube_valid_swap:\n  assumes \"valid_two_cube C\"\n  shows \"valid_two_cube (prod.swap o C o prod.swap)\"", "lemma twoChainVertDiv_of_itself:\n  assumes \"finite C\"\n    \"\\<forall>(k, \\<gamma>)\\<in>(two_chain_boundary C). valid_path \\<gamma>\"\n  shows \"only_vertical_division (two_chain_boundary C) C\"", "lemma x_coord_smooth: \"x_coord C1_differentiable_on {a..b}\"", "lemma x_coord_bounds:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\"\n  shows \"-1/2 \\<le> x_coord x \\<and> x_coord x \\<le> 1/2\"", "lemma x_coord_img: \"x_coord ` {(0::real)..1} = {-1/2 .. 1/2}\"", "lemma x_coord_back_img: \"finite ({0..1} \\<inter> x_coord -` {x::real})\"", "lemma rot_x_ivl:\n  assumes \"0 \\<le> x\"\n    \"x \\<le> 1\"\n    \"0 \\<le> y\"\n    \"y \\<le> 1\" \n  shows \"0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1\""], "translations": [["", "lemma valid_path_valid_swap:\n  assumes \"valid_path (\\<lambda>x::real. ((f x)::real, (g x)::real))\"\n  shows \"valid_path (prod.swap o (\\<lambda>x. (f x, g x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (prod.swap \\<circ> (\\<lambda>x. (f x, g x)))", "unfolding o_def valid_path_def piecewise_C1_differentiable_on_def swap_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. (g x, f x)) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S)", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous_on {0..1} (\\<lambda>x. (g x, f x))\n 2. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "show \"continuous_on {0..1} (\\<lambda>x. (g x, f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. (g x, f x))", "using assms"], ["proof (prove)\nusing this:\n  valid_path (\\<lambda>x. (f x, g x))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. (g x, f x))", "using continuous_on_Pair continuous_on_componentwise[where f = \"(\\<lambda>x. (f x, g x))\"]"], ["proof (prove)\nusing this:\n  valid_path (\\<lambda>x. (f x, g x))\n  \\<lbrakk>continuous_on ?s ?f; continuous_on ?s ?g\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. (?f x, ?g x))\n  continuous_on ?S (\\<lambda>x. (f x, g x)) =\n  (\\<forall>i\\<in>Basis.\n      continuous_on ?S (\\<lambda>x. (f x, g x) \\<bullet> i))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. (g x, f x))", "by (auto simp add: real_pair_basis valid_path_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. (g x, f x))\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "show \"\\<exists>S. finite S \\<and> (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "obtain S where \"finite S\" and S: \"(\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>finite S;\n         (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  valid_path (\\<lambda>x. (f x, g x))\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>finite S;\n         (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: real_pair_basis valid_path_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  finite S\n  (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "have 0: \"f C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f C1_differentiable_on {0..1} - S", "using S assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\n  valid_path (\\<lambda>x. (f x, g x))\n\ngoal (1 subgoal):\n 1. f C1_differentiable_on {0..1} - S", "using C1_diff_components_2[of \"(1,0)\" \"(\\<lambda>x. (f x, g x))\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\n  valid_path (\\<lambda>x. (f x, g x))\n  \\<lbrakk>(1, 0) \\<in> Basis;\n   (\\<lambda>x. (f x, g x)) C1_differentiable_on ?s\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x.\n                        (f x, g x) \\<bullet> (1, 0)) C1_differentiable_on\n                    ?s\n\ngoal (1 subgoal):\n 1. f C1_differentiable_on {0..1} - S", "by (auto simp add: real_pair_basis algebra_simps)"], ["proof (state)\nthis:\n  f C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "have 1: \"g C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g C1_differentiable_on {0..1} - S", "using S assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\n  valid_path (\\<lambda>x. (f x, g x))\n\ngoal (1 subgoal):\n 1. g C1_differentiable_on {0..1} - S", "using C1_diff_components_2 [of \"(0,1)\", OF _ S] real_pair_basis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x)) C1_differentiable_on {0..1} - S\n  valid_path (\\<lambda>x. (f x, g x))\n  (0, 1) \\<in> Basis \\<Longrightarrow>\n  (\\<lambda>x. (f x, g x) \\<bullet> (0, 1)) C1_differentiable_on {0..1} - S\n  Basis = {(1, 0), (0, 1)}\n\ngoal (1 subgoal):\n 1. g C1_differentiable_on {0..1} - S", "by fastforce"], ["proof (state)\nthis:\n  g C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "have *: \"(\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "using 0 1 C1_differentiable_on_components[where f = \"(\\<lambda>x. (g x, f x))\"]"], ["proof (prove)\nusing this:\n  f C1_differentiable_on {0..1} - S\n  g C1_differentiable_on {0..1} - S\n  (\\<And>i.\n      i \\<in> Basis \\<Longrightarrow>\n      (\\<lambda>x. (g x, f x) \\<bullet> i) C1_differentiable_on\n      ?s) \\<Longrightarrow>\n  (\\<lambda>x. (g x, f x)) C1_differentiable_on ?s\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "by (auto simp add: real_pair_basis valid_path_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "using \\<open>finite S\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\n  finite S\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S", "by auto"], ["proof (state)\nthis:\n  \\<exists>S.\n     finite S \\<and>\n     (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>S.\n     finite S \\<and>\n     (\\<lambda>x. (g x, f x)) C1_differentiable_on {0..1} - S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pair_fun_components: \"C = (\\<lambda>x. (C x \\<bullet> i, C x \\<bullet> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = (\\<lambda>x. (C x \\<bullet> i, C x \\<bullet> j))", "by (simp add: i_is_x_axis inner_Pair_0 j_is_y_axis)"], ["", "lemma swap_pair_fun: \"(\\<lambda>y. prod.swap (C (y, 0))) =  (\\<lambda>x. (C (x, 0) \\<bullet> j, C (x, 0) \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. prod.swap (C (y, 0::'b))) =\n    (\\<lambda>x. (C (x, 0::'b) \\<bullet> j, C (x, 0::'b) \\<bullet> i))", "by (simp add: prod.swap_def i_is_x_axis inner_Pair_0 j_is_y_axis)"], ["", "lemma swap_pair_fun': \"(\\<lambda>y. prod.swap (C (y, 1))) =  (\\<lambda>x. (C (x, 1) \\<bullet> j, C (x, 1) \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. prod.swap (C (y, 1::'b))) =\n    (\\<lambda>x. (C (x, 1::'b) \\<bullet> j, C (x, 1::'b) \\<bullet> i))", "by (simp add: prod.swap_def i_is_x_axis inner_Pair_0 j_is_y_axis)"], ["", "lemma swap_pair_fun'': \"(\\<lambda>y. prod.swap (C (0, y))) =  (\\<lambda>x. (C (0,x) \\<bullet> j, C (0,x) \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. prod.swap (C (0::'b, y))) =\n    (\\<lambda>x. (C (0::'b, x) \\<bullet> j, C (0::'b, x) \\<bullet> i))", "by (simp add: prod.swap_def i_is_x_axis inner_Pair_0 j_is_y_axis)"], ["", "lemma swap_pair_fun''': \"(\\<lambda>y. prod.swap (C (1, y))) =  (\\<lambda>x. (C (1,x) \\<bullet> j, C (1,x) \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. prod.swap (C (1::'b, y))) =\n    (\\<lambda>x. (C (1::'b, x) \\<bullet> j, C (1::'b, x) \\<bullet> i))", "by (simp add: prod.swap_def i_is_x_axis inner_Pair_0 j_is_y_axis)"], ["", "lemma swap_valid_boundaries:\n  assumes \"\\<forall>(k,\\<gamma>)\\<in>boundary C. valid_path \\<gamma>\"\n  assumes \"(k,\\<gamma>)\\<in>boundary (prod.swap o C o prod.swap)\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using assms\n    valid_path_valid_swap[of \"\\<lambda>x. (\\<lambda>x. C (x, 0)) x \\<bullet> i\" \"\\<lambda>x. (\\<lambda>x. C (x, 0)) x \\<bullet> j\"] pair_fun_components[of \"(\\<lambda>x. C (x, 0))\"]\n    pair_fun_components[of \"(\\<lambda>y. C (y, 0))\"]           \n    valid_path_valid_swap[of \"\\<lambda>x. (\\<lambda>y. C (y, 1)) x \\<bullet> i\" \"\\<lambda>x. (\\<lambda>y. C (y, 1)) x \\<bullet> j\"] pair_fun_components[of \"(\\<lambda>y. C (y, 1))\"]\n    pair_fun_components[of \"(\\<lambda>x. C (x, 1))\"]           \n    valid_path_valid_swap[of \"\\<lambda>x. (\\<lambda>y. C (1,y)) x \\<bullet> i\" \"\\<lambda>x. (\\<lambda>y. C (1,y)) x \\<bullet> j\"] pair_fun_components[of \"(\\<lambda>y. C (1,y))\"]\n    pair_fun_components[of \"(\\<lambda>x. C (1,x))\"]           \n    valid_path_valid_swap[of \"\\<lambda>x. (\\<lambda>y. C (0,y)) x \\<bullet> i\" \"\\<lambda>x. (\\<lambda>y. C (0,y)) x \\<bullet> j\"] pair_fun_components[of \"(\\<lambda>y. C (0,y))\"]\n    pair_fun_components[of \"(\\<lambda>x. C (0,x))\"]"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>boundary C. valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> boundary (prod.swap \\<circ> C \\<circ> prod.swap)\n  valid_path\n   (\\<lambda>x.\n       (C (x, 0) \\<bullet> i, C (x, 0) \\<bullet> j)) \\<Longrightarrow>\n  valid_path\n   (prod.swap \\<circ>\n    (\\<lambda>x. (C (x, 0) \\<bullet> i, C (x, 0) \\<bullet> j)))\n  (\\<lambda>x. C (x, 0)) =\n  (\\<lambda>x. (C (x, 0) \\<bullet> i, C (x, 0) \\<bullet> j))\n  (\\<lambda>y. C (y, 0)) =\n  (\\<lambda>x. (C (x, 0) \\<bullet> i, C (x, 0) \\<bullet> j))\n  valid_path\n   (\\<lambda>x.\n       (C (x, 1) \\<bullet> i, C (x, 1) \\<bullet> j)) \\<Longrightarrow>\n  valid_path\n   (prod.swap \\<circ>\n    (\\<lambda>x. (C (x, 1) \\<bullet> i, C (x, 1) \\<bullet> j)))\n  (\\<lambda>y. C (y, 1)) =\n  (\\<lambda>x. (C (x, 1) \\<bullet> i, C (x, 1) \\<bullet> j))\n  (\\<lambda>x. C (x, 1)) =\n  (\\<lambda>x. (C (x, 1) \\<bullet> i, C (x, 1) \\<bullet> j))\n  valid_path\n   (\\<lambda>x.\n       (C (1, x) \\<bullet> i, C (1, x) \\<bullet> j)) \\<Longrightarrow>\n  valid_path\n   (prod.swap \\<circ>\n    (\\<lambda>x. (C (1, x) \\<bullet> i, C (1, x) \\<bullet> j)))\n  (\\<lambda>y. C (1, y)) =\n  (\\<lambda>x. (C (1, x) \\<bullet> i, C (1, x) \\<bullet> j))\n  (\\<lambda>x. C (1, x)) =\n  (\\<lambda>x. (C (1, x) \\<bullet> i, C (1, x) \\<bullet> j))\n  valid_path\n   (\\<lambda>x.\n       (C (0, x) \\<bullet> i, C (0, x) \\<bullet> j)) \\<Longrightarrow>\n  valid_path\n   (prod.swap \\<circ>\n    (\\<lambda>x. (C (0, x) \\<bullet> i, C (0, x) \\<bullet> j)))\n  (\\<lambda>y. C (0, y)) =\n  (\\<lambda>x. (C (0, x) \\<bullet> i, C (0, x) \\<bullet> j))\n  (\\<lambda>x. C (0, x)) =\n  (\\<lambda>x. (C (0, x) \\<bullet> i, C (0, x) \\<bullet> j))\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by (auto simp add: boundary_def horizontal_boundary_def vertical_boundary_def\n       o_def real_pair_basis swap_pair_fun swap_pair_fun' swap_pair_fun'' swap_pair_fun''')"], ["", "lemma prod_comp_eq: \n  assumes \"f = prod.swap o g\"\n  shows \"prod.swap o f  = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.swap \\<circ> f = g", "using swap_comp_swap assms"], ["proof (prove)\nusing this:\n  prod.swap \\<circ> prod.swap = id\n  f = prod.swap \\<circ> g\n\ngoal (1 subgoal):\n 1. prod.swap \\<circ> f = g", "by fastforce"], ["", "lemma swap_typeI_is_typeII:\n  assumes \"typeI_twoCube C\"\n  shows \"typeII_twoCube (prod.swap o C o prod.swap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeII_twoCube (prod.swap \\<circ> C \\<circ> prod.swap)", "proof (simp add: typeI_twoCube_def typeII_twoCube_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a < b \\<and>\n       (\\<exists>g1 g2.\n           (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n           prod.swap \\<circ> C \\<circ> prod.swap =\n           (\\<lambda>(y, x).\n               ((1 - y) * g2 ((1 - x) * a + x * b) +\n                y * g1 ((1 - x) * a + x * b),\n                (1 - x) * a + x * b)) \\<and>\n           g1 piecewise_C1_differentiable_on {a..b} \\<and>\n           g2 piecewise_C1_differentiable_on {a..b})", "obtain a b g1 g2 where C: \" a < b \"\n    \"(\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \"\n    \"cubeImage C = {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}} \"\n    \"C = (\\<lambda>(x, y). ((1 - x) * a + x * b, (1 - y) * g2 ((1 - x) * a + x * b) + y * g1 ((1 - x) * a + x * b))) \"\n    \"g1 piecewise_C1_differentiable_on {a..b} \"\n    \"g2 piecewise_C1_differentiable_on {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b g2 g1.\n        \\<lbrakk>a < b; \\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x;\n         cubeImage C = {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}};\n         C =\n         (\\<lambda>(x, y).\n             ((1 - x) * a + x * b,\n              (1 - y) * g2 ((1 - x) * a + x * b) +\n              y * g1 ((1 - x) * a + x * b)));\n         g1 piecewise_C1_differentiable_on {a..b};\n         g2 piecewise_C1_differentiable_on {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using typeI_cube_explicit_spec[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>a b g1 g2.\n     a < b \\<and>\n     (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n     cubeImage C =\n     {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}} \\<and>\n     C =\n     (\\<lambda>(x, y).\n         ((1 - x) * a + x * b,\n          (1 - y) * g2 ((1 - x) * a + x * b) +\n          y * g1 ((1 - x) * a + x * b))) \\<and>\n     g1 piecewise_C1_differentiable_on {a..b} \\<and>\n     g2 piecewise_C1_differentiable_on {a..b} \\<and>\n     (\\<lambda>x. C (x, 0)) =\n     (\\<lambda>x. (a + (b - a) * x, g2 (a + (b - a) * x))) \\<and>\n     (\\<lambda>y. C (1, y)) =\n     (\\<lambda>x. (b, g2 b + x *\\<^sub>R (g1 b - g2 b))) \\<and>\n     (\\<lambda>x. C (x, 1)) =\n     (\\<lambda>x. (a + (b - a) * x, g1 (a + (b - a) * x))) \\<and>\n     (\\<lambda>y. C (0, y)) =\n     (\\<lambda>x. (a, g2 a + x *\\<^sub>R (g1 a - g2 a)))\n\ngoal (1 subgoal):\n 1. (\\<And>a b g2 g1.\n        \\<lbrakk>a < b; \\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x;\n         cubeImage C = {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}};\n         C =\n         (\\<lambda>(x, y).\n             ((1 - x) * a + x * b,\n              (1 - y) * g2 ((1 - x) * a + x * b) +\n              y * g1 ((1 - x) * a + x * b)));\n         g1 piecewise_C1_differentiable_on {a..b};\n         g2 piecewise_C1_differentiable_on {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a < b\n  \\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x\n  cubeImage C = {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}}\n  C =\n  (\\<lambda>(x, y).\n      ((1 - x) * a + x * b,\n       (1 - y) * g2 ((1 - x) * a + x * b) + y * g1 ((1 - x) * a + x * b)))\n  g1 piecewise_C1_differentiable_on {a..b}\n  g2 piecewise_C1_differentiable_on {a..b}\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a < b \\<and>\n       (\\<exists>g1 g2.\n           (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n           prod.swap \\<circ> C \\<circ> prod.swap =\n           (\\<lambda>(y, x).\n               ((1 - y) * g2 ((1 - x) * a + x * b) +\n                y * g1 ((1 - x) * a + x * b),\n                (1 - x) * a + x * b)) \\<and>\n           g1 piecewise_C1_differentiable_on {a..b} \\<and>\n           g2 piecewise_C1_differentiable_on {a..b})", "show \"\\<exists>a b. a < b \\<and>\n              (\\<exists>g1 g2. (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n                  prod.swap \\<circ> C \\<circ> prod.swap =\n                  (\\<lambda>(y, x). ((1 - y) * g2 ((1 - x) * a + x * b) + y * g1 ((1 - x) * a + x * b), (1 - x) * a + x * b)) \\<and>\n                  g1 piecewise_C1_differentiable_on {a..b} \\<and> g2 piecewise_C1_differentiable_on {a..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a < b \\<and>\n       (\\<exists>g1 g2.\n           (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n           prod.swap \\<circ> C \\<circ> prod.swap =\n           (\\<lambda>(y, x).\n               ((1 - y) * g2 ((1 - x) * a + x * b) +\n                y * g1 ((1 - x) * a + x * b),\n                (1 - x) * a + x * b)) \\<and>\n           g1 piecewise_C1_differentiable_on {a..b} \\<and>\n           g2 piecewise_C1_differentiable_on {a..b})", "using C"], ["proof (prove)\nusing this:\n  a < b\n  \\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x\n  cubeImage C = {(x, y). x \\<in> {a..b} \\<and> y \\<in> {g2 x..g1 x}}\n  C =\n  (\\<lambda>(x, y).\n      ((1 - x) * a + x * b,\n       (1 - y) * g2 ((1 - x) * a + x * b) + y * g1 ((1 - x) * a + x * b)))\n  g1 piecewise_C1_differentiable_on {a..b}\n  g2 piecewise_C1_differentiable_on {a..b}\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a < b \\<and>\n       (\\<exists>g1 g2.\n           (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n           prod.swap \\<circ> C \\<circ> prod.swap =\n           (\\<lambda>(y, x).\n               ((1 - y) * g2 ((1 - x) * a + x * b) +\n                y * g1 ((1 - x) * a + x * b),\n                (1 - x) * a + x * b)) \\<and>\n           g1 piecewise_C1_differentiable_on {a..b} \\<and>\n           g2 piecewise_C1_differentiable_on {a..b})", "by (fastforce simp add: prod.swap_def o_def)"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a < b \\<and>\n     (\\<exists>g1 g2.\n         (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n         prod.swap \\<circ> C \\<circ> prod.swap =\n         (\\<lambda>(y, x).\n             ((1 - y) * g2 ((1 - x) * a + x * b) +\n              y * g1 ((1 - x) * a + x * b),\n              (1 - x) * a + x * b)) \\<and>\n         g1 piecewise_C1_differentiable_on {a..b} \\<and>\n         g2 piecewise_C1_differentiable_on {a..b})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_cube_valid_swap:\n  assumes \"valid_two_cube C\"\n  shows \"valid_two_cube (prod.swap o C o prod.swap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_cube (prod.swap \\<circ> C \\<circ> prod.swap)", "using assms"], ["proof (prove)\nusing this:\n  valid_two_cube C\n\ngoal (1 subgoal):\n 1. valid_two_cube (prod.swap \\<circ> C \\<circ> prod.swap)", "unfolding valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def"], ["proof (prove)\nusing this:\n  card\n   ({(1, \\<lambda>x. C (x, 0)), (- 1, \\<lambda>x. C (x, 1))} \\<union>\n    {(- 1, \\<lambda>y. C (0, y)), (1, \\<lambda>y. C (1, y))}) =\n  4\n\ngoal (1 subgoal):\n 1. card\n     ({(1, \\<lambda>x. (prod.swap \\<circ> C \\<circ> prod.swap) (x, 0)),\n       (- 1,\n        \\<lambda>x.\n           (prod.swap \\<circ> C \\<circ> prod.swap) (x, 1))} \\<union>\n      {(- 1, \\<lambda>y. (prod.swap \\<circ> C \\<circ> prod.swap) (0, y)),\n       (1, \\<lambda>y. (prod.swap \\<circ> C \\<circ> prod.swap) (1, y))}) =\n    4", "apply (auto simp: card_insert_if  split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>y. C (0, y)) \\<noteq> (\\<lambda>x. C (x, 1));\n     (\\<lambda>y. C (1, y)) \\<noteq> (\\<lambda>x. C (x, 0));\n     (\\<lambda>y. prod.swap (C (y, 1))) =\n     (\\<lambda>x. prod.swap (C (0, x)))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(\\<lambda>y. C (0, y)) \\<noteq> (\\<lambda>x. C (x, 1));\n     (\\<lambda>y. C (1, y)) \\<noteq> (\\<lambda>x. C (x, 0));\n     (\\<lambda>y. prod.swap (C (y, 1))) \\<noteq>\n     (\\<lambda>x. prod.swap (C (0, x)));\n     (\\<lambda>y. prod.swap (C (y, 0))) =\n     (\\<lambda>x. prod.swap (C (1, x)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis swap_swap)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma twoChainVertDiv_of_itself:\n  assumes \"finite C\"\n    \"\\<forall>(k, \\<gamma>)\\<in>(two_chain_boundary C). valid_path \\<gamma>\"\n  shows \"only_vertical_division (two_chain_boundary C) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. only_vertical_division (two_chain_boundary C) C", "proof(clarsimp simp add: only_vertical_division_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<V> \\<H>.\n       finite \\<H> \\<and>\n       finite \\<V> \\<and>\n       (\\<forall>x\\<in>\\<V>.\n           case x of\n           (k, \\<gamma>) \\<Rightarrow>\n             \\<exists>x\\<in>two_chain_vertical_boundary C.\n                case x of\n                (k', \\<gamma>') \\<Rightarrow>\n                  \\<exists>a\\<in>{0..1}.\n                     \\<exists>b\\<in>{0..1}.\n                        a \\<le> b \\<and>\n                        subpath a b \\<gamma>' = \\<gamma>) \\<and>\n       (common_sudiv_exists (two_chain_horizontal_boundary C) \\<H> \\<or>\n        common_reparam_exists \\<H> (two_chain_horizontal_boundary C)) \\<and>\n       boundary_chain \\<H> \\<and>\n       two_chain_boundary C = \\<V> \\<union> \\<H> \\<and>\n       (\\<forall>x\\<in>\\<H>.\n           case x of (k, \\<gamma>) \\<Rightarrow> valid_path \\<gamma>)", "show \"\\<exists>\\<V> \\<H>. finite \\<H> \\<and> finite \\<V> \\<and>\n              (\\<forall>x\\<in>\\<V>. case x of (k, \\<gamma>) \\<Rightarrow> \\<exists>x\\<in>two_chain_vertical_boundary C. case x of (k', \\<gamma>') \\<Rightarrow> \\<exists>a\\<in>{0..1}. \\<exists>b\\<in>{0..1}. a \\<le> b \\<and> subpath a b \\<gamma>' = \\<gamma>) \\<and>\n              (common_sudiv_exists (two_chain_horizontal_boundary C) \\<H> \\<or>\n               common_reparam_exists \\<H> (two_chain_horizontal_boundary C)) \\<and>\n              boundary_chain \\<H> \\<and> two_chain_boundary C = \\<V> \\<union> \\<H> \\<and> (\\<forall>(k,\\<gamma>)\\<in>\\<H>. valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<V> \\<H>.\n       finite \\<H> \\<and>\n       finite \\<V> \\<and>\n       (\\<forall>x\\<in>\\<V>.\n           case x of\n           (k, \\<gamma>) \\<Rightarrow>\n             \\<exists>x\\<in>two_chain_vertical_boundary C.\n                case x of\n                (k', \\<gamma>') \\<Rightarrow>\n                  \\<exists>a\\<in>{0..1}.\n                     \\<exists>b\\<in>{0..1}.\n                        a \\<le> b \\<and>\n                        subpath a b \\<gamma>' = \\<gamma>) \\<and>\n       (common_sudiv_exists (two_chain_horizontal_boundary C) \\<H> \\<or>\n        common_reparam_exists \\<H> (two_chain_horizontal_boundary C)) \\<and>\n       boundary_chain \\<H> \\<and>\n       two_chain_boundary C = \\<V> \\<union> \\<H> \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>\\<H>. valid_path \\<gamma>)", "proof (intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "let ?\\<H> = \"two_chain_horizontal_boundary C\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have 0: \"\\<forall>(k,\\<gamma>)\\<in>?\\<H>. valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n       valid_path \\<gamma>", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>two_chain_boundary C. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n       valid_path \\<gamma>", "by (auto simp add: two_chain_horizontal_boundary_def two_chain_boundary_def boundary_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n     valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"\\<And>a b. (a, b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n                  \\<exists>x\\<in>two_chain_vertical_boundary C. case x of (k', \\<gamma>') \\<Rightarrow> \\<exists>a\\<in>{0..1}. \\<exists>c\\<in>{0..1}. a \\<le> c \\<and> subpath a c \\<gamma>' = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n       \\<exists>x\\<in>two_chain_vertical_boundary C.\n          case x of\n          (k', \\<gamma>') \\<Rightarrow>\n            \\<exists>a\\<in>{0..1}.\n               \\<exists>c\\<in>{0..1}.\n                  a \\<le> c \\<and> subpath a c \\<gamma>' = b", "by (metis (mono_tags, lifting) atLeastAtMost_iff case_prod_conv le_numeral_extra(1) order_refl subpath_trivial)"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  \\<exists>x\\<in>two_chain_vertical_boundary C.\n     case x of\n     (k', \\<gamma>') \\<Rightarrow>\n       \\<exists>a\\<in>{0..1}.\n          \\<exists>c\\<in>{0..1}. a \\<le> c \\<and> subpath a c \\<gamma>' = ?b\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "moreover"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  \\<exists>x\\<in>two_chain_vertical_boundary C.\n     case x of\n     (k', \\<gamma>') \\<Rightarrow>\n       \\<exists>a\\<in>{0..1}.\n          \\<exists>c\\<in>{0..1}. a \\<le> c \\<and> subpath a c \\<gamma>' = ?b\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"common_sudiv_exists ?\\<H> ?\\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_horizontal_boundary C)\n     (two_chain_horizontal_boundary C)", "using gen_common_boundary_subdiv_exists_refl_twochain_boundary[OF 0 two_chain_horizontal_boundary_is_boundary_chain]"], ["proof (prove)\nusing this:\n  common_sudiv_exists (two_chain_horizontal_boundary C)\n   (two_chain_horizontal_boundary C)\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_horizontal_boundary C)\n     (two_chain_horizontal_boundary C)", "by auto"], ["proof (state)\nthis:\n  common_sudiv_exists (two_chain_horizontal_boundary C)\n   (two_chain_horizontal_boundary C)\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "moreover"], ["proof (state)\nthis:\n  common_sudiv_exists (two_chain_horizontal_boundary C)\n   (two_chain_horizontal_boundary C)\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"boundary_chain ?\\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (two_chain_horizontal_boundary C)", "using two_chain_horizontal_boundary_is_boundary_chain"], ["proof (prove)\nusing this:\n  boundary_chain (two_chain_horizontal_boundary ?twoChain)\n\ngoal (1 subgoal):\n 1. boundary_chain (two_chain_horizontal_boundary C)", "by auto"], ["proof (state)\nthis:\n  boundary_chain (two_chain_horizontal_boundary C)\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "moreover"], ["proof (state)\nthis:\n  boundary_chain (two_chain_horizontal_boundary C)\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"\\<And>a b. (a, b) \\<in> two_chain_boundary C \\<Longrightarrow> (a, b) \\<notin> ?\\<H> \\<Longrightarrow> (a, b) \\<in> two_chain_vertical_boundary C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> two_chain_boundary C;\n        (a, b) \\<notin> two_chain_horizontal_boundary C\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> two_chain_vertical_boundary C", "by (auto simp add: two_chain_boundary_def two_chain_horizontal_boundary_def two_chain_vertical_boundary_def boundary_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> two_chain_boundary C;\n   (?a, ?b) \\<notin> two_chain_horizontal_boundary C\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> two_chain_vertical_boundary C\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?a, ?b) \\<in> two_chain_boundary C;\n   (?a, ?b) \\<notin> two_chain_horizontal_boundary C\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> two_chain_vertical_boundary C\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"\\<And>a b. (a, b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow> (a, b) \\<in> two_chain_boundary C\"\n      \"\\<And>a b. (a, b) \\<in> ?\\<H> \\<Longrightarrow> (a, b) \\<in> two_chain_boundary C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        (a, b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n        (a, b) \\<in> two_chain_boundary C) &&&\n    (\\<And>a b.\n        (a, b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n        (a, b) \\<in> two_chain_boundary C)", "by (auto simp add: two_chain_boundary_def two_chain_horizontal_boundary_def two_chain_vertical_boundary_def boundary_def)"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "moreover"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "have \"\\<And>a b. (a, b) \\<in> ?\\<H> \\<Longrightarrow> valid_path b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n       valid_path b", "using 0"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n     valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n       valid_path b", "by blast"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  valid_path ?b\n\ngoal (1 subgoal):\n 1. finite ?\\<H>1 \\<and>\n    finite ?\\<V> \\<and>\n    (\\<forall>x\\<in>?\\<V>.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C) ?\\<H>1 \\<or>\n     common_reparam_exists ?\\<H>1 (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain ?\\<H>1 \\<and>\n    two_chain_boundary C = ?\\<V> \\<union> ?\\<H>1 \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>?\\<H>1. valid_path \\<gamma>)", "ultimately"], ["proof (chain)\npicking this:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  \\<exists>x\\<in>two_chain_vertical_boundary C.\n     case x of\n     (k', \\<gamma>') \\<Rightarrow>\n       \\<exists>a\\<in>{0..1}.\n          \\<exists>c\\<in>{0..1}. a \\<le> c \\<and> subpath a c \\<gamma>' = ?b\n  common_sudiv_exists (two_chain_horizontal_boundary C)\n   (two_chain_horizontal_boundary C)\n  boundary_chain (two_chain_horizontal_boundary C)\n  \\<lbrakk>(?a, ?b) \\<in> two_chain_boundary C;\n   (?a, ?b) \\<notin> two_chain_horizontal_boundary C\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> two_chain_vertical_boundary C\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  valid_path ?b", "show \"finite ?\\<H> \\<and>\n           finite (two_chain_vertical_boundary C) \\<and>\n           (\\<forall>x\\<in>two_chain_vertical_boundary C.\n               case x of (k, \\<gamma>) \\<Rightarrow> \\<exists>x\\<in>two_chain_vertical_boundary C. case x of (k', \\<gamma>') \\<Rightarrow> \\<exists>a\\<in>{0..1}. \\<exists>b\\<in>{0..1}. a \\<le> b \\<and> subpath a b \\<gamma>' = \\<gamma>) \\<and>\n           (common_sudiv_exists ?\\<H> ?\\<H> \\<or>\n            common_reparam_exists ?\\<H> ?\\<H>) \\<and>\n           boundary_chain ?\\<H> \\<and> two_chain_boundary C = two_chain_vertical_boundary C \\<union> ?\\<H> \\<and> (\\<forall>(k,\\<gamma>)\\<in>?\\<H>. valid_path \\<gamma>)\""], ["proof (prove)\nusing this:\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  \\<exists>x\\<in>two_chain_vertical_boundary C.\n     case x of\n     (k', \\<gamma>') \\<Rightarrow>\n       \\<exists>a\\<in>{0..1}.\n          \\<exists>c\\<in>{0..1}. a \\<le> c \\<and> subpath a c \\<gamma>' = ?b\n  common_sudiv_exists (two_chain_horizontal_boundary C)\n   (two_chain_horizontal_boundary C)\n  boundary_chain (two_chain_horizontal_boundary C)\n  \\<lbrakk>(?a, ?b) \\<in> two_chain_boundary C;\n   (?a, ?b) \\<notin> two_chain_horizontal_boundary C\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> two_chain_vertical_boundary C\n  (?a, ?b) \\<in> two_chain_vertical_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  (?a, ?b) \\<in> two_chain_boundary C\n  (?a, ?b) \\<in> two_chain_horizontal_boundary C \\<Longrightarrow>\n  valid_path ?b\n\ngoal (1 subgoal):\n 1. finite (two_chain_horizontal_boundary C) \\<and>\n    finite (two_chain_vertical_boundary C) \\<and>\n    (\\<forall>x\\<in>two_chain_vertical_boundary C.\n        case x of\n        (k, \\<gamma>) \\<Rightarrow>\n          \\<exists>x\\<in>two_chain_vertical_boundary C.\n             case x of\n             (k', \\<gamma>') \\<Rightarrow>\n               \\<exists>a\\<in>{0..1}.\n                  \\<exists>b\\<in>{0..1}.\n                     a \\<le> b \\<and>\n                     subpath a b \\<gamma>' = \\<gamma>) \\<and>\n    (common_sudiv_exists (two_chain_horizontal_boundary C)\n      (two_chain_horizontal_boundary C) \\<or>\n     common_reparam_exists (two_chain_horizontal_boundary C)\n      (two_chain_horizontal_boundary C)) \\<and>\n    boundary_chain (two_chain_horizontal_boundary C) \\<and>\n    two_chain_boundary C =\n    two_chain_vertical_boundary C \\<union>\n    two_chain_horizontal_boundary C \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n        valid_path \\<gamma>)", "by (auto simp add: finite_two_chain_horizontal_boundary[OF assms(1)] finite_two_chain_vertical_boundary[OF assms(1)])"], ["proof (state)\nthis:\n  finite (two_chain_horizontal_boundary C) \\<and>\n  finite (two_chain_vertical_boundary C) \\<and>\n  (\\<forall>x\\<in>two_chain_vertical_boundary C.\n      case x of\n      (k, \\<gamma>) \\<Rightarrow>\n        \\<exists>x\\<in>two_chain_vertical_boundary C.\n           case x of\n           (k', \\<gamma>') \\<Rightarrow>\n             \\<exists>a\\<in>{0..1}.\n                \\<exists>b\\<in>{0..1}.\n                   a \\<le> b \\<and> subpath a b \\<gamma>' = \\<gamma>) \\<and>\n  (common_sudiv_exists (two_chain_horizontal_boundary C)\n    (two_chain_horizontal_boundary C) \\<or>\n   common_reparam_exists (two_chain_horizontal_boundary C)\n    (two_chain_horizontal_boundary C)) \\<and>\n  boundary_chain (two_chain_horizontal_boundary C) \\<and>\n  two_chain_boundary C =\n  two_chain_vertical_boundary C \\<union>\n  two_chain_horizontal_boundary C \\<and>\n  (\\<forall>(k, \\<gamma>)\\<in>two_chain_horizontal_boundary C.\n      valid_path \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<V> \\<H>.\n     finite \\<H> \\<and>\n     finite \\<V> \\<and>\n     (\\<forall>x\\<in>\\<V>.\n         case x of\n         (k, \\<gamma>) \\<Rightarrow>\n           \\<exists>x\\<in>two_chain_vertical_boundary C.\n              case x of\n              (k', \\<gamma>') \\<Rightarrow>\n                \\<exists>a\\<in>{0..1}.\n                   \\<exists>b\\<in>{0..1}.\n                      a \\<le> b \\<and>\n                      subpath a b \\<gamma>' = \\<gamma>) \\<and>\n     (common_sudiv_exists (two_chain_horizontal_boundary C) \\<H> \\<or>\n      common_reparam_exists \\<H> (two_chain_horizontal_boundary C)) \\<and>\n     boundary_chain \\<H> \\<and>\n     two_chain_boundary C = \\<V> \\<union> \\<H> \\<and>\n     (\\<forall>(k, \\<gamma>)\\<in>\\<H>. valid_path \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition x_coord where \"x_coord \\<equiv> (\\<lambda>t::real. t - 1/2)\""], ["", "lemma x_coord_smooth: \"x_coord C1_differentiable_on {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord C1_differentiable_on {a..b}", "by (simp add: x_coord_def)"], ["", "lemma x_coord_bounds:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\"\n  shows \"-1/2 \\<le> x_coord x \\<and> x_coord x \\<le> 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> x_coord x \\<and> x_coord x \\<le> 1 / 2", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. - 1 / 2 \\<le> x_coord x \\<and> x_coord x \\<le> 1 / 2", "by(auto simp add: x_coord_def)"], ["", "lemma x_coord_img: \"x_coord ` {(0::real)..1} = {-1/2 .. 1/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_coord ` {0..1} = {- 1 / 2..1 / 2}", "by (auto simp add: x_coord_def image_def algebra_simps)"], ["", "lemma x_coord_back_img: \"finite ({0..1} \\<inter> x_coord -` {x::real})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({0..1} \\<inter> x_coord -` {x})", "by (simp add: finite_vimageI inj_on_def x_coord_def)"], ["", "abbreviation \"rot_x t1 t2 \\<equiv> (if (t1 - 1/2) \\<le> 0 then (2 * t2 - 1) * t1 + 1/2 ::real else 2 * t2 - 2 * t1 * t2 +t1 -1/2::real)\""], ["", "lemma rot_x_ivl:\n  assumes \"0 \\<le> x\"\n    \"x \\<le> 1\"\n    \"0 \\<le> y\"\n    \"y \\<le> 1\" \n  shows \"0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "have i: \"\\<And>a::real. a \\<le> 0 \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> y \\<le> 1  \\<Longrightarrow> -1/2 < a \\<Longrightarrow> (a * (1 - 2*y) \\<le> 1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "have 0: \"\\<And>a::real. a \\<le> 0 \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> y \\<le> 1  \\<Longrightarrow> -1/2 < a \\<Longrightarrow> (-a \\<le> 1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> - a \\<le> 1 / 2", "by (sos \"((((A<0 * A<1) * R<1) + (R<1 * (R<1/4 * [2*a + 1]^2))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> - ?a \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "have 1: \"\\<And>a. a \\<le> 0 \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> y \\<le> 1  \\<Longrightarrow> -1/2 < a \\<Longrightarrow> (a * (1 - 2*y) \\<le> -a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> - a", "by (sos \"((((A<0 * A<1) * R<1) + (((A<=0 * (A<1 * R<1)) * (R<2/3 * [1]^2)) + (((A<=0 * (A<=2 * R<1)) * (R<2/3 * [1]^2)) + ((A<=0 * (A<=2 * (A<0 * R<1))) * (R<2/3 * [1]^2))))))\")"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * (1 - 2 * y) \\<le> - ?a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "show \"\\<And>a::real. a \\<le> 0 \\<Longrightarrow> 0 \\<le> y \\<Longrightarrow> y \\<le> 1 \\<Longrightarrow> -1/2 < a \\<Longrightarrow> (a * (1 - 2*y) \\<le> 1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "using 0 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> - ?a \\<le> 1 / 2\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * (1 - 2 * y) \\<le> - ?a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < a\\<rbrakk>\n       \\<Longrightarrow> a * (1 - 2 * y) \\<le> 1 / 2", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * (1 - 2 * y) \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?a * (1 - 2 * y) \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "have *: \"(x * 2 + y * 4 \\<le> 3 + x * (y * 4)) =  ( (x-1) \\<le> 1/2+ (x-1) * (y * 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * 2 + y * 4 \\<le> 3 + x * (y * 4)) =\n    (x - 1 \\<le> 1 / 2 + (x - 1) * (y * 2))", "by (sos \"((((A<0 * R<1) + ((A<=0 * R<1) * (R<2 * [1]^2)))) & (((A<0 * R<1) + ((A<=0 * R<1) * (R<1/2 * [1]^2)))))\")"], ["proof (state)\nthis:\n  (x * 2 + y * 4 \\<le> 3 + x * (y * 4)) =\n  (x - 1 \\<le> 1 / 2 + (x - 1) * (y * 2))\n\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1", "apply(auto simp add: algebra_simps divide_simps linorder_class.not_le)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> x * 2 \\<le> 1 + x * (y * 4)\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> x * (y * 4) \\<le> 1 + x * 2\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 + x * (y * 4) \\<le> x * 2 + y * 4\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> x * 2 + y * 4 \\<le> 3 + x * (y * 4)", "apply (sos \"(((A<0 * R<1) + (((A<=2 * (A<=3 * R<1)) * (R<1 * [1]^2)) + (((A<=1 * R<1) * (R<1 * [1]^2)) + ((A<=0 * (A<=1 * R<1)) * (R<2 * [1]^2))))))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> x * (y * 4) \\<le> 1 + x * 2\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 + x * (y * 4) \\<le> x * 2 + y * 4\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> x * 2 + y * 4 \\<le> 3 + x * (y * 4)", "apply (sos \"(((A<0 * R<1) + (((A<=2 * R<1) * (R<1 * [1]^2)) + (((A<=1 * (A<=3 * R<1)) * (R<1 * [1]^2)) + ((A<=0 * (A<=2 * R<1)) * (R<2 * [1]^2))))))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 + x * (y * 4) \\<le> x * 2 + y * 4\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> x * 2 + y * 4 \\<le> 3 + x * (y * 4)", "using i[of \"(x::real) - 1\"] affine_ineq"], ["proof (prove)\nusing this:\n  \\<lbrakk>x - 1 \\<le> 0; 0 \\<le> y; y \\<le> 1; - 1 / 2 < x - 1\\<rbrakk>\n  \\<Longrightarrow> (x - 1) * (1 - 2 * y) \\<le> 1 / 2\n  \\<lbrakk>?x \\<le> (1::?'a); ?v \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> ?v + ?x * ?u \\<le> ?u + ?x * ?v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 + x * (y * 4) \\<le> x * 2 + y * 4\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2\\<rbrakk>\n    \\<Longrightarrow> x * 2 + y * 4 \\<le> 3 + x * (y * 4)", "apply (fastforce simp: algebra_simps *)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 \\<le> rot_x x y \\<and> rot_x x y \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}