{"file_name": "/home/qj213/afp-2021-10-22/thys/Green/Paths.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Green", "problem_names": ["lemma reverse_subpaths_join:\n  shows \" subpath 1 (1 / 2) p +++ subpath (1 / 2) 0 p = reversepath p\"", "lemma line_integral_on_pair_straight_path:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> 'a\" and g :: \"real \\<Rightarrow> real\" and \\<gamma>\n  assumes gamma_const: \"\\<forall>x. \\<gamma>(x)\\<bullet> i = a\"\n      and gamma_smooth: \"\\<forall>x \\<in> {0 .. 1}. \\<gamma> differentiable at x\"          \n  shows \"(line_integral F {i} \\<gamma>) = 0\" \"(line_integral_exists F {i} \\<gamma>)\"", "lemma line_integral_on_pair_path_strong:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> ('a)\" and\n    g::\"real \\<Rightarrow> 'a\" and\n    \\<gamma>::\"(real \\<Rightarrow> 'a)\" and\n    i::'a \n  assumes i_norm_1: \"norm i = 1\" and\n    g_orthogonal_to_i: \"\\<forall>x. g(x) \\<bullet> i = 0\" and  \n    gamma_is_in_terms_of_i: \"\\<gamma> = (\\<lambda>x. f(x) *\\<^sub>R i + g(f(x)))\" and\n    gamma_smooth: \"\\<gamma> piecewise_C1_differentiable_on {0 .. 1}\" and\n    g_continuous_on_f: \"continuous_on (f ` {0..1}) g\" and\n    path_start_le_path_end: \"(pathstart \\<gamma>) \\<bullet> i \\<le> (pathfinish \\<gamma>) \\<bullet> i\" and\n    field_i_comp_cont: \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> i)\"\n  shows \"line_integral F {i} \\<gamma> \n         = integral (cbox ((pathstart \\<gamma>) \\<bullet> i) ((pathfinish \\<gamma>) \\<bullet> i)) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i))\"\n    \"line_integral_exists F {i} \\<gamma>\"", "lemma line_integral_on_pair_path:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> ('a)\" and\n    g::\"real \\<Rightarrow> 'a\" and\n    \\<gamma>::\"(real \\<Rightarrow> 'a)\" and\n    i::'a \n  assumes i_norm_1: \"norm i = 1\" and\n    g_orthogonal_to_i: \"\\<forall>x. g(x) \\<bullet> i = 0\" and  \n    gamma_is_in_terms_of_i: \"\\<gamma> = (\\<lambda>x. f(x) *\\<^sub>R i + g(f(x)))\" and\n    gamma_smooth: \"\\<gamma> C1_differentiable_on {0 .. 1}\" and\n    g_continuous_on_f: \"continuous_on (f ` {0..1}) g\" and\n    path_start_le_path_end: \"(pathstart \\<gamma>) \\<bullet> i \\<le> (pathfinish \\<gamma>) \\<bullet> i\" and\n    field_i_comp_cont: \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> i)\"\n  shows \"(line_integral F {i} \\<gamma>) \n                 = integral (cbox ((pathstart \\<gamma>) \\<bullet> i) ((pathfinish \\<gamma>) \\<bullet> i)) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i))\"", "lemma content_box_cases:\n  \"content (box a b) = (if \\<forall>i\\<in>Basis. a\\<bullet>i \\<le> b\\<bullet>i then prod (\\<lambda>i. b\\<bullet>i - a\\<bullet>i) Basis else 0)\"", "lemma content_box_cbox:\n  shows \"content (box a b) = content (cbox a b)\"", "lemma content_eq_0: \"content (box a b) = 0 \\<longleftrightarrow> (\\<exists>i\\<in>Basis. b\\<bullet>i \\<le> a\\<bullet>i)\"", "lemma content_pos_lt_eq: \"0 < content (cbox a (b::'a::euclidean_space)) \\<longleftrightarrow> (\\<forall>i\\<in>Basis. a\\<bullet>i < b\\<bullet>i)\"", "lemma content_lt_nz: \"0 < content (box a b) \\<longleftrightarrow> content (box a b) \\<noteq> 0\"", "lemma content_subset: \"cbox a b \\<subseteq> box c d \\<Longrightarrow> content (cbox a b) \\<le> content (box c d)\"", "lemma sum_content_null:\n  assumes \"content (box a b) = 0\"\n    and \"p tagged_division_of (box a b)\"\n  shows \"sum (\\<lambda>(x,k). content k *\\<^sub>R f x) p = (0::'a::real_normed_vector)\"", "lemma has_integral_null [intro]: \"content(box a b) = 0 \\<Longrightarrow> (f has_integral 0) (box a b)\"", "lemma line_integral_distrib:\n  assumes \"line_integral_exists f basis g1\"\n    \"line_integral_exists f basis g2\"\n    \"valid_path g1\" \"valid_path g2\"\n  shows \"line_integral f basis (g1 +++ g2) = line_integral f basis g1 + line_integral f basis g2\"\n    \"line_integral_exists f basis (g1 +++ g2)\"", "lemma line_integral_exists_joinD1:\n  assumes \"line_integral_exists f basis (g1 +++ g2)\" \"valid_path g1\"\n  shows \"line_integral_exists f basis g1\"", "lemma line_integral_exists_joinD2:\n  assumes \"line_integral_exists f basis (g1 +++ g2)\" \"valid_path g2\"\n  shows \"line_integral_exists f basis g2\"", "lemma has_line_integral_on_reverse_path:\n  assumes g: \"valid_path g\" and int:\n    \"((\\<lambda>x. \\<Sum>b\\<in>basis. F (g x) \\<bullet> b * (vector_derivative g (at x within {0..1}) \\<bullet> b)) has_integral c){0..1}\"\n  shows  \"((\\<lambda>x. \\<Sum>b\\<in>basis. F ((reversepath g) x) \\<bullet> b * (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet> b)) has_integral -c){0..1}\"", "lemma line_integral_on_reverse_path:\n  assumes \"valid_path \\<gamma>\" \"line_integral_exists F basis \\<gamma>\"\n  shows \"line_integral F basis \\<gamma> = - (line_integral F basis (reversepath \\<gamma>))\"\n        \"line_integral_exists F basis (reversepath \\<gamma>)\"", "lemma line_integral_exists_on_degenerate_path:\n  assumes \"finite basis\"\n  shows \"line_integral_exists F basis (\\<lambda>x. c)\"", "lemma degenerate_path_is_valid_path: \"valid_path (\\<lambda>x. c)\"", "lemma line_integral_degenerate_path:\n  assumes \"finite basis\"\n  shows \"line_integral F basis (\\<lambda>x. c) = 0\"", "lemma line_integral_point_path:\n  assumes \"point_path \\<gamma>\"\n  assumes \"finite basis\"\n  shows \"line_integral F basis \\<gamma> = 0\"", "lemma line_integral_exists_point_path:\n  assumes \"finite basis\" \"point_path \\<gamma>\"\n  shows \"line_integral_exists F basis \\<gamma>\"", "lemma line_integral_exists_subpath:\n  assumes f: \"line_integral_exists f basis g\" and g: \"valid_path g\"\n    and uv: \"u \\<in> {0..1}\" \"v \\<in> {0..1}\" \"u \\<le> v\"\n  shows \"(line_integral_exists f basis (subpath u v g))\"", "lemma joined_is_valid:\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    valid_chain_list_ass: \"valid_chain_list l\"\n  shows \"valid_path (rec_join l)\"", "lemma pathstart_rec_join_1:\n  \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\"", "lemma pathstart_rec_join_2:\n  \"pathstart (rec_join ((-1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\"", "lemma pathstart_rec_join:\n  \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\"\n  \"pathstart (rec_join ((-1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\"", "lemma line_integral_exists_on_rec_join:\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_chain_list: \"valid_chain_list l\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    line_integral_exists: \"\\<forall>(k, \\<gamma>) \\<in> set l. line_integral_exists F basis \\<gamma>\"\n  shows \"line_integral_exists F basis (rec_join l)\"", "lemma line_integral_exists_rec_join_cons:\n  assumes \"line_integral_exists F basis (rec_join ((1,\\<gamma>) # l))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis (\\<gamma> +++ (rec_join l))\"", "lemma line_integral_exists_rec_join_cons_2:\n  assumes \"line_integral_exists F basis (rec_join ((-1,\\<gamma>) # l))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis ((reversepath \\<gamma>) +++ (rec_join l))\"", "lemma line_integral_exists_on_rec_join':\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_chain_list: \"valid_chain_list l\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    line_integral_exists: \"line_integral_exists F basis (rec_join l)\" and\n    finite_basis: \"finite basis\"\n  shows \"\\<forall>(k, \\<gamma>) \\<in> set l. line_integral_exists F basis \\<gamma>\"", "lemma valid_path_equiv_valid_chain_list:\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" \n    and \"boundary_chain one_chain\" \"\\<forall>(k, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\"\n  shows \"valid_path \\<gamma>\"", "lemma line_integral_rec_join_cons:\n  assumes \"line_integral_exists F basis \\<gamma>\"\n    \"line_integral_exists F basis (rec_join ((l)))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral F basis (rec_join ((1,\\<gamma>) # l)) = line_integral F basis (\\<gamma> +++ (rec_join l))\"", "lemma line_integral_rec_join_cons_2:\n  assumes \"line_integral_exists F basis \\<gamma>\"\n    \"line_integral_exists F basis (rec_join ((l)))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((-1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral F basis (rec_join ((-1,\\<gamma>) # l)) = line_integral F basis ((reversepath \\<gamma>) +++ (rec_join l))\"", "lemma one_chain_line_integral_rec_join:\n  assumes l_props: \"set l = one_chain\" \"distinct l\" \"valid_chain_list l\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"line_integral F basis (rec_join l) = one_chain_line_integral F basis one_chain\"", "lemma line_integral_on_path_eq_line_integral_on_equiv_chain:\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\"\n    \"line_integral_exists F basis \\<gamma>\"\n    \"valid_path \\<gamma>\"", "lemma line_integral_on_path_eq_line_integral_on_equiv_chain':\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\"", "lemma chain_subdiv_chain_character:\n  shows \"chain_subdiv_chain one_chain1 subdiv \\<longleftrightarrow>\n        (\\<exists>f. \\<Union>(f ` one_chain1) = subdiv \\<and>\n             (\\<forall>(k, \\<gamma>)\\<in>one_chain1.\n                 if k = 1\n                 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n                 else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))) \\<and>\n             (\\<forall>p\\<in>one_chain1.\n                 \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n             (\\<forall>x\\<in>one_chain1. finite (f x)))\"", "lemma chain_subdiv_chain_imp_finite_subdiv:\n  assumes \"finite one_chain1\"\n    \"chain_subdiv_chain one_chain1 subdiv\"\n  shows \"finite subdiv\"", "lemma valid_subdiv_imp_valid_one_chain:\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\"\n  shows \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. valid_path \\<gamma>\"", "lemma one_chain_line_integral_eq_line_integral_on_sudivision:\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain2: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma one_chain_line_integral_eq_line_integral_on_sudivision':\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain1: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> subdiv. line_integral_exists F basis \\<gamma>\"", "lemma line_integral_sum_gen:\n  assumes finite_basis:\n    \"finite basis\" and\n    line_integral_exists:\n    \"line_integral_exists F basis1 \\<gamma>\"\n    \"line_integral_exists F basis2 \\<gamma>\" and\n    basis_partition:\n    \"basis1 \\<union> basis2 = basis\" \"basis1 \\<inter> basis2 = {}\"\n  shows \"line_integral F basis \\<gamma> = (line_integral F  basis1 \\<gamma>) + (line_integral F basis2 \\<gamma>)\"\n    \"line_integral_exists F basis \\<gamma>\"", "lemma common_boundary_sudivision_commutative:\n  \"(common_boundary_sudivision_exists one_chain1 one_chain2) = (common_boundary_sudivision_exists one_chain2 one_chain1)\"", "lemma common_subdivision_imp_eq_line_integral:\n  assumes \"(common_boundary_sudivision_exists one_chain1 one_chain2)\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"\n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\"", "lemma common_sudiv_exists_comm:\n  shows \"common_sudiv_exists C1 C2 = common_sudiv_exists C2 C1\"", "lemma line_integral_degenerate_chain:\n  assumes \"(\\<forall>(k, \\<gamma>) \\<in> chain. point_path \\<gamma>)\"\n  assumes \"finite basis\"\n  shows \"one_chain_line_integral F basis chain = 0\"", "lemma gen_common_subdiv_imp_common_subdiv:\n  shows \"(common_sudiv_exists one_chain1 one_chain2) = (\\<exists>ps1 ps2. (common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2)) \\<and> (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and> (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))\"", "lemma common_subdiv_imp_gen_common_subdiv:\n  assumes \"(common_boundary_sudivision_exists one_chain1 one_chain2)\"\n  shows \"(common_sudiv_exists one_chain1 one_chain2)\"", "lemma one_chain_line_integral_point_paths:\n  assumes \"finite one_chain\"\n  assumes \"finite basis\"\n  assumes \"(\\<forall>(k, \\<gamma>)\\<in>ps. point_path \\<gamma>)\"\n  shows \"one_chain_line_integral F basis (one_chain - ps) = one_chain_line_integral F basis (one_chain)\"", "lemma boundary_chain_diff:\n  assumes \"boundary_chain one_chain\"\n  shows \"boundary_chain (one_chain - s)\"", "lemma gen_common_subdivision_imp_eq_line_integral:\n  assumes \"(common_sudiv_exists one_chain1 one_chain2)\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"\n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\"", "lemma common_sudiv_exists_refl:\n      assumes \"common_sudiv_exists C1 C2\"\n      shows \"common_sudiv_exists C2 C1\"", "lemma chain_subdiv_path_singleton:\n  shows \"chain_subdiv_path \\<gamma> {(1,\\<gamma>)}\"", "lemma chain_subdiv_path_singleton_reverse:\n  shows \"chain_subdiv_path (reversepath \\<gamma>) {(-1,\\<gamma>)}\"", "lemma chain_subdiv_chain_refl:\n  assumes \"boundary_chain C\"\n  shows \"chain_subdiv_chain C C\"", "lemma reparam_weak_eq_refl:\n  shows \"reparam_weak \\<gamma>1 \\<gamma>1\"", "lemma line_integral_exists_smooth_one_base:\n  assumes \"\\<gamma> C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"line_integral_exists F {b} \\<gamma>\"", "lemma contour_integral_primitive_lemma:\n  fixes f :: \"complex \\<Rightarrow> complex\" and g :: \"real \\<Rightarrow> complex\"\n  assumes \"a \\<le> b\"\n      and \"\\<And>x. x \\<in> s \\<Longrightarrow> (f has_field_derivative f' x) (at x within s)\"\n      and \"g piecewise_differentiable_on {a..b}\"  \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> g x \\<in> s\"\n    shows \"((\\<lambda>x. f'(g x) * vector_derivative g (at x within {a..b}))\n             has_integral (f(g b) - f(g a))) {a..b}\"", "lemma line_integral_primitive_lemma: (*Only for real normed fields, i.e. vectors with products*)\n  fixes f :: \"'a::{euclidean_space,real_normed_field} \\<Rightarrow> 'a::{euclidean_space,real_normed_field}\" and\n        g :: \"real \\<Rightarrow> 'a\"\n  assumes \"\\<And>(a::'a). a \\<in> s \\<Longrightarrow> (f has_field_derivative (f' a)) (at a within s)\"\n      and \"g piecewise_differentiable_on {0::real..1}\"  \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> g x \\<in> s\"\n      and \"base_vec \\<in> Basis\"\n    shows \"((\\<lambda>x. ((f'(g x)) * (vector_derivative g (at x within {0..1}))) \\<bullet> base_vec)\n             has_integral (((f(g 1)) \\<bullet> base_vec - (f(g 0)) \\<bullet> base_vec))) {0..1}\"", "lemma reparam_eq_line_integrals:\n  assumes reparam: \"reparam \\<gamma>1 \\<gamma>2\" and\n    pw_smooth: \"\\<gamma>2 piecewise_C1_differentiable_on {0..1}\" and (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    cont: \"continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\" and\n    line_integral_ex: \"line_integral_exists F {b} \\<gamma>2\" (*We need to remove this and work on special cases like conservative fields and field/line combinations that satisfy the improper integrals theorem assumptions*)\n  shows \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\"\n    \"line_integral_exists F {b} \\<gamma>1\"", "lemma reparam_weak_eq_line_integrals:\n  assumes \"reparam_weak \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    \"continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\"\n    \"line_integral_exists F {b} \\<gamma>1\"", "lemma line_integral_sum_basis:\n  assumes \"finite (basis::('a::euclidean_space) set)\"  \"\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>\"\n  shows \"line_integral F basis \\<gamma> = (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\"\n        \"line_integral_exists F basis \\<gamma>\"", "lemma reparam_weak_eq_line_integrals_basis:\n  assumes \"reparam_weak \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities*)\n    \"\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n  shows \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\"\n    \"line_integral_exists F basis \\<gamma>1\"", "lemma reparam_eq_line_integrals_basis:\n  assumes \"reparam \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 piecewise_C1_differentiable_on {0..1}\" \n    \"\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n    \"\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\" (*We need to remove this and work on special cases like conservative fields and field/line combinations that satisfy the improper integrals theorem assumptions*)\n  shows \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\"\n    \"line_integral_exists F basis \\<gamma>1\"", "lemma line_integral_exists_smooth:\n  assumes \"\\<gamma> C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities*)\n    \"\\<forall>(b::'a::euclidean_space) \\<in>basis. continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis \\<gamma>\"", "lemma smooth_path_imp_reverse:\n  assumes \"g C1_differentiable_on {0..1}\"\n  shows \"(reversepath g) C1_differentiable_on {0..1}\"", "lemma piecewise_smooth_path_imp_reverse:\n  assumes \"g piecewise_C1_differentiable_on {0..1}\"\n  shows \"(reversepath g) piecewise_C1_differentiable_on {0..1}\"", "lemma chain_reparam_weak_chain_line_integral:\n  assumes \"chain_reparam_weak_chain one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 C1_differentiable_on {0..1}\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2.\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n  and bound1: \"boundary_chain one_chain1\"\n  and bound2: \"boundary_chain one_chain2\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma chain_reparam_chain_line_integral:\n  assumes \"chain_reparam_chain one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 piecewise_C1_differentiable_on {0..1}\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2.\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n  and bound1: \"boundary_chain one_chain1\"\n  and bound2: \"boundary_chain one_chain2\"\n  and line: \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. (\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma path_image_rec_join:\n  fixes \\<gamma>::\"real \\<Rightarrow> (real \\<times> real)\"\n  fixes k::int\n  fixes l\n  shows \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_chain_list l \\<Longrightarrow> path_image \\<gamma> \\<subseteq> path_image (rec_join l)\"", "lemma path_image_rec_join_2:\n  fixes l\n  shows \"l \\<noteq> [] \\<Longrightarrow> valid_chain_list l \\<Longrightarrow> path_image (rec_join l) \\<subseteq> (\\<Union>(k, \\<gamma>) \\<in> set l. path_image \\<gamma>)\"", "lemma continuous_on_closed_UN:\n  assumes \"finite S\"\n  shows \"((\\<And>s. s \\<in> S \\<Longrightarrow> closed s) \\<Longrightarrow> (\\<And>s. s \\<in> S \\<Longrightarrow> continuous_on s f) \\<Longrightarrow> continuous_on (\\<Union>S) f)\"", "lemma chain_reparam_weak_path_line_integral:\n  assumes path_eq_chain: \"chain_reparam_weak_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>b\\<in>basis. \\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F {b} \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\" and \n    cont: \"\\<forall>b\\<in>basis. \\<forall>(k,\\<gamma>2)\\<in>one_chain. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\" and\n    finite_one_chain: \"finite one_chain\"\n  shows \"line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\"\n    \"line_integral_exists F basis \\<gamma>\"", "lemma chain_reparam_chain'_imp_finite_subdiv:\n  assumes \"finite one_chain1\"\n    \"chain_reparam_chain' one_chain1 subdiv\"\n  shows \"finite subdiv\"", "lemma chain_reparam_chain'_line_integral:\n  assumes chain1_eq_chain2: \"chain_reparam_chain' one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain2: \"\\<forall>b\\<in>basis. \\<forall>(k::int, \\<gamma>) \\<in> subdiv. line_integral_exists F {b} \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    valid_path_2: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\" and\n    cont_field: \" \\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>2)\\<in>subdiv. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma chain_reparam_chain'_line_integral_smooth_cubes:\n  assumes \"chain_reparam_chain' one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 C1_differentiable_on {0..1}\"\n    \"\\<forall>b\\<in>basis.\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n    \"finite one_chain1\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k,\\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma chain_subdiv_path_pathimg_subset:\n  assumes \"chain_subdiv_path \\<gamma> subdiv\"\n  shows \"\\<forall>(k',\\<gamma>')\\<in>subdiv. (path_image \\<gamma>') \\<subseteq> path_image \\<gamma>\"", "lemma reparam_path_image:\n  assumes \"reparam \\<gamma>1 \\<gamma>2\"\n  shows \"path_image \\<gamma>1 = path_image \\<gamma>2\"", "lemma chain_reparam_weak_path_pathimg_subset:\n  assumes \"chain_reparam_weak_path \\<gamma> subdiv\"\n  shows \"\\<forall>(k',\\<gamma>')\\<in>subdiv. (path_image \\<gamma>') \\<subseteq> path_image \\<gamma>\"", "lemma chain_subdiv_chain_pathimg_subset':\n  assumes \"chain_subdiv_chain one_chain subdiv\"\n  assumes \"(k,\\<gamma>)\\<in> subdiv\"\n  shows \" \\<exists>k' \\<gamma>'. (k',\\<gamma>')\\<in> one_chain \\<and> path_image \\<gamma> \\<subseteq> path_image \\<gamma>'\"", "lemma chain_subdiv_chain_pathimg_subset:\n  assumes \"chain_subdiv_chain one_chain subdiv\"\n  shows \"\\<Union> (path_image ` {\\<gamma>. \\<exists>k. (k,\\<gamma>)\\<in> subdiv}) \\<subseteq> \\<Union> (path_image ` {\\<gamma>. \\<exists>k. (k,\\<gamma>)\\<in> one_chain})\"", "lemma chain_reparam_chain'_pathimg_subset':\n  assumes \"chain_reparam_chain' one_chain subdiv\"\n  assumes \"(k,\\<gamma>)\\<in> subdiv\"\n  shows \" \\<exists>k' \\<gamma>'. (k',\\<gamma>')\\<in> one_chain \\<and> path_image \\<gamma> \\<subseteq> path_image \\<gamma>'\"", "lemma common_reparam_exists_imp_eq_line_integral:\n  assumes finite_basis: \"finite basis\" and \n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"boundary_chain (one_chain1::(int \\<times> (real \\<Rightarrow> real \\<times> real)) set)\"\n    \"boundary_chain (one_chain2::(int \\<times> (real \\<Rightarrow> real \\<times> real)) set)\"\n    \" \\<forall>(k2, \\<gamma>2)\\<in>one_chain2. \\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"(common_reparam_exists one_chain1 one_chain2)\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>one_chain1.  valid_path \\<gamma>)\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>one_chain2.  valid_path \\<gamma>)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"", "lemma subcube_valid_path:\n  assumes \"valid_path (snd cube)\" \"a \\<in> {0..1}\" \"b \\<in> {0..1}\"\n  shows \"valid_path (snd (subcube a b cube))\""], "translations": [["", "lemma reverse_subpaths_join:\n  shows \" subpath 1 (1 / 2) p +++ subpath (1 / 2) 0 p = reversepath p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath 1 (1 / 2) p +++ subpath (1 / 2) 0 p = reversepath p", "using reversepath_subpath join_subpaths_middle pathfinish_subpath pathstart_subpath reversepath_joinpaths"], ["proof (prove)\nusing this:\n  reversepath (subpath ?u ?v ?g) = subpath ?v ?u ?g\n  subpath 0 (1 / 2) ?p +++ subpath (1 / 2) 1 ?p = ?p\n  pathfinish (subpath ?u ?v ?g) = ?g ?v\n  pathstart (subpath ?u ?v ?g) = ?g ?u\n  pathfinish ?g1.0 = pathstart ?g2.0 \\<Longrightarrow>\n  reversepath (?g1.0 +++ ?g2.0) = reversepath ?g2.0 +++ reversepath ?g1.0\n\ngoal (1 subgoal):\n 1. subpath 1 (1 / 2) p +++ subpath (1 / 2) 0 p = reversepath p", "by (metis (no_types, lifting))"], ["", "(*Below F cannot be from 'a \\<Rightarrow> 'b because the dot product won't work.\n  We have that g returns 'a and then F takes the output of g, so F should start from 'a\n  Then we have to compute the dot product of the vector b with both the derivative of g, and F.\n  Since the derivative of g returns the same type as g, accordingly F should return the same type as g, i.e. 'a.\n *)"], ["", "definition line_integral:: \"('a::euclidean_space \\<Rightarrow> 'a::euclidean_space) \\<Rightarrow> (('a) set) \\<Rightarrow> (real \\<Rightarrow> 'a) \\<Rightarrow> real\" where\n\"line_integral F basis g \\<equiv> integral {0 .. 1} (\\<lambda>x. \\<Sum>b\\<in>basis. (F(g x) \\<bullet> b) * (vector_derivative g (at x within {0..1}) \\<bullet> b))\""], ["", "definition line_integral_exists where\n  \"line_integral_exists F basis \\<gamma> \\<equiv> (\\<lambda>x. \\<Sum>b\\<in>basis. F(\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["", "lemma line_integral_on_pair_straight_path:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> 'a\" and g :: \"real \\<Rightarrow> real\" and \\<gamma>\n  assumes gamma_const: \"\\<forall>x. \\<gamma>(x)\\<bullet> i = a\"\n      and gamma_smooth: \"\\<forall>x \\<in> {0 .. 1}. \\<gamma> differentiable at x\"          \n  shows \"(line_integral F {i} \\<gamma>) = 0\" \"(line_integral_exists F {i} \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {i} \\<gamma> = 0 &&& line_integral_exists F {i} \\<gamma>", "proof (simp add: line_integral_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0\n 2. line_integral_exists F {i} \\<gamma>", "have *: \"F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) = 0\"\n    if \"0 \\<le> x \\<and> x \\<le> 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "have \"((\\<lambda>x. \\<gamma>(x)\\<bullet> i) has_vector_derivative 0) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)", "using vector_derivative_const_at[of \"a\" \"x\"] and gamma_const"], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. a) (at x) = 0\n  \\<forall>x. \\<gamma> x \\<bullet> i = a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)\n\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)", "have \"(vector_derivative \\<gamma> (at x) \\<bullet> i) = 0\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i = 0", "using derivative_component_fun_component[ of \"\\<gamma>\" \"x\" \"i\"]\n        and gamma_smooth and that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative 0) (at x)\n  \\<gamma> differentiable at x \\<Longrightarrow>\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x)\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i = 0", "by (simp add: vector_derivative_at)"], ["proof (state)\nthis:\n  vector_derivative \\<gamma> (at x) \\<bullet> i = 0\n\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "then"], ["proof (chain)\npicking this:\n  vector_derivative \\<gamma> (at x) \\<bullet> i = 0", "have \"(vector_derivative \\<gamma> (at x within {0 .. 1}) \\<bullet> i) = 0\""], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma> (at x) \\<bullet> i = 0\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i = 0", "using has_vector_derivative_at_within vector_derivative_at_within_ivl that"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma> (at x) \\<bullet> i = 0\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i = 0", "by (metis atLeastAtMost_iff gamma_smooth vector_derivative_works zero_less_one)"], ["proof (state)\nthis:\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i = 0\n\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "then"], ["proof (chain)\npicking this:\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i = 0\n\ngoal (1 subgoal):\n 1. F (\\<gamma> x) \\<bullet> i *\n    (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n    0", "by auto"], ["proof (state)\nthis:\n  F (\\<gamma> x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> ?x \\<and> ?x \\<le> 1 \\<Longrightarrow>\n  F (\\<gamma> ?x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at ?x within {0..1}) \\<bullet> i) =\n  0\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?x \\<and> ?x \\<le> 1 \\<Longrightarrow>\n  F (\\<gamma> ?x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at ?x within {0..1}) \\<bullet> i) =\n  0", "have \"((\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) has_integral 0) {0..1}\""], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<and> ?x \\<le> 1 \\<Longrightarrow>\n  F (\\<gamma> ?x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at ?x within {0..1}) \\<bullet> i) =\n  0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          i)) has_integral\n     0)\n     {0..1}", "using has_integral_is_0[of \"{0 .. 1}\" \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i))\"]"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<and> ?x \\<le> 1 \\<Longrightarrow>\n  F (\\<gamma> ?x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at ?x within {0..1}) \\<bullet> i) =\n  0\n  (\\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n      0) \\<Longrightarrow>\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          i)) has_integral\n     0)\n     {0..1}", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   0)\n   {0..1}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   0)\n   {0..1}", "have \"((\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) integrable_on {0..1})\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> i *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n         i)) integrable_on\n    {0..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}", "show \"line_integral_exists F {i} \\<gamma>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {i} \\<gamma>", "by (auto simp add:line_integral_exists_def)"], ["proof (state)\nthis:\n  line_integral_exists F {i} \\<gamma>\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0", "show \"integral {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0", "using * has_integral_is_0[of \"{0 .. 1}\" \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i))\"]"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<and> ?x \\<le> 1 \\<Longrightarrow>\n  F (\\<gamma> ?x) \\<bullet> i *\n  (vector_derivative \\<gamma> (at ?x within {0..1}) \\<bullet> i) =\n  0\n  (\\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n      0) \\<Longrightarrow>\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    0", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_on_pair_path_strong:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> ('a)\" and\n    g::\"real \\<Rightarrow> 'a\" and\n    \\<gamma>::\"(real \\<Rightarrow> 'a)\" and\n    i::'a \n  assumes i_norm_1: \"norm i = 1\" and\n    g_orthogonal_to_i: \"\\<forall>x. g(x) \\<bullet> i = 0\" and  \n    gamma_is_in_terms_of_i: \"\\<gamma> = (\\<lambda>x. f(x) *\\<^sub>R i + g(f(x)))\" and\n    gamma_smooth: \"\\<gamma> piecewise_C1_differentiable_on {0 .. 1}\" and\n    g_continuous_on_f: \"continuous_on (f ` {0..1}) g\" and\n    path_start_le_path_end: \"(pathstart \\<gamma>) \\<bullet> i \\<le> (pathfinish \\<gamma>) \\<bullet> i\" and\n    field_i_comp_cont: \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> i)\"\n  shows \"line_integral F {i} \\<gamma> \n         = integral (cbox ((pathstart \\<gamma>) \\<bullet> i) ((pathfinish \\<gamma>) \\<bullet> i)) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i))\"\n    \"line_integral_exists F {i} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {i} \\<gamma> =\n    integral\n     (cbox (pathstart \\<gamma> \\<bullet> i)\n       (pathfinish \\<gamma> \\<bullet> i))\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) &&&\n    line_integral_exists F {i} \\<gamma>", "proof (simp add: line_integral_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "obtain s where gamma_differentiable: \"finite s\" \"(\\<forall>x \\<in> {0 .. 1} - s. \\<gamma> differentiable at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s;\n         \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gamma_smooth"], ["proof (prove)\nusing this:\n  \\<gamma> piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s;\n         \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: C1_differentiable_on_eq piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  finite s\n  \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  finite s\n  \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x", "have gamma_i_component_smooth: \"\\<forall>x \\<in> {0 .. 1} - s. (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\""], ["proof (prove)\nusing this:\n  finite s\n  \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have field_cont_on_path: \"continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1}) (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have 0: \"(\\<lambda>x. \\<gamma> x \\<bullet> i) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma> x \\<bullet> i) = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<gamma> x \\<bullet> i = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<gamma> x \\<bullet> i = f x", "show \"\\<gamma> x \\<bullet> i = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> x \\<bullet> i = f x", "using g_orthogonal_to_i i_norm_1"], ["proof (prove)\nusing this:\n  \\<forall>x. g x \\<bullet> i = 0\n  norm i = 1\n\ngoal (1 subgoal):\n 1. \\<gamma> x \\<bullet> i = f x", "by (simp only: gamma_is_in_terms_of_i  real_inner_class.inner_add_left g_orthogonal_to_i inner_scaleR_left inner_same_Basis norm_eq_1)"], ["proof (state)\nthis:\n  \\<gamma> x \\<bullet> i = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<gamma> x \\<bullet> i) = f\n\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (f ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "apply (rule continuous_on_compose2 [of _ \"(\\<lambda>x. F(x)  \\<bullet> i)\" \"f ` { 0..1}\" \"(\\<lambda>x. x *\\<^sub>R i + g x)\"]\n          field_i_comp_cont g_continuous_on_f field_i_comp_cont continuous_intros)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f_var. f_var *\\<^sub>R i + g f_var) ` f ` {0..1}\n    \\<subseteq> path_image \\<gamma>", "by (auto simp add: gamma_is_in_terms_of_i path_image_def)"], ["proof (state)\nthis:\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have path_start_le_path_end': \"\\<gamma> 0 \\<bullet> i \\<le> \\<gamma> 1 \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> 0 \\<bullet> i \\<le> \\<gamma> 1 \\<bullet> i", "using path_start_le_path_end"], ["proof (prove)\nusing this:\n  pathstart \\<gamma> \\<bullet> i \\<le> pathfinish \\<gamma> \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<gamma> 0 \\<bullet> i \\<le> \\<gamma> 1 \\<bullet> i", "by (auto simp add: pathstart_def pathfinish_def)"], ["proof (state)\nthis:\n  \\<gamma> 0 \\<bullet> i \\<le> \\<gamma> 1 \\<bullet> i\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have gamm_cont: \"continuous_on {0..1} (\\<lambda>a. \\<gamma> a \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>a. \\<gamma> a \\<bullet> i)", "apply(rule continuous_on_inner)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..1} \\<gamma>\n 2. continuous_on {0..1} (\\<lambda>x. i)", "using gamma_smooth"], ["proof (prove)\nusing this:\n  \\<gamma> piecewise_C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. continuous_on {0..1} \\<gamma>\n 2. continuous_on {0..1} (\\<lambda>x. i)", "apply (simp add: piecewise_C1_differentiable_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. i)", "using continuous_on_const"], ["proof (prove)\nusing this:\n  continuous_on ?s (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. i)", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>a. \\<gamma> a \\<bullet> i)\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1} (\\<lambda>a. \\<gamma> a \\<bullet> i)", "obtain c d where cd: \"c \\<le> d\" \"(\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}\""], ["proof (prove)\nusing this:\n  continuous_on {0..1} (\\<lambda>a. \\<gamma> a \\<bullet> i)\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>c \\<le> d;\n         (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson continuous_image_closed_interval zero_le_one)"], ["proof (state)\nthis:\n  c \\<le> d\n  (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  c \\<le> d\n  (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}", "have subset_cd: \"(\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} \\<subseteq> {c..d}\""], ["proof (prove)\nusing this:\n  c \\<le> d\n  (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} \\<subseteq> {c..d}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} \\<subseteq> {c..d}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have field_cont_on_path_cd:\n    \"continuous_on {c..d} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {c..d}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "using field_cont_on_path cd"], ["proof (prove)\nusing this:\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n  c \\<le> d\n  (\\<lambda>a. \\<gamma> a \\<bullet> i) ` {0..1} = {c..d}\n\ngoal (1 subgoal):\n 1. continuous_on {c..d}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "by auto"], ["proof (state)\nthis:\n  continuous_on {c..d}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have path_vector_deriv_line_integrals:\n    \"\\<forall>x\\<in>{0..1} - s. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative \n                                          vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n                                                  (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n        (at x)", "using gamma_i_component_smooth and derivative_component_fun_component and\n      vector_derivative_works"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  vector_derivative ?f (at ?x) \\<bullet> ?i =\n  vector_derivative (\\<lambda>x. ?f x \\<bullet> ?i) (at ?x)\n  (?f differentiable ?net) =\n  (?f has_vector_derivative vector_derivative ?f ?net) ?net\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n        (at x)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)", "have \"\\<forall>x\\<in>{0..1} - s. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative \n                                          vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within ({0..1})))\n                                                  (at x within ({0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1}))\n        (at x within {0..1})", "using has_vector_derivative_at_within vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1}))\n        (at x within {0..1})", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})", "have has_int:\"((\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}) *\\<^sub>R (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i + g (\\<gamma> x \\<bullet> i)) \\<bullet> i)) has_integral\n           integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)) {0..1}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}) *\\<^sub>R\n         (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n             g (\\<gamma> x \\<bullet> i)) \\<bullet>\n          i)) has_integral\n     integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "using has_integral_substitution_strong[OF gamma_differentiable(1) rel_simps(44)\n        path_start_le_path_end' subset_cd field_cont_on_path_cd gamm_cont,\n        of \"(\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within ({0..1})))\"]\n      gamma_is_in_terms_of_i"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n  (\\<And>x.\n      x \\<in> {0..1} - s \\<Longrightarrow>\n      ((\\<lambda>a. \\<gamma> a \\<bullet> i) has_real_derivative\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n       (at x within {0..1})) \\<Longrightarrow>\n  ((\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) has_integral\n   integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n  \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}) *\\<^sub>R\n         (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n             g (\\<gamma> x \\<bullet> i)) \\<bullet>\n          i)) has_integral\n     integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "by (auto simp only: has_field_derivative_iff_has_vector_derivative)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) has_integral\n   integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) has_integral\n   integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}", "have has_int':\"((\\<lambda>x. (F(\\<gamma>(x)) \\<bullet> i)*(vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within ({0..1})))) has_integral\n           integral {((pathstart \\<gamma>) \\<bullet> i)..((pathfinish \\<gamma>) \\<bullet> i)} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)) {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) has_integral\n   integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1})) has_integral\n     integral\n      {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "using  gamma_is_in_terms_of_i i_norm_1"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) has_integral\n   integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n  \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x))\n  norm i = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1})) has_integral\n     integral\n      {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "apply (auto simp add: pathstart_def pathfinish_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>x.\n                  vector_derivative\n                   (\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                   (at x within {0..1}) *\n                  (F (((f x *\\<^sub>R i + g (f x)) \\<bullet> i) *\\<^sub>R\n                      i +\n                      g ((f x *\\<^sub>R i + g (f x)) \\<bullet> i)) \\<bullet>\n                   i)) has_integral\n              integral\n               {(f 0 *\\<^sub>R i + g (f 0)) \\<bullet>\n                i..(f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i}\n               (\\<lambda>f_var.\n                   F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n              {0..1};\n     \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x)); norm i = 1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative\n                            (\\<lambda>x.\n                                (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                            (at x within {0..1})) has_integral\n                       integral\n                        {(f 0 *\\<^sub>R i + g (f 0)) \\<bullet>\n                         i..(f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i}\n                        (\\<lambda>f_var.\n                            F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n                       {0..1}", "apply (simp only:  real_inner_class.inner_add_left inner_not_same_Basis g_orthogonal_to_i inner_scaleR_left norm_eq_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>x.\n                  vector_derivative (\\<lambda>x. f x * 1 + 0)\n                   (at x within {0..1}) *\n                  (F ((f x * 1 + 0) *\\<^sub>R i + g (f x * 1 + 0)) \\<bullet>\n                   i)) has_integral\n              integral {f 0 * 1 + 0..f 1 * 1 + 0}\n               (\\<lambda>f_var.\n                   F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n              {0..1};\n     \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x));\n     i \\<bullet> i = 1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative (\\<lambda>x. f x * 1 + 0)\n                            (at x within {0..1})) has_integral\n                       integral {f 0 * 1 + 0..f 1 * 1 + 0}\n                        (\\<lambda>f_var.\n                            F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n                       {0..1}", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1})) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have substitute:\n    \"integral ({((pathstart \\<gamma>) \\<bullet> i)..((pathfinish \\<gamma>) \\<bullet> i)}) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i)) \n                 = integral ({0..1}) (\\<lambda>x. (F(\\<gamma>(x)) \\<bullet> i)*(vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within ({0..1}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "using gamma_is_in_terms_of_i integral_unique[OF has_int] i_norm_1"], ["proof (prove)\nusing this:\n  \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x))\n  integral {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) *\\<^sub>R\n       (F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n           g (\\<gamma> x \\<bullet> i)) \\<bullet>\n        i)) =\n  integral {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n  norm i = 1\n\ngoal (1 subgoal):\n 1. integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "apply (auto simp add: pathstart_def pathfinish_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x));\n     integral {0..1}\n      (\\<lambda>x.\n          vector_derivative\n           (\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n           (at x within {0..1}) *\n          (F (((f x *\\<^sub>R i + g (f x)) \\<bullet> i) *\\<^sub>R i +\n              g ((f x *\\<^sub>R i + g (f x)) \\<bullet> i)) \\<bullet>\n           i)) =\n     integral\n      {(f 0 *\\<^sub>R i + g (f 0)) \\<bullet>\n       i..(f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i);\n     norm i = 1\\<rbrakk>\n    \\<Longrightarrow> integral\n                       {(f 0 *\\<^sub>R i + g (f 0)) \\<bullet>\n                        i..(f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i}\n                       (\\<lambda>f_var.\n                           F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n                      integral {0..1}\n                       (\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative\n                            (\\<lambda>x.\n                                (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                            (at x within {0..1}))", "apply (simp only:  real_inner_class.inner_add_left inner_not_same_Basis g_orthogonal_to_i inner_scaleR_left norm_eq_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x));\n     integral {0..1}\n      (\\<lambda>x.\n          vector_derivative (\\<lambda>x. f x * 1 + 0) (at x within {0..1}) *\n          (F ((f x * 1 + 0) *\\<^sub>R i + g (f x * 1 + 0)) \\<bullet> i)) =\n     integral {f 0 * 1 + 0..f 1 * 1 + 0}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i);\n     i \\<bullet> i = 1\\<rbrakk>\n    \\<Longrightarrow> integral {f 0 * 1 + 0..f 1 * 1 + 0}\n                       (\\<lambda>f_var.\n                           F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n                      integral {0..1}\n                       (\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative (\\<lambda>x. f x * 1 + 0)\n                            (at x within {0..1}))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "have comp_in_eq_comp_out: \"\\<forall>x \\<in> {0..1} - s.\n            (vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1}))\n                = (vector_derivative \\<gamma> (at x within {0..1})) \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "fix x:: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "assume ass:\"x \\<in> {0..1} -s\""], ["proof (state)\nthis:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0..1} - s", "have x_bounds:\"x \\<in> {0..1}\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. x \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "have \"\\<gamma> differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at x", "using ass gamma_differentiable"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - s\n  finite s\n  \\<forall>x\\<in>{0..1} - s. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  \\<gamma> differentiable at x", "have dotprod_in_is_out:\n      \"vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x)\n                         = (vector_derivative \\<gamma> (at x)) \\<bullet> i\""], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i", "using derivative_component_fun_component"], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  vector_derivative ?f (at ?x) \\<bullet> ?i =\n  vector_derivative (\\<lambda>x. ?f x \\<bullet> ?i) (at ?x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i", "by force"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i", "have 0: \"(vector_derivative \\<gamma> (at x)) \\<bullet> i = (vector_derivative \\<gamma> (at x within {0..1})) \\<bullet> i\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i \\<Longrightarrow>\n    vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "have \"(\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x))\n     (at x)", "using \\<open>\\<gamma> differentiable at x\\<close> vector_derivative_works"], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at x\n  (?f differentiable ?net) =\n  (?f has_vector_derivative vector_derivative ?f ?net) ?net\n\ngoal (1 subgoal):\n 1. (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x))\n     (at x)", "by blast"], ["proof (state)\nthis:\n  (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x)) (at x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i \\<Longrightarrow>\n    vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "moreover"], ["proof (state)\nthis:\n  (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x)) (at x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i \\<Longrightarrow>\n    vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "have \"0 \\<le> x \\<and> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "using x_bounds"], ["proof (prove)\nusing this:\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "by presburger"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i \\<Longrightarrow>\n    vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "ultimately"], ["proof (chain)\npicking this:\n  (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x)) (at x)\n  0 \\<le> x \\<and> x \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<gamma> has_vector_derivative vector_derivative \\<gamma> (at x)) (at x)\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "by (simp add: vector_derivative_at_within_ivl)"], ["proof (state)\nthis:\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "have 1: \"vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x) = vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1})", "using path_vector_deriv_line_integrals and vector_derivative_at_within_ivl and\n        x_bounds"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1})", "by (metis ass atLeastAtMost_iff zero_less_one)"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "show \"vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}) = vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1}) =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "using 0 and 1 and dotprod_in_is_out"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1})\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1}) =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1}) =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1}) =\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n 2. line_integral_exists F {i} \\<gamma>", "show \"integral {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n                   integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "using substitute and comp_in_eq_comp_out and negligible_finite\n      Henstock_Kurzweil_Integration.integral_spike\n      [of \"s\" \"{0..1}\" \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i))\"\n        \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\"]"], ["proof (prove)\nusing this:\n  integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n  \\<forall>x\\<in>{0..1} - s.\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1}) =\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n  finite ?s \\<Longrightarrow> negligible ?s\n  \\<lbrakk>negligible s;\n   \\<And>x.\n      x \\<in> {0..1} - s \\<Longrightarrow>\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n      F (\\<gamma> x) \\<bullet> i *\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1})\\<rbrakk>\n  \\<Longrightarrow> integral {0..1}\n                     (\\<lambda>x.\n                         F (\\<gamma> x) \\<bullet> i *\n                         vector_derivative\n                          (\\<lambda>x. \\<gamma> x \\<bullet> i)\n                          (at x within {0..1})) =\n                    integral {0..1}\n                     (\\<lambda>x.\n                         F (\\<gamma> x) \\<bullet> i *\n                         (vector_derivative \\<gamma>\n                           (at x within {0..1}) \\<bullet>\n                          i))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "by (metis (no_types, lifting) gamma_differentiable(1))"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n  integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal (1 subgoal):\n 1. line_integral_exists F {i} \\<gamma>", "have \"((\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) has_integral\n                   integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          i)) has_integral\n     integral\n      {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "using has_int' and comp_in_eq_comp_out and negligible_finite\n      Henstock_Kurzweil_Integration.has_integral_spike\n      [of \"s\" \"{0..1}\" \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i))\"\n        \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\"\n        \"integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\"]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1})) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n  \\<forall>x\\<in>{0..1} - s.\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1}) =\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n  finite ?s \\<Longrightarrow> negligible ?s\n  \\<lbrakk>negligible s;\n   \\<And>x.\n      x \\<in> {0..1} - s \\<Longrightarrow>\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n      F (\\<gamma> x) \\<bullet> i *\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1});\n   ((\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> i *\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1})) has_integral\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n    {0..1}\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         F (\\<gamma> x) \\<bullet> i *\n                         (vector_derivative \\<gamma>\n                           (at x within {0..1}) \\<bullet>\n                          i)) has_integral\n                     integral\n                      {pathstart \\<gamma> \\<bullet>\n                       i..pathfinish \\<gamma> \\<bullet> i}\n                      (\\<lambda>f_var.\n                          F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n                     {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          i)) has_integral\n     integral\n      {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n     {0..1}", "by (metis (no_types, lifting) gamma_differentiable(1))"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}", "have \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) integrable_on {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> i *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n         i)) integrable_on\n    {0..1}", "using integrable_on_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n        i)) has_integral\n   integral\n    {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i))\n   {0..1}\n  (?f integrable_on ?i) = (\\<exists>y. (?f has_integral y) ?i)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> i *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n         i)) integrable_on\n    {0..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {i} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}", "show \"line_integral_exists F {i} \\<gamma>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       i)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {i} \\<gamma>", "by (auto simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  line_integral_exists F {i} \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_on_pair_path:\n  fixes F::\"('a::euclidean_space) \\<Rightarrow> ('a)\" and\n    g::\"real \\<Rightarrow> 'a\" and\n    \\<gamma>::\"(real \\<Rightarrow> 'a)\" and\n    i::'a \n  assumes i_norm_1: \"norm i = 1\" and\n    g_orthogonal_to_i: \"\\<forall>x. g(x) \\<bullet> i = 0\" and  \n    gamma_is_in_terms_of_i: \"\\<gamma> = (\\<lambda>x. f(x) *\\<^sub>R i + g(f(x)))\" and\n    gamma_smooth: \"\\<gamma> C1_differentiable_on {0 .. 1}\" and\n    g_continuous_on_f: \"continuous_on (f ` {0..1}) g\" and\n    path_start_le_path_end: \"(pathstart \\<gamma>) \\<bullet> i \\<le> (pathfinish \\<gamma>) \\<bullet> i\" and\n    field_i_comp_cont: \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> i)\"\n  shows \"(line_integral F {i} \\<gamma>) \n                 = integral (cbox ((pathstart \\<gamma>) \\<bullet> i) ((pathfinish \\<gamma>) \\<bullet> i)) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {i} \\<gamma> =\n    integral\n     (cbox (pathstart \\<gamma> \\<bullet> i)\n       (pathfinish \\<gamma> \\<bullet> i))\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "proof (simp add: line_integral_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have gamma_differentiable: \"\\<forall>x \\<in> {0 .. 1}. \\<gamma> differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "using gamma_smooth  C1_differentiable_on_eq"], ["proof (prove)\nusing this:\n  \\<gamma> C1_differentiable_on {0..1}\n  (?f C1_differentiable_on ?S) =\n  ((\\<forall>x\\<in>?S. ?f differentiable at x) \\<and>\n   continuous_on ?S (\\<lambda>x. vector_derivative ?f (at x)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "have gamma_i_component_smooth:\n    \"\\<forall>x \\<in> {0 .. 1}. (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have vec_deriv_i_comp_cont:\n    \"continuous_on {0..1} (\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "have \"continuous_on {0..1} (\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma> x) (at x within {0..1}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "using gamma_smooth C1_differentiable_on_eq"], ["proof (prove)\nusing this:\n  \\<gamma> C1_differentiable_on {0..1}\n  (?f C1_differentiable_on ?S) =\n  ((\\<forall>x\\<in>?S. ?f differentiable at x) \\<and>\n   continuous_on ?S (\\<lambda>x. vector_derivative ?f (at x)))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "by (smt C1_differentiable_on_def atLeastAtMost_iff continuous_on_eq vector_derivative_at_within_ivl)"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "have deriv_comp_cont:\n      \"continuous_on {0..1} (\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma> x) (at x within {0..1}) \\<bullet> i)\""], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)", "by (simp add: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "using derivative_component_fun_component_at_within[OF gamma_differentiable, of \"i\"]                    \n        continuous_on_eq[OF deriv_comp_cont, of \"(\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i =\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1})\n  (\\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i =\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1})) \\<Longrightarrow>\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "by fastforce"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have field_cont_on_path:\n    \"continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1}) (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have 0: \"(\\<lambda>x. \\<gamma> x \\<bullet> i) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma> x \\<bullet> i) = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<gamma> x \\<bullet> i = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<gamma> x \\<bullet> i = f x", "show \"\\<gamma> x \\<bullet> i = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> x \\<bullet> i = f x", "using g_orthogonal_to_i i_norm_1"], ["proof (prove)\nusing this:\n  \\<forall>x. g x \\<bullet> i = 0\n  norm i = 1\n\ngoal (1 subgoal):\n 1. \\<gamma> x \\<bullet> i = f x", "by (simp only: gamma_is_in_terms_of_i  real_inner_class.inner_add_left g_orthogonal_to_i inner_scaleR_left inner_same_Basis norm_eq_1)"], ["proof (state)\nthis:\n  \\<gamma> x \\<bullet> i = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<gamma> x \\<bullet> i) = f\n\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "unfolding 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (f ` {0..1})\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "apply (rule continuous_on_compose2 [of _ \"(\\<lambda>x. F(x)  \\<bullet> i)\" \"f ` { 0..1}\" \"(\\<lambda>x. x *\\<^sub>R i + g x)\"]\n          field_i_comp_cont g_continuous_on_f field_i_comp_cont continuous_intros)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f_var. f_var *\\<^sub>R i + g f_var) ` f ` {0..1}\n    \\<subseteq> path_image \\<gamma>", "by (auto simp add: gamma_is_in_terms_of_i path_image_def)"], ["proof (state)\nthis:\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have path_vector_deriv_line_integrals:\n    \"\\<forall>x\\<in>{0..1}. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative \n                                          vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n                                                  (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n        (at x)", "using gamma_i_component_smooth and derivative_component_fun_component and\n      vector_derivative_works"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> i) differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  vector_derivative ?f (at ?x) \\<bullet> ?i =\n  vector_derivative (\\<lambda>x. ?f x \\<bullet> ?i) (at ?x)\n  (?f differentiable ?net) =\n  (?f has_vector_derivative vector_derivative ?f ?net) ?net\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n        (at x)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)", "have \"\\<forall>x\\<in>{0..1}. ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative \n                                          vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\n                                                  (at x within {0..1})\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1}))\n        (at x within {0..1})", "using has_vector_derivative_at_within vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1}))\n        (at x within {0..1})", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})", "have substitute:\n    \"integral (cbox ((pathstart \\<gamma>) \\<bullet> i) ((pathfinish \\<gamma>) \\<bullet> i)) (\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i)) \n                 = integral (cbox 0 1) (\\<lambda>x. (F(\\<gamma>(x)) \\<bullet> i)*(vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1})))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. integral\n     (cbox (pathstart \\<gamma> \\<bullet> i)\n       (pathfinish \\<gamma> \\<bullet> i))\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n    integral (cbox 0 1)\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "using gauge_integral_by_substitution\n      [of \"0\" \"1\" \"(\\<lambda>x. (\\<gamma> x) \\<bullet> i)\"\n        \"(\\<lambda>x. vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1}))\"\n        \"(\\<lambda>f_var. (F (f_var *\\<^sub>R i + g(f_var)) \\<bullet> i))\"] and\n      path_start_le_path_end and vec_deriv_i_comp_cont and field_cont_on_path and \n      gamma_is_in_terms_of_i i_norm_1"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1}))\n      (at x within {0..1})\n  \\<lbrakk>0 \\<le> 1; \\<gamma> 0 \\<bullet> i \\<le> \\<gamma> 1 \\<bullet> i;\n   \\<forall>x\\<in>{0..1}.\n      ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n       (at x within {0..1});\n   continuous_on {0..1}\n    (\\<lambda>x.\n        vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n         (at x within {0..1}));\n   continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n    (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\\<rbrakk>\n  \\<Longrightarrow> integral\n                     {\\<gamma> 0 \\<bullet> i..\\<gamma> 1 \\<bullet> i}\n                     (\\<lambda>f_var.\n                         F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n                    integral {0..1}\n                     (\\<lambda>x.\n                         F ((\\<gamma> x \\<bullet> i) *\\<^sub>R i +\n                            g (\\<gamma> x \\<bullet> i)) \\<bullet>\n                         i *\n                         vector_derivative\n                          (\\<lambda>x. \\<gamma> x \\<bullet> i)\n                          (at x within {0..1}))\n  pathstart \\<gamma> \\<bullet> i \\<le> pathfinish \\<gamma> \\<bullet> i\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n  continuous_on ((\\<lambda>x. \\<gamma> x \\<bullet> i) ` {0..1})\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n  \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x))\n  norm i = 1\n\ngoal (1 subgoal):\n 1. integral\n     (cbox (pathstart \\<gamma> \\<bullet> i)\n       (pathfinish \\<gamma> \\<bullet> i))\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n    integral (cbox 0 1)\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n          (at x within {0..1}))", "apply (auto simp add: pathstart_def pathfinish_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                ((\\<lambda>x.\n                     (f x *\\<^sub>R i + g (f x)) \\<bullet>\n                     i) has_vector_derivative\n                 vector_derivative\n                  (\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                  (at x within {0..1}))\n                 (at x within {0..1});\n     integral\n      {(f 0 *\\<^sub>R i + g (f 0)) \\<bullet>\n       i..(f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n     integral {0..1}\n      (\\<lambda>x.\n          F (((f x *\\<^sub>R i + g (f x)) \\<bullet> i) *\\<^sub>R i +\n             g ((f x *\\<^sub>R i + g (f x)) \\<bullet> i)) \\<bullet>\n          i *\n          vector_derivative\n           (\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n           (at x within {0..1}));\n     (f 0 *\\<^sub>R i + g (f 0)) \\<bullet> i\n     \\<le> (f 1 *\\<^sub>R i + g (f 1)) \\<bullet> i;\n     continuous_on {0..1}\n      (\\<lambda>x.\n          vector_derivative\n           (\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n           (at x within {0..1}));\n     continuous_on\n      ((\\<lambda>x. (f x *\\<^sub>R i + g (f x)) \\<bullet> i) ` {0..1})\n      (\\<lambda>x. F (x *\\<^sub>R i + g x) \\<bullet> i);\n     \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x)); norm i = 1\\<rbrakk>\n    \\<Longrightarrow> integral {0..1}\n                       (\\<lambda>x.\n                           F (((f x *\\<^sub>R i + g (f x)) \\<bullet>\n                               i) *\\<^sub>R\n                              i +\n                              g ((f x *\\<^sub>R i + g (f x)) \\<bullet>\n                                 i)) \\<bullet>\n                           i *\n                           vector_derivative\n                            (\\<lambda>x.\n                                (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                            (at x within {0..1})) =\n                      integral {0..1}\n                       (\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative\n                            (\\<lambda>x.\n                                (f x *\\<^sub>R i + g (f x)) \\<bullet> i)\n                            (at x within {0..1}))", "apply (simp only:  real_inner_class.inner_add_left inner_not_same_Basis g_orthogonal_to_i inner_scaleR_left norm_eq_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                ((\\<lambda>x. f x * 1 + 0) has_vector_derivative\n                 vector_derivative (\\<lambda>x. f x * 1 + 0)\n                  (at x within {0..1}))\n                 (at x within {0..1});\n     integral {f 0 * 1 + 0..f 1 * 1 + 0}\n      (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n     integral {0..1}\n      (\\<lambda>x.\n          F ((f x * 1 + 0) *\\<^sub>R i + g (f x * 1 + 0)) \\<bullet> i *\n          vector_derivative (\\<lambda>x. f x * 1 + 0) (at x within {0..1}));\n     f 0 * 1 + 0 \\<le> f 1 * 1 + 0;\n     continuous_on {0..1}\n      (\\<lambda>x.\n          vector_derivative (\\<lambda>x. f x * 1 + 0) (at x within {0..1}));\n     continuous_on ((\\<lambda>x. f x * 1 + 0) ` {0..1})\n      (\\<lambda>x. F (x *\\<^sub>R i + g x) \\<bullet> i);\n     \\<gamma> = (\\<lambda>x. f x *\\<^sub>R i + g (f x));\n     i \\<bullet> i = 1\\<rbrakk>\n    \\<Longrightarrow> integral {0..1}\n                       (\\<lambda>x.\n                           F ((f x * 1 + 0) *\\<^sub>R i +\n                              g (f x * 1 + 0)) \\<bullet>\n                           i *\n                           vector_derivative (\\<lambda>x. f x * 1 + 0)\n                            (at x within {0..1})) =\n                      integral {0..1}\n                       (\\<lambda>x.\n                           F (f x *\\<^sub>R i + g (f x)) \\<bullet> i *\n                           vector_derivative (\\<lambda>x. f x * 1 + 0)\n                            (at x within {0..1}))", "by (auto)"], ["proof (state)\nthis:\n  integral\n   (cbox (pathstart \\<gamma> \\<bullet> i) (pathfinish \\<gamma> \\<bullet> i))\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n  integral (cbox 0 1)\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "(*integration by substitution*)"], ["proof (state)\nthis:\n  integral\n   (cbox (pathstart \\<gamma> \\<bullet> i) (pathfinish \\<gamma> \\<bullet> i))\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n  integral (cbox 0 1)\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "have comp_in_eq_comp_out: \"\\<forall>x \\<in> {0..1}.\n            (vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1}))\n                = (vector_derivative \\<gamma> (at x within {0..1})) \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "fix x:: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "assume x_bounds: \"x \\<in> {0..1}\""], ["proof (state)\nthis:\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0..1}", "have \"\\<gamma> differentiable at x\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at x", "using gamma_differentiable"], ["proof (prove)\nusing this:\n  x \\<in> {0..1}\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<gamma> differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  \\<gamma> differentiable at x", "have dotprod_in_is_out:\n      \"vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x)\n                         = (vector_derivative \\<gamma> (at x)) \\<bullet> i\""], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i", "using derivative_component_fun_component"], ["proof (prove)\nusing this:\n  \\<gamma> differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  vector_derivative ?f (at ?x) \\<bullet> ?i =\n  vector_derivative (\\<lambda>x. ?f x \\<bullet> ?i) (at ?x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative \\<gamma> (at x) \\<bullet> i", "by force"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i", "have 0: \"(vector_derivative \\<gamma> (at x)) \\<bullet> i\n                         = (vector_derivative \\<gamma> (at x within {0..1})) \\<bullet> i\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "using has_vector_derivative_at_within and x_bounds and vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n  x \\<in> {0..1}\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma> (at x) \\<bullet> i =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "by (smt atLeastAtMost_iff gamma_differentiable inner_commute vector_derivative_works)"], ["proof (state)\nthis:\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "have 1: \"vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x) = vector_derivative (\\<lambda>x. \\<gamma>(x) \\<bullet> i) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1})", "using path_vector_deriv_line_integrals and vector_derivative_at_within_ivl and\n        x_bounds"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     ((\\<lambda>x. \\<gamma> x \\<bullet> i) has_vector_derivative\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x))\n      (at x)\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n    vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1})", "by fastforce"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}) =\n       vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "show \"vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}) = vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1}) =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "using 0 and 1 and dotprod_in_is_out"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma> (at x) \\<bullet> i =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1})\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x) =\n  vector_derivative \\<gamma> (at x) \\<bullet> i\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n     (at x within {0..1}) =\n    vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n   (at x within {0..1}) =\n  vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1}) =\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "show \"integral {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n                   integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i} (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "using substitute and comp_in_eq_comp_out and \n      Henstock_Kurzweil_Integration.integral_cong\n      [of \"{0..1}\" \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i))\"\n        \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> i * vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i) (at x within {0..1}))\"]"], ["proof (prove)\nusing this:\n  integral\n   (cbox (pathstart \\<gamma> \\<bullet> i) (pathfinish \\<gamma> \\<bullet> i))\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i) =\n  integral (cbox 0 1)\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n      (at x within {0..1}) =\n     vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i\n  (\\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      F (\\<gamma> x) \\<bullet> i *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i) =\n      F (\\<gamma> x) \\<bullet> i *\n      vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n       (at x within {0..1})) \\<Longrightarrow>\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       vector_derivative (\\<lambda>x. \\<gamma> x \\<bullet> i)\n        (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> i *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n    integral\n     {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n     (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> i *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> i)) =\n  integral {pathstart \\<gamma> \\<bullet> i..pathfinish \\<gamma> \\<bullet> i}\n   (\\<lambda>f_var. F (f_var *\\<^sub>R i + g f_var) \\<bullet> i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_box_cases:\n  \"content (box a b) = (if \\<forall>i\\<in>Basis. a\\<bullet>i \\<le> b\\<bullet>i then prod (\\<lambda>i. b\\<bullet>i - a\\<bullet>i) Basis else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (box a b) =\n    (if \\<forall>i\\<in>Basis. a \\<bullet> i \\<le> b \\<bullet> i\n     then \\<Prod>i\\<in>Basis. b \\<bullet> i - a \\<bullet> i else 0)", "by (simp add: measure_lborel_box_eq inner_diff)"], ["", "lemma content_box_cbox:\n  shows \"content (box a b) = content (cbox a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (box a b) = content (cbox a b)", "by (simp add: content_box_cases content_cbox_cases)"], ["", "lemma content_eq_0: \"content (box a b) = 0 \\<longleftrightarrow> (\\<exists>i\\<in>Basis. b\\<bullet>i \\<le> a\\<bullet>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (content (box a b) = 0) =\n    (\\<exists>i\\<in>Basis. b \\<bullet> i \\<le> a \\<bullet> i)", "by (auto simp: content_box_cases not_le intro: less_imp_le antisym eq_refl)"], ["", "lemma content_pos_lt_eq: \"0 < content (cbox a (b::'a::euclidean_space)) \\<longleftrightarrow> (\\<forall>i\\<in>Basis. a\\<bullet>i < b\\<bullet>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < content (cbox a b)) =\n    (\\<forall>i\\<in>Basis. a \\<bullet> i < b \\<bullet> i)", "by (auto simp add: content_cbox_cases less_le prod_nonneg)"], ["", "lemma content_lt_nz: \"0 < content (box a b) \\<longleftrightarrow> content (box a b) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < content (box a b)) = (content (box a b) \\<noteq> 0)", "using Paths.content_eq_0 zero_less_measure_iff"], ["proof (prove)\nusing this:\n  (content (box ?a ?b) = 0) =\n  (\\<exists>i\\<in>Basis. ?b \\<bullet> i \\<le> ?a \\<bullet> i)\n  (0 < Sigma_Algebra.measure ?M ?A) =\n  (Sigma_Algebra.measure ?M ?A \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (0 < content (box a b)) = (content (box a b) \\<noteq> 0)", "by blast"], ["", "lemma content_subset: \"cbox a b \\<subseteq> box c d \\<Longrightarrow> content (cbox a b) \\<le> content (box c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox a b \\<subseteq> box c d \\<Longrightarrow>\n    content (cbox a b) \\<le> content (box c d)", "unfolding measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox a b \\<subseteq> box c d \\<Longrightarrow>\n    enn2real (emeasure lborel (cbox a b))\n    \\<le> enn2real (emeasure lborel (box c d))", "by (intro enn2real_mono emeasure_mono) (auto simp: emeasure_lborel_cbox_eq emeasure_lborel_box_eq)"], ["", "lemma sum_content_null:\n  assumes \"content (box a b) = 0\"\n    and \"p tagged_division_of (box a b)\"\n  shows \"sum (\\<lambda>(x,k). content k *\\<^sub>R f x) p = (0::'a::real_normed_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, k)\\<in>p. content k *\\<^sub>R f x) = (0::'a)", "proof (rule sum.neutral, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "assume y: \"y \\<in> p\""], ["proof (state)\nthis:\n  y \\<in> p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "obtain x k where xk: \"y = (x, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x k. y = (x, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using surj_pair[of y]"], ["proof (prove)\nusing this:\n  \\<exists>x ya. y = (x, ya)\n\ngoal (1 subgoal):\n 1. (\\<And>x k. y = (x, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = (x, k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "note assm = tagged_division_ofD(3-4)[OF assms(2) y[unfolded xk]]"], ["proof (state)\nthis:\n  k \\<subseteq> box a b\n  \\<exists>a b. k = cbox a b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "from this(2)"], ["proof (chain)\npicking this:\n  \\<exists>a b. k = cbox a b", "obtain c d where k: \"k = cbox c d\""], ["proof (prove)\nusing this:\n  \\<exists>a b. k = cbox a b\n\ngoal (1 subgoal):\n 1. (\\<And>c d. k = cbox c d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = cbox c d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "have \"(\\<lambda>(x, k). content k *\\<^sub>R f x) y = content k *\\<^sub>R f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) =\n    content k *\\<^sub>R f x", "unfolding xk"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x, k) of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) =\n    content k *\\<^sub>R f x", "by auto"], ["proof (state)\nthis:\n  (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) =\n  content k *\\<^sub>R f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "also"], ["proof (state)\nthis:\n  (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) =\n  content k *\\<^sub>R f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content k *\\<^sub>R f x = (0::'a)", "using content_subset[OF assm(1)[unfolded k]] content_pos_le[of \"cbox c d\"]"], ["proof (prove)\nusing this:\n  content (cbox c d) \\<le> content (box a b)\n  0 \\<le> content (cbox c d)\n\ngoal (1 subgoal):\n 1. content k *\\<^sub>R f x = (0::'a)", "unfolding assms(1) k"], ["proof (prove)\nusing this:\n  content (cbox c d) \\<le> 0\n  0 \\<le> content (cbox c d)\n\ngoal (1 subgoal):\n 1. content (cbox c d) *\\<^sub>R f x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  content k *\\<^sub>R f x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> p \\<Longrightarrow>\n       (case x of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "show \"(\\<lambda>(x, k). content k *\\<^sub>R f x) y = 0\""], ["proof (prove)\nusing this:\n  (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)\n\ngoal (1 subgoal):\n 1. (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)", "."], ["proof (state)\nthis:\n  (case y of (x, k) \\<Rightarrow> content k *\\<^sub>R f x) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_integral_null [intro]: \"content(box a b) = 0 \\<Longrightarrow> (f has_integral 0) (box a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (box a b) = 0 \\<Longrightarrow>\n    (f has_integral (0::'b)) (box a b)", "by (simp add: content_box_cbox content_eq_0_interior)"], ["", "lemma line_integral_distrib:\n  assumes \"line_integral_exists f basis g1\"\n    \"line_integral_exists f basis g2\"\n    \"valid_path g1\" \"valid_path g2\"\n  shows \"line_integral f basis (g1 +++ g2) = line_integral f basis g1 + line_integral f basis g2\"\n    \"line_integral_exists f basis (g1 +++ g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2 &&&\n    line_integral_exists f basis (g1 +++ g2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "obtain s1 s2\n    where s1: \"finite s1\" \"\\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\"\n      and s2: \"finite s2\" \"\\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        \\<lbrakk>finite s1;\n         \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x; finite s2;\n         \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis g1\n  line_integral_exists f basis g2\n  valid_path g1\n  valid_path g2\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        \\<lbrakk>finite s1;\n         \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x; finite s2;\n         \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: valid_path_def piecewise_C1_differentiable_on_def C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "obtain i1 i2\n    where 1: \"((\\<lambda>x. \\<Sum>b\\<in>basis. f (g1 x) \\<bullet> b * (vector_derivative g1 (at x within {0..1}) \\<bullet> b)) has_integral i1) {0..1}\"\n      and 2: \"((\\<lambda>x. \\<Sum>b\\<in>basis. f (g2 x) \\<bullet> b * (vector_derivative g2 (at x within {0..1}) \\<bullet> b)) has_integral i2) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        \\<lbrakk>((\\<lambda>x.\n                      \\<Sum>b\\<in>basis.\n                        f (g1 x) \\<bullet> b *\n                        (vector_derivative g1 (at x within {0..1}) \\<bullet>\n                         b)) has_integral\n                  i1)\n                  {0..1};\n         ((\\<lambda>x.\n              \\<Sum>b\\<in>basis.\n                f (g2 x) \\<bullet> b *\n                (vector_derivative g2 (at x within {0..1}) \\<bullet>\n                 b)) has_integral\n          i2)\n          {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis g1\n  line_integral_exists f basis g2\n  valid_path g1\n  valid_path g2\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        \\<lbrakk>((\\<lambda>x.\n                      \\<Sum>b\\<in>basis.\n                        f (g1 x) \\<bullet> b *\n                        (vector_derivative g1 (at x within {0..1}) \\<bullet>\n                         b)) has_integral\n                  i1)\n                  {0..1};\n         ((\\<lambda>x.\n              \\<Sum>b\\<in>basis.\n                f (g2 x) \\<bullet> b *\n                (vector_derivative g2 (at x within {0..1}) \\<bullet>\n                 b)) has_integral\n          i2)\n          {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: line_integral_exists_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g1 x) \\<bullet> b *\n         (vector_derivative g1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g2 x) \\<bullet> b *\n         (vector_derivative g2 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "have i1: \"((\\<lambda>x. 2 * (\\<Sum>b\\<in>basis. f (g1 (2 * x)) \\<bullet> b * (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet> b))) has_integral i1) {0..1/2}\"\n   and i2: \"((\\<lambda>x. 2 * (\\<Sum>b\\<in>basis. f (g2 (2 * x - 1)) \\<bullet> b * (vector_derivative g2 (at ((2 * x) - 1) within {0..1}) \\<bullet> b))) has_integral i2) {1/2..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         2 *\n         (\\<Sum>b\\<in>basis.\n            f (g1 (2 * x)) \\<bullet> b *\n            (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet>\n             b))) has_integral\n     i1)\n     {0..1 / 2} &&&\n    ((\\<lambda>x.\n         2 *\n         (\\<Sum>b\\<in>basis.\n            f (g2 (2 * x - 1)) \\<bullet> b *\n            (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet>\n             b))) has_integral\n     i2)\n     {1 / 2..1}", "using has_integral_affinity01 [OF 1, where m= 2 and c=0, THEN has_integral_cmul [where c=2]]\n      has_integral_affinity01 [OF 2, where m= 2 and c=\"-1\", THEN has_integral_cmul [where c=2]]"], ["proof (prove)\nusing this:\n  2 \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       2 *\\<^sub>R\n       (\\<Sum>b\\<in>basis.\n          f (g1 (2 * x + 0)) \\<bullet> b *\n          (vector_derivative g1 (at (2 * x + 0) within {0..1}) \\<bullet>\n           b))) has_integral\n   2 *\\<^sub>R (1 / \\<bar>2\\<bar>) *\\<^sub>R i1)\n   ((\\<lambda>x. x / 2 - 0 / 2) ` {0..1})\n  2 \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       2 *\\<^sub>R\n       (\\<Sum>b\\<in>basis.\n          f (g2 (2 * x + - 1)) \\<bullet> b *\n          (vector_derivative g2 (at (2 * x + - 1) within {0..1}) \\<bullet>\n           b))) has_integral\n   2 *\\<^sub>R (1 / \\<bar>2\\<bar>) *\\<^sub>R i2)\n   ((\\<lambda>x. x / 2 - - 1 / 2) ` {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         2 *\n         (\\<Sum>b\\<in>basis.\n            f (g1 (2 * x)) \\<bullet> b *\n            (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet>\n             b))) has_integral\n     i1)\n     {0..1 / 2} &&&\n    ((\\<lambda>x.\n         2 *\n         (\\<Sum>b\\<in>basis.\n            f (g2 (2 * x - 1)) \\<bullet> b *\n            (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet>\n             b))) has_integral\n     i2)\n     {1 / 2..1}", "by (simp_all only: image_affinity_atLeastAtMost_div_diff, simp_all add: scaleR_conv_of_real mult_ac)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g1 (2 * x)) \\<bullet> b *\n          (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet>\n           b))) has_integral\n   i1)\n   {0..1 / 2}\n  ((\\<lambda>x.\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g2 (2 * x - 1)) \\<bullet> b *\n          (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet>\n           b))) has_integral\n   i2)\n   {1 / 2..1}\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "have g1: \"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n            vector_derivative (\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) (at z within {0..1}) =\n            2 *\\<^sub>R vector_derivative g1 (at (z*2) within {0..1})\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "have i:\"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n              vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2))\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "have g1_at_z:\"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n                         ((\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) has_vector_derivative\n                         2 *\\<^sub>R vector_derivative g1 (at (z*2))) (at z)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (rule has_vector_derivative_transform_at [of \"\\<bar>z - 1/2\\<bar>\" _ \"(\\<lambda>x. g1(2*x))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> 0 < \\<bar>z - 1 / 2\\<bar>\n 2. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x'.\n                         dist x' z < \\<bar>z - 1 / 2\\<bar> \\<longrightarrow>\n                         g1 (2 * x') =\n                         (if x' * 2 \\<le> 1 then g1 (2 * x')\n                          else g2 (2 * x' - 1))\n 3. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g1 (2 * x)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (simp_all add: dist_real_def abs_if split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g1 (2 * x)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (rule vector_diff_chain_at [of \"\\<lambda>x. 2*x\" 2 _ g1, simplified o_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((*) 2 has_vector_derivative 2) (at z)\n 2. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "apply (simp add: has_vector_derivative_def has_derivative_def bounded_linear_mult_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "using s1"], ["proof (prove)\nusing this:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "apply (auto simp: algebra_simps vector_derivative_works)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1)) has_vector_derivative\n                     2 *\\<^sub>R vector_derivative g1 (at (?z * 2)))\n                     (at ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "assume ass: \"0 \\<le> z\" \"z*2 < 1\" \"z*2 \\<notin> s1\""], ["proof (state)\nthis:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1", "have z_ge: \"z\\<le> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. z \\<le> 1", "by auto"], ["proof (state)\nthis:\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "using Derivative.vector_derivative_at_within_ivl[OF g1_at_z[OF ass] ass(1) z_ge]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R vector_derivative g1 (at (?z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "assume ass: \"0 \\<le> z\" \"z*2 < 1\" \"z*2 \\<notin> s1\""], ["proof (state)\nthis:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "then"], ["proof (chain)\npicking this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1", "have \"(g1 has_vector_derivative ((vector_derivative g1 (at (z*2))))) (at (z*2))\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. (g1 has_vector_derivative vector_derivative g1 (at (z * 2)))\n     (at (z * 2))", "using s1"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. (g1 has_vector_derivative vector_derivative g1 (at (z * 2)))\n     (at (z * 2))", "by (auto simp: algebra_simps vector_derivative_works)"], ["proof (state)\nthis:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "then"], ["proof (chain)\npicking this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))", "have ii: \"(vector_derivative g1 (at (z*2) within {0..1})) = (vector_derivative g1 (at (z*2)))\""], ["proof (prove)\nusing this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative g1 (at (z * 2) within {0..1}) =\n    vector_derivative g1 (at (z * 2))", "using Derivative.vector_derivative_at_within_ivl ass"], ["proof (prove)\nusing this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. vector_derivative g1 (at (z * 2) within {0..1}) =\n    vector_derivative g1 (at (z * 2))", "by force"], ["proof (state)\nthis:\n  vector_derivative g1 (at (z * 2) within {0..1}) =\n  vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})", "using i[OF ass] ii"], ["proof (prove)\nusing this:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n  vector_derivative g1 (at (z * 2) within {0..1}) =\n  vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R\n                    vector_derivative g1 (at (?z * 2) within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "have g2: \"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n            vector_derivative (\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) (at z within {0..1}) =\n            2 *\\<^sub>R vector_derivative g2 (at (z*2 - 1) within {0..1})\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "have i:\"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n              vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1})\n                   = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "have g2_at_z:\"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n                      ((\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) has_vector_derivative 2 *\\<^sub>R vector_derivative g2 (at (z*2 - 1))) (at z)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (rule has_vector_derivative_transform_at [of \"\\<bar>z - 1/2\\<bar>\" _ \"(\\<lambda>x. g2 (2*x - 1))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> 0 < \\<bar>z - 1 / 2\\<bar>\n 2. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x'.\n                         dist x' z < \\<bar>z - 1 / 2\\<bar> \\<longrightarrow>\n                         g2 (2 * x' - 1) =\n                         (if x' * 2 \\<le> 1 then g1 (2 * x')\n                          else g2 (2 * x' - 1))\n 3. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (simp_all add: dist_real_def abs_if split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (rule vector_diff_chain_at [of \"\\<lambda>x. 2*x - 1\" 2 _ g2, simplified o_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. 2 * x - 1) has_vector_derivative 2)\n                       (at z)\n 2. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "apply (simp add: has_vector_derivative_def has_derivative_def bounded_linear_mult_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "using s2"], ["proof (prove)\nusing this:\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "apply (auto simp: algebra_simps vector_derivative_works)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1)) has_vector_derivative\n                     2 *\\<^sub>R vector_derivative g2 (at (?z * 2 - 1)))\n                     (at ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "assume ass: \"1 < z*2\" \"z \\<le> 1\" \"z*2 - 1 \\<notin> s2\""], ["proof (state)\nthis:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "then"], ["proof (chain)\npicking this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2", "have z_le: \"z\\<le> 1\""], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. z \\<le> 1", "by auto"], ["proof (state)\nthis:\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "have z_ge: \"0 \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> z", "using ass"], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. 0 \\<le> z", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1})\n                                = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "using Derivative.vector_derivative_at_within_ivl[OF g2_at_z[OF ass] z_ge z_le]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R vector_derivative g2 (at (?z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "assume ass: \"1 < z*2\" \"z \\<le> 1\" \"z*2 - 1 \\<notin> s2\""], ["proof (state)\nthis:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "then"], ["proof (chain)\npicking this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2", "have \"(g2 has_vector_derivative ((vector_derivative g2 (at (z*2 - 1))))) (at (z*2 - 1))\""], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n     (at (z * 2 - 1))", "using s2"], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n     (at (z * 2 - 1))", "by (auto simp: algebra_simps vector_derivative_works)"], ["proof (state)\nthis:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "then"], ["proof (chain)\npicking this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))", "have ii: \"(vector_derivative g2 (at (z*2 - 1) within {0..1})) = (vector_derivative g2 (at (z*2 - 1)))\""], ["proof (prove)\nusing this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n    vector_derivative g2 (at (z * 2 - 1))", "using Derivative.vector_derivative_at_within_ivl ass"], ["proof (prove)\nusing this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n    vector_derivative g2 (at (z * 2 - 1))", "by force"], ["proof (state)\nthis:\n  vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n  vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})", "using i[OF ass] ii"], ["proof (prove)\nusing this:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n  vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n  vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R\n                    vector_derivative g2 (at (?z * 2 - 1) within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "have lem1: \"((\\<lambda>x. \\<Sum>b\\<in>basis. f ((g1+++g2) x) \\<bullet> b * (vector_derivative (g1+++g2) (at x within {0..1}) \\<bullet> b)) has_integral i1) {0..1/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f ((g1 +++ g2) x) \\<bullet> b *\n           (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     i1)\n     {0..1 / 2}", "apply (rule has_integral_spike_finite [OF _ _ i1, of \"insert (1/2) ((*)2 -` s1)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (insert (1 / 2) ((*) 2 -` s1))\n 2. \\<And>x.\n       x \\<in> {0..1 / 2} - insert (1 / 2) ((*) 2 -` s1) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g1 (2 * x)) \\<bullet> b *\n          (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet> b))", "using s1"], ["proof (prove)\nusing this:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (2 subgoals):\n 1. finite (insert (1 / 2) ((*) 2 -` s1))\n 2. \\<And>x.\n       x \\<in> {0..1 / 2} - insert (1 / 2) ((*) 2 -` s1) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g1 (2 * x)) \\<bullet> b *\n          (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet> b))", "apply (force intro: finite_vimageI [where h = \"(*)2\"] inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1 / 2} - insert (1 / 2) ((*) 2 -` s1) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g1 (2 * x)) \\<bullet> b *\n          (vector_derivative g1 (at (2 * x) within {0..1}) \\<bullet> b))", "apply (clarsimp simp add: joinpaths_def scaleR_conv_of_real mult_ac g1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 \\<le> x; x * 2 \\<le> 1; x * 2 \\<noteq> 1;\n        x * 2 \\<notin> s1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>b\\<in>basis.\n                            2 *\n                            (f (g1 (x * 2)) \\<bullet> b *\n                             (vector_derivative g1\n                               (at (x * 2) within {0..1}) \\<bullet>\n                              b))) =\n                         2 *\n                         (\\<Sum>b\\<in>basis.\n                            f (g1 (x * 2)) \\<bullet> b *\n                            (vector_derivative g1\n                              (at (x * 2) within {0..1}) \\<bullet>\n                             b))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1 / 2}\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1 / 2}\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "have lem2: \"((\\<lambda>x. \\<Sum>b\\<in>basis. f ((g1+++g2) x) \\<bullet> b * (vector_derivative (g1+++g2) (at x within {0..1}) \\<bullet> b)) has_integral i2) {1/2..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f ((g1 +++ g2) x) \\<bullet> b *\n           (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     i2)\n     {1 / 2..1}", "apply (rule has_integral_spike_finite [OF _ _ i2, of \"insert (1/2) ((\\<lambda>x. 2*x-1) -` s2)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (insert (1 / 2) ((\\<lambda>x. 2 * x - 1) -` s2))\n 2. \\<And>x.\n       x \\<in> {1 / 2..1} -\n               insert (1 / 2)\n                ((\\<lambda>x. 2 * x - 1) -` s2) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g2 (2 * x - 1)) \\<bullet> b *\n          (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet> b))", "using s2"], ["proof (prove)\nusing this:\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (2 subgoals):\n 1. finite (insert (1 / 2) ((\\<lambda>x. 2 * x - 1) -` s2))\n 2. \\<And>x.\n       x \\<in> {1 / 2..1} -\n               insert (1 / 2)\n                ((\\<lambda>x. 2 * x - 1) -` s2) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g2 (2 * x - 1)) \\<bullet> b *\n          (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet> b))", "apply (force intro: finite_vimageI [where h = \"\\<lambda>x. 2*x-1\"] inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1 / 2..1} -\n               insert (1 / 2)\n                ((\\<lambda>x. 2 * x - 1) -` s2) \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) x) \\<bullet> b *\n          (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n           b)) =\n       2 *\n       (\\<Sum>b\\<in>basis.\n          f (g2 (2 * x - 1)) \\<bullet> b *\n          (vector_derivative g2 (at (2 * x - 1) within {0..1}) \\<bullet> b))", "apply (clarsimp simp add: joinpaths_def scaleR_conv_of_real mult_ac g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>1 \\<le> x * 2; x \\<le> 1; x * 2 \\<noteq> 1;\n        x * 2 - 1 \\<notin> s2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>b\\<in>basis.\n                            2 *\n                            (f (g2 (x * 2 - 1)) \\<bullet> b *\n                             (vector_derivative g2\n                               (at (x * 2 - 1) within {0..1}) \\<bullet>\n                              b))) =\n                         2 *\n                         (\\<Sum>b\\<in>basis.\n                            f (g2 (x * 2 - 1)) \\<bullet> b *\n                            (vector_derivative g2\n                              (at (x * 2 - 1) within {0..1}) \\<bullet>\n                             b))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {1 / 2..1}\n\ngoal (2 subgoals):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2\n 2. line_integral_exists f basis (g1 +++ g2)", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1 / 2}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {1 / 2..1}", "show \"line_integral f basis (g1 +++ g2) = line_integral f basis g1 + line_integral f basis g2\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1 / 2}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {1 / 2..1}\n\ngoal (1 subgoal):\n 1. line_integral f basis (g1 +++ g2) =\n    line_integral f basis g1 + line_integral f basis g2", "apply (simp add: line_integral_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> integral {0..1}\n                       (\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f ((g1 +++ g2) x) \\<bullet> b *\n                             (vector_derivative (g1 +++ g2)\n                               (at x within {0..1}) \\<bullet>\n                              b)) =\n                      integral {0..1}\n                       (\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g1 x) \\<bullet> b *\n                             (vector_derivative g1\n                               (at x within {0..1}) \\<bullet>\n                              b)) +\n                      integral {0..1}\n                       (\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g2 x) \\<bullet> b *\n                             (vector_derivative g2\n                               (at x within {0..1}) \\<bullet>\n                              b))", "apply (rule integral_unique [OF has_integral_combine [where c = \"1/2\"]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 1 / 2\n 2. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> 1 / 2 \\<le> 1\n 3. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f ((g1 +++ g2) x) \\<bullet> b *\n                             (vector_derivative (g1 +++ g2)\n                               (at x within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g1 x) \\<bullet> b *\n                              (vector_derivative g1\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {0..1 / 2}\n 4. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f ((g1 +++ g2) x) \\<bullet> b *\n                             (vector_derivative (g1 +++ g2)\n                               (at x within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g2 x) \\<bullet> b *\n                              (vector_derivative g2\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {1 / 2..1}", "using 1 2 integral_unique"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g1 x) \\<bullet> b *\n         (vector_derivative g1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g2 x) \\<bullet> b *\n         (vector_derivative g2 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {0..1}\n  (?f has_integral ?y) ?k \\<Longrightarrow> integral ?k ?f = ?y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 1 / 2\n 2. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> 1 / 2 \\<le> 1\n 3. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f ((g1 +++ g2) x) \\<bullet> b *\n                             (vector_derivative (g1 +++ g2)\n                               (at x within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g1 x) \\<bullet> b *\n                              (vector_derivative g1\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {0..1 / 2}\n 4. \\<lbrakk>((\\<lambda>x.\n                  \\<Sum>b\\<in>basis.\n                    f ((g1 +++ g2) x) \\<bullet> b *\n                    (vector_derivative (g1 +++ g2)\n                      (at x within {0..1}) \\<bullet>\n                     b)) has_integral\n              i1)\n              {0..1 / 2};\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f ((g1 +++ g2) x) \\<bullet> b *\n            (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      i2)\n      {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f ((g1 +++ g2) x) \\<bullet> b *\n                             (vector_derivative (g1 +++ g2)\n                               (at x within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g2 x) \\<bullet> b *\n                              (vector_derivative g2\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {1 / 2..1}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  line_integral f basis (g1 +++ g2) =\n  line_integral f basis g1 + line_integral f basis g2\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis (g1 +++ g2)", "show \"line_integral_exists f basis (g1 +++ g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis (g1 +++ g2)", "proof (simp add: line_integral_exists_def integrable_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       ((\\<lambda>x.\n            \\<Sum>b\\<in>basis.\n              f ((g1 +++ g2) x) \\<bullet> b *\n              (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n               b)) has_integral\n        y)\n        {0..1}", "have \"(1::real) \\<le> 1 * 2 \\<and> (0::real) \\<le> 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> 1 * 2 \\<and> 0 \\<le> 1 / 2", "by simp"], ["proof (state)\nthis:\n  1 \\<le> 1 * 2 \\<and> 0 \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       ((\\<lambda>x.\n            \\<Sum>b\\<in>basis.\n              f ((g1 +++ g2) x) \\<bullet> b *\n              (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n               b)) has_integral\n        y)\n        {0..1}", "then"], ["proof (chain)\npicking this:\n  1 \\<le> 1 * 2 \\<and> 0 \\<le> 1 / 2", "show \"\\<exists>r. ((\\<lambda>r. \\<Sum>a\\<in>basis. f ((g1 +++ g2) r) \\<bullet> a * (vector_derivative (g1 +++ g2) (at r within {0..1}) \\<bullet> a)) has_integral r) {0..1}\""], ["proof (prove)\nusing this:\n  1 \\<le> 1 * 2 \\<and> 0 \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       ((\\<lambda>r.\n            \\<Sum>a\\<in>basis.\n              f ((g1 +++ g2) r) \\<bullet> a *\n              (vector_derivative (g1 +++ g2) (at r within {0..1}) \\<bullet>\n               a)) has_integral\n        r)\n        {0..1}", "using has_integral_combine [where c = \"1/2\"] 1 2 divide_le_eq_numeral1(1) lem1 lem2"], ["proof (prove)\nusing this:\n  1 \\<le> 1 * 2 \\<and> 0 \\<le> 1 / 2\n  \\<lbrakk>?a \\<le> 1 / 2; 1 / 2 \\<le> ?b; (?f has_integral ?i) {?a..1 / 2};\n   (?f has_integral ?j) {1 / 2..?b}\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?i + ?j) {?a..?b}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g1 x) \\<bullet> b *\n         (vector_derivative g1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g2 x) \\<bullet> b *\n         (vector_derivative g2 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {0..1}\n  (?b / numeral ?w \\<le> ?a) = (?b \\<le> ?a * numeral ?w)\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i1)\n   {0..1 / 2}\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f ((g1 +++ g2) x) \\<bullet> b *\n         (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i2)\n   {1 / 2..1}\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       ((\\<lambda>r.\n            \\<Sum>a\\<in>basis.\n              f ((g1 +++ g2) r) \\<bullet> a *\n              (vector_derivative (g1 +++ g2) (at r within {0..1}) \\<bullet>\n               a)) has_integral\n        r)\n        {0..1}", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     ((\\<lambda>r.\n          \\<Sum>a\\<in>basis.\n            f ((g1 +++ g2) r) \\<bullet> a *\n            (vector_derivative (g1 +++ g2) (at r within {0..1}) \\<bullet>\n             a)) has_integral\n      r)\n      {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists f basis (g1 +++ g2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_joinD1:\n  assumes \"line_integral_exists f basis (g1 +++ g2)\" \"valid_path g1\"\n  shows \"line_integral_exists f basis g1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "obtain s1\n    where s1: \"finite s1\" \"\\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>finite s1;\n         \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis (g1 +++ g2)\n  valid_path g1\n\ngoal (1 subgoal):\n 1. (\\<And>s1.\n        \\<lbrakk>finite s1;\n         \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: valid_path_def piecewise_C1_differentiable_on_def C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "have \"(\\<lambda>x. \\<Sum>b\\<in>basis. f ((g1 +++ g2) (x/2)) \\<bullet> b * (vector_derivative (g1 +++ g2) (at (x/2) within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis (g1 +++ g2)\n  valid_path g1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "apply (auto simp: line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x.\n                 \\<Sum>b\\<in>basis.\n                   f ((g1 +++ g2) x) \\<bullet> b *\n                   (vector_derivative (g1 +++ g2)\n                     (at x within {0..1}) \\<bullet>\n                    b)) integrable_on\n             {0..1};\n     valid_path g1\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2) within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (drule integrable_on_subcbox [where a=0 and b=\"1/2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path g1 \\<Longrightarrow> cbox 0 (1 / 2) \\<subseteq> {0..1}\n 2. \\<lbrakk>valid_path g1;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f ((g1 +++ g2) x) \\<bullet> b *\n           (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     cbox 0 (1 / 2)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2) within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (auto intro: integrable_affinity [of _ 0 \"1/2::real\" \"1/2\" 0, simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2) (at (x / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2) (at (x / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}", "have *:\"(\\<lambda>x. \\<Sum>b\\<in>basis. ((f ((g1 +++ g2) (x/2)) \\<bullet> b) / 2)* (vector_derivative (g1 +++ g2) (at (x/2) within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2) (at (x / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2)) \\<bullet> b / 2 *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "by (auto simp: Groups_Big.sum_distrib_left dest: integrable_cmul [where c=\"1/2\"] simp: scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2)) \\<bullet> b / 2 *\n        (vector_derivative (g1 +++ g2) (at (x / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "have g1: \"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n            vector_derivative (\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) (at z within {0..1}) =\n            2 *\\<^sub>R vector_derivative g1 (at (z*2) within {0..1})\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "have i:\"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n              vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2))\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "have g1_at_z:\"\\<lbrakk>0 \\<le> z; z*2 < 1; z*2 \\<notin> s1\\<rbrakk> \\<Longrightarrow>\n                         ((\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) has_vector_derivative\n                         2 *\\<^sub>R vector_derivative g1 (at (z*2))) (at z)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (rule has_vector_derivative_transform_at [of \"\\<bar>z - 1/2\\<bar>\" _ \"(\\<lambda>x. g1(2*x))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> 0 < \\<bar>z - 1 / 2\\<bar>\n 2. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x'.\n                         dist x' z < \\<bar>z - 1 / 2\\<bar> \\<longrightarrow>\n                         g1 (2 * x') =\n                         (if x' * 2 \\<le> 1 then g1 (2 * x')\n                          else g2 (2 * x' - 1))\n 3. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g1 (2 * x)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (simp_all add: dist_real_def abs_if split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g1 (2 * x)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g1 (at (z * 2)))\n                       (at z)", "apply (rule vector_diff_chain_at [of \"\\<lambda>x. 2*x\" 2 _ g1, simplified o_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> ((*) 2 has_vector_derivative 2) (at z)\n 2. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "apply (simp add: has_vector_derivative_def has_derivative_def bounded_linear_mult_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "using s1"], ["proof (prove)\nusing this:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> (g1 has_vector_derivative\n                       vector_derivative g1 (at (z * 2)))\n                       (at (2 * z))", "apply (auto simp: algebra_simps vector_derivative_works)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1)) has_vector_derivative\n                     2 *\\<^sub>R vector_derivative g1 (at (?z * 2)))\n                     (at ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "assume ass: \"0 \\<le> z\" \"z*2 < 1\" \"z*2 \\<notin> s1\""], ["proof (state)\nthis:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1", "have z_ge: \"z\\<le> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. z \\<le> 1", "by auto"], ["proof (state)\nthis:\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "using Derivative.vector_derivative_at_within_ivl[OF g1_at_z[OF ass] ass(1) z_ge]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2))", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R vector_derivative g1 (at (?z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "assume ass: \"0 \\<le> z\" \"z*2 < 1\" \"z*2 \\<notin> s1\""], ["proof (state)\nthis:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "then"], ["proof (chain)\npicking this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1", "have \"(g1 has_vector_derivative ((vector_derivative g1 (at (z*2))))) (at (z*2))\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. (g1 has_vector_derivative vector_derivative g1 (at (z * 2)))\n     (at (z * 2))", "using s1"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. (g1 has_vector_derivative vector_derivative g1 (at (z * 2)))\n     (at (z * 2))", "by (auto simp: algebra_simps vector_derivative_works)"], ["proof (state)\nthis:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "then"], ["proof (chain)\npicking this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))", "have ii: \"(vector_derivative g1 (at (z*2) within {0..1})) = (vector_derivative g1 (at (z*2)))\""], ["proof (prove)\nusing this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative g1 (at (z * 2) within {0..1}) =\n    vector_derivative g1 (at (z * 2))", "using Derivative.vector_derivative_at_within_ivl ass"], ["proof (prove)\nusing this:\n  (g1 has_vector_derivative vector_derivative g1 (at (z * 2))) (at (z * 2))\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  0 \\<le> z\n  z * 2 < 1\n  z * 2 \\<notin> s1\n\ngoal (1 subgoal):\n 1. vector_derivative g1 (at (z * 2) within {0..1}) =\n    vector_derivative g1 (at (z * 2))", "by force"], ["proof (state)\nthis:\n  vector_derivative g1 (at (z * 2) within {0..1}) =\n  vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z * 2 < 1; z * 2 \\<notin> s1\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g1 (at (z * 2) within {0..1})", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})", "using i[OF ass] ii"], ["proof (prove)\nusing this:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2))\n  vector_derivative g1 (at (z * 2) within {0..1}) =\n  vector_derivative g1 (at (z * 2))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g1 (at (z * 2) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?z; ?z * 2 < 1; ?z * 2 \\<notin> s1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R\n                    vector_derivative g1 (at (?z * 2) within {0..1})\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "using s1"], ["proof (prove)\nusing this:\n  finite s1\n  \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g1", "apply (auto simp: line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s1;\n     \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f (g1 x) \\<bullet> b *\n                            (vector_derivative g1\n                              (at x within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (rule integrable_spike_finite [of \"{0,1} \\<union> s1\", OF _ _ *])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite s1;\n     \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x\\<rbrakk>\n    \\<Longrightarrow> finite ({0, 1} \\<union> s1)\n 2. \\<And>x.\n       \\<lbrakk>finite s1;\n        \\<forall>x\\<in>{0..1} - s1. g1 differentiable at x;\n        x \\<in> {0..1} - ({0, 1} \\<union> s1)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>b\\<in>basis.\n                            f (g1 x) \\<bullet> b *\n                            (vector_derivative g1\n                              (at x within {0..1}) \\<bullet>\n                             b)) =\n                         (\\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2)) \\<bullet> b / 2 *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2) within {0..1}) \\<bullet>\n                             b))", "apply (auto simp: joinpaths_def scaleR_conv_of_real g1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  line_integral_exists f basis g1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_joinD2:\n  assumes \"line_integral_exists f basis (g1 +++ g2)\" \"valid_path g2\"\n  shows \"line_integral_exists f basis g2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "obtain s2\n    where s2: \"finite s2\" \"\\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>finite s2;\n         \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis (g1 +++ g2)\n  valid_path g2\n\ngoal (1 subgoal):\n 1. (\\<And>s2.\n        \\<lbrakk>finite s2;\n         \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: valid_path_def piecewise_C1_differentiable_on_def C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "have \"(\\<lambda>x. \\<Sum>b\\<in>basis. f ((g1 +++ g2) (x/2 + 1/2)) \\<bullet> b * (vector_derivative (g1 +++ g2) (at (x/2 + 1/2) within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists f basis (g1 +++ g2)\n  valid_path g2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "apply (auto simp: line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x.\n                 \\<Sum>b\\<in>basis.\n                   f ((g1 +++ g2) x) \\<bullet> b *\n                   (vector_derivative (g1 +++ g2)\n                     (at x within {0..1}) \\<bullet>\n                    b)) integrable_on\n             {0..1};\n     valid_path g2\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (drule integrable_on_subcbox [where a=\"1/2\" and b=1], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path g2;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f ((g1 +++ g2) x) \\<bullet> b *\n           (vector_derivative (g1 +++ g2) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (drule integrable_affinity [of _ \"1/2::real\" 1 \"1/2\" \"1/2\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_path g2;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n           (vector_derivative (g1 +++ g2)\n             (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n            b)) integrable_on\n     (\\<lambda>x. 2 * x - 1) ` {1 / 2..1}\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (simp add: image_affinity_atLeastAtMost_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2)\n          (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2)\n          (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}", "have *:\"(\\<lambda>x. \\<Sum>b\\<in>basis. ((f ((g1 +++ g2) (x/2 + 1/2)) \\<bullet> b) / 2)* (vector_derivative (g1 +++ g2) (at (x/2 + 1/2) within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b *\n        (vector_derivative (g1 +++ g2)\n          (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b / 2 *\n          (vector_derivative (g1 +++ g2)\n            (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "by (auto simp: Groups_Big.sum_distrib_left dest: integrable_cmul [where c=\"1/2\"] simp: scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b / 2 *\n        (vector_derivative (g1 +++ g2)\n          (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "have g2: \"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n            vector_derivative (\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) (at z within {0..1}) =\n            2 *\\<^sub>R vector_derivative g2 (at (z*2 - 1) within {0..1})\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "have i:\"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n              vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1})\n                   = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "have g2_at_z:\"\\<lbrakk>1 < z*2; z \\<le> 1; z*2 - 1 \\<notin> s2\\<rbrakk> \\<Longrightarrow>\n                      ((\\<lambda>x. if x*2 \\<le> 1 then g1 (2*x) else g2 (2*x - 1)) has_vector_derivative 2 *\\<^sub>R vector_derivative g2 (at (z*2 - 1))) (at z)\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (rule has_vector_derivative_transform_at [of \"\\<bar>z - 1/2\\<bar>\" _ \"(\\<lambda>x. g2 (2*x - 1))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> 0 < \\<bar>z - 1 / 2\\<bar>\n 2. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x'.\n                         dist x' z < \\<bar>z - 1 / 2\\<bar> \\<longrightarrow>\n                         g2 (2 * x' - 1) =\n                         (if x' * 2 \\<le> 1 then g1 (2 * x')\n                          else g2 (2 * x' - 1))\n 3. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (simp_all add: dist_real_def abs_if split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. g2 (2 * x - 1)) has_vector_derivative\n                       2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1)))\n                       (at z)", "apply (rule vector_diff_chain_at [of \"\\<lambda>x. 2*x - 1\" 2 _ g2, simplified o_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. 2 * x - 1) has_vector_derivative 2)\n                       (at z)\n 2. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "apply (simp add: has_vector_derivative_def has_derivative_def bounded_linear_mult_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "using s2"], ["proof (prove)\nusing this:\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> (g2 has_vector_derivative\n                       vector_derivative g2 (at (z * 2 - 1)))\n                       (at (2 * z - 1))", "apply (auto simp: algebra_simps vector_derivative_works)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1)) has_vector_derivative\n                     2 *\\<^sub>R vector_derivative g2 (at (?z * 2 - 1)))\n                     (at ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "assume ass: \"1 < z*2\" \"z \\<le> 1\" \"z*2 - 1 \\<notin> s2\""], ["proof (state)\nthis:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "then"], ["proof (chain)\npicking this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2", "have z_le: \"z\\<le> 1\""], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. z \\<le> 1", "by auto"], ["proof (state)\nthis:\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "have z_ge: \"0 \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> z", "using ass"], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. 0 \\<le> z", "by auto"], ["proof (state)\nthis:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1})\n                                = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "using Derivative.vector_derivative_at_within_ivl[OF g2_at_z[OF ass] z_ge z_le]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R vector_derivative g2 (at (?z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "assume ass: \"1 < z*2\" \"z \\<le> 1\" \"z*2 - 1 \\<notin> s2\""], ["proof (state)\nthis:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "then"], ["proof (chain)\npicking this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2", "have \"(g2 has_vector_derivative ((vector_derivative g2 (at (z*2 - 1))))) (at (z*2 - 1))\""], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n     (at (z * 2 - 1))", "using s2"], ["proof (prove)\nusing this:\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n     (at (z * 2 - 1))", "by (auto simp: algebra_simps vector_derivative_works)"], ["proof (state)\nthis:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "then"], ["proof (chain)\npicking this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))", "have ii: \"(vector_derivative g2 (at (z*2 - 1) within {0..1})) = (vector_derivative g2 (at (z*2 - 1)))\""], ["proof (prove)\nusing this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n    vector_derivative g2 (at (z * 2 - 1))", "using Derivative.vector_derivative_at_within_ivl ass"], ["proof (prove)\nusing this:\n  (g2 has_vector_derivative vector_derivative g2 (at (z * 2 - 1)))\n   (at (z * 2 - 1))\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n  1 < z * 2\n  z \\<le> 1\n  z * 2 - 1 \\<notin> s2\n\ngoal (1 subgoal):\n 1. vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n    vector_derivative g2 (at (z * 2 - 1))", "by force"], ["proof (state)\nthis:\n  vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n  vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < z * 2; z \\<le> 1; z * 2 - 1 \\<notin> s2\\<rbrakk>\n    \\<Longrightarrow> vector_derivative\n                       (\\<lambda>x.\n                           if x * 2 \\<le> 1 then g1 (2 * x)\n                           else g2 (2 * x - 1))\n                       (at z within {0..1}) =\n                      2 *\\<^sub>R\n                      vector_derivative g2 (at (z * 2 - 1) within {0..1})", "show \"vector_derivative (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1)) (at z within {0..1}) = 2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})", "using i[OF ass] ii"], ["proof (prove)\nusing this:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1))\n  vector_derivative g2 (at (z * 2 - 1) within {0..1}) =\n  vector_derivative g2 (at (z * 2 - 1))\n\ngoal (1 subgoal):\n 1. vector_derivative\n     (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n     (at z within {0..1}) =\n    2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative\n   (\\<lambda>x. if x * 2 \\<le> 1 then g1 (2 * x) else g2 (2 * x - 1))\n   (at z within {0..1}) =\n  2 *\\<^sub>R vector_derivative g2 (at (z * 2 - 1) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>1 < ?z * 2; ?z \\<le> 1; ?z * 2 - 1 \\<notin> s2\\<rbrakk>\n  \\<Longrightarrow> vector_derivative\n                     (\\<lambda>x.\n                         if x * 2 \\<le> 1 then g1 (2 * x)\n                         else g2 (2 * x - 1))\n                     (at ?z within {0..1}) =\n                    2 *\\<^sub>R\n                    vector_derivative g2 (at (?z * 2 - 1) within {0..1})\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "using s2"], ["proof (prove)\nusing this:\n  finite s2\n  \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis g2", "apply (auto simp: line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite s2;\n     \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          \\<Sum>b\\<in>basis.\n                            f (g2 x) \\<bullet> b *\n                            (vector_derivative g2\n                              (at x within {0..1}) \\<bullet>\n                             b)) integrable_on\n                      {0..1}", "apply (rule integrable_spike_finite [of \"{0,1} \\<union> s2\", OF _ _ *])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite s2;\n     \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x\\<rbrakk>\n    \\<Longrightarrow> finite ({0, 1} \\<union> s2)\n 2. \\<And>x.\n       \\<lbrakk>finite s2;\n        \\<forall>x\\<in>{0..1} - s2. g2 differentiable at x;\n        x \\<in> {0..1} - ({0, 1} \\<union> s2)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>b\\<in>basis.\n                            f (g2 x) \\<bullet> b *\n                            (vector_derivative g2\n                              (at x within {0..1}) \\<bullet>\n                             b)) =\n                         (\\<Sum>b\\<in>basis.\n                            f ((g1 +++ g2) (x / 2 + 1 / 2)) \\<bullet> b /\n                            2 *\n                            (vector_derivative (g1 +++ g2)\n                              (at (x / 2 + 1 / 2) within {0..1}) \\<bullet>\n                             b))", "apply (auto simp: joinpaths_def scaleR_conv_of_real g2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  line_integral_exists f basis g2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_line_integral_on_reverse_path:\n  assumes g: \"valid_path g\" and int:\n    \"((\\<lambda>x. \\<Sum>b\\<in>basis. F (g x) \\<bullet> b * (vector_derivative g (at x within {0..1}) \\<bullet> b)) has_integral c){0..1}\"\n  shows  \"((\\<lambda>x. \\<Sum>b\\<in>basis. F ((reversepath g) x) \\<bullet> b * (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet> b)) has_integral -c){0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "fix s x"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "assume xs: \"g C1_differentiable_on ({0..1} - s)\" \"x \\<notin> (-) 1 ` s\" \"0 \\<le> x\" \"x \\<le> 1\""], ["proof (state)\nthis:\n  g C1_differentiable_on {0..1} - s\n  x \\<notin> (-) 1 ` s\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "have \"vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n                - vector_derivative g (at (1 - x) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "obtain f' where f': \"(g has_vector_derivative f') (at (1 - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        (g has_vector_derivative f') (at (1 - x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using xs"], ["proof (prove)\nusing this:\n  g C1_differentiable_on {0..1} - s\n  x \\<notin> (-) 1 ` s\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        (g has_vector_derivative f') (at (1 - x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force simp: has_vector_derivative_def C1_differentiable_on_def)"], ["proof (state)\nthis:\n  (g has_vector_derivative f') (at (1 - x))\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "have \"(g o (\\<lambda>x. 1 - x) has_vector_derivative -1 *\\<^sub>R f') (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ> (-) 1 has_vector_derivative - 1 *\\<^sub>R f') (at x)", "apply (rule vector_diff_chain_within)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((-) 1 has_vector_derivative - 1) (at x)\n 2. (g has_vector_derivative f') (at (1 - x) within range ((-) 1))", "apply (intro vector_diff_chain_within derivative_eq_intros | simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g has_vector_derivative f') (at (1 - x) within range ((-) 1))", "apply (rule has_vector_derivative_at_within [OF f'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (g \\<circ> (-) 1 has_vector_derivative - 1 *\\<^sub>R f') (at x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "then"], ["proof (chain)\npicking this:\n  (g \\<circ> (-) 1 has_vector_derivative - 1 *\\<^sub>R f') (at x)", "have mf': \"((\\<lambda>x. g (1 - x)) has_vector_derivative -f') (at x)\""], ["proof (prove)\nusing this:\n  (g \\<circ> (-) 1 has_vector_derivative - 1 *\\<^sub>R f') (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g (1 - x)) has_vector_derivative - f') (at x)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. g (1 - x)) has_vector_derivative - f') (at x)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "using xs"], ["proof (prove)\nusing this:\n  g C1_differentiable_on {0..1} - s\n  x \\<notin> (-) 1 ` s\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n    - vector_derivative g (at (1 - x) within {0..1})", "by (auto simp: vector_derivative_at_within_ivl [OF mf'] vector_derivative_at_within_ivl [OF f'])"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n  - vector_derivative g (at (1 - x) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. g (1 - x)) (at x within {0..1}) =\n  - vector_derivative g (at (1 - x) within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g C1_differentiable_on {0..1} - ?s2; ?x2 \\<notin> (-) 1 ` ?s2;\n   0 \\<le> ?x2; ?x2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<lambda>x. g (1 - x))\n                     (at ?x2 within {0..1}) =\n                    - vector_derivative g (at (1 - ?x2) within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>g C1_differentiable_on {0..1} - ?s2; ?x2 \\<notin> (-) 1 ` ?s2;\n   0 \\<le> ?x2; ?x2 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<lambda>x. g (1 - x))\n                     (at ?x2 within {0..1}) =\n                    - vector_derivative g (at (1 - ?x2) within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "obtain S where \"continuous_on {0..1} g\" \"finite S\" \"g C1_differentiable_on {0..1} - S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>continuous_on {0..1} g; finite S;\n         g C1_differentiable_on {0..1} - S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g"], ["proof (prove)\nusing this:\n  valid_path g\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>continuous_on {0..1} g; finite S;\n         g C1_differentiable_on {0..1} - S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: valid_path_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} g\n  finite S\n  g C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1} g\n  finite S\n  g C1_differentiable_on {0..1} - S", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  finite S\n  g C1_differentiable_on {0..1} - S\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "using has_integral_affinity01 [OF int, where m= \"-1\" and c=1]"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  finite S\n  g C1_differentiable_on {0..1} - S\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (g (- 1 * x + 1)) \\<bullet> b *\n         (vector_derivative g (at (- 1 * x + 1) within {0..1}) \\<bullet>\n          b)) has_integral\n   (1 / \\<bar>- 1\\<bar>) *\\<^sub>R c)\n   ((\\<lambda>x. x / - 1 - 1 / - 1) ` {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath g x) \\<bullet> b *\n           (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "unfolding reversepath_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g\n  finite S\n  g C1_differentiable_on {0..1} - S\n  - 1 \\<noteq> 0 \\<Longrightarrow>\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (g (- 1 * x + 1)) \\<bullet> b *\n         (vector_derivative g (at (- 1 * x + 1) within {0..1}) \\<bullet>\n          b)) has_integral\n   (1 / \\<bar>- 1\\<bar>) *\\<^sub>R c)\n   ((\\<lambda>x. x / - 1 - 1 / - 1) ` {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (g (1 - x)) \\<bullet> b *\n           (vector_derivative (\\<lambda>x. g (1 - x))\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - c)\n     {0..1}", "by (rule_tac S = \"(\\<lambda>x. 1 - x) ` S\" in has_integral_spike_finite) (auto simp: * has_integral_neg Groups_Big.sum_negf)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath g x) \\<bullet> b *\n         (vector_derivative (reversepath g) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - c)\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_on_reverse_path:\n  assumes \"valid_path \\<gamma>\" \"line_integral_exists F basis \\<gamma>\"\n  shows \"line_integral F basis \\<gamma> = - (line_integral F basis (reversepath \\<gamma>))\"\n        \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>) &&&\n    line_integral_exists F basis (reversepath \\<gamma>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)\n 2. line_integral_exists F basis (reversepath \\<gamma>)", "obtain i where\n    0: \"((\\<lambda>x. \\<Sum>b\\<in>basis. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) has_integral i){0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ((\\<lambda>x.\n             \\<Sum>b\\<in>basis.\n               F (\\<gamma> x) \\<bullet> b *\n               (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n                b)) has_integral\n         i)\n         {0..1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ((\\<lambda>x.\n             \\<Sum>b\\<in>basis.\n               F (\\<gamma> x) \\<bullet> b *\n               (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n                b)) has_integral\n         i)\n         {0..1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding integrable_on_def line_integral_exists_def"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  \\<exists>y.\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      y)\n      {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ((\\<lambda>x.\n             \\<Sum>b\\<in>basis.\n               F (\\<gamma> x) \\<bullet> b *\n               (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n                b)) has_integral\n         i)\n         {0..1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i)\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)\n 2. line_integral_exists F basis (reversepath \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i)\n   {0..1}", "have 1: \"((\\<lambda>x. \\<Sum>b\\<in>basis. F ((reversepath \\<gamma>) x) \\<bullet> b * (vector_derivative (reversepath \\<gamma>) (at x within {0..1}) \\<bullet> b)) has_integral -i){0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath \\<gamma> x) \\<bullet> b *\n           (vector_derivative (reversepath \\<gamma>)\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - i)\n     {0..1}", "using has_line_integral_on_reverse_path assms"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i)\n   {0..1}\n  \\<lbrakk>valid_path ?g;\n   ((\\<lambda>x.\n        \\<Sum>b\\<in>?basis.\n          ?F (?g x) \\<bullet> b *\n          (vector_derivative ?g (at x within {0..1}) \\<bullet>\n           b)) has_integral\n    ?c)\n    {0..1}\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         \\<Sum>b\\<in>?basis.\n                           ?F (reversepath ?g x) \\<bullet> b *\n                           (vector_derivative (reversepath ?g)\n                             (at x within {0..1}) \\<bullet>\n                            b)) has_integral\n                     - ?c)\n                     {0..1}\n  valid_path \\<gamma>\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (reversepath \\<gamma> x) \\<bullet> b *\n           (vector_derivative (reversepath \\<gamma>)\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     - i)\n     {0..1}", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath \\<gamma> x) \\<bullet> b *\n         (vector_derivative (reversepath \\<gamma>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - i)\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)\n 2. line_integral_exists F basis (reversepath \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath \\<gamma> x) \\<bullet> b *\n         (vector_derivative (reversepath \\<gamma>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - i)\n   {0..1}", "have rev_line_integral:\"line_integral F basis (reversepath \\<gamma>) = -i\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath \\<gamma> x) \\<bullet> b *\n         (vector_derivative (reversepath \\<gamma>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - i)\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral F basis (reversepath \\<gamma>) = - i", "using line_integral_def Henstock_Kurzweil_Integration.integral_unique"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath \\<gamma> x) \\<bullet> b *\n         (vector_derivative (reversepath \\<gamma>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - i)\n   {0..1}\n  line_integral ?F ?basis ?g \\<equiv>\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>?basis.\n         ?F (?g x) \\<bullet> b *\n         (vector_derivative ?g (at x within {0..1}) \\<bullet> b))\n  (?f has_integral ?y) ?k \\<Longrightarrow> integral ?k ?f = ?y\n\ngoal (1 subgoal):\n 1. line_integral F basis (reversepath \\<gamma>) = - i", "by (metis (no_types))"], ["proof (state)\nthis:\n  line_integral F basis (reversepath \\<gamma>) = - i\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)\n 2. line_integral_exists F basis (reversepath \\<gamma>)", "have line_integral: \"line_integral F basis \\<gamma> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> = i", "using line_integral_def 0 Henstock_Kurzweil_Integration.integral_unique"], ["proof (prove)\nusing this:\n  line_integral ?F ?basis ?g \\<equiv>\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>?basis.\n         ?F (?g x) \\<bullet> b *\n         (vector_derivative ?g (at x within {0..1}) \\<bullet> b))\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   i)\n   {0..1}\n  (?f has_integral ?y) ?k \\<Longrightarrow> integral ?k ?f = ?y\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> = i", "by blast"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> = i\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)\n 2. line_integral_exists F basis (reversepath \\<gamma>)", "show \"line_integral F basis \\<gamma> = - (line_integral F basis (reversepath \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)", "using line_integral rev_line_integral"], ["proof (prove)\nusing this:\n  line_integral F basis \\<gamma> = i\n  line_integral F basis (reversepath \\<gamma>) = - i\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    - line_integral F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> =\n  - line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "show \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using 1 line_integral_exists_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (reversepath \\<gamma> x) \\<bullet> b *\n         (vector_derivative (reversepath \\<gamma>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   - i)\n   {0..1}\n  line_integral_exists ?F ?basis ?\\<gamma> \\<equiv>\n  (\\<lambda>x.\n      \\<Sum>b\\<in>?basis.\n        ?F (?\\<gamma> x) \\<bullet> b *\n        (vector_derivative ?\\<gamma> (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_on_degenerate_path:\n  assumes \"finite basis\"\n  shows \"line_integral_exists F basis (\\<lambda>x. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "have every_component_integrable:\n    \"\\<forall>b\\<in>basis. (\\<lambda>x. F ((\\<lambda>x. c) x) \\<bullet> b * (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "assume b_in_basis: \"b \\<in> basis\""], ["proof (state)\nthis:\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "have cont_field_zero_one: \"continuous_on {0..1} (\\<lambda>x. F ((\\<lambda>x. c) x) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0::'b..1::'b} (\\<lambda>x. F c \\<bullet> b)", "using continuous_on_const"], ["proof (prove)\nusing this:\n  continuous_on ?s (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. continuous_on {0::'b..1::'b} (\\<lambda>x. F c \\<bullet> b)", "by fastforce"], ["proof (state)\nthis:\n  continuous_on {0::?'b1..1::?'b1} (\\<lambda>x. F c \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "have cont_path_zero_one:\n      \"continuous_on {0..1} (\\<lambda>x. (vector_derivative (\\<lambda>x. c) (at x within {0..1})) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)", "have \"((vector_derivative (\\<lambda>x. c) (at x within {0..1})) \\<bullet> b) = 0\" if \"x \\<in> {0..1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "have \"vector_derivative (\\<lambda>x. c) (at x within {0..1}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "using that gamma_deriv_at_within[of \"0\" \"1\"] differentiable_const vector_derivative_const_at"], ["proof (prove)\nusing this:\n  x \\<in> {0..1}\n  \\<lbrakk>0 < 1; ?x \\<in> {0..1};\n   \\<forall>x\\<in>{0..1}. ?\\<gamma> differentiable at x\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?\\<gamma> (at ?x within {0..1}) =\n                    vector_derivative ?\\<gamma> (at ?x)\n  (\\<lambda>z. ?a) differentiable ?F\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "show \"vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x1 within {0..1}) \\<bullet> b = 0\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)", "then"], ["proof (chain)\npicking this:\n  ?x1 \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x1 within {0..1}) \\<bullet> b = 0", "show \"continuous_on {0..1} (\\<lambda>x. (vector_derivative (\\<lambda>x. c) (at x within {0..1})) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  ?x1 \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x1 within {0..1}) \\<bullet> b = 0\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)", "using continuous_on_const[of \"{0..1}\" \"0\"] continuous_on_eq[of \"{0..1}\" \"\\<lambda>x. 0\" \"(\\<lambda>x. (vector_derivative (\\<lambda>x. c) (at x within {0..1})) \\<bullet> b)\"]"], ["proof (prove)\nusing this:\n  ?x1 \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x1 within {0..1}) \\<bullet> b = 0\n  continuous_on {0::?'b1..1::?'b1} (\\<lambda>x. 0::?'c1)\n  \\<lbrakk>continuous_on {0..1} (\\<lambda>x. 0);\n   \\<And>x.\n      x \\<in> {0..1} \\<Longrightarrow>\n      0 =\n      vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n      b\\<rbrakk>\n  \\<Longrightarrow> continuous_on {0..1}\n                     (\\<lambda>x.\n                         vector_derivative (\\<lambda>x. c)\n                          (at x within {0..1}) \\<bullet>\n                         b)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       (\\<lambda>x.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n       {0..1}", "show \"(\\<lambda>x. F (c) \\<bullet> b * (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "using cont_field_zero_one cont_path_zero_one continuous_on_mult integrable_continuous_real"], ["proof (prove)\nusing this:\n  continuous_on {0::?'b1..1::?'b1} (\\<lambda>x. F c \\<bullet> b)\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)\n  \\<lbrakk>continuous_on ?s ?f; continuous_on ?s ?g\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. ?f x * ?g x)\n  continuous_on {?a..?b} ?f \\<Longrightarrow> ?f integrable_on {?a..?b}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F c \\<bullet> b *\n      (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     (\\<lambda>x.\n         F c \\<bullet> b *\n         (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n          b)) integrable_on\n     {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "have integrable_sum': \"\\<And>t f s. finite t \\<Longrightarrow>\n                \\<forall>a\\<in>t. f a integrable_on s \\<Longrightarrow> (\\<lambda>x. \\<Sum>a\\<in>t. f a x) integrable_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t f s.\n       \\<lbrakk>finite t; \\<forall>a\\<in>t. f a integrable_on s\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. \\<Sum>a\\<in>t. f a x) integrable_on s", "using integrable_sum"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?I;\n   \\<And>a. a \\<in> ?I \\<Longrightarrow> ?f a integrable_on ?S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. \\<Sum>a\\<in>?I. ?f a x) integrable_on ?S\n\ngoal (1 subgoal):\n 1. \\<And>t f s.\n       \\<lbrakk>finite t; \\<forall>a\\<in>t. f a integrable_on s\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. \\<Sum>a\\<in>t. f a x) integrable_on s", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?t; \\<forall>a\\<in>?t. ?f a integrable_on ?s\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. \\<Sum>a\\<in>?t. ?f a x) integrable_on ?s\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "have field_integrable_on_basis:\n    \"(\\<lambda>x. \\<Sum>b\\<in>basis. F (c) \\<bullet> b * (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F c \\<bullet> b *\n          (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "using integrable_sum'[OF assms(1) every_component_integrable]"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      \\<Sum>a\\<in>basis.\n        F c \\<bullet> a *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         a)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F c \\<bullet> b *\n          (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "using line_integral_exists_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F c \\<bullet> b *\n        (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n  line_integral_exists ?F ?basis ?\\<gamma> \\<equiv>\n  (\\<lambda>x.\n      \\<Sum>b\\<in>?basis.\n        ?F (?\\<gamma> x) \\<bullet> b *\n        (vector_derivative ?\\<gamma> (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<lambda>x. c)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<lambda>x. c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degenerate_path_is_valid_path: \"valid_path (\\<lambda>x. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<lambda>x. c)", "by (auto simp add: valid_path_def piecewise_C1_differentiable_on_def continuous_on_const)"], ["", "lemma line_integral_degenerate_path:\n  assumes \"finite basis\"\n  shows \"line_integral F basis (\\<lambda>x. c) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (\\<lambda>x. c) = 0", "proof (simp add: line_integral_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "have \"((vector_derivative (\\<lambda>x. c) (at x within {0..1})) \\<bullet> b) = 0\" if \"x \\<in> {0..1}\" for x b"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "have \"vector_derivative (\\<lambda>x. c) (at x within {0..1}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "using that gamma_deriv_at_within[of \"0\" \"1\"] differentiable_const vector_derivative_const_at"], ["proof (prove)\nusing this:\n  x \\<in> {0..1}\n  \\<lbrakk>0 < 1; ?x \\<in> {0..1};\n   \\<forall>x\\<in>{0..1}. ?\\<gamma> differentiable at x\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?\\<gamma> (at ?x within {0..1}) =\n                    vector_derivative ?\\<gamma> (at ?x)\n  (\\<lambda>z. ?a) differentiable ?F\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)", "show \"vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet> ?b = 0\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet> ?b = 0", "have 0: \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> (\\<lambda>x. \\<Sum>b\\<in>basis. F c \\<bullet> b * (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)) x = (\\<lambda>x. 0) x\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet> ?b = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} \\<Longrightarrow>\n       (\\<Sum>b\\<in>basis.\n          F c \\<bullet> b *\n          (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n           b)) =\n       0", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     F c \\<bullet> b *\n     (vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     F c \\<bullet> b *\n     (vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0", "show \"integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis. F c \\<bullet> b * (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet> b)) = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     F c \\<bullet> b *\n     (vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "using integral_cong[of \"{0..1}\", OF 0] integral_0"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     F c \\<bullet> b *\n     (vector_derivative (\\<lambda>x. c) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0\n  (\\<And>x.\n      x \\<in> {0::?'b1..1::?'b1} \\<Longrightarrow>\n      ?x2 x \\<in> {0..1}) \\<Longrightarrow>\n  integral {0::?'b1..1::?'b1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F c \\<bullet> b *\n         (vector_derivative (\\<lambda>x. c)\n           (at (?x2 x) within {0..1}) \\<bullet>\n          b)) =\n  integral {0::?'b1..1::?'b1} (\\<lambda>x. 0)\n  integral ?S (\\<lambda>x. 0::?'m) = (0::?'m)\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F c \\<bullet> b *\n           (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F c \\<bullet> b *\n         (vector_derivative (\\<lambda>x. c) (at x within {0..1}) \\<bullet>\n          b)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition point_path where\n    \"point_path \\<gamma> \\<equiv> \\<exists>c. \\<gamma> = (\\<lambda>x. c)\""], ["", "lemma line_integral_point_path:\n  assumes \"point_path \\<gamma>\"\n  assumes \"finite basis\"\n  shows \"line_integral F basis \\<gamma> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> = 0", "using assms(1) point_path_def line_integral_degenerate_path[OF assms(2)]"], ["proof (prove)\nusing this:\n  point_path \\<gamma>\n  point_path ?\\<gamma> \\<equiv> \\<exists>c. ?\\<gamma> = (\\<lambda>x. c)\n  line_integral ?F basis (\\<lambda>x. ?c) = 0\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> = 0", "by force"], ["", "lemma line_integral_exists_point_path:\n  assumes \"finite basis\" \"point_path \\<gamma>\"\n  shows \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  finite basis\n  point_path \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "apply(simp add: point_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite basis; \\<exists>c. \\<gamma> = (\\<lambda>x. c)\\<rbrakk>\n    \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "using line_integral_exists_on_degenerate_path"], ["proof (prove)\nusing this:\n  finite ?basis \\<Longrightarrow>\n  line_integral_exists ?F ?basis (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite basis; \\<exists>c. \\<gamma> = (\\<lambda>x. c)\\<rbrakk>\n    \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "by auto"], ["", "lemma line_integral_exists_subpath:\n  assumes f: \"line_integral_exists f basis g\" and g: \"valid_path g\"\n    and uv: \"u \\<in> {0..1}\" \"v \\<in> {0..1}\" \"u \\<le> v\"\n  shows \"(line_integral_exists f basis (subpath u v g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists f basis (subpath u v g)", "proof (cases \"v=u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = u \\<Longrightarrow> line_integral_exists f basis (subpath u v g)\n 2. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "case tr: True"], ["proof (state)\nthis:\n  v = u\n\ngoal (2 subgoals):\n 1. v = u \\<Longrightarrow> line_integral_exists f basis (subpath u v g)\n 2. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "have zero: \"(\\<Sum>b\\<in>basis. f (g u) \\<bullet> b * (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet> b)) = 0\" if \"x \\<in> {0..1}\" for x::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>basis.\n       f (g u) \\<bullet> b *\n       (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n        b)) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>basis.\n       f (g u) \\<bullet> b *\n       (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n        b)) =\n    0", "have \"(vector_derivative (\\<lambda>x. g u) (at x within {0..1})) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g u) (at x within {0..1}) = (0::'a)", "using Deriv.has_vector_derivative_const that Derivative.vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ?c) has_vector_derivative (0::?'a)) ?net\n  x \\<in> {0..1}\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<lambda>x. g u) (at x within {0..1}) = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  vector_derivative (\\<lambda>x. g u) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>basis.\n       f (g u) \\<bullet> b *\n       (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n        b)) =\n    0", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<lambda>x. g u) (at x within {0..1}) = (0::'a)", "show \"(\\<Sum>b\\<in>basis. f (g u) \\<bullet> b * (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet> b)) = 0\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. g u) (at x within {0..1}) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>basis.\n       f (g u) \\<bullet> b *\n       (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n        b)) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>basis.\n     f (g u) \\<bullet> b *\n     (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n      b)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     f (g u) \\<bullet> b *\n     (vector_derivative (\\<lambda>x. g u) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0\n\ngoal (2 subgoals):\n 1. v = u \\<Longrightarrow> line_integral_exists f basis (subpath u v g)\n 2. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     f (g u) \\<bullet> b *\n     (vector_derivative (\\<lambda>x. g u) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0", "have \"((\\<lambda>x. \\<Sum>b\\<in>basis. f (g u)  \\<bullet> b * (vector_derivative (\\<lambda>x. g u) (at x within {0..1})  \\<bullet> b)) has_integral 0) {0..1}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow>\n  (\\<Sum>b\\<in>basis.\n     f (g u) \\<bullet> b *\n     (vector_derivative (\\<lambda>x. g u) (at ?x within {0..1}) \\<bullet>\n      b)) =\n  0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g u) \\<bullet> b *\n           (vector_derivative (\\<lambda>x. g u)\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "by (meson has_integral_is_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g u) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n\ngoal (2 subgoals):\n 1. v = u \\<Longrightarrow> line_integral_exists f basis (subpath u v g)\n 2. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g u) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g u) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis (subpath u v g)", "using f tr"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g u) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g u) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n  line_integral_exists f basis g\n  v = u\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis (subpath u v g)", "by (auto simp add: line_integral_def line_integral_exists_def subpath_def)"], ["proof (state)\nthis:\n  line_integral_exists f basis (subpath u v g)\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "case False"], ["proof (state)\nthis:\n  v \\<noteq> u\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "obtain s where s: \"\\<And>x. x \\<in> {0..1} - s \\<Longrightarrow> g differentiable at x\" and fs: \"finite s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> {0..1} - s \\<Longrightarrow>\n                    g differentiable at x;\n         finite s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using g"], ["proof (prove)\nusing this:\n  valid_path g\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> {0..1} - s \\<Longrightarrow>\n                    g differentiable at x;\n         finite s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding piecewise_C1_differentiable_on_def C1_differentiable_on_eq valid_path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g \\<and>\n  (\\<exists>S.\n      finite S \\<and>\n      (\\<forall>x\\<in>{0..1} - S. g differentiable at x) \\<and>\n      continuous_on ({0..1} - S) (\\<lambda>x. vector_derivative g (at x)))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> {0..1} - s \\<Longrightarrow>\n                    g differentiable at x;\n         finite s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow> g differentiable at ?x\n  finite s\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "have *: \"((\\<lambda>x. \\<Sum>b\\<in>basis. f (g ((v - u) * x + u))  \\<bullet> b * (vector_derivative g (at ((v - u) * x + u) within {0..1})  \\<bullet> b))\n            has_integral (1 / (v - u)) * integral {u..v} (\\<lambda>x. \\<Sum>b\\<in>basis. f (g (x))  \\<bullet> b * (vector_derivative g (at x within {0..1})  \\<bullet> b)))\n           {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g ((v - u) * x + u)) \\<bullet> b *\n           (vector_derivative g\n             (at ((v - u) * x + u) within {0..1}) \\<bullet>\n            b)) has_integral\n     1 / (v - u) *\n     integral {u..v}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using f uv"], ["proof (prove)\nusing this:\n  line_integral_exists f basis g\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g ((v - u) * x + u)) \\<bullet> b *\n           (vector_derivative g\n             (at ((v - u) * x + u) within {0..1}) \\<bullet>\n            b)) has_integral\n     1 / (v - u) *\n     integral {u..v}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "apply (simp add: line_integral_exists_def subpath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x.\n                 \\<Sum>b\\<in>basis.\n                   f (g x) \\<bullet> b *\n                   (vector_derivative g (at x within {0..1}) \\<bullet>\n                    b)) integrable_on\n             {0..1};\n     0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative g\n                               (at ((v - u) * x + u)\n                                within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)) /\n                       (v - u))\n                       {0..1}", "apply (drule integrable_on_subcbox [where a=u and b=v, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> {u..v} \\<subseteq> {0..1}\n 2. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g x) \\<bullet> b *\n           (vector_derivative g (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {u..v}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative g\n                               (at ((v - u) * x + u)\n                                within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)) /\n                       (v - u))\n                       {0..1}", "apply (simp_all add: has_integral_integral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v;\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet>\n             b)) has_integral\n      integral {u..v}\n       (\\<lambda>x.\n           \\<Sum>b\\<in>basis.\n             f (g x) \\<bullet> b *\n             (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n      {u..v}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative g\n                               (at ((v - u) * x + u)\n                                within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)) /\n                       (v - u))\n                       {0..1}", "apply (drule has_integral_affinity [where m=\"v-u\" and c=u, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> v \\<noteq> u\n 2. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v;\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g ((v - u) * x + u)) \\<bullet> b *\n            (vector_derivative g\n              (at ((v - u) * x + u) within {0..1}) \\<bullet>\n             b)) has_integral\n      (1 / \\<bar>v - u\\<bar>) *\\<^sub>R\n      integral {u..v}\n       (\\<lambda>x.\n           \\<Sum>b\\<in>basis.\n             f (g x) \\<bullet> b *\n             (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n      ((\\<lambda>x. x / (v - u) - u / (v - u)) ` {u..v})\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative g\n                               (at ((v - u) * x + u)\n                                within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)) /\n                       (v - u))\n                       {0..1}", "apply (simp_all add: False image_affinity_atLeastAtMost_div_diff scaleR_conv_of_real)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> u; v \\<le> 1; u \\<le> v;\n     ((\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g ((v - u) * x + u)) \\<bullet> b *\n            (vector_derivative g\n              (at ((v - u) * x + u) within {0..1}) \\<bullet>\n             b)) has_integral\n      integral {u..v}\n       (\\<lambda>x.\n           \\<Sum>b\\<in>basis.\n             f (g x) \\<bullet> b *\n             (vector_derivative g (at x within {0..1}) \\<bullet> b)) /\n      (v - u))\n      {0..v / (v - u) - u / (v - u)}\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative g\n                               (at ((v - u) * x + u)\n                                within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)) /\n                       (v - u))\n                       {0..1}", "apply (simp add: divide_simps False)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g ((v - u) * x + u)) \\<bullet> b *\n         (vector_derivative g (at ((v - u) * x + u) within {0..1}) \\<bullet>\n          b)) has_integral\n   1 / (v - u) *\n   integral {u..v}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f (g x) \\<bullet> b *\n          (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "have vd:\"\\<And>x. x \\<in> {0..1} \\<Longrightarrow>\n           x \\<notin> (\\<lambda>t. (v-u) *\\<^sub>R t + u) -` s \\<Longrightarrow>\n           vector_derivative (\\<lambda>x. g ((v-u) * x + u)) (at x within {0..1}) = (v-u) *\\<^sub>R vector_derivative g (at ((v-u) * x + u) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {0..1};\n        x \\<notin> (\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s\\<rbrakk>\n       \\<Longrightarrow> vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n                          (at x within {0..1}) =\n                         (v - u) *\\<^sub>R\n                         vector_derivative g\n                          (at ((v - u) * x + u) within {0..1})", "using test2[OF s fs uv]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> {0..1} - s \\<Longrightarrow> x \\<in> {0..1} - s;\n   ?x \\<in> {0..1};\n   ?x \\<notin> (\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n                     (at ?x within {0..1}) =\n                    (v - u) *\\<^sub>R\n                    vector_derivative g\n                     (at ((v - u) * ?x + u) within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {0..1};\n        x \\<notin> (\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s\\<rbrakk>\n       \\<Longrightarrow> vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n                          (at x within {0..1}) =\n                         (v - u) *\\<^sub>R\n                         vector_derivative g\n                          (at ((v - u) * x + u) within {0..1})", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> {0..1};\n   ?x \\<notin> (\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n                     (at ?x within {0..1}) =\n                    (v - u) *\\<^sub>R\n                    vector_derivative g\n                     (at ((v - u) * ?x + u) within {0..1})\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "have arg:\"\\<And>x. (\\<Sum>n\\<in>basis. (v - u) * (f (g ((v - u) * x + u)) \\<bullet> n) * (vector_derivative g (at ((v - u) * x + u) within {0..1}) \\<bullet> n))\n              =    (\\<Sum>b\\<in>basis. f (g ((v - u) * x + u)) \\<bullet> b * (v - u) * (vector_derivative g (at ((v - u) * x + u) within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>n\\<in>basis.\n          (v - u) * (f (g ((v - u) * x + u)) \\<bullet> n) *\n          (vector_derivative g\n            (at ((v - u) * x + u) within {0..1}) \\<bullet>\n           n)) =\n       (\\<Sum>b\\<in>basis.\n          f (g ((v - u) * x + u)) \\<bullet> b * (v - u) *\n          (vector_derivative g\n            (at ((v - u) * x + u) within {0..1}) \\<bullet>\n           b))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<Sum>n\\<in>basis.\n     (v - u) * (f (g ((v - u) * ?x + u)) \\<bullet> n) *\n     (vector_derivative g (at ((v - u) * ?x + u) within {0..1}) \\<bullet>\n      n)) =\n  (\\<Sum>b\\<in>basis.\n     f (g ((v - u) * ?x + u)) \\<bullet> b * (v - u) *\n     (vector_derivative g (at ((v - u) * ?x + u) within {0..1}) \\<bullet>\n      b))\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "have\"((\\<lambda>x. \\<Sum>b\\<in>basis. f (g ((v - u) * x + u))  \\<bullet> b * (vector_derivative (\\<lambda>x. g ((v - u) * x + u)) (at x within {0..1})  \\<bullet> b)) has_integral\n          (integral {u..v} (\\<lambda>x. \\<Sum>b\\<in>basis. f (g (x))  \\<bullet> b * (vector_derivative g (at x within {0..1}) \\<bullet> b)))) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g ((v - u) * x + u)) \\<bullet> b *\n           (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {u..v}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "apply (cut_tac Henstock_Kurzweil_Integration.has_integral_mult_right [OF *, where c = \"v-u\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (v - u) *\n         (\\<Sum>b\\<in>basis.\n            f (g ((v - u) * x + u)) \\<bullet> b *\n            (vector_derivative g\n              (at ((v - u) * x + u) within {0..1}) \\<bullet>\n             b))) has_integral\n     (v - u) *\n     (1 / (v - u) *\n      integral {u..v}\n       (\\<lambda>x.\n           \\<Sum>b\\<in>basis.\n             f (g x) \\<bullet> b *\n             (vector_derivative g (at x within {0..1}) \\<bullet> b))))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g ((v - u) * x + u)) \\<bullet> b *\n           (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {u..v}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using fs assms"], ["proof (prove)\nusing this:\n  finite s\n  line_integral_exists f basis g\n  valid_path g\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (v - u) *\n         (\\<Sum>b\\<in>basis.\n            f (g ((v - u) * x + u)) \\<bullet> b *\n            (vector_derivative g\n              (at ((v - u) * x + u) within {0..1}) \\<bullet>\n             b))) has_integral\n     (v - u) *\n     (1 / (v - u) *\n      integral {u..v}\n       (\\<lambda>x.\n           \\<Sum>b\\<in>basis.\n             f (g x) \\<bullet> b *\n             (vector_derivative g (at x within {0..1}) \\<bullet> b))))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g ((v - u) * x + u)) \\<bullet> b *\n           (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n             (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {u..v}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            f (g x) \\<bullet> b *\n            (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "apply (simp add: False subpath_def line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((\\<lambda>x.\n                  (v - u) *\n                  (\\<Sum>b\\<in>basis.\n                     f (g ((v - u) * x + u)) \\<bullet> b *\n                     (vector_derivative g\n                       (at ((v - u) * x + u) within {0..1}) \\<bullet>\n                      b))) has_integral\n              integral {u..v}\n               (\\<lambda>x.\n                   \\<Sum>b\\<in>basis.\n                     f (g x) \\<bullet> b *\n                     (vector_derivative g (at x within {0..1}) \\<bullet>\n                      b)))\n              {0..1};\n     finite s;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g x) \\<bullet> b *\n           (vector_derivative g (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {0..1};\n     valid_path g; 0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           \\<Sum>b\\<in>basis.\n                             f (g ((v - u) * x + u)) \\<bullet> b *\n                             (vector_derivative\n                               (\\<lambda>x. g ((v - u) * x + u))\n                               (at x within {0..1}) \\<bullet>\n                              b)) has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {0..1}", "apply (rule_tac S = \"(\\<lambda>t. ((v-u) *\\<^sub>R t + u)) -` s\" in has_integral_spike_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((\\<lambda>x.\n                  (v - u) *\n                  (\\<Sum>b\\<in>basis.\n                     f (g ((v - u) * x + u)) \\<bullet> b *\n                     (vector_derivative g\n                       (at ((v - u) * x + u) within {0..1}) \\<bullet>\n                      b))) has_integral\n              integral {u..v}\n               (\\<lambda>x.\n                   \\<Sum>b\\<in>basis.\n                     f (g x) \\<bullet> b *\n                     (vector_derivative g (at x within {0..1}) \\<bullet>\n                      b)))\n              {0..1};\n     finite s;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g x) \\<bullet> b *\n           (vector_derivative g (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {0..1};\n     valid_path g; 0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> finite ((\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s)\n 2. \\<And>x.\n       \\<lbrakk>((\\<lambda>x.\n                     (v - u) *\n                     (\\<Sum>b\\<in>basis.\n                        f (g ((v - u) * x + u)) \\<bullet> b *\n                        (vector_derivative g\n                          (at ((v - u) * x + u) within {0..1}) \\<bullet>\n                         b))) has_integral\n                 integral {u..v}\n                  (\\<lambda>x.\n                      \\<Sum>b\\<in>basis.\n                        f (g x) \\<bullet> b *\n                        (vector_derivative g (at x within {0..1}) \\<bullet>\n                         b)))\n                 {0..1};\n        finite s;\n        (\\<lambda>x.\n            \\<Sum>b\\<in>basis.\n              f (g x) \\<bullet> b *\n              (vector_derivative g (at x within {0..1}) \\<bullet>\n               b)) integrable_on\n        {0..1};\n        valid_path g; 0 \\<le> u; v \\<le> 1; u \\<le> v;\n        x \\<in> {0..1} - (\\<lambda>t. (v - u) *\\<^sub>R t + u) -` s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>b\\<in>basis.\n                            f (g ((v - u) * x + u)) \\<bullet> b *\n                            (vector_derivative\n                              (\\<lambda>x. g ((v - u) * x + u))\n                              (at x within {0..1}) \\<bullet>\n                             b)) =\n                         ?f8 x\n 3. \\<lbrakk>((\\<lambda>x.\n                  (v - u) *\n                  (\\<Sum>b\\<in>basis.\n                     f (g ((v - u) * x + u)) \\<bullet> b *\n                     (vector_derivative g\n                       (at ((v - u) * x + u) within {0..1}) \\<bullet>\n                      b))) has_integral\n              integral {u..v}\n               (\\<lambda>x.\n                   \\<Sum>b\\<in>basis.\n                     f (g x) \\<bullet> b *\n                     (vector_derivative g (at x within {0..1}) \\<bullet>\n                      b)))\n              {0..1};\n     finite s;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           f (g x) \\<bullet> b *\n           (vector_derivative g (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {0..1};\n     valid_path g; 0 \\<le> u; v \\<le> 1; u \\<le> v\\<rbrakk>\n    \\<Longrightarrow> (?f8 has_integral\n                       integral {u..v}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis.\n                              f (g x) \\<bullet> b *\n                              (vector_derivative g\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {0..1}", "apply (auto simp: inj_on_def False vd finite_vimageI scaleR_conv_of_real Groups_Big.sum_distrib_left\n        mult.assoc[symmetric] arg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g ((v - u) * x + u)) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   integral {u..v}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f (g x) \\<bullet> b *\n          (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. v \\<noteq> u \\<Longrightarrow>\n    line_integral_exists f basis (subpath u v g)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g ((v - u) * x + u)) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   integral {u..v}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f (g x) \\<bullet> b *\n          (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "show \"(line_integral_exists f basis (subpath u v g))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         f (g ((v - u) * x + u)) \\<bullet> b *\n         (vector_derivative (\\<lambda>x. g ((v - u) * x + u))\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   integral {u..v}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          f (g x) \\<bullet> b *\n          (vector_derivative g (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists f basis (subpath u v g)", "by(auto simp add: line_integral_exists_def subpath_def integrable_on_def)"], ["proof (state)\nthis:\n  line_integral_exists f basis (subpath u v g)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*This should have everything that has to do with onecubes*)"], ["", "type_synonym path = \"real \\<Rightarrow> (real * real)\""], ["", "type_synonym one_cube = \"(real \\<Rightarrow> (real * real))\""], ["", "type_synonym one_chain = \"(int * path) set\""], ["", "type_synonym two_cube = \"(real * real) \\<Rightarrow> (real * real)\""], ["", "type_synonym two_chain = \"two_cube set\""], ["", "definition one_chain_line_integral :: \"((real * real) \\<Rightarrow> (real * real)) => ((real*real) set) \\<Rightarrow> one_chain \\<Rightarrow> real\" where\n    \"one_chain_line_integral F b C \\<equiv> (\\<Sum>(k,g)\\<in>C. k * (line_integral F b g))\""], ["", "definition boundary_chain where\n    \"boundary_chain s \\<equiv> (\\<forall>(k, \\<gamma>) \\<in> s. k = 1 \\<or> k = -1)\""], ["", "fun coeff_cube_to_path::\"(int * one_cube) \\<Rightarrow> path\" \n  where \"coeff_cube_to_path (k, \\<gamma>) = (if k = 1 then \\<gamma> else (reversepath \\<gamma>))\""], ["", "fun rec_join :: \"(int*path) list \\<Rightarrow> path\" where   \n  \"rec_join [] = (\\<lambda>x.0)\" |\n  \"rec_join [oneC] = coeff_cube_to_path oneC\" |\n  \"rec_join (oneC # xs) = coeff_cube_to_path oneC +++ (rec_join xs)\""], ["", "fun valid_chain_list where\n  \"valid_chain_list [] = True\" |\n  \"valid_chain_list [oneC] = True\" |\n  \"valid_chain_list (oneC#l) = (pathfinish (coeff_cube_to_path (oneC)) = pathstart (rec_join l) \\<and> valid_chain_list l)\""], ["", "lemma joined_is_valid:\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    valid_chain_list_ass: \"valid_chain_list l\"\n  shows \"valid_path (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "proof(induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []);\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     valid_chain_list []\\<rbrakk>\n    \\<Longrightarrow> valid_path (rec_join [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "case Nil"], ["proof (state)\nthis:\n  boundary_chain (set [])\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []);\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     valid_chain_list []\\<rbrakk>\n    \\<Longrightarrow> valid_path (rec_join [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "then"], ["proof (chain)\npicking this:\n  boundary_chain (set [])\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list []", "show ?case"], ["proof (prove)\nusing this:\n  boundary_chain (set [])\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list []\n\ngoal (1 subgoal):\n 1. valid_path (rec_join [])", "using C1_differentiable_imp_piecewise[OF C1_differentiable_on_const[of \"0\" \"{0..1}\"]]"], ["proof (prove)\nusing this:\n  boundary_chain (set [])\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list []\n  (\\<lambda>z. 0::?'a) piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. valid_path (rec_join [])", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  valid_path (rec_join [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>boundary_chain (set l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join l)\n  boundary_chain (set (a # l))\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "have *: \"valid_path (rec_join ((k::int, \\<gamma>) # l))\"\n    if \"boundary_chain (set (l))\"\n      \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set l \\<Longrightarrow> valid_path \\<gamma>')\"\n      \"valid_chain_list l\"\n      \"valid_path (rec_join l) \"\n      \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((k, \\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n      \"valid_chain_list ((k, \\<gamma>) # l)\"\n      \"boundary_chain (set ((k,\\<gamma>) # l))\" for k \\<gamma> l"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join ((k, \\<gamma>) # l))", "proof (cases \"l = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> valid_path (rec_join ((k, \\<gamma>) # l))\n 2. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "case True"], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> valid_path (rec_join ((k, \\<gamma>) # l))\n 2. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "with that"], ["proof (chain)\npicking this:\n  boundary_chain (set l)\n  (?k', ?\\<gamma>') \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>'\n  valid_chain_list l\n  valid_path (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((k, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  valid_chain_list ((k, \\<gamma>) # l)\n  boundary_chain (set ((k, \\<gamma>) # l))\n  l = []", "show \"valid_path (rec_join ((k, \\<gamma>) # l))\""], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  (?k', ?\\<gamma>') \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>'\n  valid_chain_list l\n  valid_path (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((k, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  valid_chain_list ((k, \\<gamma>) # l)\n  boundary_chain (set ((k, \\<gamma>) # l))\n  l = []\n\ngoal (1 subgoal):\n 1. valid_path (rec_join ((k, \\<gamma>) # l))", "by auto"], ["proof (state)\nthis:\n  valid_path (rec_join ((k, \\<gamma>) # l))\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where l_nempty: \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    valid_path (rec_join ((k, \\<gamma>) # l))", "then"], ["proof (chain)\npicking this:\n  l = h # l'", "show \"valid_path (rec_join ((k, \\<gamma>) # l))\""], ["proof (prove)\nusing this:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. valid_path (rec_join ((k, \\<gamma>) # l))", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k = 1\\<rbrakk>\n    \\<Longrightarrow> valid_path (\\<gamma> +++ rec_join (h # l'))\n 2. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k = 1\\<rbrakk>\n    \\<Longrightarrow> valid_path (\\<gamma> +++ rec_join (h # l'))\n 2. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "have 0:\"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using that"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  (?k', ?\\<gamma>') \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>'\n  valid_chain_list l\n  valid_path (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((k, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  valid_chain_list ((k, \\<gamma>) # l)\n  boundary_chain (set ((k, \\<gamma>) # l))\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k = 1\\<rbrakk>\n    \\<Longrightarrow> valid_path (\\<gamma> +++ rec_join (h # l'))\n 2. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "have 1:\"pathfinish \\<gamma> = pathstart (rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish \\<gamma> = pathstart (rec_join (h # l'))", "using that(6) k_eq_1 l_nempty"], ["proof (prove)\nusing this:\n  valid_chain_list ((k, \\<gamma>) # l)\n  k = 1\n  l = h # l'\n\ngoal (1 subgoal):\n 1. pathfinish \\<gamma> = pathstart (rec_join (h # l'))", "by auto"], ["proof (state)\nthis:\n  pathfinish \\<gamma> = pathstart (rec_join (h # l'))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k = 1\\<rbrakk>\n    \\<Longrightarrow> valid_path (\\<gamma> +++ rec_join (h # l'))\n 2. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "show \"valid_path (\\<gamma> +++ rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (\\<gamma> +++ rec_join (h # l'))", "using 0 1 valid_path_join that(4) l_nempty"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  pathfinish \\<gamma> = pathstart (rec_join (h # l'))\n  \\<lbrakk>valid_path ?g1.0; valid_path ?g2.0;\n   pathfinish ?g1.0 = pathstart ?g2.0\\<rbrakk>\n  \\<Longrightarrow> valid_path (?g1.0 +++ ?g2.0)\n  valid_path (rec_join l)\n  l = h # l'\n\ngoal (1 subgoal):\n 1. valid_path (\\<gamma> +++ rec_join (h # l'))", "by auto"], ["proof (state)\nthis:\n  valid_path (\\<gamma> +++ rec_join (h # l'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg_1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using that(7)"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  boundary_chain (set ((k, \\<gamma>) # l))\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "have \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using that"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  (?k', ?\\<gamma>') \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>'\n  valid_chain_list l\n  valid_path (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((k, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  valid_chain_list ((k, \\<gamma>) # l)\n  boundary_chain (set ((k, \\<gamma>) # l))\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "then"], ["proof (chain)\npicking this:\n  valid_path \\<gamma>", "have 0: \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using valid_path_imp_reverse"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  valid_path ?g \\<Longrightarrow> valid_path (reversepath ?g)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "have 1: \"pathfinish (reversepath \\<gamma>) = pathstart (rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish (reversepath \\<gamma>) = pathstart (rec_join (h # l'))", "using that(6) k_eq_neg_1 l_nempty"], ["proof (prove)\nusing this:\n  valid_chain_list ((k, \\<gamma>) # l)\n  k = - 1\n  l = h # l'\n\ngoal (1 subgoal):\n 1. pathfinish (reversepath \\<gamma>) = pathstart (rec_join (h # l'))", "by auto"], ["proof (state)\nthis:\n  pathfinish (reversepath \\<gamma>) = pathstart (rec_join (h # l'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = h # l'; l = h # l'; k \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> valid_path\n                       (reversepath \\<gamma> +++ rec_join (h # l'))", "show \"valid_path ((reversepath \\<gamma>) +++ rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma> +++ rec_join (h # l'))", "using 0 1 valid_path_join that(4) l_nempty"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n  pathfinish (reversepath \\<gamma>) = pathstart (rec_join (h # l'))\n  \\<lbrakk>valid_path ?g1.0; valid_path ?g2.0;\n   pathfinish ?g1.0 = pathstart ?g2.0\\<rbrakk>\n  \\<Longrightarrow> valid_path (?g1.0 +++ ?g2.0)\n  valid_path (rec_join l)\n  l = h # l'\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma> +++ rec_join (h # l'))", "by blast"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma> +++ rec_join (h # l'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path (rec_join ((k, \\<gamma>) # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>';\n   valid_chain_list ?l; valid_path (rec_join ?l);\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((?k, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   valid_chain_list ((?k, ?\\<gamma>) # ?l);\n   boundary_chain (set ((?k, ?\\<gamma>) # ?l))\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ((?k, ?\\<gamma>) # ?l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "have \"\\<forall>ps. valid_chain_list ps \\<or> (\\<exists>i f p psa. ps = (i, f) # p # psa \\<and> ((i = 1 \\<and> pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or> i \\<noteq> 1 \\<and> pathfinish (reversepath f) \\<noteq> pathstart (rec_join (p # psa))) \\<or> \\<not> valid_chain_list (p # psa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps.\n       valid_chain_list ps \\<or>\n       (\\<exists>i f p psa.\n           ps = (i, f) # p # psa \\<and>\n           ((i = 1 \\<and>\n             pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n             i \\<noteq> 1 \\<and>\n             pathfinish (reversepath f) \\<noteq>\n             pathstart (rec_join (p # psa))) \\<or>\n            \\<not> valid_chain_list (p # psa)))", "by (smt coeff_cube_to_path.elims valid_chain_list.elims(3))"], ["proof (state)\nthis:\n  \\<forall>ps.\n     valid_chain_list ps \\<or>\n     (\\<exists>i f p psa.\n         ps = (i, f) # p # psa \\<and>\n         ((i = 1 \\<and>\n           pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n           i \\<noteq> 1 \\<and>\n           pathfinish (reversepath f) \\<noteq>\n           pathstart (rec_join (p # psa))) \\<or>\n          \\<not> valid_chain_list (p # psa)))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "moreover"], ["proof (state)\nthis:\n  \\<forall>ps.\n     valid_chain_list ps \\<or>\n     (\\<exists>i f p psa.\n         ps = (i, f) # p # psa \\<and>\n         ((i = 1 \\<and>\n           pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n           i \\<noteq> 1 \\<and>\n           pathfinish (reversepath f) \\<noteq>\n           pathstart (rec_join (p # psa))) \\<or>\n          \\<not> valid_chain_list (p # psa)))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "have \"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by (meson Cons.prems(1) boundary_chain_def set_subset_Cons subset_eq)"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l);\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> valid_path (rec_join l);\n        boundary_chain (set (a # l));\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> valid_path (rec_join (a # l))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>ps.\n     valid_chain_list ps \\<or>\n     (\\<exists>i f p psa.\n         ps = (i, f) # p # psa \\<and>\n         ((i = 1 \\<and>\n           pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n           i \\<noteq> 1 \\<and>\n           pathfinish (reversepath f) \\<noteq>\n           pathstart (rec_join (p # psa))) \\<or>\n          \\<not> valid_chain_list (p # psa)))\n  boundary_chain (set l)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>ps.\n     valid_chain_list ps \\<or>\n     (\\<exists>i f p psa.\n         ps = (i, f) # p # psa \\<and>\n         ((i = 1 \\<and>\n           pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n           i \\<noteq> 1 \\<and>\n           pathfinish (reversepath f) \\<noteq>\n           pathstart (rec_join (p # psa))) \\<or>\n          \\<not> valid_chain_list (p # psa)))\n  boundary_chain (set l)\n\ngoal (1 subgoal):\n 1. valid_path (rec_join (a # l))", "using * Cons"], ["proof (prove)\nusing this:\n  \\<forall>ps.\n     valid_chain_list ps \\<or>\n     (\\<exists>i f p psa.\n         ps = (i, f) # p # psa \\<and>\n         ((i = 1 \\<and>\n           pathfinish f \\<noteq> pathstart (rec_join (p # psa)) \\<or>\n           i \\<noteq> 1 \\<and>\n           pathfinish (reversepath f) \\<noteq>\n           pathstart (rec_join (p # psa))) \\<or>\n          \\<not> valid_chain_list (p # psa)))\n  boundary_chain (set l)\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>';\n   valid_chain_list ?l; valid_path (rec_join ?l);\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((?k, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   valid_chain_list ((?k, ?\\<gamma>) # ?l);\n   boundary_chain (set ((?k, ?\\<gamma>) # ?l))\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ((?k, ?\\<gamma>) # ?l))\n  \\<lbrakk>boundary_chain (set l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join l)\n  boundary_chain (set (a # l))\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. valid_path (rec_join (a # l))", "by (metis (no_types) list.set_intros(2) prod.collapse valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  valid_path (rec_join (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathstart_rec_join_1:\n  \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "proof (cases \"l = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\n 2. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "case True"], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\n 2. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "then"], ["proof (chain)\npicking this:\n  l = []", "show \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\""], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "by simp"], ["proof (state)\nthis:\n  pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "then"], ["proof (chain)\npicking this:\n  l = h # l'", "show \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\""], ["proof (prove)\nusing this:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>", "by simp"], ["proof (state)\nthis:\n  pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathstart_rec_join_2:\n  \"pathstart (rec_join ((-1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "assume \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  l = []", "show \"pathstart (rec_join ((- 1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "by simp"], ["proof (state)\nthis:\n  pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n  pathstart (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "assume \"l \\<noteq> [] \""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  l = h # l'", "show \"pathstart (rec_join ((- 1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "by simp"], ["proof (state)\nthis:\n  pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n  pathstart (reversepath \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathstart_rec_join:\n  \"pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma>\"\n  \"pathstart (rec_join ((-1, \\<gamma>) # l)) = pathstart (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma> &&&\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "using pathstart_rec_join_1 pathstart_rec_join_2"], ["proof (prove)\nusing this:\n  pathstart (rec_join ((1, ?\\<gamma>) # ?l)) = pathstart ?\\<gamma>\n  pathstart (rec_join ((- 1, ?\\<gamma>) # ?l)) =\n  pathstart (reversepath ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. pathstart (rec_join ((1, \\<gamma>) # l)) = pathstart \\<gamma> &&&\n    pathstart (rec_join ((- 1, \\<gamma>) # l)) =\n    pathstart (reversepath \\<gamma>)", "by auto"], ["", "lemma line_integral_exists_on_rec_join:\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_chain_list: \"valid_chain_list l\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    line_integral_exists: \"\\<forall>(k, \\<gamma>) \\<in> set l. line_integral_exists F basis \\<gamma>\"\n  shows \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []); valid_chain_list [];\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     \\<forall>(k, y)\\<in>set []. line_integral_exists F basis y\\<rbrakk>\n    \\<Longrightarrow> line_integral_exists F basis (rec_join [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "case Nil"], ["proof (state)\nthis:\n  boundary_chain (set [])\n  valid_chain_list []\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set [].\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []); valid_chain_list [];\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     \\<forall>(k, y)\\<in>set []. line_integral_exists F basis y\\<rbrakk>\n    \\<Longrightarrow> line_integral_exists F basis (rec_join [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "then"], ["proof (chain)\npicking this:\n  boundary_chain (set [])\n  valid_chain_list []\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set [].\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a", "show ?case"], ["proof (prove)\nusing this:\n  boundary_chain (set [])\n  valid_chain_list []\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set [].\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join [])", "proof (simp add: line_integral_exists_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "have \"\\<forall>x. (vector_derivative (\\<lambda>x. 0) (at x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. vector_derivative (\\<lambda>x. 0::'a) (at x) = (0::'a)", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x. vector_derivative (\\<lambda>x. 0::'a) (at x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)", "have \"\\<forall>x. ((\\<lambda>x. 0) has_vector_derivative 0) (at x)\""], ["proof (prove)\nusing this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n\ngoal (1 subgoal):\n 1. \\<forall>x. ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a)) (at x)", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x. ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a)) (at x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)", "have \"\\<forall>x. ((\\<lambda>x. 0) has_vector_derivative 0) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a))\n        (at x within {0..1})", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a))\n        (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})", "have 0: \"\\<forall>x\\<in>{0..1}. (vector_derivative (\\<lambda>x. 0) (at x within{0..1})) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative (\\<lambda>x. 0::'a) (at x within {0..1}) = (0::'a)", "by (simp add: gamma_deriv_at_within)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative (\\<lambda>x. 0::?'a4) (at x within {0..1}) =\n     (0::?'a4)\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "have \"(\\<forall>x\\<in>{0..1}. (\\<Sum>b\\<in>basis. F 0 \\<bullet> b * (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet> b)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       (\\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n           b)) =\n       0", "by (simp add: 0)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0", "have \" ((\\<lambda>x. \\<Sum>b\\<in>basis. F 0 \\<bullet> b * (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet> b)) has_integral 0) {0..1}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "by (meson has_integral_is_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F 0 \\<bullet> b *\n         (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. boundary_chain {} \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>a. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F 0 \\<bullet> b *\n         (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}", "show \"(\\<lambda>x. \\<Sum>b\\<in>basis. F 0 \\<bullet> b * (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F 0 \\<bullet> b *\n         (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n           b)) integrable_on\n    {0..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n  {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "obtain k \\<gamma> where aeq: \"a = (k,\\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 \\<forall>(k, y)\\<in>set l.\n                    line_integral_exists F basis y\\<rbrakk>\n                \\<Longrightarrow> line_integral_exists F basis (rec_join l);\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        \\<forall>(k, y)\\<in>set (a # l).\n           line_integral_exists F basis y\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F basis (rec_join (a # l))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join (a # l))", "unfolding aeq"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "assume l_empty: \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "then"], ["proof (chain)\npicking this:\n  l = []", "show \"line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\""], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "using Cons.prems aeq line_integral_on_reverse_path(2)"], ["proof (prove)\nusing this:\n  l = []\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "assume \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where l_nempty: \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "show \"line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))", "proof (auto simp add: l_nempty)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 0: \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using Cons.prems(4) aeq"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 1: \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by (metis (mono_tags) Cons boundary_chain_def list.set_intros(2) valid_chain_list.elims(3) valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 2: \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using Cons aeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 3:\"valid_path (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "by (metis (no_types) Cons.prems boundary_chain_def joined_is_valid l_nempty set_subset_Cons subsetCE valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  valid_path (rec_join l)\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "show \"line_integral_exists F basis (\\<gamma> +++ rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))", "using line_integral_distrib(2)[OF 0 1 2 3] assms l_nempty"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n  boundary_chain (set l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>\n  l = h # l'\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<gamma> +++ rec_join (h # l'))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg_1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using Cons aeq"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. k = - 1", "by (simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have gamma_valid: \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using Cons aeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "then"], ["proof (chain)\npicking this:\n  valid_path \\<gamma>", "have 2: \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using valid_path_imp_reverse"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  valid_path ?g \\<Longrightarrow> valid_path (reversepath ?g)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using Cons aeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis \\<gamma>", "have 0: \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using line_integral_on_reverse_path(2) gamma_valid"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 1: \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using Cons aeq"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by (metis (mono_tags) boundary_chain_def insert_iff list.set(2) list.set_intros(2) valid_chain_list.elims(3) valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "have 3:\"valid_path (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "by (metis (no_types) Cons.prems(1) Cons.prems(2) Cons.prems(3) boundary_chain_def joined_is_valid l_nempty set_subset_Cons subsetCE valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  valid_path (rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "show \"line_integral_exists F basis ((reversepath \\<gamma>) +++ rec_join (h#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "using line_integral_distrib(2)[OF 0 1 2 3] assms l_nempty"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n  boundary_chain (set l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>\n  l = h # l'\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis\n     (reversepath \\<gamma> +++ rec_join (h # l'))", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join (h # l'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join ((k, \\<gamma>) # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_rec_join_cons:\n  assumes \"line_integral_exists F basis (rec_join ((1,\\<gamma>) # l))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "assume l_empty: \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "show \"line_integral_exists F basis (\\<gamma> +++ rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "using assms(2) line_integral_distrib(2)[OF assms(1) line_integral_exists_on_degenerate_path[OF assms(3)], of \"0\"]"], ["proof (prove)\nusing this:\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  \\<lbrakk>valid_path (rec_join ((1, \\<gamma>) # l));\n   valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis\n                     (rec_join ((1, \\<gamma>) # l) +++ (\\<lambda>x. 0))\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "using degenerate_path_is_valid_path"], ["proof (prove)\nusing this:\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  \\<lbrakk>valid_path (rec_join ((1, \\<gamma>) # l));\n   valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis\n                     (rec_join ((1, \\<gamma>) # l) +++ (\\<lambda>x. 0))\n  valid_path (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "by (fastforce simp add: l_empty)"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "assume \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (\\<gamma> +++ rec_join l)", "then"], ["proof (chain)\npicking this:\n  l = h # l'", "show \"line_integral_exists F basis (\\<gamma> +++ rec_join l)\""], ["proof (prove)\nusing this:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  l = h # l'\n  line_integral_exists F basis (rec_join ((1, \\<gamma>) # l))\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_rec_join_cons_2:\n  assumes \"line_integral_exists F basis (rec_join ((-1,\\<gamma>) # l))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "assume l_empty: \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "show \"line_integral_exists F basis ((reversepath \\<gamma>) +++ rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "using assms(2) line_integral_distrib(2)[OF assms(1) line_integral_exists_on_degenerate_path[OF assms(3)], of \"0\"]"], ["proof (prove)\nusing this:\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  \\<lbrakk>valid_path (rec_join ((- 1, \\<gamma>) # l));\n   valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis\n                     (rec_join ((- 1, \\<gamma>) # l) +++ (\\<lambda>x. 0))\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "using degenerate_path_is_valid_path"], ["proof (prove)\nusing this:\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  \\<lbrakk>valid_path (rec_join ((- 1, \\<gamma>) # l));\n   valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F basis\n                     (rec_join ((- 1, \\<gamma>) # l) +++ (\\<lambda>x. 0))\n  valid_path (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "by (auto simp add: l_empty)"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "assume \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where  \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "with assms"], ["proof (chain)\npicking this:\n  line_integral_exists F basis (rec_join ((- 1, \\<gamma>) # l))\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  l = h # l'", "show \"line_integral_exists F basis ((reversepath \\<gamma>) +++ rec_join l)\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis (rec_join ((- 1, \\<gamma>) # l))\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  l = h # l'\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (rec_join ((- 1, \\<gamma>) # l))\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  l = h # l'\n  line_integral_exists F basis (rec_join ((- 1, \\<gamma>) # l))\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_on_rec_join':\n  assumes boundary_chain: \"boundary_chain (set l)\" and\n    valid_chain_list: \"valid_chain_list l\" and\n    valid_path: \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\" and\n    line_integral_exists: \"line_integral_exists F basis (rec_join l)\" and\n    finite_basis: \"finite basis\"\n  shows \"\\<forall>(k, \\<gamma>) \\<in> set l. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join l)\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []); valid_chain_list [];\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     line_integral_exists F basis (rec_join []); finite basis\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(k, y)\\<in>set [].\n                         line_integral_exists F basis y\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "case Nil"], ["proof (state)\nthis:\n  boundary_chain (set [])\n  valid_chain_list []\n  (?k, ?\\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join [])\n  finite basis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>boundary_chain (set []); valid_chain_list [];\n     \\<And>k \\<gamma>.\n        (k, \\<gamma>) \\<in> set [] \\<Longrightarrow> valid_path \\<gamma>;\n     line_integral_exists F basis (rec_join []); finite basis\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(k, y)\\<in>set [].\n                         line_integral_exists F basis y\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set [].\n       case a of (k, a) \\<Rightarrow> line_integral_exists F basis a", "by (simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set [].\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "case ass: (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "obtain k \\<gamma> where k_gamma:\"a = (k,\\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>boundary_chain (set l); valid_chain_list l;\n                 \\<And>k \\<gamma>.\n                    (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n                    valid_path \\<gamma>;\n                 line_integral_exists F basis (rec_join l);\n                 finite basis\\<rbrakk>\n                \\<Longrightarrow> \\<forall>(k, y)\\<in>set l.\n                                     line_integral_exists F basis y;\n        boundary_chain (set (a # l)); valid_chain_list (a # l);\n        \\<And>k \\<gamma>.\n           (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n           valid_path \\<gamma>;\n        line_integral_exists F basis (rec_join (a # l));\n        finite basis\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(k, y)\\<in>set (a # l).\n                            line_integral_exists F basis y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (a # l).\n       case a of (k, a) \\<Rightarrow> line_integral_exists F basis a", "apply (auto simp add: k_gamma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. line_integral_exists F basis \\<gamma>\n 2. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral_exists F basis \\<gamma>\n 2. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have 0: \"line_integral_exists F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "using line_integral_exists_rec_join_cons k_eq_1 k_gamma ass(4) ass(5) ass(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>line_integral_exists ?F ?basis (rec_join ((1, ?\\<gamma>) # ?l));\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((1, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis\n                     (?\\<gamma> +++ rec_join ?l)\n  k = 1\n  a = (k, \\<gamma>)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have 2: \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using ass k_gamma"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_exists_joinD1[OF 0 2]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg_1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass k_gamma"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. k = - 1", "by (simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have 0: \"line_integral_exists F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "using line_integral_exists_rec_join_cons_2[OF ] k_eq_neg_1 k_gamma ass(4) ass(5) ass(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>line_integral_exists ?F ?basis\n            (rec_join ((- 1, ?\\<gamma>) # ?l));\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((1, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis\n                     (reversepath ?\\<gamma> +++ rec_join ?l)\n  k = - 1\n  a = (k, \\<gamma>)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have gamma_valid:\n        \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using ass k_gamma"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  valid_path \\<gamma>", "have 2: \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using valid_path_imp_reverse"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n  valid_path ?g \\<Longrightarrow> valid_path (reversepath ?g)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using line_integral_exists_joinD1[OF 0 2]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis (reversepath \\<gamma>)", "show \"line_integral_exists F basis (\\<gamma>)\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_on_reverse_path(2)[OF 2] reversepath_reversepath"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (reversepath \\<gamma>)\n  line_integral_exists ?F ?basis (reversepath \\<gamma>) \\<Longrightarrow>\n  line_integral_exists ?F ?basis (reversepath (reversepath \\<gamma>))\n  reversepath (reversepath ?g) = ?g\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "have 0:\"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "using ass(2)"], ["proof (prove)\nusing this:\n  boundary_chain (set (a # l))\n\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "have 1:\"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list l", "using ass(3)"], ["proof (prove)\nusing this:\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. valid_chain_list l", "apply (auto simp add: k_gamma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list ((k, \\<gamma>) # l) \\<Longrightarrow>\n    valid_chain_list l", "by (metis valid_chain_list.elims(3) valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "have 2:\"(\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set (l) \\<Longrightarrow> valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "using ass(4)"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "have 3: \"valid_path (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "using joined_is_valid[OF 0] 1 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k \\<gamma>.\n              (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n              valid_path \\<gamma>;\n   valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "by auto"], ["proof (state)\nthis:\n  valid_path (rec_join l)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "have 4: \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "have 0: \"line_integral_exists F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "using line_integral_exists_rec_join_cons k_eq_1 k_gamma ass(4) ass(5) ass(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>line_integral_exists ?F ?basis (rec_join ((1, ?\\<gamma>) # ?l));\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((1, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis\n                     (?\\<gamma> +++ rec_join ?l)\n  k = 1\n  a = (k, \\<gamma>)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (\\<gamma> +++ rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "show \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_joinD2[OF 0 3]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg_1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass k_gamma"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  \\<lbrakk>boundary_chain (set l); valid_chain_list l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. k = - 1", "by (simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "have 0: \"line_integral_exists F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "using line_integral_exists_rec_join_cons_2[OF ] k_eq_neg_1 k_gamma ass(4) ass(5) ass(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>line_integral_exists ?F ?basis\n            (rec_join ((- 1, ?\\<gamma>) # ?l));\n   \\<And>k' \\<gamma>'.\n      (k', \\<gamma>') \\<in> set ((1, ?\\<gamma>) # ?l) \\<Longrightarrow>\n      valid_path \\<gamma>';\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis\n                     (reversepath ?\\<gamma> +++ rec_join ?l)\n  k = - 1\n  a = (k, \\<gamma>)\n  (?k, ?\\<gamma>) \\<in> set (a # l) \\<Longrightarrow> valid_path ?\\<gamma>\n  line_integral_exists F basis (rec_join (a # l))\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis (rec_join l)", "show \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_joinD2[OF 0 3]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "show \"\\<And>a b. (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "using 0 1 2 3 4 ass(1)[OF 0 1 2] ass(6)"], ["proof (prove)\nusing this:\n  boundary_chain (set l)\n  valid_chain_list l\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n  valid_path (rec_join l)\n  line_integral_exists F basis (rec_join l)\n  \\<lbrakk>\\<And>k \\<gamma>.\n              (k, \\<gamma>) \\<in> set l \\<Longrightarrow>\n              (?k k \\<gamma>, \\<gamma>) \\<in> set l;\n   line_integral_exists F basis (rec_join l); finite basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set l.\n                       case a of\n                       (k, a) \\<Rightarrow> line_integral_exists F basis a\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis b", "by fastforce"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> set l \\<Longrightarrow> line_integral_exists F basis ?b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive chain_subdiv_path\n  where I: \"chain_subdiv_path \\<gamma> (set l)\" if \"distinct l\" \"rec_join l = \\<gamma>\" \"valid_chain_list l\""], ["", "lemma valid_path_equiv_valid_chain_list:\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" \n    and \"boundary_chain one_chain\" \"\\<forall>(k, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "obtain l where l_props: \"set l = one_chain\" \"distinct l\" \"rec_join l = \\<gamma>\" \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain_subdiv_path.cases path_eq_chain"], ["proof (prove)\nusing this:\n  \\<lbrakk>chain_subdiv_path ?a1.0 ?a2.0;\n   \\<And>l \\<gamma>.\n      \\<lbrakk>?a1.0 = \\<gamma>; ?a2.0 = set l; distinct l;\n       rec_join l = \\<gamma>; valid_chain_list l\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  chain_subdiv_path \\<gamma> one_chain\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "show \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using joined_is_valid assms l_props"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ?l)\n  chain_subdiv_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_rec_join_cons:\n  assumes \"line_integral_exists F basis \\<gamma>\"\n    \"line_integral_exists F basis (rec_join ((l)))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral F basis (rec_join ((1,\\<gamma>) # l)) = line_integral F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "assume l_empty: \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "show \"line_integral F basis (rec_join ((1,\\<gamma>) # l)) = line_integral F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "using assms line_integral_distrib(1)[OF assms(1) line_integral_exists_on_degenerate_path[OF assms(4)], of \"0\"]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  \\<lbrakk>valid_path \\<gamma>; valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (\\<gamma> +++ (\\<lambda>x. 0)) =\n                    line_integral F basis \\<gamma> +\n                    line_integral F basis (\\<lambda>x. 0)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "apply (auto simp add: l_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>line_integral_exists F basis \\<gamma>;\n     line_integral_exists F basis (\\<lambda>x. 0); valid_path \\<gamma>;\n     finite basis;\n     valid_path (\\<lambda>x. 0) \\<Longrightarrow>\n     line_integral F basis (\\<gamma> +++ (\\<lambda>x. 0)) =\n     line_integral F basis \\<gamma> +\n     line_integral F basis (\\<lambda>x. 0)\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis \\<gamma> =\n                      line_integral F basis (\\<gamma> +++ (\\<lambda>x. 0))", "using degenerate_path_is_valid_path line_integral_degenerate_path"], ["proof (prove)\nusing this:\n  valid_path (\\<lambda>x. ?c)\n  finite ?basis \\<Longrightarrow>\n  line_integral ?F ?basis (\\<lambda>x. ?c) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>line_integral_exists F basis \\<gamma>;\n     line_integral_exists F basis (\\<lambda>x. 0); valid_path \\<gamma>;\n     finite basis;\n     valid_path (\\<lambda>x. 0) \\<Longrightarrow>\n     line_integral F basis (\\<gamma> +++ (\\<lambda>x. 0)) =\n     line_integral F basis \\<gamma> +\n     line_integral F basis (\\<lambda>x. 0)\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis \\<gamma> =\n                      line_integral F basis (\\<gamma> +++ (\\<lambda>x. 0))", "by fastforce"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n  line_integral F basis (\\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "assume \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where l_nempty: \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "show \"line_integral F basis (rec_join ((1,\\<gamma>) # l)) = line_integral F basis (\\<gamma> +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "by (auto simp add: l_nempty)"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n  line_integral F basis (\\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_rec_join_cons_2:\n  assumes \"line_integral_exists F basis \\<gamma>\"\n    \"line_integral_exists F basis (rec_join ((l)))\"\n    \"(\\<And>k' \\<gamma>'. (k', \\<gamma>') \\<in> set ((-1,\\<gamma>) # l) \\<Longrightarrow> valid_path \\<gamma>')\"\n    \"finite basis\"\n  shows \"line_integral F basis (rec_join ((-1,\\<gamma>) # l)) = line_integral F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "assume l_empty: \"l = []\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "have 0: \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using assms line_integral_on_reverse_path(2)"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "have 1: \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by fastforce"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "show \"line_integral F basis (rec_join ((-1,\\<gamma>) # l)) = line_integral F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "using assms line_integral_distrib(1)[OF 0 line_integral_exists_on_degenerate_path[OF assms(4)], of \"0\"]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n  \\<lbrakk>valid_path (reversepath \\<gamma>);\n   valid_path (\\<lambda>x. 0)\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis\n                     (reversepath \\<gamma> +++ (\\<lambda>x. 0)) =\n                    line_integral F basis (reversepath \\<gamma>) +\n                    line_integral F basis (\\<lambda>x. 0)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "apply (auto simp add: l_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>line_integral_exists F basis \\<gamma>;\n     line_integral_exists F basis (\\<lambda>x. 0); valid_path \\<gamma>;\n     finite basis;\n     valid_path (\\<lambda>x. 0) \\<Longrightarrow>\n     line_integral F basis (reversepath \\<gamma> +++ (\\<lambda>x. 0)) =\n     line_integral F basis (reversepath \\<gamma>) +\n     line_integral F basis (\\<lambda>x. 0)\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis (reversepath \\<gamma>) =\n                      line_integral F basis\n                       (reversepath \\<gamma> +++ (\\<lambda>x. 0))", "using degenerate_path_is_valid_path line_integral_degenerate_path"], ["proof (prove)\nusing this:\n  valid_path (\\<lambda>x. ?c)\n  finite ?basis \\<Longrightarrow>\n  line_integral ?F ?basis (\\<lambda>x. ?c) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>line_integral_exists F basis \\<gamma>;\n     line_integral_exists F basis (\\<lambda>x. 0); valid_path \\<gamma>;\n     finite basis;\n     valid_path (\\<lambda>x. 0) \\<Longrightarrow>\n     line_integral F basis (reversepath \\<gamma> +++ (\\<lambda>x. 0)) =\n     line_integral F basis (reversepath \\<gamma>) +\n     line_integral F basis (\\<lambda>x. 0)\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis (reversepath \\<gamma>) =\n                      line_integral F basis\n                       (reversepath \\<gamma> +++ (\\<lambda>x. 0))", "by fastforce"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "assume \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain h l' where l_nempty: \"l = h#l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h l'. l = h # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = h # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "show \"line_integral F basis (rec_join ((-1,\\<gamma>) # l)) = line_integral F basis ((reversepath \\<gamma>) +++ (rec_join l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "using assms"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  line_integral_exists F basis (rec_join l)\n  (?k', ?\\<gamma>') \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n  valid_path ?\\<gamma>'\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "by (auto simp add: l_nempty)"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_chain_line_integral_rec_join:\n  assumes l_props: \"set l = one_chain\" \"distinct l\" \"valid_chain_list l\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"line_integral F basis (rec_join l) = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "have 0: \"sum_list (map (\\<lambda>((k::int), \\<gamma>). (k::int) * (line_integral F basis \\<gamma>)) l) = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(k,\n        \\<gamma>)\\<leftarrow>l. real_of_int k *\n                                line_integral F basis \\<gamma>) =\n    one_chain_line_integral F basis one_chain", "unfolding one_chain_line_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(k,\n        \\<gamma>)\\<leftarrow>l. real_of_int k *\n                                line_integral F basis \\<gamma>) =\n    (\\<Sum>(k, g)\\<in>one_chain. real_of_int k * line_integral F basis g)", "using l_props Groups_List.comm_monoid_add_class.sum.distinct_set_conv_list[OF l_props(2), of \"(\\<lambda>(k, \\<gamma>). (k::int) * (line_integral F basis \\<gamma>))\"]"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  valid_chain_list l\n  (\\<Sum>(k, \\<gamma>)\\<in>set l.\n     real_of_int k * line_integral F basis \\<gamma>) =\n  (\\<Sum>(k,\n      \\<gamma>)\\<leftarrow>l. real_of_int k *\n                              line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(k,\n        \\<gamma>)\\<leftarrow>l. real_of_int k *\n                                line_integral F basis \\<gamma>) =\n    (\\<Sum>(k, g)\\<in>one_chain. real_of_int k * line_integral F basis g)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(k,\n      \\<gamma>)\\<leftarrow>l. real_of_int k *\n                              line_integral F basis \\<gamma>) =\n  one_chain_line_integral F basis one_chain\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "have \"valid_chain_list l \\<Longrightarrow>\n                    boundary_chain (set l) \\<Longrightarrow>\n                    (\\<forall>(k::int, \\<gamma>) \\<in> set l. line_integral_exists F basis \\<gamma>) \\<Longrightarrow>\n                    (\\<forall>(k::int, \\<gamma>) \\<in> set l. valid_path \\<gamma>) \\<Longrightarrow>\n                    line_integral F basis (rec_join l) = sum_list (map (\\<lambda>(k::int, \\<gamma>). k * (line_integral F basis \\<gamma>)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n     \\<forall>(k, \\<gamma>)\\<in>set l.\n        line_integral_exists F basis \\<gamma>;\n     \\<forall>(k, \\<gamma>)\\<in>set l. valid_path \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis (rec_join l) =\n                      (\\<Sum>(x,\n                          \\<gamma>)\\<leftarrow>l. real_of_int x *\n            line_integral F basis \\<gamma>)", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_chain_list []; boundary_chain (set []);\n     \\<forall>(k, y)\\<in>set []. line_integral_exists F basis y;\n     \\<forall>(k, y)\\<in>set []. valid_path y\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis (rec_join []) =\n                      (\\<Sum>(x,\n                          \\<gamma>)\\<leftarrow>[]. real_of_int x *\n             line_integral F basis \\<gamma>)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "case Nil"], ["proof (state)\nthis:\n  valid_chain_list []\n  boundary_chain (set [])\n  \\<forall>a\\<in>set [].\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set []. case a of (k, a) \\<Rightarrow> valid_path a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_chain_list []; boundary_chain (set []);\n     \\<forall>(k, y)\\<in>set []. line_integral_exists F basis y;\n     \\<forall>(k, y)\\<in>set []. valid_path y\\<rbrakk>\n    \\<Longrightarrow> line_integral F basis (rec_join []) =\n                      (\\<Sum>(x,\n                          \\<gamma>)\\<leftarrow>[]. real_of_int x *\n             line_integral F basis \\<gamma>)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join []) =\n    (\\<Sum>a\\<leftarrow>[]. case a of\n                            (x, \\<gamma>) \\<Rightarrow>\n                              real_of_int x *\n                              line_integral F basis \\<gamma>)", "unfolding line_integral_def boundary_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (rec_join [] x) \\<bullet> b *\n           (vector_derivative (rec_join []) (at x within {0..1}) \\<bullet>\n            b)) =\n    (\\<Sum>a\\<leftarrow>[]. case a of\n                            (x, \\<gamma>) \\<Rightarrow>\n                              real_of_int x *\n                              integral {0..1}\n                               (\\<lambda>x.\n                                   \\<Sum>b\\<in>basis.\n                                     F (\\<gamma> x) \\<bullet> b *\n                                     (vector_derivative \\<gamma>\n (at x within {0..1}) \\<bullet>\nb)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) =\n    0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "have \"\\<forall>x. (vector_derivative (\\<lambda>x. 0) (at x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. vector_derivative (\\<lambda>x. 0::'a) (at x) = (0::'a)", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x. vector_derivative (\\<lambda>x. 0::'a) (at x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)", "have \"\\<forall>x. ((\\<lambda>x. 0) has_vector_derivative 0) (at x)\""], ["proof (prove)\nusing this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n\ngoal (1 subgoal):\n 1. \\<forall>x. ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a)) (at x)", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  \\<forall>x. vector_derivative (\\<lambda>x. 0::?'a1) (at x) = (0::?'a1)\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x. ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a)) (at x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)", "have \"\\<forall>x. ((\\<lambda>x. 0) has_vector_derivative 0) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a))\n        (at x within {0..1})", "using Derivative.vector_derivative_const_at"], ["proof (prove)\nusing this:\n  \\<forall>x. ((\\<lambda>x. 0::?'a2) has_vector_derivative (0::?'a2)) (at x)\n  vector_derivative (\\<lambda>x. ?c) (at ?a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. 0::'a) has_vector_derivative (0::'a))\n        (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})", "have 0: \"\\<forall>x\\<in>{0..1}. (vector_derivative (\\<lambda>x. 0) (at x within{0..1})) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     ((\\<lambda>x. 0::?'a3) has_vector_derivative (0::?'a3))\n      (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative (\\<lambda>x. 0::'a) (at x within {0..1}) = (0::'a)", "by (metis (no_types) box_real(2) vector_derivative_within_cbox zero_less_one)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative (\\<lambda>x. 0::?'a4) (at x within {0..1}) =\n     (0::?'a4)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "have \"(\\<forall>x\\<in>{0..1}. (\\<Sum>b\\<in>basis. F 0 \\<bullet> b * (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet> b)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       (\\<Sum>b\\<in>basis.\n          F 0 \\<bullet> b *\n          (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n           b)) =\n       0", "by (simp add: 0)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0", "show \"((\\<lambda>x. \\<Sum>b\\<in>basis. F 0 \\<bullet> b * (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet> b)) has_integral 0) {0..1}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<Sum>b\\<in>basis.\n        F 0 \\<bullet> b *\n        (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n         b)) =\n     0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F 0 \\<bullet> b *\n           (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     0)\n     {0..1}", "by (meson has_integral_is_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F 0 \\<bullet> b *\n         (vector_derivative (\\<lambda>x. 0) (at x within {0..1}) \\<bullet>\n          b)) has_integral\n   0)\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (rec_join []) =\n  (\\<Sum>a\\<leftarrow>[]. case a of\n                          (x, \\<gamma>) \\<Rightarrow>\n                            real_of_int x * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "case ass: (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "obtain k::\"int\" and\n      \\<gamma>::\"one_cube\" where props: \"a = (k,\\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    a = (?k2, ?\\<gamma>2)", "let ?k2 = \"fst a\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    a = (?k2, ?\\<gamma>2)", "let ?\\<gamma>2 = \"snd a\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        a = (k, \\<gamma>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    a = (?k2, ?\\<gamma>2)", "show \"a = (?k2, ?\\<gamma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (fst a, snd a)", "by auto"], ["proof (state)\nthis:\n  a = (fst a, snd a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have \"line_integral_exists F basis (rec_join (a # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join (a # l))", "using line_integral_exists_on_rec_join[OF ass(3) ass(2)] ass(5) ass(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k \\<gamma>.\n              (k, \\<gamma>) \\<in> set (a # l) \\<Longrightarrow>\n              valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set (a # l).\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join (a # l))\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join (a # l))", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join (a # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have \"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by (meson ass.prems(2) boundary_chain_def list.set_intros(2))"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have val_l: \"\\<And>f i. (i,f) \\<in> set l \\<Longrightarrow> valid_path f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f i. (i, f) \\<in> set l \\<Longrightarrow> valid_path f", "using ass.prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n\ngoal (1 subgoal):\n 1. \\<And>f i. (i, f) \\<in> set l \\<Longrightarrow> valid_path f", "by fastforce"], ["proof (state)\nthis:\n  (?i, ?f) \\<in> set l \\<Longrightarrow> valid_path ?f\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have vcl_l: \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list l", "by (metis (no_types) ass.prems(1) valid_chain_list.elims(3) valid_chain_list.simps(3))"], ["proof (state)\nthis:\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have line_integral_exists_on_joined:\n      \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by (metis \\<open>boundary_chain (set l)\\<close> \\<open>line_integral_exists F basis (rec_join (a # l))\\<close> emptyE val_l vcl_l joined_is_valid line_integral_exists_joinD2 line_integral_exists_on_rec_join list.set(1) neq_Nil_conv rec_join.simps(3))"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "have \"valid_path (rec_join (a # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join (a # l))", "using joined_is_valid ass(5) ass(3) ass(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ?l)\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  boundary_chain (set (a # l))\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. valid_path (rec_join (a # l))", "by blast"], ["proof (state)\nthis:\n  valid_path (rec_join (a # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  valid_path (rec_join (a # l))", "have joined_is_valid: \"valid_path (rec_join l)\""], ["proof (prove)\nusing this:\n  valid_path (rec_join (a # l))\n\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "using \\<open>boundary_chain (set l)\\<close> val_l vcl_l joined_is_valid"], ["proof (prove)\nusing this:\n  valid_path (rec_join (a # l))\n  boundary_chain (set l)\n  (?i, ?f) \\<in> set l \\<Longrightarrow> valid_path ?f\n  valid_chain_list l\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ?l)\n\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "by blast"], ["proof (state)\nthis:\n  valid_path (rec_join l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>valid_chain_list l; boundary_chain (set l);\n                 \\<forall>(k, y)\\<in>set l. line_integral_exists F basis y;\n                 \\<forall>(k, y)\\<in>set l. valid_path y\\<rbrakk>\n                \\<Longrightarrow> line_integral F basis (rec_join l) =\n                                  (\\<Sum>(x,\n\\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>);\n        valid_chain_list (a # l); boundary_chain (set (a # l));\n        \\<forall>(k, y)\\<in>set (a # l). line_integral_exists F basis y;\n        \\<forall>(k, y)\\<in>set (a # l). valid_path y\\<rbrakk>\n       \\<Longrightarrow> line_integral F basis (rec_join (a # l)) =\n                         (\\<Sum>(x,\n                             \\<gamma>)\\<leftarrow>a #\n            l. real_of_int x * line_integral F basis \\<gamma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join (a # l)) =\n    (\\<Sum>a\\<leftarrow>a #\n                        l. case a of\n                           (x, \\<gamma>) \\<Rightarrow>\n                             real_of_int x * line_integral F basis \\<gamma>)", "proof (clarsimp, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "assume k_eq_1: \"(k::int) = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have line_integral_exists_on_gamma: \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using ass props"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have gamma_is_valid: \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using ass props"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have line_int_rw: \"line_integral F basis (rec_join ((k, \\<gamma>) # l)) = line_integral F basis (\\<gamma> +++ rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "have gam_int: \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using ass props"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "have rec_join_int: \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_on_rec_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set ?l.\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join ?l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_on_joined"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set ?l.\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join ?l)\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "using line_integral_rec_join_cons[OF gam_int rec_join_int] ass k_eq_1 finite_basis props"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k' \\<gamma>'.\n              (k', \\<gamma>')\n              \\<in> set ((1, \\<gamma>) # l) \\<Longrightarrow>\n              valid_path \\<gamma>';\n   finite basis\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join ((1, \\<gamma>) # l)) =\n                    line_integral F basis (\\<gamma> +++ rec_join l)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  k = 1\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (\\<gamma> +++ rec_join l)", "by force"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n  line_integral F basis (\\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n  line_integral F basis (\\<gamma> +++ rec_join l)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)\n 2. \\<not> ?P \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "show \"line_integral F basis (rec_join (a # l)) =\n            (case a of (x, \\<gamma>) \\<Rightarrow> real_of_int x * line_integral F basis \\<gamma>) + (\\<Sum>(x, \\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "apply (simp add: props line_int_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (\\<gamma> +++ rec_join l) =\n    real_of_int k * line_integral F basis \\<gamma> +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "using line_integral_distrib[OF line_integral_exists_on_gamma line_integral_exists_on_joined gamma_is_valid joined_is_valid]\n          ass k_eq_1 vcl_l"], ["proof (prove)\nusing this:\n  line_integral F basis (\\<gamma> +++ rec_join l) =\n  line_integral F basis \\<gamma> + line_integral F basis (rec_join l)\n  line_integral_exists F basis (\\<gamma> +++ rec_join l)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  k = 1\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. line_integral F basis (\\<gamma> +++ rec_join l) =\n    real_of_int k * line_integral F basis \\<gamma> +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "by (auto simp: boundary_chain_def props)"], ["proof (state)\nthis:\n  line_integral F basis (rec_join (a # l)) =\n  (case a of\n   (x, \\<gamma>) \\<Rightarrow>\n     real_of_int x * line_integral F basis \\<gamma>) +\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg_1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass props"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have line_integral_exists_on_gamma:\n        \"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using line_integral_on_reverse_path ass props"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have gamma_is_valid: \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using valid_path_imp_reverse ass props"], ["proof (prove)\nusing this:\n  valid_path ?g \\<Longrightarrow> valid_path (reversepath ?g)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "have line_int_rw: \"line_integral F basis (rec_join ((k, \\<gamma>) # l)) = line_integral F basis ((reversepath \\<gamma>) +++ rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "have gam_int: \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using ass props"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "have rec_join_int: \"line_integral_exists F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_on_rec_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set ?l.\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join ?l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "using line_integral_exists_on_joined"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set ?l.\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join ?l)\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (rec_join l)", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "using line_integral_rec_join_cons_2[OF gam_int rec_join_int]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k' \\<gamma>'.\n              (k', \\<gamma>')\n              \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n              valid_path \\<gamma>';\n   finite basis\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n                    line_integral F basis\n                     (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "using ass k_eq_neg_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k' \\<gamma>'.\n              (k', \\<gamma>')\n              \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n              valid_path \\<gamma>';\n   finite basis\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n                    line_integral F basis\n                     (reversepath \\<gamma> +++ rec_join l)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  k = - 1\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "using finite_basis props"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>k' \\<gamma>'.\n              (k', \\<gamma>')\n              \\<in> set ((- 1, \\<gamma>) # l) \\<Longrightarrow>\n              valid_path \\<gamma>';\n   finite basis\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join ((- 1, \\<gamma>) # l)) =\n                    line_integral F basis\n                     (reversepath \\<gamma> +++ rec_join l)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  k = - 1\n  finite basis\n  a = (k, \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n    line_integral F basis (reversepath \\<gamma> +++ rec_join l)", "by blast"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (rec_join ((k, \\<gamma>) # l)) =\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "show \"line_integral F basis (rec_join (a # l)) =\n            (case a of (x, \\<gamma>) \\<Rightarrow> real_of_int x * line_integral F basis \\<gamma>) + (\\<Sum>(x, \\<gamma>)\\<leftarrow>l. real_of_int x * line_integral F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join (a # l)) =\n    (case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>) +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "apply (simp add: props line_int_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (reversepath \\<gamma> +++ rec_join l) =\n    real_of_int k * line_integral F basis \\<gamma> +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "using line_integral_distrib[OF line_integral_exists_on_gamma line_integral_exists_on_joined gamma_is_valid joined_is_valid]\n          props ass line_integral_on_reverse_path(1)[of \"\\<gamma>\" \"F\" \"basis\"] k_eq_neg_1"], ["proof (prove)\nusing this:\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l) =\n  line_integral F basis (reversepath \\<gamma>) +\n  line_integral F basis (rec_join l)\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n  a = (k, \\<gamma>)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  \\<lbrakk>valid_path \\<gamma>;\n   line_integral_exists F basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis \\<gamma> =\n                    - line_integral F basis (reversepath \\<gamma>)\n  k = - 1\n\ngoal (1 subgoal):\n 1. line_integral F basis (reversepath \\<gamma> +++ rec_join l) =\n    real_of_int k * line_integral F basis \\<gamma> +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "using \\<open>boundary_chain (set l)\\<close> vcl_l"], ["proof (prove)\nusing this:\n  line_integral F basis (reversepath \\<gamma> +++ rec_join l) =\n  line_integral F basis (reversepath \\<gamma>) +\n  line_integral F basis (rec_join l)\n  line_integral_exists F basis (reversepath \\<gamma> +++ rec_join l)\n  a = (k, \\<gamma>)\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> line_integral_exists F basis a;\n   \\<forall>a\\<in>set l.\n      case a of (k, a) \\<Rightarrow> valid_path a\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>a\\<leftarrow>l. case a of\n     (x, \\<gamma>) \\<Rightarrow>\n       real_of_int x * line_integral F basis \\<gamma>)\n  valid_chain_list (a # l)\n  boundary_chain (set (a # l))\n  \\<forall>a\\<in>set (a # l).\n     case a of (k, a) \\<Rightarrow> line_integral_exists F basis a\n  \\<forall>a\\<in>set (a # l). case a of (k, a) \\<Rightarrow> valid_path a\n  \\<lbrakk>valid_path \\<gamma>;\n   line_integral_exists F basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis \\<gamma> =\n                    - line_integral F basis (reversepath \\<gamma>)\n  k = - 1\n  boundary_chain (set l)\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. line_integral F basis (reversepath \\<gamma> +++ rec_join l) =\n    real_of_int k * line_integral F basis \\<gamma> +\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (rec_join (a # l)) =\n  (case a of\n   (x, \\<gamma>) \\<Rightarrow>\n     real_of_int x * line_integral F basis \\<gamma>) +\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (rec_join (a # l)) =\n  (\\<Sum>a\\<leftarrow>a #\n                      l. case a of\n                         (x, \\<gamma>) \\<Rightarrow>\n                           real_of_int x * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set l. valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>(x,\n                        \\<gamma>)\\<leftarrow>l. real_of_int x *\n          line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set l. valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>(x,\n                        \\<gamma>)\\<leftarrow>l. real_of_int x *\n          line_integral F basis \\<gamma>)", "have 1:\"line_integral F basis (rec_join l) = sum_list (map (\\<lambda>(k::int, \\<gamma>). k * (line_integral F basis \\<gamma>)) l)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set l. valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>(x,\n                        \\<gamma>)\\<leftarrow>l. real_of_int x *\n          line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "using l_props assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_chain_list l; boundary_chain (set l);\n   \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set l. valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral F basis (rec_join l) =\n                    (\\<Sum>(x,\n                        \\<gamma>)\\<leftarrow>l. real_of_int x *\n          line_integral F basis \\<gamma>)\n  set l = one_chain\n  distinct l\n  valid_chain_list l\n  set l = one_chain\n  distinct l\n  valid_chain_list l\n  boundary_chain one_chain\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    (\\<Sum>(x,\n        \\<gamma>)\\<leftarrow>l. real_of_int x *\n                                line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (rec_join l) =\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "then"], ["proof (chain)\npicking this:\n  line_integral F basis (rec_join l) =\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  line_integral F basis (rec_join l) =\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "using 0 1"], ["proof (prove)\nusing this:\n  line_integral F basis (rec_join l) =\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n  (\\<Sum>(k,\n      \\<gamma>)\\<leftarrow>l. real_of_int k *\n                              line_integral F basis \\<gamma>) =\n  one_chain_line_integral F basis one_chain\n  line_integral F basis (rec_join l) =\n  (\\<Sum>(x,\n      \\<gamma>)\\<leftarrow>l. real_of_int x *\n                              line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_on_path_eq_line_integral_on_equiv_chain:\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\"\n    \"line_integral_exists F basis \\<gamma>\"\n    \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma> &&&\n    line_integral_exists F basis \\<gamma> &&& valid_path \\<gamma>", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>\n 2. line_integral_exists F basis \\<gamma>\n 3. valid_path \\<gamma>", "obtain l where l_props: \"set l = one_chain\" \"distinct l\" \"rec_join l = \\<gamma>\" \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain_subdiv_path.cases path_eq_chain"], ["proof (prove)\nusing this:\n  \\<lbrakk>chain_subdiv_path ?a1.0 ?a2.0;\n   \\<And>l \\<gamma>.\n      \\<lbrakk>?a1.0 = \\<gamma>; ?a2.0 = set l; distinct l;\n       rec_join l = \\<gamma>; valid_chain_list l\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  chain_subdiv_path \\<gamma> one_chain\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (3 subgoals):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>\n 2. line_integral_exists F basis \\<gamma>\n 3. valid_path \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_exists_on_rec_join assms l_props"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>set ?l.\n      line_integral_exists ?F ?basis \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (rec_join ?l)\n  chain_subdiv_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>\n 2. valid_path \\<gamma>", "show \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using joined_is_valid assms l_props"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l);\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> valid_path (rec_join ?l)\n  chain_subdiv_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "have \"line_integral F basis (rec_join l) = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "using one_chain_line_integral_rec_join l_props assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?l = ?one_chain; distinct ?l; valid_chain_list ?l;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis (rec_join ?l) =\n                    one_chain_line_integral ?F ?basis ?one_chain\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n  chain_subdiv_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain", "show \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "using l_props"], ["proof (prove)\nusing this:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_on_path_eq_line_integral_on_equiv_chain':\n  assumes path_eq_chain: \"chain_subdiv_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma> &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "obtain l where l_props: \"set l = one_chain\" \"distinct l\" \"rec_join l = \\<gamma>\" \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain_subdiv_path.cases path_eq_chain"], ["proof (prove)\nusing this:\n  \\<lbrakk>chain_subdiv_path ?a1.0 ?a2.0;\n   \\<And>l \\<gamma>.\n      \\<lbrakk>?a1.0 = \\<gamma>; ?a2.0 = set l; distinct l;\n       rec_join l = \\<gamma>; valid_chain_list l\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  chain_subdiv_path \\<gamma> one_chain\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l; rec_join l = \\<gamma>;\n         valid_chain_list l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "show 0: \"\\<forall>(k, \\<gamma>) \\<in> one_chain. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "using line_integral_exists_on_rec_join' assms l_props"], ["proof (prove)\nusing this:\n  \\<lbrakk>boundary_chain (set ?l); valid_chain_list ?l;\n   \\<And>k \\<gamma>.\n      (k, \\<gamma>) \\<in> set ?l \\<Longrightarrow> valid_path \\<gamma>;\n   line_integral_exists ?F ?basis (rec_join ?l); finite ?basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(k, \\<gamma>)\\<in>set ?l.\n                       line_integral_exists ?F ?basis \\<gamma>\n  chain_subdiv_path \\<gamma> one_chain\n  boundary_chain one_chain\n  line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  set l = one_chain\n  distinct l\n  rec_join l = \\<gamma>\n  valid_chain_list l\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "using line_integral_on_path_eq_line_integral_on_equiv_chain(1)[OF assms(1) assms(2) 0 assms(4) assms(5)]"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain =\n    line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain = line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition chain_subdiv_chain where\n  \"chain_subdiv_chain one_chain1 subdiv\n        \\<equiv> \\<exists>f. (\\<Union>(f ` one_chain1)) = subdiv \\<and>\n              (\\<forall>c\\<in>one_chain1. chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n              pairwise (\\<lambda> p p'. f p \\<inter> f p' = {}) one_chain1 \\<and>\n              (\\<forall>x \\<in> one_chain1. finite (f x))\""], ["", "lemma chain_subdiv_chain_character:\n  shows \"chain_subdiv_chain one_chain1 subdiv \\<longleftrightarrow>\n        (\\<exists>f. \\<Union>(f ` one_chain1) = subdiv \\<and>\n             (\\<forall>(k, \\<gamma>)\\<in>one_chain1.\n                 if k = 1\n                 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n                 else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))) \\<and>\n             (\\<forall>p\\<in>one_chain1.\n                 \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n             (\\<forall>x\\<in>one_chain1. finite (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_chain one_chain1 subdiv =\n    (\\<exists>f.\n        \\<Union> (f ` one_chain1) = subdiv \\<and>\n        (\\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>)\n                  (f (k, \\<gamma>))) \\<and>\n        (\\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow>\n               f p \\<inter> f p' = {}) \\<and>\n        (\\<forall>x\\<in>one_chain1. finite (f x)))", "unfolding chain_subdiv_chain_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f.\n        \\<Union> (f ` one_chain1) = subdiv \\<and>\n        (\\<forall>c\\<in>one_chain1.\n            chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n        pairwise (\\<lambda>p p'. f p \\<inter> f p' = {}) one_chain1 \\<and>\n        (\\<forall>x\\<in>one_chain1. finite (f x))) =\n    (\\<exists>f.\n        \\<Union> (f ` one_chain1) = subdiv \\<and>\n        (\\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>)\n                  (f (k, \\<gamma>))) \\<and>\n        (\\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow>\n               f p \\<inter> f p' = {}) \\<and>\n        (\\<forall>x\\<in>one_chain1. finite (f x)))", "by (safe; intro exI conjI iffI; fastforce simp add: pairwise_def)"], ["", "lemma chain_subdiv_chain_imp_finite_subdiv:\n  assumes \"finite one_chain1\"\n    \"chain_subdiv_chain one_chain1 subdiv\"\n  shows \"finite subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite subdiv", "using assms"], ["proof (prove)\nusing this:\n  finite one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n\ngoal (1 subgoal):\n 1. finite subdiv", "by(auto simp add: chain_subdiv_chain_def)"], ["", "lemma valid_subdiv_imp_valid_one_chain:\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\"\n  shows \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>", "obtain f where f_props:\n    \"((\\<Union>(f ` one_chain1)) = subdiv)\"\n    \"(\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = 1 then chain_subdiv_path \\<gamma> (f(k,\\<gamma>)) else chain_subdiv_path (reversepath \\<gamma>) (f(k,\\<gamma>)))\"\n    \"(\\<forall>p\\<in>one_chain1. \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow>\n               f p \\<inter> f p' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain1_eq_chain2 chain_subdiv_chain_character"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain1 subdiv\n  chain_subdiv_chain ?one_chain1.0 ?subdiv =\n  (\\<exists>f.\n      \\<Union> (f ` ?one_chain1.0) = ?subdiv \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>?one_chain1.0.\n          if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n          else chain_subdiv_path (reversepath \\<gamma>)\n                (f (k, \\<gamma>))) \\<and>\n      (\\<forall>p\\<in>?one_chain1.0.\n          \\<forall>p'\\<in>?one_chain1.0.\n             p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n      (\\<forall>x\\<in>?one_chain1.0. finite (f x)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow>\n               f p \\<inter> f p' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>", "have \"\\<And> k \\<gamma>. (k,\\<gamma>) \\<in> one_chain1\\<Longrightarrow> valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path \\<gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path \\<gamma>", "assume ass: \"(k,\\<gamma>) \\<in> one_chain1\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path \\<gamma>", "show \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "proof (cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> valid_path \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> valid_path \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = 1", "have i:\"chain_subdiv_path \\<gamma> (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> valid_path \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "apply (simp add: boundary_chain_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n     (k, \\<gamma>) \\<in> one_chain1; chain_subdiv_chain one_chain1 subdiv;\n     \\<forall>x\\<in>one_chain1.\n        case x of (k, \\<gamma>) \\<Rightarrow> k = 1 \\<or> k = - 1;\n     \\<forall>x\\<in>subdiv.\n        case x of (k, \\<gamma>) \\<Rightarrow> k = 1 \\<or> k = - 1;\n     \\<forall>x\\<in>subdiv.\n        case x of (k, \\<gamma>) \\<Rightarrow> valid_path \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>f (k, \\<gamma>).\n                         case x of\n                         (k, \\<gamma>) \\<Rightarrow> k = 1 \\<or> k = - 1", "by blast"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> valid_path \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> valid_path \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using valid_path_equiv_valid_chain_list[OF i ii iv]"], ["proof (prove)\nusing this:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = - 1", "have i:\"chain_subdiv_path (reversepath \\<gamma>) (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = - 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "using \\<open>k \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  k = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k, \\<gamma>) \\<in> one_chain1\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "have \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using valid_path_equiv_valid_chain_list[OF i ii iv]"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> valid_path \\<gamma>", "then"], ["proof (chain)\npicking this:\n  valid_path (reversepath \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using  reversepath_reversepath valid_path_imp_reverse"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n  reversepath (reversepath ?g) = ?g\n  valid_path ?g \\<Longrightarrow> valid_path (reversepath ?g)\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by force"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path ?\\<gamma>", "show valid_path1: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. valid_path \\<gamma>\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_chain_line_integral_eq_line_integral_on_sudivision:\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain2: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "obtain f where f_props:\n    \"((\\<Union>(f ` one_chain1)) = subdiv)\"\n    \"(\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = 1 then chain_subdiv_path \\<gamma> (f(k,\\<gamma>)) else chain_subdiv_path (reversepath \\<gamma>) (f(k,\\<gamma>)))\"\n    \"(\\<forall>p\\<in>one_chain1. \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {})\"\n    \"(\\<forall>x \\<in> one_chain1. finite (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain1_eq_chain2 chain_subdiv_chain_character"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain1 subdiv\n  chain_subdiv_chain ?one_chain1.0 ?subdiv =\n  (\\<exists>f.\n      \\<Union> (f ` ?one_chain1.0) = ?subdiv \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>?one_chain1.0.\n          if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n          else chain_subdiv_path (reversepath \\<gamma>)\n                (f (k, \\<gamma>))) \\<and>\n      (\\<forall>p\\<in>?one_chain1.0.\n          \\<forall>p'\\<in>?one_chain1.0.\n             p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n      (\\<forall>x\\<in>?one_chain1.0. finite (f x)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: pairwise_def chain_subdiv_chain_def)"], ["proof (state)\nthis:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)", "have 0: \"one_chain_line_integral F basis subdiv = one_chain_line_integral F basis (\\<Union>(f ` one_chain1))\""], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis subdiv =\n    one_chain_line_integral F basis (\\<Union> (f ` one_chain1))", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis subdiv =\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have finite_chain2: \"finite subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite subdiv", "using finite_chain1 f_props(1) f_props(4)"], ["proof (prove)\nusing this:\n  finite one_chain1\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. finite subdiv", "apply (simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite one_chain1;\n     \\<Union> {y. \\<exists>x\\<in>one_chain1. y = f x} = subdiv;\n     \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n    \\<Longrightarrow> finite subdiv", "using f_props(1)"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite one_chain1;\n     \\<Union> {y. \\<exists>x\\<in>one_chain1. y = f x} = subdiv;\n     \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n    \\<Longrightarrow> finite subdiv", "by auto"], ["proof (state)\nthis:\n  finite subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have \"\\<And> k \\<gamma>. (k,\\<gamma>) \\<in> one_chain1\\<Longrightarrow> line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "assume ass: \"(k,\\<gamma>) \\<in> one_chain1\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "proof (cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = 1", "have i:\"chain_subdiv_path \\<gamma> (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have iii:\"\\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_on_path_eq_line_integral_on_equiv_chain(2)[OF i ii iii iv finite_basis]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = - 1", "have i:\"chain_subdiv_path (reversepath \\<gamma>) (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = - 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have iii:\"\\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have x:\"line_integral_exists F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "using line_integral_on_path_eq_line_integral_on_equiv_chain(2)[OF i ii iii iv finite_basis]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using line_integral_on_path_eq_line_integral_on_equiv_chain(3)[OF i ii iii iv finite_basis]"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  valid_path (reversepath \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_on_reverse_path(2) reversepath_reversepath x"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  reversepath (reversepath ?g) = ?g\n  line_integral_exists F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>", "show line_integral_exists_on_chain1: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "have 1: \"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) = one_chain_line_integral F basis one_chain1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "have 0:\"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) =\n                           (\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have finite: \"\\<forall>chain \\<in> (f ` one_chain1). finite chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>chain\\<in>f ` one_chain1. finite chain", "using f_props(1) finite_chain2"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  finite subdiv\n\ngoal (1 subgoal):\n 1. \\<forall>chain\\<in>f ` one_chain1. finite chain", "by (meson Sup_upper finite_subset)"], ["proof (state)\nthis:\n  \\<forall>chain\\<in>f ` one_chain1. finite chain\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have disj: \" \\<forall>A\\<in>f ` one_chain1. \\<forall>B\\<in>f ` one_chain1. A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>f ` one_chain1.\n       \\<forall>B\\<in>f ` one_chain1.\n          A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}", "by (metis (no_types, hide_lams) f_props(3) image_iff)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>f ` one_chain1.\n     \\<forall>B\\<in>f ` one_chain1.\n        A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "show \"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) =\n                                (\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "using Groups_Big.comm_monoid_add_class.sum.Union_disjoint[OF finite disj]\n          one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  sum ?g (\\<Union> (f ` one_chain1)) = (sum \\<circ> sum) ?g (f ` one_chain1)\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "have 1:\"(\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain) =\n                            one_chain_line_integral F basis one_chain1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "have \"(\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain) =\n                                     (\\<Sum>(k,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have i:\"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                       (\\<Sum>(k,\\<gamma>)\\<in>one_chain1 - {p. f p = {}}. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"inj_on f (one_chain1 - {p. f p = {}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (one_chain1 - {p. f p = {}})", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1 - {p. f p = {}}.\n       \\<forall>y\\<in>one_chain1 - {p. f p = {}}.\n          f x = f y \\<longrightarrow> x = y", "using f_props(3)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1 - {p. f p = {}}.\n       \\<forall>y\\<in>one_chain1 - {p. f p = {}}.\n          f x = f y \\<longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  inj_on f (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  inj_on f (one_chain1 - {p. f p = {}})", "have 0: \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain)\n                                                       = (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). one_chain_line_integral F basis (f (k, \\<gamma>)))\""], ["proof (prove)\nusing this:\n  inj_on f (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>)))", "using Groups_Big.comm_monoid_add_class.sum.reindex"], ["proof (prove)\nusing this:\n  inj_on f (one_chain1 - {p. f p = {}})\n  inj_on ?h ?A \\<Longrightarrow> sum ?g (?h ` ?A) = sum (?g \\<circ> ?h) ?A\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>)))", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>)))\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> k \\<gamma>. (k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n                        one_chain_line_integral F basis (f(k, \\<gamma>)) = k* (line_integral F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "assume ass: \"(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "have bchain: \"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) boundary_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  boundary_chain subdiv\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "have wexist: \"\\<forall>(k, \\<gamma>)\\<in>(f(k,\\<gamma>)). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "using f_props(1) line_integral_exists_on_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "have vpath: \" \\<forall>(k, \\<gamma>)\\<in>(f(k, \\<gamma>)). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) assms ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "using f_props(2) k_eq_1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n  k = 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "using f_props(2) k_eq_neg1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = - 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = - (line_integral F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "using line_integral_on_reverse_path(1) ass line_integral_exists_on_chain1\n                  valid_subdiv_imp_valid_one_chain[OF chain1_eq_chain2 boundary_chain1 boundary_chain2 valid_path]"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}}\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "by force"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_neg1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n  k = - 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>", "have \"(\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). one_chain_line_integral F basis (f (k, \\<gamma>)))\n                   = (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). k* (line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>))) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "by (auto intro!: Finite_Cartesian_Product.sum_cong_aux)"], ["proof (state)\nthis:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)", "show \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                     (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). k* (line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "using 0"], ["proof (prove)\nusing this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>)))\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> (k::int) \\<gamma>. (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> (f (k, \\<gamma>) = {}) \\<Longrightarrow> (k, \\<gamma>) \\<in> {(k',\\<gamma>'). k'* (line_integral F basis \\<gamma>') = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "fix k::\"int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "fix \\<gamma>::\"one_cube\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "assume ass:\"(k, \\<gamma>) \\<in> one_chain1\"\n            \"(f (k, \\<gamma>) = {})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}", "have zero_line_integral:\"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "have bchain: \"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) boundary_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  boundary_chain subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "have wexist: \"\\<forall>(k, \\<gamma>)\\<in>(f(k,\\<gamma>)). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "using f_props(1) line_integral_exists_on_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "have vpath: \" \\<forall>(k, \\<gamma>)\\<in>(f(k, \\<gamma>)). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) assms ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "using f_props(2) k_eq_1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n  k = 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "using f_props(2) k_eq_neg1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = - 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = - (line_integral F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "using line_integral_on_reverse_path(1)  ass line_integral_exists_on_chain1\n                valid_subdiv_imp_valid_one_chain[OF chain1_eq_chain2 boundary_chain1 boundary_chain2 valid_path]"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "by force"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k::int, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_neg1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n  k = - 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>", "show \"(k, \\<gamma>) \\<in> {(k'::int, \\<gamma>'). k' * line_integral F basis \\<gamma>' = 0}\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. (k, \\<gamma>)\n    \\<in> {(x, \\<gamma>').\n           real_of_int x * line_integral F basis \\<gamma>' = 0}", "using zero_line_integral"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. (k, \\<gamma>)\n    \\<in> {(x, \\<gamma>').\n           real_of_int x * line_integral F basis \\<gamma>' = 0}", "by auto"], ["proof (state)\nthis:\n  (k, \\<gamma>)\n  \\<in> {(x, \\<gamma>').\n         real_of_int x * line_integral F basis \\<gamma>' = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}", "have ii:\"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                          (\\<Sum>one_chain \\<in> (f ` (one_chain1)). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have \"\\<And>one_chain. one_chain \\<in> (f ` (one_chain1)) - (f ` (one_chain1 - {p. f p = {}})) \\<Longrightarrow>\n                                                         one_chain_line_integral F basis one_chain = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "fix one_chain"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "assume \"one_chain \\<in> (f ` (one_chain1)) - (f ` (one_chain1 - {p. f p = {}}))\""], ["proof (state)\nthis:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "then"], ["proof (chain)\npicking this:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})", "show \"one_chain_line_integral F basis one_chain = 0\""], ["proof (prove)\nusing this:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain = 0", "by (auto simp add: one_chain_line_integral_def)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0", "have 0:\"(\\<Sum>one_chain \\<in> f ` (one_chain1) - (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain)\n                                                       = 0\""], ["proof (prove)\nusing this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0", "using comm_monoid_add_class.sum.neutral"], ["proof (prove)\nusing this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n  \\<forall>x\\<in>?A. ?g x = (0::?'a) \\<Longrightarrow> sum ?g ?A = (0::?'a)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0", "have \"(\\<Sum>one_chain \\<in> f ` (one_chain1). one_chain_line_integral F basis one_chain)\n                                                      - (\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain)\n                                                       = 0\""], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0 \\<Longrightarrow>\n    sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "have finte: \"finite (f ` one_chain1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` one_chain1)", "using finite_chain1"], ["proof (prove)\nusing this:\n  finite one_chain1\n\ngoal (1 subgoal):\n 1. finite (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  finite (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0 \\<Longrightarrow>\n    sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "using Groups_Big.sum_diff[OF finte, of \" (f ` (one_chain1 - {p. f p = {}}))\"\n                  \"one_chain_line_integral F basis\"]\n                0"], ["proof (prove)\nusing this:\n  f ` (one_chain1 - {p. f p = {}})\n  \\<subseteq> f ` one_chain1 \\<Longrightarrow>\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}}))\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0", "show \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                          (\\<Sum>one_chain \\<in> (f ` (one_chain1)). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> (k::int) \\<gamma>. (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> (f (k, \\<gamma>) = {}) \\<Longrightarrow> f (k, \\<gamma>) \\<in> {chain. one_chain_line_integral F basis chain = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "fix k::\"int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "fix \\<gamma>::\"one_cube\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "assume ass:\"(k, \\<gamma>) \\<in> one_chain1\" \"(f (k, \\<gamma>) = {})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "show \"f (k, \\<gamma>) \\<in> {p'. (one_chain_line_integral F basis p' = 0)}\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. f (k, \\<gamma>) \\<in> {p'. one_chain_line_integral F basis p' = 0}", "by auto"], ["proof (state)\nthis:\n  f (k, \\<gamma>) \\<in> {p'. one_chain_line_integral F basis p' = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}", "have iii:\"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1 - {p. f p = {}}. k*(line_integral F basis \\<gamma>))\n                                                 = (\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "have \"\\<And> k \\<gamma>. (k,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}})\n                                                    \\<Longrightarrow> k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "assume ass: \"(k,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})", "have \"f(k, \\<gamma>) = {}\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. f (k, \\<gamma>) = {}", "by auto"], ["proof (state)\nthis:\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  f (k, \\<gamma>) = {}", "have \"one_chain_line_integral F basis (f(k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by (auto simp add: one_chain_line_integral_def)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "have zero_line_integral:\"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "have bchain: \"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) boundary_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  boundary_chain subdiv\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "have wexist: \"\\<forall>(k, \\<gamma>)\\<in>(f(k,\\<gamma>)). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "using f_props(1) line_integral_exists_on_chain2 ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "have vpath: \" \\<forall>(k, \\<gamma>)\\<in>(f(k, \\<gamma>)). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) assms ass"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "using f_props(2) k_eq_1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n  k = 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "using f_props(2) k_eq_neg1 line_integral_on_path_eq_line_integral_on_equiv_chain bchain wexist vpath ass finite_basis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  k = - 1\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain =\n                    line_integral ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<lbrakk>chain_subdiv_path ?\\<gamma> ?one_chain;\n   boundary_chain ?one_chain;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?one_chain. valid_path \\<gamma>;\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  boundary_chain (f (k, \\<gamma>))\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = - (line_integral F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "using line_integral_on_reverse_path(1)  ass line_integral_exists_on_chain1\n                  valid_subdiv_imp_valid_one_chain[OF chain1_eq_chain2 boundary_chain1 boundary_chain2 valid_path]"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "by force"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>", "show \"one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_neg1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n  k = - 1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>", "show \"k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. real_of_int k * line_integral F basis \\<gamma> = 0", "using zero_line_integral"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. real_of_int k * line_integral F basis \\<gamma> = 0", "by auto"], ["proof (state)\nthis:\n  real_of_int k * line_integral F basis \\<gamma> = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0", "have \"\\<forall>(k::int,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n                                                      k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma> = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0", "have \"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}). k*(line_integral F basis \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "using Groups_Big.comm_monoid_add_class.sum.neutral\n              [of \"one_chain1 - (one_chain1 - {p. f p = {}})\" \"(\\<lambda>(k::int,\\<gamma>). k* (line_integral F basis \\<gamma>))\"]"], ["proof (prove)\nusing this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n  \\<forall>x\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     (case x of\n      (x, \\<gamma>) \\<Rightarrow>\n        real_of_int x * line_integral F basis \\<gamma>) =\n     0 \\<Longrightarrow>\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0", "have \"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>)) -\n                     (\\<Sum>(k::int,\\<gamma>)\\<in> (one_chain1 - {p. f p = {}}). k*(line_integral F basis \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>) -\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "using Groups_Big.sum_diff[OF finite_chain1]"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n  ?B \\<subseteq> one_chain1 \\<Longrightarrow>\n  sum ?f (one_chain1 - ?B) = sum ?f one_chain1 - sum ?f ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>) -\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "by (metis (no_types) Diff_subset \\<open>(\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}). k * line_integral F basis \\<gamma>) = 0\\<close> \\<open>\\<And>f B. B \\<subseteq> one_chain1 \\<Longrightarrow> sum f (one_chain1 - B) = sum f one_chain1 - sum f B\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "using i ii iii"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "using 0 1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "using 0 1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis subdiv =\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1))\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis subdiv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_chain_line_integral_eq_line_integral_on_sudivision':\n  assumes chain1_eq_chain2: \"chain_subdiv_chain one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain1: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> subdiv. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv &&&\n    \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "obtain f where f_props:\n    \"((\\<Union>(f ` one_chain1)) = subdiv)\"\n    \"(\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = 1 then chain_subdiv_path \\<gamma> (f(k,\\<gamma>)) else chain_subdiv_path (reversepath \\<gamma>) (f(k,\\<gamma>)))\"\n    \"(\\<forall>p\\<in>one_chain1. \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {})\"\n    \"(\\<forall>x \\<in> one_chain1. finite (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain1_eq_chain2 chain_subdiv_chain_character"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain1 subdiv\n  chain_subdiv_chain ?one_chain1.0 ?subdiv =\n  (\\<exists>f.\n      \\<Union> (f ` ?one_chain1.0) = ?subdiv \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>?one_chain1.0.\n          if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n          else chain_subdiv_path (reversepath \\<gamma>)\n                (f (k, \\<gamma>))) \\<and>\n      (\\<forall>p\\<in>?one_chain1.0.\n          \\<forall>p'\\<in>?one_chain1.0.\n             p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n      (\\<forall>x\\<in>?one_chain1.0. finite (f x)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>));\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: pairwise_def chain_subdiv_chain_def)"], ["proof (state)\nthis:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "have finite_chain2: \"finite subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite subdiv", "using finite_chain1 f_props(1) f_props(4)"], ["proof (prove)\nusing this:\n  finite one_chain1\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. finite subdiv", "by blast"], ["proof (state)\nthis:\n  finite subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "have \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow> line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "assume ass: \"(k, \\<gamma>) \\<in> subdiv\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> subdiv\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> subdiv", "obtain k' \\<gamma>' where kp_gammap: \"(k',\\<gamma>') \\<in> one_chain1\" \"(k,\\<gamma>) \\<in> f(k',\\<gamma>')\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> subdiv\n\ngoal (1 subgoal):\n 1. (\\<And>k' \\<gamma>'.\n        \\<lbrakk>(k', \\<gamma>') \\<in> one_chain1;\n         (k, \\<gamma>) \\<in> f (k', \\<gamma>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f_props(1)"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> subdiv\n  \\<Union> (f ` one_chain1) = subdiv\n\ngoal (1 subgoal):\n 1. (\\<And>k' \\<gamma>'.\n        \\<lbrakk>(k', \\<gamma>') \\<in> one_chain1;\n         (k, \\<gamma>) \\<in> f (k', \\<gamma>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "proof (cases \"k' = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume k_eq_1: \"k' = 1\""], ["proof (state)\nthis:\n  k' = 1\n\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k' = 1", "have i:\"chain_subdiv_path \\<gamma>' (f(k',\\<gamma>'))\""], ["proof (prove)\nusing this:\n  k' = 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma>' (f (k', \\<gamma>'))", "using f_props(2) kp_gammap ass"], ["proof (prove)\nusing this:\n  k' = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n  (k, \\<gamma>) \\<in> subdiv\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma>' (f (k', \\<gamma>'))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path \\<gamma>' (f (k', \\<gamma>'))\n\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have ii:\"boundary_chain (f(k',\\<gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k', \\<gamma>'))", "using f_props(1) ass assms kp_gammap"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k', \\<gamma>'))", "by (meson UN_I boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k', \\<gamma>'))\n\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have iii:\"line_integral_exists F basis \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>'", "using assms kp_gammap"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>'", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>'\n\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>", "using f_props(1) ass assms kp_gammap"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k' = 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>\n 2. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_on_path_eq_line_integral_on_equiv_chain'(2)[OF i ii iii iv finite_basis] kp_gammap"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>').\n     line_integral_exists F basis \\<gamma>\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "assume \"k' \\<noteq> 1\""], ["proof (state)\nthis:\n  k' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k' \\<noteq> 1", "have k_eq_neg1: \"k' = -1\""], ["proof (prove)\nusing this:\n  k' \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k' = - 1", "using boundary_chain1 kp_gammap"], ["proof (prove)\nusing this:\n  k' \\<noteq> 1\n  boundary_chain one_chain1\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. k' = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k' = - 1\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k' = - 1", "have i:\"chain_subdiv_path (reversepath \\<gamma>') (f(k',\\<gamma>'))\""], ["proof (prove)\nusing this:\n  k' = - 1\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>') (f (k', \\<gamma>'))", "using f_props(2) kp_gammap"], ["proof (prove)\nusing this:\n  k' = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>') (f (k', \\<gamma>'))", "by auto"], ["proof (state)\nthis:\n  chain_subdiv_path (reversepath \\<gamma>') (f (k', \\<gamma>'))\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have ii:\"boundary_chain (f(k',\\<gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k', \\<gamma>'))", "using f_props(1) assms kp_gammap"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k', \\<gamma>'))", "by (meson UN_I boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (f (k', \\<gamma>'))\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have iii: \" \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>", "using f_props(1) ass assms kp_gammap"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>'). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have iv: \"valid_path (reversepath \\<gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>')", "using valid_path_equiv_valid_chain_list[OF i ii iii]"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>')\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>')", "by force"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>')\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "have \"line_integral_exists F basis \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>'", "using assms kp_gammap"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>'", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>'\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis \\<gamma>'", "have x: \"line_integral_exists F basis (reversepath \\<gamma>')\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>'\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>')", "using iv line_integral_on_reverse_path(2) valid_path_reversepath"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>'\n  valid_path (reversepath \\<gamma>')\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  valid_path (reversepath ?g) = valid_path ?g\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>')", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>')\n\ngoal (1 subgoal):\n 1. k' \\<noteq> 1 \\<Longrightarrow> line_integral_exists F basis \\<gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using line_integral_on_path_eq_line_integral_on_equiv_chain'(2)[OF i ii x iii finite_basis] kp_gammap"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>f (k', \\<gamma>').\n     line_integral_exists F basis \\<gamma>\n  (k', \\<gamma>') \\<in> one_chain1\n  (k, \\<gamma>) \\<in> f (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\""], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "using one_chain_line_integral_eq_line_integral_on_sudivision(1) assms"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<lbrakk>chain_subdiv_chain ?one_chain1.0 ?subdiv;\n   boundary_chain ?one_chain1.0; boundary_chain ?subdiv;\n   \\<forall>(k, \\<gamma>)\\<in>?subdiv.\n      line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>?subdiv. valid_path \\<gamma>;\n   finite ?one_chain1.0; finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis ?one_chain1.0 =\n                    one_chain_line_integral ?F ?basis ?subdiv\n  chain_subdiv_chain one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis subdiv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_sum_gen:\n  assumes finite_basis:\n    \"finite basis\" and\n    line_integral_exists:\n    \"line_integral_exists F basis1 \\<gamma>\"\n    \"line_integral_exists F basis2 \\<gamma>\" and\n    basis_partition:\n    \"basis1 \\<union> basis2 = basis\" \"basis1 \\<inter> basis2 = {}\"\n  shows \"line_integral F basis \\<gamma> = (line_integral F  basis1 \\<gamma>) + (line_integral F basis2 \\<gamma>)\"\n    \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    line_integral F basis1 \\<gamma> + line_integral F basis2 \\<gamma> &&&\n    line_integral_exists F basis \\<gamma>", "apply (simp add: line_integral_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n 2. line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n 2. line_integral_exists F basis \\<gamma>", "have 0: \"integral {0..1} (\\<lambda>x. (\\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                                       (\\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))) =\n                    integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                           integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         (\\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n         (\\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n             b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "using Henstock_Kurzweil_Integration.integral_add line_integral_exists"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f integrable_on ?S; ?g integrable_on ?S\\<rbrakk>\n  \\<Longrightarrow> integral ?S (\\<lambda>x. ?f x + ?g x) =\n                    integral ?S ?f + integral ?S ?g\n  line_integral_exists F basis1 \\<gamma>\n  line_integral_exists F basis2 \\<gamma>\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         (\\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n         (\\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n             b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "by (auto simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n 2. line_integral_exists F basis \\<gamma>", "have 1: \"integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n                       integral {0..1} (\\<lambda>x. (\\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                                            (\\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         (\\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n         (\\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))", "by (metis (mono_tags, lifting) basis_partition finite_Un finite_basis sum.union_disjoint)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n\ngoal (2 subgoals):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n 2. line_integral_exists F basis \\<gamma>", "show \"integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n                  integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                  integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "using 0 1"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n    integral {0..1}\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n  integral {0..1}\n   (\\<lambda>x.\n       \\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "have 2: \"((\\<lambda>x. (\\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                                       (\\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))) has_integral\n                    integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                           integral {0..1} (\\<lambda>x. \\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (\\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n         (\\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n             b))) has_integral\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using Henstock_Kurzweil_Integration.has_integral_add line_integral_exists has_integral_integral"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?f has_integral ?k) ?S; (?g has_integral ?l) ?S\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?f x + ?g x) has_integral ?k + ?l) ?S\n  line_integral_exists F basis1 \\<gamma>\n  line_integral_exists F basis2 \\<gamma>\n  (?f integrable_on ?s) = (?f has_integral integral ?s ?f) ?s\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (\\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n         (\\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n             b))) has_integral\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis1.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis2.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "apply (auto simp add: line_integral_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f k S g l.\n                \\<lbrakk>(f has_integral k) S; (g has_integral l) S\\<rbrakk>\n                \\<Longrightarrow> ((\\<lambda>x. f x + g x) has_integral\n                                   k + l)\n                                   S;\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {0..1};\n     (\\<lambda>x.\n         \\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n            b)) integrable_on\n     {0..1};\n     \\<And>f s.\n        (f integrable_on s) = (f has_integral integral s f) s\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x.\n                           (\\<Sum>b\\<in>basis1.\n                              F (\\<gamma> x) \\<bullet> b *\n                              (vector_derivative \\<gamma>\n                                (at x within {0..1}) \\<bullet>\n                               b)) +\n                           (\\<Sum>b\\<in>basis2.\n                              F (\\<gamma> x) \\<bullet> b *\n                              (vector_derivative \\<gamma>\n                                (at x within {0..1}) \\<bullet>\n                               b))) has_integral\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis1.\n                              F (\\<gamma> x) \\<bullet> b *\n                              (vector_derivative \\<gamma>\n                                (at x within {0..1}) \\<bullet>\n                               b)) +\n                       integral {0..1}\n                        (\\<lambda>x.\n                            \\<Sum>b\\<in>basis2.\n                              F (\\<gamma> x) \\<bullet> b *\n                              (vector_derivative \\<gamma>\n                                (at x within {0..1}) \\<bullet>\n                               b)))\n                       {0..1}", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n           b))) has_integral\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "have 3: \"(\\<lambda>x. \\<Sum>b\\<in>basis. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n                       (\\<lambda>x. (\\<Sum>b\\<in>basis1. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n                                            (\\<Sum>b\\<in>basis2. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>b\\<in>basis.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n    (\\<lambda>x.\n        (\\<Sum>b\\<in>basis1.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n        (\\<Sum>b\\<in>basis2.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))", "by (metis (mono_tags, lifting) basis_partition finite_Un finite_basis sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F (\\<gamma> x) \\<bullet> b *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  (\\<lambda>x.\n      (\\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n      (\\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "apply(auto simp add: line_integral_exists_def has_integral_integral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using 2 3"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n           b))) has_integral\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F (\\<gamma> x) \\<bullet> b *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  (\\<lambda>x.\n      (\\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n      (\\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using has_integral_integrable_integral"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       (\\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n       (\\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n           b))) has_integral\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis1.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n   integral {0..1}\n    (\\<lambda>x.\n        \\<Sum>b\\<in>basis2.\n          F (\\<gamma> x) \\<bullet> b *\n          (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  (\\<lambda>x.\n      \\<Sum>b\\<in>basis.\n        F (\\<gamma> x) \\<bullet> b *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) =\n  (\\<lambda>x.\n      (\\<Sum>b\\<in>basis1.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) +\n      (\\<Sum>b\\<in>basis2.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n  (?f has_integral ?i) ?s = (?f integrable_on ?s \\<and> integral ?s ?f = ?i)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         \\<Sum>b\\<in>basis.\n           F (\\<gamma> x) \\<bullet> b *\n           (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n            b)) has_integral\n     integral {0..1}\n      (\\<lambda>x.\n          \\<Sum>b\\<in>basis.\n            F (\\<gamma> x) \\<bullet> b *\n            (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition common_boundary_sudivision_exists where\n    \"common_boundary_sudivision_exists one_chain1 one_chain2 \\<equiv>\n             \\<exists>subdiv. chain_subdiv_chain one_chain1 subdiv \\<and>\n                      chain_subdiv_chain one_chain2 subdiv \\<and>\n                      (\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>)\\<and>\n                      boundary_chain subdiv\""], ["", "lemma common_boundary_sudivision_commutative:\n  \"(common_boundary_sudivision_exists one_chain1 one_chain2) = (common_boundary_sudivision_exists one_chain2 one_chain1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_boundary_sudivision_exists one_chain1 one_chain2 =\n    common_boundary_sudivision_exists one_chain2 one_chain1", "apply (simp add: common_boundary_sudivision_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>subdiv.\n        chain_subdiv_chain one_chain1 subdiv \\<and>\n        chain_subdiv_chain one_chain2 subdiv \\<and>\n        (\\<forall>x\\<in>subdiv.\n            case x of\n            (k, \\<gamma>) \\<Rightarrow> valid_path \\<gamma>) \\<and>\n        boundary_chain subdiv) =\n    (\\<exists>subdiv.\n        chain_subdiv_chain one_chain2 subdiv \\<and>\n        chain_subdiv_chain one_chain1 subdiv \\<and>\n        (\\<forall>x\\<in>subdiv.\n            case x of\n            (k, \\<gamma>) \\<Rightarrow> valid_path \\<gamma>) \\<and>\n        boundary_chain subdiv)", "by blast"], ["", "lemma common_subdivision_imp_eq_line_integral:\n  assumes \"(common_boundary_sudivision_exists one_chain1 one_chain2)\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"\n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "obtain subdiv where subdiv_props:\n    \"chain_subdiv_chain one_chain1 subdiv\"\n    \"chain_subdiv_chain one_chain2 subdiv\"\n    \"(\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>)\"\n    \"(boundary_chain subdiv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>subdiv.\n        \\<lbrakk>chain_subdiv_chain one_chain1 subdiv;\n         chain_subdiv_chain one_chain2 subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n         boundary_chain subdiv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  common_boundary_sudivision_exists one_chain1 one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  finite one_chain1\n  finite one_chain2\n  finite basis\n\ngoal (1 subgoal):\n 1. (\\<And>subdiv.\n        \\<lbrakk>chain_subdiv_chain one_chain1 subdiv;\n         chain_subdiv_chain one_chain2 subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n         boundary_chain subdiv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: common_boundary_sudivision_exists_def)"], ["proof (state)\nthis:\n  chain_subdiv_chain one_chain1 subdiv\n  chain_subdiv_chain one_chain2 subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  boundary_chain subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "have i: \"\\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "using one_chain_line_integral_eq_line_integral_on_sudivision'(2)[OF subdiv_props(1) assms(2) subdiv_props(4) assms(4) subdiv_props(3) assms(5) assms(7)]"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using one_chain_line_integral_eq_line_integral_on_sudivision'(1)[OF subdiv_props(1) assms(2) subdiv_props(4) assms(4) subdiv_props(3) assms(5) assms(7)]\n      one_chain_line_integral_eq_line_integral_on_sudivision(1)[OF subdiv_props(2) assms(3) subdiv_props(4) i subdiv_props(3) assms(6) assms(7)]"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis subdiv\n  one_chain_line_integral F basis one_chain2 =\n  one_chain_line_integral F basis subdiv\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "using one_chain_line_integral_eq_line_integral_on_sudivision(2)[OF subdiv_props(2) assms(3) subdiv_props(4) i subdiv_props(3) assms(6) assms(7)]"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition common_sudiv_exists where\n    \"common_sudiv_exists one_chain1 one_chain2 \\<equiv>\n        \\<exists>subdiv ps1 ps2. chain_subdiv_chain (one_chain1 - ps1) subdiv \\<and>\n                  chain_subdiv_chain (one_chain2 - ps2) subdiv \\<and>\n                  (\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>) \\<and>\n                  (boundary_chain subdiv) \\<and>\n                  (\\<forall>(k, \\<gamma>) \\<in> ps1. point_path \\<gamma>) \\<and>\n                  (\\<forall>(k, \\<gamma>) \\<in> ps2. point_path \\<gamma>)\""], ["", "lemma common_sudiv_exists_comm:\n  shows \"common_sudiv_exists C1 C2 = common_sudiv_exists C2 C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists C1 C2 = common_sudiv_exists C2 C1", "by (auto simp add: common_sudiv_exists_def)"], ["", "lemma line_integral_degenerate_chain:\n  assumes \"(\\<forall>(k, \\<gamma>) \\<in> chain. point_path \\<gamma>)\"\n  assumes \"finite basis\"\n  shows \"one_chain_line_integral F basis chain = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis chain = 0", "proof (simp add: one_chain_line_integral_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>chain.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n    0", "have \"\\<forall>(k,g)\\<in>chain. line_integral F basis g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, g)\\<in>chain. line_integral F basis g = 0", "using assms line_integral_point_path"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>chain. point_path \\<gamma>\n  finite basis\n  \\<lbrakk>point_path ?\\<gamma>; finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>(k, g)\\<in>chain. line_integral F basis g = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, g)\\<in>chain. line_integral F basis g = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>chain.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n    0", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, g)\\<in>chain. line_integral F basis g = 0", "have \"\\<forall>(k,g)\\<in>chain. real_of_int k * line_integral F basis g = 0\""], ["proof (prove)\nusing this:\n  \\<forall>(k, g)\\<in>chain. line_integral F basis g = 0\n\ngoal (1 subgoal):\n 1. \\<forall>(k, g)\\<in>chain. real_of_int k * line_integral F basis g = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, g)\\<in>chain. real_of_int k * line_integral F basis g = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>chain.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n    0", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, g)\\<in>chain. real_of_int k * line_integral F basis g = 0", "have \"\\<And>p. p \\<in> chain \\<Longrightarrow> (case p of (i, f) \\<Rightarrow> real_of_int i * line_integral F basis f) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>(k, g)\\<in>chain. real_of_int k * line_integral F basis g = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> chain \\<Longrightarrow>\n       (case p of\n        (i, f) \\<Rightarrow> real_of_int i * line_integral F basis f) =\n       0", "by fastforce"], ["proof (state)\nthis:\n  ?p \\<in> chain \\<Longrightarrow>\n  (case ?p of\n   (i, f) \\<Rightarrow> real_of_int i * line_integral F basis f) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>chain.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n    0", "then"], ["proof (chain)\npicking this:\n  ?p \\<in> chain \\<Longrightarrow>\n  (case ?p of\n   (i, f) \\<Rightarrow> real_of_int i * line_integral F basis f) =\n  0", "show \"(\\<Sum>x\\<in>chain. case x of (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) = 0\""], ["proof (prove)\nusing this:\n  ?p \\<in> chain \\<Longrightarrow>\n  (case ?p of\n   (i, f) \\<Rightarrow> real_of_int i * line_integral F basis f) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>chain.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n    0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>chain.\n     case x of\n     (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_common_subdiv_imp_common_subdiv:\n  shows \"(common_sudiv_exists one_chain1 one_chain2) = (\\<exists>ps1 ps2. (common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2)) \\<and> (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and> (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists one_chain1 one_chain2 =\n    (\\<exists>ps1 ps2.\n        common_boundary_sudivision_exists (one_chain1 - ps1)\n         (one_chain2 - ps2) \\<and>\n        (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n        (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))", "by (auto simp add: common_sudiv_exists_def common_boundary_sudivision_exists_def)"], ["", "lemma common_subdiv_imp_gen_common_subdiv:\n  assumes \"(common_boundary_sudivision_exists one_chain1 one_chain2)\"\n  shows \"(common_sudiv_exists one_chain1 one_chain2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists one_chain1 one_chain2", "using assms"], ["proof (prove)\nusing this:\n  common_boundary_sudivision_exists one_chain1 one_chain2\n\ngoal (1 subgoal):\n 1. common_sudiv_exists one_chain1 one_chain2", "apply (auto simp add: common_sudiv_exists_def common_boundary_sudivision_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>subdiv.\n       \\<lbrakk>chain_subdiv_chain one_chain1 subdiv;\n        chain_subdiv_chain one_chain2 subdiv;\n        \\<forall>x\\<in>subdiv.\n           case x of (k, \\<gamma>) \\<Rightarrow> valid_path \\<gamma>;\n        boundary_chain subdiv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>subdiv ps1.\n                            chain_subdiv_chain (one_chain1 - ps1)\n                             subdiv \\<and>\n                            (\\<exists>ps2.\n                                chain_subdiv_chain (one_chain2 - ps2)\n                                 subdiv \\<and>\n                                (\\<forall>x\\<in>subdiv.\n                                    case x of\n                                    (k, x) \\<Rightarrow>\nvalid_path x) \\<and>\n                                boundary_chain subdiv \\<and>\n                                (\\<forall>x\\<in>ps1.\n                                    case x of\n                                    (k, x) \\<Rightarrow>\npoint_path x) \\<and>\n                                (\\<forall>x\\<in>ps2.\n                                    case x of\n                                    (k, x) \\<Rightarrow> point_path x))", "by (metis Diff_empty all_not_in_conv)"], ["", "lemma one_chain_line_integral_point_paths:\n  assumes \"finite one_chain\"\n  assumes \"finite basis\"\n  assumes \"(\\<forall>(k, \\<gamma>)\\<in>ps. point_path \\<gamma>)\"\n  shows \"one_chain_line_integral F basis (one_chain - ps) = one_chain_line_integral F basis (one_chain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain - ps) =\n    one_chain_line_integral F basis one_chain", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain - ps) =\n    one_chain_line_integral F basis one_chain", "have 0:\"(\\<forall>x\\<in>ps. case x of (k, g) \\<Rightarrow>  (real_of_int k * line_integral F basis g) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ps.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g = 0", "using line_integral_point_path assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>point_path ?\\<gamma>; finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> = 0\n  finite one_chain\n  finite basis\n  \\<forall>(k, \\<gamma>)\\<in>ps. point_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ps.\n       case x of\n       (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g = 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>ps.\n     case x of\n     (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g = 0\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain - ps) =\n    one_chain_line_integral F basis one_chain", "show \"one_chain_line_integral F basis (one_chain - ps) = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain - ps) =\n    one_chain_line_integral F basis one_chain", "unfolding one_chain_line_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(k, g)\\<in>one_chain - ps.\n       real_of_int k * line_integral F basis g) =\n    (\\<Sum>(k, g)\\<in>one_chain. real_of_int k * line_integral F basis g)", "using 0 \\<open>finite one_chain\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>ps.\n     case x of\n     (k, g) \\<Rightarrow> real_of_int k * line_integral F basis g = 0\n  finite one_chain\n\ngoal (1 subgoal):\n 1. (\\<Sum>(k, g)\\<in>one_chain - ps.\n       real_of_int k * line_integral F basis g) =\n    (\\<Sum>(k, g)\\<in>one_chain. real_of_int k * line_integral F basis g)", "by (force simp add:  intro: comm_monoid_add_class.sum.mono_neutral_left)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (one_chain - ps) =\n  one_chain_line_integral F basis one_chain\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma boundary_chain_diff:\n  assumes \"boundary_chain one_chain\"\n  shows \"boundary_chain (one_chain - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (one_chain - s)", "using assms"], ["proof (prove)\nusing this:\n  boundary_chain one_chain\n\ngoal (1 subgoal):\n 1. boundary_chain (one_chain - s)", "by (auto simp add: boundary_chain_def)"], ["", "lemma gen_common_subdivision_imp_eq_line_integral:\n  assumes \"(common_sudiv_exists one_chain1 one_chain2)\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\"\n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"finite basis\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "obtain ps1 ps2 where gen_subdiv: \"(common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2))\" \"(\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>)\" \" (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps1 ps2.\n        \\<lbrakk>common_boundary_sudivision_exists (one_chain1 - ps1)\n                  (one_chain2 - ps2);\n         \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>;\n         \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) gen_common_subdiv_imp_common_subdiv"], ["proof (prove)\nusing this:\n  common_sudiv_exists one_chain1 one_chain2\n  common_sudiv_exists ?one_chain1.0 ?one_chain2.0 =\n  (\\<exists>ps1 ps2.\n      common_boundary_sudivision_exists (?one_chain1.0 - ps1)\n       (?one_chain2.0 - ps2) \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))\n\ngoal (1 subgoal):\n 1. (\\<And>ps1 ps2.\n        \\<lbrakk>common_boundary_sudivision_exists (one_chain1 - ps1)\n                  (one_chain2 - ps2);\n         \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>;\n         \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2)\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using one_chain_line_integral_point_paths gen_common_subdiv_imp_common_subdiv\n      assms(2-7) gen_subdiv\n      common_subdivision_imp_eq_line_integral(1)[OF gen_subdiv(1) boundary_chain_diff[OF assms(2)] boundary_chain_diff[OF assms(3)]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?one_chain; finite ?basis;\n   \\<forall>(k, \\<gamma>)\\<in>?ps. point_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis (?one_chain - ?ps) =\n                    one_chain_line_integral ?F ?basis ?one_chain\n  common_sudiv_exists ?one_chain1.0 ?one_chain2.0 =\n  (\\<exists>ps1 ps2.\n      common_boundary_sudivision_exists (?one_chain1.0 - ps1)\n       (?one_chain2.0 - ps2) \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n      (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  finite one_chain1\n  finite one_chain2\n  finite basis\n  common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2)\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n              line_integral_exists ?F ?basis \\<gamma>;\n   finite (one_chain1 - ps1); finite (one_chain2 - ps2);\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis (one_chain1 - ps1) =\n                    one_chain_line_integral ?F ?basis (one_chain2 - ps2)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "obtain subdiv where subdiv_props:\n      \"chain_subdiv_chain (one_chain1-ps1) subdiv\"\n      \"chain_subdiv_chain (one_chain2-ps2) subdiv\"\n      \"(\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>)\"\n      \"(boundary_chain subdiv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>subdiv.\n        \\<lbrakk>chain_subdiv_chain (one_chain1 - ps1) subdiv;\n         chain_subdiv_chain (one_chain2 - ps2) subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n         boundary_chain subdiv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gen_subdiv(1)"], ["proof (prove)\nusing this:\n  common_boundary_sudivision_exists (one_chain1 - ps1) (one_chain2 - ps2)\n\ngoal (1 subgoal):\n 1. (\\<And>subdiv.\n        \\<lbrakk>chain_subdiv_chain (one_chain1 - ps1) subdiv;\n         chain_subdiv_chain (one_chain2 - ps2) subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n         boundary_chain subdiv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: common_boundary_sudivision_exists_def)"], ["proof (state)\nthis:\n  chain_subdiv_chain (one_chain1 - ps1) subdiv\n  chain_subdiv_chain (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  boundary_chain subdiv\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "have \"\\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "using one_chain_line_integral_eq_line_integral_on_sudivision'(2)[OF subdiv_props(1) boundary_chain_diff[OF assms(2)] subdiv_props(4)] assms(4) subdiv_props(3) assms(5) assms(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n              line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n   finite (one_chain1 - ps1); finite ?basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(k, \\<gamma>)\\<in>subdiv.\n                       line_integral_exists ?F ?basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>", "have i: \"\\<forall>(k, \\<gamma>)\\<in>one_chain2-ps2. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n       line_integral_exists F basis \\<gamma>", "using one_chain_line_integral_eq_line_integral_on_sudivision(2)[OF subdiv_props(2) boundary_chain_diff[OF assms(3)] subdiv_props(4)] subdiv_props(3) assms(6) assms(7)"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F basis \\<gamma>\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>subdiv.\n              line_integral_exists ?F ?basis \\<gamma>;\n   \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>;\n   finite (one_chain2 - ps2); finite ?basis\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n                       line_integral_exists ?F ?basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  finite one_chain2\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "using  gen_subdiv(3) line_integral_exists_point_path[OF assms(7)]"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  point_path ?\\<gamma> \\<Longrightarrow>\n  line_integral_exists ?F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma common_sudiv_exists_refl:\n      assumes \"common_sudiv_exists C1 C2\"\n      shows \"common_sudiv_exists C2 C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists C2 C1", "using assms"], ["proof (prove)\nusing this:\n  common_sudiv_exists C1 C2\n\ngoal (1 subgoal):\n 1. common_sudiv_exists C2 C1", "apply(simp add: common_sudiv_exists_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>subdiv ps1.\n       chain_subdiv_chain (C1 - ps1) subdiv \\<and>\n       (\\<exists>ps2.\n           chain_subdiv_chain (C2 - ps2) subdiv \\<and>\n           (\\<forall>x\\<in>subdiv.\n               case x of (k, x) \\<Rightarrow> valid_path x) \\<and>\n           boundary_chain subdiv \\<and>\n           (\\<forall>x\\<in>ps1.\n               case x of (k, x) \\<Rightarrow> point_path x) \\<and>\n           (\\<forall>x\\<in>ps2.\n               case x of\n               (k, x) \\<Rightarrow> point_path x)) \\<Longrightarrow>\n    \\<exists>subdiv ps1.\n       chain_subdiv_chain (C2 - ps1) subdiv \\<and>\n       (\\<exists>ps2.\n           chain_subdiv_chain (C1 - ps2) subdiv \\<and>\n           (\\<forall>x\\<in>subdiv.\n               case x of (k, x) \\<Rightarrow> valid_path x) \\<and>\n           boundary_chain subdiv \\<and>\n           (\\<forall>x\\<in>ps1.\n               case x of (k, x) \\<Rightarrow> point_path x) \\<and>\n           (\\<forall>x\\<in>ps2.\n               case x of (k, x) \\<Rightarrow> point_path x))", "by auto"], ["", "lemma chain_subdiv_path_singleton:\n  shows \"chain_subdiv_path \\<gamma> {(1,\\<gamma>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> {(1, \\<gamma>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> {(1, \\<gamma>)}", "have \"rec_join [(1,\\<gamma>)] = \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join [(1, \\<gamma>)] = \\<gamma>", "by (simp add: joinpaths_def)"], ["proof (state)\nthis:\n  rec_join [(1, \\<gamma>)] = \\<gamma>\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> {(1, \\<gamma>)}", "then"], ["proof (chain)\npicking this:\n  rec_join [(1, \\<gamma>)] = \\<gamma>", "have \"set [(1,\\<gamma>)] = {(1, \\<gamma>)}\" \"distinct [(1,\\<gamma>)]\" \"rec_join [(1,\\<gamma>)] = \\<gamma>\" \"valid_chain_list [(1,\\<gamma>)]\""], ["proof (prove)\nusing this:\n  rec_join [(1, \\<gamma>)] = \\<gamma>\n\ngoal (1 subgoal):\n 1. (set [(1::'a, \\<gamma>)] = {(1::'a, \\<gamma>)} &&&\n     distinct [(1::'b, \\<gamma>)]) &&&\n    rec_join [(1, \\<gamma>)] = \\<gamma> &&& valid_chain_list [(1, \\<gamma>)]", "by auto"], ["proof (state)\nthis:\n  set [(1::?'a, \\<gamma>)] = {(1::?'a, \\<gamma>)}\n  distinct [(1::?'b, \\<gamma>)]\n  rec_join [(1, \\<gamma>)] = \\<gamma>\n  valid_chain_list [(1, \\<gamma>)]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> {(1, \\<gamma>)}", "then"], ["proof (chain)\npicking this:\n  set [(1::?'a, \\<gamma>)] = {(1::?'a, \\<gamma>)}\n  distinct [(1::?'b, \\<gamma>)]\n  rec_join [(1, \\<gamma>)] = \\<gamma>\n  valid_chain_list [(1, \\<gamma>)]", "show ?thesis"], ["proof (prove)\nusing this:\n  set [(1::?'a, \\<gamma>)] = {(1::?'a, \\<gamma>)}\n  distinct [(1::?'b, \\<gamma>)]\n  rec_join [(1, \\<gamma>)] = \\<gamma>\n  valid_chain_list [(1, \\<gamma>)]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path \\<gamma> {(1, \\<gamma>)}", "by (metis (no_types) chain_subdiv_path.intros)"], ["proof (state)\nthis:\n  chain_subdiv_path \\<gamma> {(1, \\<gamma>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_subdiv_path_singleton_reverse:\n  shows \"chain_subdiv_path (reversepath \\<gamma>) {(-1,\\<gamma>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "have \"rec_join [(-1,\\<gamma>)] = reversepath \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>", "by (simp add: joinpaths_def)"], ["proof (state)\nthis:\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "then"], ["proof (chain)\npicking this:\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>", "have \"set [(-1,\\<gamma>)] = {(- 1, \\<gamma>)}\" \"distinct [(-1,\\<gamma>)]\" \n             \"rec_join [(-1,\\<gamma>)] = reversepath \\<gamma>\" \"valid_chain_list [(-1,\\<gamma>)]\""], ["proof (prove)\nusing this:\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n\ngoal (1 subgoal):\n 1. (set [(- (1::'a), \\<gamma>)] = {(- (1::'a), \\<gamma>)} &&&\n     distinct [(- (1::'b), \\<gamma>)]) &&&\n    rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma> &&&\n    valid_chain_list [(- 1, \\<gamma>)]", "by auto"], ["proof (state)\nthis:\n  set [(- (1::?'a), \\<gamma>)] = {(- (1::?'a), \\<gamma>)}\n  distinct [(- (1::?'b), \\<gamma>)]\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n  valid_chain_list [(- 1, \\<gamma>)]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "then"], ["proof (chain)\npicking this:\n  set [(- (1::?'a), \\<gamma>)] = {(- (1::?'a), \\<gamma>)}\n  distinct [(- (1::?'b), \\<gamma>)]\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n  valid_chain_list [(- 1, \\<gamma>)]", "have \"chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])\""], ["proof (prove)\nusing this:\n  set [(- (1::?'a), \\<gamma>)] = {(- (1::?'a), \\<gamma>)}\n  distinct [(- (1::?'b), \\<gamma>)]\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n  valid_chain_list [(- 1, \\<gamma>)]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])", "using chain_subdiv_path.intros"], ["proof (prove)\nusing this:\n  set [(- (1::?'a), \\<gamma>)] = {(- (1::?'a), \\<gamma>)}\n  distinct [(- (1::?'b), \\<gamma>)]\n  rec_join [(- 1, \\<gamma>)] = reversepath \\<gamma>\n  valid_chain_list [(- 1, \\<gamma>)]\n  \\<lbrakk>distinct ?l; rec_join ?l = ?\\<gamma>;\n   valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> chain_subdiv_path ?\\<gamma> (set ?l)\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])", "by blast"], ["proof (state)\nthis:\n  chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "then"], ["proof (chain)\npicking this:\n  chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])", "show ?thesis"], ["proof (prove)\nusing this:\n  chain_subdiv_path (reversepath \\<gamma>) (set [(- 1, \\<gamma>)])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}", "by simp"], ["proof (state)\nthis:\n  chain_subdiv_path (reversepath \\<gamma>) {(- 1, \\<gamma>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_subdiv_chain_refl:\n  assumes \"boundary_chain C\"\n  shows \"chain_subdiv_chain C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_chain C C", "using chain_subdiv_path_singleton chain_subdiv_path_singleton_reverse assms"], ["proof (prove)\nusing this:\n  chain_subdiv_path ?\\<gamma> {(1, ?\\<gamma>)}\n  chain_subdiv_path (reversepath ?\\<gamma>) {(- 1, ?\\<gamma>)}\n  boundary_chain C\n\ngoal (1 subgoal):\n 1. chain_subdiv_chain C C", "unfolding chain_subdiv_chain_def boundary_chain_def pairwise_def"], ["proof (prove)\nusing this:\n  chain_subdiv_path ?\\<gamma> {(1, ?\\<gamma>)}\n  chain_subdiv_path (reversepath ?\\<gamma>) {(- 1, ?\\<gamma>)}\n  \\<forall>(k, \\<gamma>)\\<in>C. k = 1 \\<or> k = - 1\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union> (f ` C) = C \\<and>\n       (\\<forall>c\\<in>C.\n           chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n       (\\<forall>x\\<in>C.\n           \\<forall>y\\<in>C.\n              x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {}) \\<and>\n       (\\<forall>x\\<in>C. finite (f x))", "using case_prodI2 coeff_cube_to_path.simps"], ["proof (prove)\nusing this:\n  chain_subdiv_path ?\\<gamma> {(1, ?\\<gamma>)}\n  chain_subdiv_path (reversepath ?\\<gamma>) {(- 1, ?\\<gamma>)}\n  \\<forall>(k, \\<gamma>)\\<in>C. k = 1 \\<or> k = - 1\n  (\\<And>a b. ?p = (a, b) \\<Longrightarrow> ?c a b) \\<Longrightarrow>\n  case ?p of (a, b) \\<Rightarrow> ?c a b\n  coeff_cube_to_path (?k, ?\\<gamma>) =\n  (if ?k = 1 then ?\\<gamma> else reversepath ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union> (f ` C) = C \\<and>\n       (\\<forall>c\\<in>C.\n           chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n       (\\<forall>x\\<in>C.\n           \\<forall>y\\<in>C.\n              x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {}) \\<and>\n       (\\<forall>x\\<in>C. finite (f x))", "by (rule_tac x=\"\\<lambda>x. {x}\" in exI) auto"], ["", "(*path reparam_weaketrization*)"], ["", "definition reparam_weak where\n  \"reparam_weak \\<gamma>1 \\<gamma>2 \\<equiv> \\<exists>\\<phi>. (\\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 o \\<phi>) x) \\<and> \\<phi> piecewise_C1_differentiable_on {0..1} \\<and> \\<phi>(0) = 0 \\<and> \\<phi>(1) = 1 \\<and> \\<phi> ` {0..1} = {0..1}\""], ["", "definition reparam where\n  \"reparam \\<gamma>1 \\<gamma>2 \\<equiv> \\<exists>\\<phi>. (\\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 o \\<phi>) x) \\<and> \\<phi> piecewise_C1_differentiable_on {0..1} \\<and> \\<phi>(0) = 0 \\<and> \\<phi>(1) = 1 \\<and> bij_betw \\<phi> {0..1} {0..1} \\<and> \\<phi> -` {0..1} \\<subseteq> {0..1} \\<and> (\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}))\""], ["", "lemma reparam_weak_eq_refl:\n  shows \"reparam_weak \\<gamma>1 \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 \\<gamma>1", "unfolding reparam_weak_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>x\\<in>{0..1}.\n           \\<gamma>1 x = (\\<gamma>1 \\<circ> \\<phi>) x) \\<and>\n       \\<phi> piecewise_C1_differentiable_on {0..1} \\<and>\n       \\<phi> 0 = 0 \\<and> \\<phi> 1 = 1 \\<and> \\<phi> ` {0..1} = {0..1}", "apply (rule_tac x=\"id\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>1 \\<circ> id) x) \\<and>\n    id piecewise_C1_differentiable_on {0..1} \\<and>\n    id 0 = 0 \\<and> id 1 = 1 \\<and> id ` {0..1} = {0..1}", "by (auto simp add: id_def piecewise_C1_differentiable_on_def C1_differentiable_on_def continuous_on_id)"], ["", "lemma line_integral_exists_smooth_one_base:\n  assumes \"\\<gamma> C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    \"continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "have gamma2_differentiable: \"(\\<forall>x \\<in> {0 .. 1}. \\<gamma> differentiable at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<gamma> C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "by (auto simp add: valid_path_def C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x", "have gamma2_b_component_differentiable: \"(\\<forall>x \\<in> {0 .. 1}. (\\<lambda>x. (\\<gamma> x) \\<bullet> b) differentiable at x)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable at x\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable at x", "have \"(\\<lambda>x. (\\<gamma> x) \\<bullet> b) differentiable_on {0..1}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}", "using differentiable_at_withinI"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  ?f differentiable at ?x within ?s\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}", "by (auto simp add: differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}", "have gama2_cont_comp: \"continuous_on {0..1} (\\<lambda>x. (\\<gamma> x) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. \\<gamma> x \\<bullet> b)", "using differentiable_imp_continuous_on"], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma> x \\<bullet> b) differentiable_on {0..1}\n  ?f differentiable_on ?s \\<Longrightarrow> continuous_on ?s ?f\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. \\<gamma> x \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. \\<gamma> x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "have gamma2_cont:\"continuous_on {0..1} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<gamma>", "using assms(1) C1_differentiable_imp_continuous_on"], ["proof (prove)\nusing this:\n  \\<gamma> C1_differentiable_on {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow> continuous_on ?S ?f\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<gamma>", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "have iii: \"continuous_on {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "have 0: \"continuous_on {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> b)", "using assms(2) continuous_on_compose[OF gamma2_cont]"], ["proof (prove)\nusing this:\n  continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n  continuous_on (\\<gamma> ` {0..1}) ?g \\<Longrightarrow>\n  continuous_on {0..1} (?g \\<circ> \\<gamma>)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> b)", "by (auto simp add: path_image_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. F (\\<gamma> x) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "obtain D where D: \"(\\<forall>x\\<in>{0..1}. (\\<gamma> has_vector_derivative D x) (at x)) \\<and> continuous_on {0..1} D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D.\n        (\\<forall>x\\<in>{0..1}.\n            (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n        continuous_on {0..1} D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<gamma> C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        (\\<forall>x\\<in>{0..1}.\n            (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n        continuous_on {0..1} D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: C1_differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D", "have *:\"\\<forall>x\\<in>{0..1}. vector_derivative \\<gamma> (at x within{0..1}) = D x\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative \\<gamma> (at x within {0..1}) = D x", "using vector_derivative_at vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  vector_derivative ?f (at ?x) = ?f'\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative \\<gamma> (at x within {0..1}) = D x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma> (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma> (at x within {0..1}) = D x", "have \"continuous_on {0..1} (\\<lambda>x. vector_derivative \\<gamma> (at x within{0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma> (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "using continuous_on_eq D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma> (at x within {0..1}) = D x\n  \\<lbrakk>continuous_on ?s ?f;\n   \\<And>x. x \\<in> ?s \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s ?g\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma> has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "by force"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))", "have 1: \"continuous_on {0..1} (\\<lambda>x. (vector_derivative \\<gamma> (at x within{0..1})) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)", "by(auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "using continuous_on_mult[OF 0 1]"], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma> x) \\<bullet> b *\n         (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))", "have \"(\\<lambda>x. F (\\<gamma> x) \\<bullet> b * (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> b *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "using integrable_continuous_real"], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma> x) \\<bullet> b *\n       (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet> b))\n  continuous_on {?a..?b} ?f \\<Longrightarrow> ?f integrable_on {?a..?b}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma> x) \\<bullet> b *\n        (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> b *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> b *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}", "show \"line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      F (\\<gamma> x) \\<bullet> b *\n      (vector_derivative \\<gamma> (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "by(auto simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  line_integral_exists F {b} \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contour_integral_primitive_lemma:\n  fixes f :: \"complex \\<Rightarrow> complex\" and g :: \"real \\<Rightarrow> complex\"\n  assumes \"a \\<le> b\"\n      and \"\\<And>x. x \\<in> s \\<Longrightarrow> (f has_field_derivative f' x) (at x within s)\"\n      and \"g piecewise_differentiable_on {a..b}\"  \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> g x \\<in> s\"\n    shows \"((\\<lambda>x. f'(g x) * vector_derivative g (at x within {a..b}))\n             has_integral (f(g b) - f(g a))) {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "obtain k where k: \"finite k\" \"\\<forall>x\\<in>{a..b} - k. g differentiable (at x within {a..b})\" and cg: \"continuous_on {a..b} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         \\<forall>x\\<in>{a..b} - k. g differentiable at x within {a..b};\n         continuous_on {a..b} g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> b\n  ?x \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?x) (at ?x within s)\n  g piecewise_differentiable_on {a..b}\n  ?x \\<in> {a..b} \\<Longrightarrow> g ?x \\<in> s\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         \\<forall>x\\<in>{a..b} - k. g differentiable at x within {a..b};\n         continuous_on {a..b} g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: piecewise_differentiable_on_def)"], ["proof (state)\nthis:\n  finite k\n  \\<forall>x\\<in>{a..b} - k. g differentiable at x within {a..b}\n  continuous_on {a..b} g\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "have cfg: \"continuous_on {a..b} (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (\\<lambda>x. f (g x))", "apply (rule continuous_on_compose [OF cg, unfolded o_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (g ` {a..b}) f", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> b\n  ?x \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?x) (at ?x within s)\n  g piecewise_differentiable_on {a..b}\n  ?x \\<in> {a..b} \\<Longrightarrow> g ?x \\<in> s\n\ngoal (1 subgoal):\n 1. continuous_on (g ` {a..b}) f", "apply (metis field_differentiable_def field_differentiable_imp_continuous_at continuous_on_eq_continuous_within continuous_on_subset image_subset_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  continuous_on {a..b} (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "{"], ["proof (state)\nthis:\n  continuous_on {a..b} (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "assume a: \"a < x\" and b: \"x < b\" and xk: \"x \\<notin> k\""], ["proof (state)\nthis:\n  a < x\n  x < b\n  x \\<notin> k\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "then"], ["proof (chain)\npicking this:\n  a < x\n  x < b\n  x \\<notin> k", "have \"g differentiable at x within {a..b}\""], ["proof (prove)\nusing this:\n  a < x\n  x < b\n  x \\<notin> k\n\ngoal (1 subgoal):\n 1. g differentiable at x within {a..b}", "using k"], ["proof (prove)\nusing this:\n  a < x\n  x < b\n  x \\<notin> k\n  finite k\n  \\<forall>x\\<in>{a..b} - k. g differentiable at x within {a..b}\n\ngoal (1 subgoal):\n 1. g differentiable at x within {a..b}", "by (simp add: differentiable_at_withinI)"], ["proof (state)\nthis:\n  g differentiable at x within {a..b}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "then"], ["proof (chain)\npicking this:\n  g differentiable at x within {a..b}", "have \"(g has_vector_derivative vector_derivative g (at x within {a..b})) (at x within {a..b})\""], ["proof (prove)\nusing this:\n  g differentiable at x within {a..b}\n\ngoal (1 subgoal):\n 1. (g has_vector_derivative vector_derivative g (at x within {a..b}))\n     (at x within {a..b})", "by (simp add: vector_derivative_works has_field_derivative_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (g has_vector_derivative vector_derivative g (at x within {a..b}))\n   (at x within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "then"], ["proof (chain)\npicking this:\n  (g has_vector_derivative vector_derivative g (at x within {a..b}))\n   (at x within {a..b})", "have gdiff: \"(g has_derivative (\\<lambda>u. u * vector_derivative g (at x within {a..b}))) (at x within {a..b})\""], ["proof (prove)\nusing this:\n  (g has_vector_derivative vector_derivative g (at x within {a..b}))\n   (at x within {a..b})\n\ngoal (1 subgoal):\n 1. (g has_derivative\n     (\\<lambda>xa.\n         complex_of_real xa * vector_derivative g (at x within {a..b})))\n     (at x within {a..b})", "by (simp add: has_vector_derivative_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (g has_derivative\n   (\\<lambda>xa.\n       complex_of_real xa * vector_derivative g (at x within {a..b})))\n   (at x within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "have \"(f has_field_derivative (f' (g x))) (at (g x) within g ` {a..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_field_derivative f' (g x)) (at (g x) within g ` {a..b})", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> b\n  ?x \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?x) (at ?x within s)\n  g piecewise_differentiable_on {a..b}\n  ?x \\<in> {a..b} \\<Longrightarrow> g ?x \\<in> s\n\ngoal (1 subgoal):\n 1. (f has_field_derivative f' (g x)) (at (g x) within g ` {a..b})", "by (metis a atLeastAtMost_iff b DERIV_subset image_subset_iff less_eq_real_def)"], ["proof (state)\nthis:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "then"], ["proof (chain)\npicking this:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {a..b})", "have fdiff: \"(f has_derivative (*) (f' (g x))) (at (g x) within g ` {a..b})\""], ["proof (prove)\nusing this:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {a..b})\n\ngoal (1 subgoal):\n 1. (f has_derivative (*) (f' (g x))) (at (g x) within g ` {a..b})", "by (simp add: has_field_derivative_def)"], ["proof (state)\nthis:\n  (f has_derivative (*) (f' (g x))) (at (g x) within g ` {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "have \"((\\<lambda>x. f (g x)) has_vector_derivative f' (g x) * vector_derivative g (at x within {a..b})) (at x within {a..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (g x)) has_vector_derivative\n     f' (g x) * vector_derivative g (at x within {a..b}))\n     (at x within {a..b})", "using diff_chain_within [OF gdiff fdiff]"], ["proof (prove)\nusing this:\n  (f \\<circ> g has_derivative\n   (*) (f' (g x)) \\<circ>\n   (\\<lambda>xa.\n       complex_of_real xa * vector_derivative g (at x within {a..b})))\n   (at x within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (g x)) has_vector_derivative\n     f' (g x) * vector_derivative g (at x within {a..b}))\n     (at x within {a..b})", "by (simp add: has_vector_derivative_def scaleR_conv_of_real o_def mult_ac)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (g x)) has_vector_derivative\n   f' (g x) * vector_derivative g (at x within {a..b}))\n   (at x within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x2; ?x2 < b; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {a..b}))\n                     (at ?x2 within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x2; ?x2 < b; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {a..b}))\n                     (at ?x2 within {a..b})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n     f (g b) - f (g a))\n     {a..b}", "apply (rule fundamental_theorem_of_calculus_interior_strong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite ?S\n 2. a \\<le> b\n 3. \\<And>x.\n       x \\<in> {a<..<b} - ?S \\<Longrightarrow>\n       ((\\<lambda>a. f (g a)) has_vector_derivative\n        f' (g x) * vector_derivative g (at x within {a..b}))\n        (at x)\n 4. continuous_on {a..b} (\\<lambda>a. f (g a))", "using k assms cfg *"], ["proof (prove)\nusing this:\n  finite k\n  \\<forall>x\\<in>{a..b} - k. g differentiable at x within {a..b}\n  a \\<le> b\n  ?x \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?x) (at ?x within s)\n  g piecewise_differentiable_on {a..b}\n  ?x \\<in> {a..b} \\<Longrightarrow> g ?x \\<in> s\n  continuous_on {a..b} (\\<lambda>x. f (g x))\n  \\<lbrakk>a < ?x2; ?x2 < b; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {a..b}))\n                     (at ?x2 within {a..b})\n\ngoal (4 subgoals):\n 1. finite ?S\n 2. a \\<le> b\n 3. \\<And>x.\n       x \\<in> {a<..<b} - ?S \\<Longrightarrow>\n       ((\\<lambda>a. f (g a)) has_vector_derivative\n        f' (g x) * vector_derivative g (at x within {a..b}))\n        (at x)\n 4. continuous_on {a..b} (\\<lambda>a. f (g a))", "apply (auto simp: at_within_Icc_at)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       f' (g x) * vector_derivative g (at x within {a..b})) has_integral\n   f (g b) - f (g a))\n   {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_primitive_lemma: (*Only for real normed fields, i.e. vectors with products*)\n  fixes f :: \"'a::{euclidean_space,real_normed_field} \\<Rightarrow> 'a::{euclidean_space,real_normed_field}\" and\n        g :: \"real \\<Rightarrow> 'a\"\n  assumes \"\\<And>(a::'a). a \\<in> s \\<Longrightarrow> (f has_field_derivative (f' a)) (at a within s)\"\n      and \"g piecewise_differentiable_on {0::real..1}\"  \"\\<And>x. x \\<in> {0..1} \\<Longrightarrow> g x \\<in> s\"\n      and \"base_vec \\<in> Basis\"\n    shows \"((\\<lambda>x. ((f'(g x)) * (vector_derivative g (at x within {0..1}))) \\<bullet> base_vec)\n             has_integral (((f(g 1)) \\<bullet> base_vec - (f(g 0)) \\<bullet> base_vec))) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "obtain k where k: \"finite k\" \"\\<forall>x\\<in>{0..1} - k. g differentiable (at x within {0..1})\" and cg: \"continuous_on {0..1} g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         \\<forall>x\\<in>{0..1} - k. g differentiable at x within {0..1};\n         continuous_on {0..1} g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?a) (at ?a within s)\n  g piecewise_differentiable_on {0..1}\n  ?x \\<in> {0..1} \\<Longrightarrow> g ?x \\<in> s\n  base_vec \\<in> Basis\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         \\<forall>x\\<in>{0..1} - k. g differentiable at x within {0..1};\n         continuous_on {0..1} g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: piecewise_differentiable_on_def)"], ["proof (state)\nthis:\n  finite k\n  \\<forall>x\\<in>{0..1} - k. g differentiable at x within {0..1}\n  continuous_on {0..1} g\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "have cfg: \"continuous_on {0..1} (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. f (g x))", "apply (rule continuous_on_compose [OF cg, unfolded o_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (g ` {0..1}) f", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?a) (at ?a within s)\n  g piecewise_differentiable_on {0..1}\n  ?x \\<in> {0..1} \\<Longrightarrow> g ?x \\<in> s\n  base_vec \\<in> Basis\n\ngoal (1 subgoal):\n 1. continuous_on (g ` {0..1}) f", "apply (metis field_differentiable_def field_differentiable_imp_continuous_at continuous_on_eq_continuous_within continuous_on_subset image_subset_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "{"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "assume a: \"0 < x\" and b: \"x < 1\" and xk: \"x \\<notin> k\""], ["proof (state)\nthis:\n  0 < x\n  x < 1\n  x \\<notin> k\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  0 < x\n  x < 1\n  x \\<notin> k", "have \"g differentiable at x within {0..1}\""], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n  x \\<notin> k\n\ngoal (1 subgoal):\n 1. g differentiable at x within {0..1}", "using k"], ["proof (prove)\nusing this:\n  0 < x\n  x < 1\n  x \\<notin> k\n  finite k\n  \\<forall>x\\<in>{0..1} - k. g differentiable at x within {0..1}\n\ngoal (1 subgoal):\n 1. g differentiable at x within {0..1}", "by (simp add: differentiable_at_withinI)"], ["proof (state)\nthis:\n  g differentiable at x within {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  g differentiable at x within {0..1}", "have \"(g has_vector_derivative vector_derivative g (at x within {0..1})) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  g differentiable at x within {0..1}\n\ngoal (1 subgoal):\n 1. (g has_vector_derivative vector_derivative g (at x within {0..1}))\n     (at x within {0..1})", "by (simp add: vector_derivative_works has_field_derivative_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (g has_vector_derivative vector_derivative g (at x within {0..1}))\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  (g has_vector_derivative vector_derivative g (at x within {0..1}))\n   (at x within {0..1})", "have gdiff: \"(g has_derivative (\\<lambda>u. of_real u * vector_derivative g (at x within {0..1}))) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  (g has_vector_derivative vector_derivative g (at x within {0..1}))\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. (g has_derivative\n     (\\<lambda>u. of_real u * vector_derivative g (at x within {0..1})))\n     (at x within {0..1})", "by (simp add: has_vector_derivative_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (g has_derivative\n   (\\<lambda>u. of_real u * vector_derivative g (at x within {0..1})))\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "have \"(f has_field_derivative (f' (g x))) (at (g x) within g ` {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_field_derivative f' (g x)) (at (g x) within g ` {0..1})", "using assms"], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?a) (at ?a within s)\n  g piecewise_differentiable_on {0..1}\n  ?x \\<in> {0..1} \\<Longrightarrow> g ?x \\<in> s\n  base_vec \\<in> Basis\n\ngoal (1 subgoal):\n 1. (f has_field_derivative f' (g x)) (at (g x) within g ` {0..1})", "by (metis a atLeastAtMost_iff b DERIV_subset image_subset_iff less_eq_real_def)"], ["proof (state)\nthis:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {0..1})", "have fdiff: \"(f has_derivative (*) (f' (g x))) (at (g x) within g ` {0..1})\""], ["proof (prove)\nusing this:\n  (f has_field_derivative f' (g x)) (at (g x) within g ` {0..1})\n\ngoal (1 subgoal):\n 1. (f has_derivative (*) (f' (g x))) (at (g x) within g ` {0..1})", "by (simp add: has_field_derivative_def)"], ["proof (state)\nthis:\n  (f has_derivative (*) (f' (g x))) (at (g x) within g ` {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "have \"((\\<lambda>x. f (g x)) has_vector_derivative f' (g x) * vector_derivative g (at x within {0..1})) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (g x)) has_vector_derivative\n     f' (g x) * vector_derivative g (at x within {0..1}))\n     (at x within {0..1})", "using diff_chain_within [OF gdiff fdiff]"], ["proof (prove)\nusing this:\n  (f \\<circ> g has_derivative\n   (*) (f' (g x)) \\<circ>\n   (\\<lambda>u. of_real u * vector_derivative g (at x within {0..1})))\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. f (g x)) has_vector_derivative\n     f' (g x) * vector_derivative g (at x within {0..1}))\n     (at x within {0..1})", "by (simp add: has_vector_derivative_def scaleR_conv_of_real o_def mult_ac)"], ["proof (state)\nthis:\n  ((\\<lambda>x. f (g x)) has_vector_derivative\n   f' (g x) * vector_derivative g (at x within {0..1}))\n   (at x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?x2; ?x2 < 1; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {0..1}))\n                     (at ?x2 within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?x2; ?x2 < 1; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {0..1}))\n                     (at ?x2 within {0..1})", "have *: \"\\<And>x. x\\<in>{0<..<1} - k \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative f' (g x) * vector_derivative g (at x within {0..1})) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?x2; ?x2 < 1; ?x2 \\<notin> k\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (g x)) has_vector_derivative\n                     f' (g ?x2) *\n                     vector_derivative g (at ?x2 within {0..1}))\n                     (at ?x2 within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - k \\<Longrightarrow>\n       ((\\<lambda>x. f (g x)) has_vector_derivative\n        f' (g x) * vector_derivative g (at x within {0..1}))\n        (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} - k \\<Longrightarrow>\n  ((\\<lambda>x. f (g x)) has_vector_derivative\n   f' (g ?x) * vector_derivative g (at ?x within {0..1}))\n   (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "have \"((\\<lambda>x. ((f'(g x))) * ((vector_derivative g (at x within {0..1}))))\n             has_integral (((f(g 1)) - (f(g 0))))) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n     f (g 1) - f (g 0))\n     {0..1}", "using fundamental_theorem_of_calculus_interior_strong[OF k(1) zero_le_one _ cfg]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0<..<1} - k \\<Longrightarrow>\n      ((\\<lambda>x. f (g x)) has_vector_derivative ?f' x)\n       (at x)) \\<Longrightarrow>\n  (?f' has_integral f (g 1) - f (g 0)) {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n     f (g 1) - f (g 0))\n     {0..1}", "using k assms cfg *"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0<..<1} - k \\<Longrightarrow>\n      ((\\<lambda>x. f (g x)) has_vector_derivative ?f' x)\n       (at x)) \\<Longrightarrow>\n  (?f' has_integral f (g 1) - f (g 0)) {0..1}\n  finite k\n  \\<forall>x\\<in>{0..1} - k. g differentiable at x within {0..1}\n  ?a \\<in> s \\<Longrightarrow>\n  (f has_field_derivative f' ?a) (at ?a within s)\n  g piecewise_differentiable_on {0..1}\n  ?x \\<in> {0..1} \\<Longrightarrow> g ?x \\<in> s\n  base_vec \\<in> Basis\n  continuous_on {0..1} (\\<lambda>x. f (g x))\n  ?x \\<in> {0<..<1} - k \\<Longrightarrow>\n  ((\\<lambda>x. f (g x)) has_vector_derivative\n   f' (g ?x) * vector_derivative g (at ?x within {0..1}))\n   (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n     f (g 1) - f (g 0))\n     {0..1}", "by (auto simp: at_within_Icc_at)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n   f (g 1) - f (g 0))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n   f (g 1) - f (g 0))\n   {0..1}", "have \"((\\<lambda>x. (((f'(g x))) * ((vector_derivative g (at x within {0..1})))) \\<bullet> base_vec)\n             has_integral (((f(g 1)) - (f(g 0)))) \\<bullet> base_vec) {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n   f (g 1) - f (g 0))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     (f (g 1) - f (g 0)) \\<bullet> base_vec)\n     {0..1}", "using has_integral_componentwise_iff assms(4)"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       f' (g x) * vector_derivative g (at x within {0..1})) has_integral\n   f (g 1) - f (g 0))\n   {0..1}\n  (?f has_integral ?y) ?A =\n  (\\<forall>b\\<in>Basis.\n      ((\\<lambda>x. ?f x \\<bullet> b) has_integral ?y \\<bullet> b) ?A)\n  base_vec \\<in> Basis\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     (f (g 1) - f (g 0)) \\<bullet> base_vec)\n     {0..1}", "by fastforce"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n       base_vec) has_integral\n   (f (g 1) - f (g 0)) \\<bullet> base_vec)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n       base_vec) has_integral\n   (f (g 1) - f (g 0)) \\<bullet> base_vec)\n   {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n       base_vec) has_integral\n   (f (g 1) - f (g 0)) \\<bullet> base_vec)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "using inner_mult_left'"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n       base_vec) has_integral\n   (f (g 1) - f (g 0)) \\<bullet> base_vec)\n   {0..1}\n  (?a * of_real ?m) \\<bullet> ?b = ?m * (?a \\<bullet> ?b)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n         base_vec) has_integral\n     f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n     {0..1}", "by (simp add: inner_mult_left' inner_diff_left)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       (f' (g x) * vector_derivative g (at x within {0..1})) \\<bullet>\n       base_vec) has_integral\n   f (g 1) \\<bullet> base_vec - f (g 0) \\<bullet> base_vec)\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reparam_eq_line_integrals:\n  assumes reparam: \"reparam \\<gamma>1 \\<gamma>2\" and\n    pw_smooth: \"\\<gamma>2 piecewise_C1_differentiable_on {0..1}\" and (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    cont: \"continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\" and\n    line_integral_ex: \"line_integral_exists F {b} \\<gamma>2\" (*We need to remove this and work on special cases like conservative fields and field/line combinations that satisfy the improper integrals theorem assumptions*)\n  shows \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\"\n    \"line_integral_exists F {b} \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2 &&&\n    line_integral_exists F {b} \\<gamma>1", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain \\<phi> where phi: \"(\\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 o \\<phi>) x)\"\" \\<phi> piecewise_C1_differentiable_on {0..1}\"\" \\<phi>(0) = 0\"\" \\<phi>(1) = 1\"\"bij_betw \\<phi> {0..1} {0..1}\" \"\\<phi> -` {0..1} \\<subseteq> {0..1}\" \"\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                    \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x;\n         \\<phi> piecewise_C1_differentiable_on {0..1}; \\<phi> 0 = 0;\n         \\<phi> 1 = 1; bij_betw \\<phi> {0..1} {0..1};\n         \\<phi> -` {0..1} \\<subseteq> {0..1};\n         \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reparam"], ["proof (prove)\nusing this:\n  reparam \\<gamma>1 \\<gamma>2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                    \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x;\n         \\<phi> piecewise_C1_differentiable_on {0..1}; \\<phi> 0 = 0;\n         \\<phi> 1 = 1; bij_betw \\<phi> {0..1} {0..1};\n         \\<phi> -` {0..1} \\<subseteq> {0..1};\n         \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: reparam_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain s where s: \"finite s\" \"\\<phi> C1_differentiable_on {0..1} - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s; \\<phi> C1_differentiable_on {0..1} - s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s; \\<phi> C1_differentiable_on {0..1} - s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: reparam_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "let ?s = \"s \\<inter> {0..1}\""], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have s_inter: \"finite ?s\" \"\\<phi> C1_differentiable_on {0..1} - ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (s \\<inter> {0..1}) &&&\n    \\<phi> C1_differentiable_on {0..1} - s \\<inter> {0..1}", "using s"], ["proof (prove)\nusing this:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (1 subgoal):\n 1. finite (s \\<inter> {0..1}) &&&\n    \\<phi> C1_differentiable_on {0..1} - s \\<inter> {0..1}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> C1_differentiable_on {0..1} - s \\<inter> {0..1}", "by (metis Diff_Compl Diff_Diff_Int Diff_eq inf.commute s(2))"], ["proof (state)\nthis:\n  finite (s \\<inter> {0..1})\n  \\<phi> C1_differentiable_on {0..1} - s \\<inter> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have cont_phi: \"continuous_on {0..1} \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<phi>", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<phi>", "by(auto simp add: reparam_def piecewise_C1_differentiable_on_imp_continuous_on)"], ["proof (state)\nthis:\n  continuous_on {0..1} \\<phi>\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain s' D where s'_D: \"finite s'\" \"(\\<forall>x \\<in> {0 .. 1} - s'. \\<gamma>2 differentiable at x)\" \"(\\<forall>x\\<in>{0..1} - s'. (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and> continuous_on ({0..1} - s') D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' D.\n        \\<lbrakk>finite s';\n         \\<forall>x\\<in>{0..1} - s'. \\<gamma>2 differentiable at x;\n         (\\<forall>x\\<in>{0..1} - s'.\n             (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n         continuous_on ({0..1} - s') D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pw_smooth"], ["proof (prove)\nusing this:\n  \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>s' D.\n        \\<lbrakk>finite s';\n         \\<forall>x\\<in>{0..1} - s'. \\<gamma>2 differentiable at x;\n         (\\<forall>x\\<in>{0..1} - s'.\n             (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n         continuous_on ({0..1} - s') D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (auto simp add: valid_path_def piecewise_C1_differentiable_on_def C1_differentiable_on_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>s' D.\n                   \\<lbrakk>finite s';\n                    \\<forall>x\\<in>{0..1} - s'.\n                       \\<gamma>2 differentiable at x;\n                    (\\<forall>x\\<in>{0..1} - s'.\n                        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n                    continuous_on ({0..1} - s') D\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        continuous_on {0..1} \\<gamma>2; finite S;\n        \\<forall>x\\<in>{0..1} - S. \\<gamma>2 differentiable at x;\n        continuous_on ({0..1} - S)\n         (\\<lambda>x. vector_derivative \\<gamma>2 (at x))\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (simp add: vector_derivative_works)"], ["proof (state)\nthis:\n  finite s'\n  \\<forall>x\\<in>{0..1} - s'. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s'.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s') D\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "let ?s' = \"s' \\<inter> {0..1}\""], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_differentiable: \"finite ?s'\" \"(\\<forall>x \\<in> {0 .. 1} - ?s'. \\<gamma>2 differentiable at x)\" \"(\\<forall>x\\<in>{0..1} - ?s'. (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and> continuous_on ({0..1} - ?s') D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (s' \\<inter> {0..1}) &&&\n    \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       \\<gamma>2 differentiable at x &&&\n    (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "using s'_D"], ["proof (prove)\nusing this:\n  finite s'\n  \\<forall>x\\<in>{0..1} - s'. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s'.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s') D\n\ngoal (1 subgoal):\n 1. finite (s' \\<inter> {0..1}) &&&\n    \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       \\<gamma>2 differentiable at x &&&\n    (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       \\<gamma>2 differentiable at x\n 2. (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "using s'_D(2)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s'. \\<gamma>2 differentiable at x\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       \\<gamma>2 differentiable at x\n 2. (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "by (metis Diff_Int2 inf_top.left_neutral s'_D(3))"], ["proof (state)\nthis:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D", "have gamma2_b_component_differentiable: \"(\\<forall>x \\<in> {0 .. 1} - ?s'. (\\<lambda>x. (\\<gamma>2 x) \\<bullet> b) differentiable at x)\""], ["proof (prove)\nusing this:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x", "using differentiable_inner"], ["proof (prove)\nusing this:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n  \\<lbrakk>?f differentiable at ?x within ?s;\n   ?g differentiable at ?x within ?s\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. ?f x \\<bullet> ?g x) differentiable at ?x\n                    within ?s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x", "have \"(\\<lambda>x. (\\<gamma>2 x) \\<bullet> b) differentiable_on {0..1} - ?s'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n    {0..1} - s' \\<inter> {0..1}", "using differentiable_at_withinI"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  ?f differentiable at ?x within ?s\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n    {0..1} - s' \\<inter> {0..1}", "by (auto simp add: differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n  {0..1} - s' \\<inter> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n  {0..1} - s' \\<inter> {0..1}", "have gama2_cont_comp: \"continuous_on ({0..1} - ?s') (\\<lambda>x. (\\<gamma>2 x) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n  {0..1} - s' \\<inter> {0..1}\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b)", "using differentiable_imp_continuous_on"], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on\n  {0..1} - s' \\<inter> {0..1}\n  ?f differentiable_on ?s \\<Longrightarrow> continuous_on ?s ?f\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. \\<gamma>2 x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "(**********Additional needed assumptions ************)"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. \\<gamma>2 x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have s_in01: \"?s \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<inter> {0..1} \\<subseteq> {0..1}", "by auto"], ["proof (state)\nthis:\n  s \\<inter> {0..1} \\<subseteq> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have s'_in01: \"?s' \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<inter> {0..1} \\<subseteq> {0..1}", "by auto"], ["proof (state)\nthis:\n  s' \\<inter> {0..1} \\<subseteq> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have phi_backimg_s': \"\\<phi> -` {0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> -` {0..1} \\<subseteq> {0..1}", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. \\<phi> -` {0..1} \\<subseteq> {0..1}", "by auto"], ["proof (state)\nthis:\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have \"inj_on \\<phi> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<phi> {0..1}", "using phi(5)"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n\ngoal (1 subgoal):\n 1. inj_on \\<phi> {0..1}", "by (auto simp add: bij_betw_def)"], ["proof (state)\nthis:\n  inj_on \\<phi> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have bij_phi: \"bij_betw \\<phi> {0..1} {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<phi> {0..1} {0..1}", "using phi(5)"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> {0..1} {0..1}", "by auto"], ["proof (state)\nthis:\n  bij_betw \\<phi> {0..1} {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have finite_bck_img_single: \"\\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})", "have finite_bck_img_single_s': \" \\<forall>x\\<in>?s'. finite (\\<phi> -` {x})\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>s' \\<inter> {0..1}. finite (\\<phi> -` {x})", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>s' \\<inter> {0..1}. finite (\\<phi> -` {x})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_line_integrable: \"(\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) integrable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "using line_integral_ex"], ["proof (prove)\nusing this:\n  line_integral_exists F {b} \\<gamma>2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet>\n         b)) integrable_on\n    {0..1}", "by (simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F (\\<gamma>2 x) \\<bullet> b *\n      (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "(****************************************************************)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      F (\\<gamma>2 x) \\<bullet> b *\n      (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet>\n       b)) integrable_on\n  {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have finite_neg_img: \"finite (\\<phi> -` ?s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<phi> -` (s' \\<inter> {0..1}))", "using finite_bck_img_single"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. finite (\\<phi> -` (s' \\<inter> {0..1}))", "by (metis Int_iff finite_Int gamma2_differentiable(1) image_vimage_eq inf_img_fin_dom')"], ["proof (state)\nthis:\n  finite (\\<phi> -` (s' \\<inter> {0..1}))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_cont:\"continuous_on ({0..1} - ?s') \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1}) \\<gamma>2", "using  gamma2_differentiable"], ["proof (prove)\nusing this:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1}) \\<gamma>2", "by (meson continuous_at_imp_continuous_on differentiable_imp_continuous_within)"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1}) \\<gamma>2\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have iii: \"continuous_on ({0..1} - ?s') (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "have 0: \"continuous_on ({0..1} - ?s') (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)", "using cont continuous_on_compose[OF gamma2_cont] continuous_on_compose2 gamma2_cont"], ["proof (prove)\nusing this:\n  continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  continuous_on (\\<gamma>2 ` ({0..1} - s' \\<inter> {0..1}))\n   ?g \\<Longrightarrow>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) (?g \\<circ> \\<gamma>2)\n  \\<lbrakk>continuous_on ?t ?g; continuous_on ?s ?f;\n   ?f ` ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. ?g (?f x))\n  continuous_on ({0..1} - s' \\<inter> {0..1}) \\<gamma>2\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  continuous_on (\\<gamma>2 ` {0..1}) (\\<lambda>x. F x \\<bullet> b)\n  continuous_on (\\<gamma>2 ` ({0..1} - s' \\<inter> {0..1}))\n   ?g \\<Longrightarrow>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) (?g \\<circ> \\<gamma>2)\n  \\<lbrakk>continuous_on ?t ?g; continuous_on ?s ?f;\n   ?f ` ?s \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. ?g (?f x))\n  continuous_on ({0..1} - s' \\<inter> {0..1}) \\<gamma>2\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)", "by fastforce"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "have D: \"(\\<forall>x\\<in>{0..1} - ?s'. (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and> continuous_on ({0..1} - ?s') D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "using gamma2_differentiable"], ["proof (prove)\nusing this:\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n        (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n    continuous_on ({0..1} - s' \\<inter> {0..1}) D", "by auto"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D", "have *:\"\\<forall>x\\<in>{0..1} - ?s'. vector_derivative \\<gamma>2 (at x within{0..1}) = D x\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "using vector_derivative_at vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  vector_derivative ?f (at ?x) = ?f'\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n       vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "have \"continuous_on ({0..1} - ?s') (\\<lambda>x. vector_derivative \\<gamma>2 (at x within{0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "using continuous_on_eq D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n  \\<lbrakk>continuous_on ?s ?f;\n   \\<And>x. x \\<in> ?s \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s ?g\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "by metis"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "have 1: \"continuous_on ({0..1} - ?s') (\\<lambda>x. (vector_derivative \\<gamma>2 (at x within{0..1})) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x.\n       vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "using continuous_on_mult[OF 0 1]"], ["proof (prove)\nusing this:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. continuous_on ({0..1} - s' \\<inter> {0..1})\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on ({0..1} - s' \\<inter> {0..1})\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have iv: \"\\<phi>(0) \\<le> \\<phi>(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> 0 \\<le> \\<phi> 1", "using phi(3) phi(4)"], ["proof (prove)\nusing this:\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n\ngoal (1 subgoal):\n 1. \\<phi> 0 \\<le> \\<phi> 1", "by (simp add: reparam_def)"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> \\<phi> 1\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have v: \"\\<phi>`{0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ` {0..1} \\<subseteq> {0..1}", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. \\<phi> ` {0..1} \\<subseteq> {0..1}", "by (auto simp add: reparam_def bij_betw_def)"], ["proof (state)\nthis:\n  \\<phi> ` {0..1} \\<subseteq> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain D where D_props: \"(\\<forall>x\\<in>{0..1} - ?s. (\\<phi> has_vector_derivative D x) (at x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n           (\\<phi> has_vector_derivative D x) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using s"], ["proof (prove)\nusing this:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n           (\\<phi> has_vector_derivative D x) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: C1_differentiable_on_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)", "have \"(\\<And>x. x \\<in> ({0..1} - ?s) \\<Longrightarrow> (\\<phi> has_vector_derivative D x) (at x within {0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_vector_derivative D x) (at x within {0..1})", "using has_vector_derivative_at_within"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_vector_derivative D x) (at x within {0..1})", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})", "have vi: \"(\\<And>x. x \\<in> ({0..1} - ?s) \\<Longrightarrow> (\\<phi> has_real_derivative D x) (at x within {0..1}))\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "using has_field_derivative_iff_has_vector_derivative"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n  (?f has_real_derivative ?y) ?F = (?f has_vector_derivative ?y) ?F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_real_derivative D ?x) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have a:\"((\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) has_integral\n              integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n              ({0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have a: \"integral {\\<phi> 1..\\<phi> 0} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {\\<phi> 1..\\<phi> 0}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) =\n    0", "using integral_singleton integral_empty iv"], ["proof (prove)\nusing this:\n  integral {?a} ?f = (0::?'a)\n  integral {} ?f = (0::?'a)\n  \\<phi> 0 \\<le> \\<phi> 1\n\ngoal (1 subgoal):\n 1. integral {\\<phi> 1..\\<phi> 0}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) =\n    0", "by (simp add: phi(3) phi(4))"], ["proof (state)\nthis:\n  integral {\\<phi> 1..\\<phi> 0}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) =\n  0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have b: \"((\\<lambda>x. D x *\\<^sub>R (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) has_integral\n                       integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) - integral {\\<phi> 1..\\<phi> 0} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n                           {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\\<^sub>R\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) -\n     integral {\\<phi> 1..\\<phi> 0}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "apply(rule  has_integral_substitution_general_'[OF s_inter(1) zero_le_one gamma2_differentiable(1) v gamma2_line_integrable iii cont_phi finite_bck_img_single_s'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. surj_on (s' \\<inter> {0..1}) \\<phi>\n 2. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n 3. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. surj_on (s' \\<inter> {0..1}) \\<phi>\n 2. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n 3. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "have \"surj_on {0..1} \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj_on {0..1} \\<phi>", "using bij_phi"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n\ngoal (1 subgoal):\n 1. surj_on {0..1} \\<phi>", "by (metis (full_types) bij_betw_def image_subsetI rangeI)"], ["proof (state)\nthis:\n  surj_on {0..1} \\<phi>\n\ngoal (3 subgoals):\n 1. surj_on (s' \\<inter> {0..1}) \\<phi>\n 2. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n 3. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "then"], ["proof (chain)\npicking this:\n  surj_on {0..1} \\<phi>", "show \"surj_on ?s' \\<phi>\""], ["proof (prove)\nusing this:\n  surj_on {0..1} \\<phi>\n\ngoal (1 subgoal):\n 1. surj_on (s' \\<inter> {0..1}) \\<phi>", "using bij_phi s'_in01"], ["proof (prove)\nusing this:\n  surj_on {0..1} \\<phi>\n  bij_betw \\<phi> {0..1} {0..1}\n  s' \\<inter> {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. surj_on (s' \\<inter> {0..1}) \\<phi>", "by blast"], ["proof (state)\nthis:\n  surj_on (s' \\<inter> {0..1}) \\<phi>\n\ngoal (2 subgoals):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n 2. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "show \"inj_on \\<phi> ({0..1} \\<union> (?s \\<union> \\<phi> -` ?s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "have i: \"inj_on \\<phi> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<phi> {0..1}", "using  bij_phi"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n\ngoal (1 subgoal):\n 1. inj_on \\<phi> {0..1}", "using bij_betw_def"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. inj_on \\<phi> {0..1}", "by blast"], ["proof (state)\nthis:\n  inj_on \\<phi> {0..1}\n\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "have ii: \"({0..1} \\<union> (?s \\<union> \\<phi> -` ?s')) = {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..1} \\<union>\n    (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})) =\n    {0..1}", "using phi_backimg_s' s_in01 s'_in01"], ["proof (prove)\nusing this:\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  s \\<inter> {0..1} \\<subseteq> {0..1}\n  s' \\<inter> {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. {0..1} \\<union>\n    (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})) =\n    {0..1}", "by blast"], ["proof (state)\nthis:\n  {0..1} \\<union>\n  (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})) =\n  {0..1}\n\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "using i ii"], ["proof (prove)\nusing this:\n  inj_on \\<phi> {0..1}\n  {0..1} \\<union>\n  (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})) =\n  {0..1}\n\ngoal (1 subgoal):\n 1. inj_on \\<phi>\n     ({0..1} \\<union>\n      (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))", "by auto"], ["proof (state)\nthis:\n  inj_on \\<phi>\n   ({0..1} \\<union>\n    (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on \\<phi>\n   ({0..1} \\<union>\n    (s \\<inter> {0..1} \\<union> \\<phi> -` (s' \\<inter> {0..1})))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "show \"\\<And>x. x \\<in> {0..1} - ?s \\<Longrightarrow> (\\<phi> has_real_derivative D x) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "using vi"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_real_derivative D ?x) (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<inter> {0..1} \\<Longrightarrow>\n  (\\<phi> has_real_derivative D ?x) (at ?x within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       D x *\\<^sub>R\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) -\n   integral {\\<phi> 1..\\<phi> 0}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using a b"], ["proof (prove)\nusing this:\n  integral {\\<phi> 1..\\<phi> 0}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) =\n  0\n  ((\\<lambda>x.\n       D x *\\<^sub>R\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)) -\n   integral {\\<phi> 1..\\<phi> 0}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "have b: \"integral {0..1} (\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) = \n                       integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {\\<phi> 0..\\<phi> 1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_vec_diffable: \"\\<And>x::real. x \\<in> {0..1} - ((\\<phi> -` ?s') \\<union> ?s) \\<Longrightarrow> ((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "assume ass: \"x \\<in> {0..1} -   ((\\<phi> -` ?s') \\<union> ?s)\""], ["proof (state)\nthis:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "have zer_le_x_le_1:\"0\\<le> x \\<and> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "using ass"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "show \"((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "have **: \"\\<gamma>2 differentiable at (\\<phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "using  gamma2_differentiable(2) ass v"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n  \\<phi> ` {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "by blast"], ["proof (state)\nthis:\n  \\<gamma>2 differentiable at (\\<phi> x)\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "have ***: \" \\<phi> differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "using s ass"], ["proof (prove)\nusing this:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "by (auto simp add: C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "then"], ["proof (chain)\npicking this:\n  \\<phi> differentiable at x", "show \"((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\nusing this:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "using differentiable_chain_at[OF *** **]"], ["proof (prove)\nusing this:\n  \\<phi> differentiable at x\n  \\<gamma>2 \\<circ> \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "by (auto simp add: vector_derivative_works)"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)", "have gamma2_vec_deriv_within: \"\\<And>x::real. x \\<in> {0..1} - ((\\<phi> -` ?s') \\<union> ?s) \\<Longrightarrow> vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF gamma2_vec_diffable]"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n  \\<lbrakk>?x \\<in> {0..1} -\n                    (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                     s \\<inter> {0..1});\n   ?a \\<le> ?x; ?x \\<le> ?b; ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                     (at ?x within {?a..?b}) =\n                    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have \"\\<forall>x\\<in>{0..1} - ((\\<phi> -` ?s') \\<union> ?s). D x * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) = (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "assume ass: \"x \\<in> {0..1} -((\\<phi> -` ?s') \\<union> ?s)\""], ["proof (state)\nthis:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "have 0: \"\\<phi> differentiable (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "using s"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "by (auto simp add: C1_differentiable_on_def differentiable_def has_vector_derivative_def)"], ["proof (state)\nthis:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "obtain D2 where \"(\\<phi> has_vector_derivative D2) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D2.\n        (\\<phi> has_vector_derivative D2) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using D_props ass"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>D2.\n        (\\<phi> has_vector_derivative D2) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<phi> has_vector_derivative D2) (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "have \"\\<phi> x \\<in> {0..1} - ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}", "using phi(5) ass"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}", "by (metis Diff_Un Diff_iff Int_iff bij_betw_def image_eqI vimageI)"], ["proof (state)\nthis:\n  \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "then"], ["proof (chain)\npicking this:\n  \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}", "have 1: \"\\<gamma>2 differentiable (at (\\<phi> x))\""], ["proof (prove)\nusing this:\n  \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "using gamma2_differentiable"], ["proof (prove)\nusing this:\n  \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}\n  finite (s' \\<inter> {0..1})\n  \\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}. \\<gamma>2 differentiable at x\n  (\\<forall>x\\<in>{0..1} - s' \\<inter> {0..1}.\n      (\\<gamma>2 has_vector_derivative D__ x) (at x)) \\<and>\n  continuous_on ({0..1} - s' \\<inter> {0..1}) D__\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "by auto"], ["proof (state)\nthis:\n  \\<gamma>2 differentiable at (\\<phi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "have 3:\" vector_derivative \\<gamma>2 (at (\\<phi> x)) =  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "have *:\"0\\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "using phi(5) ass"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "using \\<open>\\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}\\<close>"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..1} {0..1}\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n  \\<phi> x \\<in> {0..1} - s' \\<inter> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "then"], ["proof (chain)\npicking this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "have **:\"(\\<gamma>2 has_vector_derivative (vector_derivative \\<gamma>2 (at (\\<phi> x)))) (at (\\<phi> x))\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 has_vector_derivative\n     vector_derivative \\<gamma>2 (at (\\<phi> x)))\n     (at (\\<phi> x))", "using 1 vector_derivative_works"], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n  \\<gamma>2 differentiable at (\\<phi> x)\n  (?f differentiable ?net) =\n  (?f has_vector_derivative vector_derivative ?f ?net) ?net\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 has_vector_derivative\n     vector_derivative \\<gamma>2 (at (\\<phi> x)))\n     (at (\\<phi> x))", "by auto"], ["proof (state)\nthis:\n  (\\<gamma>2 has_vector_derivative\n   vector_derivative \\<gamma>2 (at (\\<phi> x)))\n   (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "using * vector_derivative_at_within_ivl[OF **]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n  \\<lbrakk>?a \\<le> \\<phi> x; \\<phi> x \\<le> ?b; ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative \\<gamma>2\n                     (at (\\<phi> x) within {?a..?b}) =\n                    vector_derivative \\<gamma>2 (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "show \"D x * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x *\n    (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n     b) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b", "using vector_derivative_chain_at[OF 0 1]"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n  vector_derivative \\<phi> (at x) *\\<^sub>R\n  vector_derivative \\<gamma>2 (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. D x *\n    (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n     b) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b", "apply (auto simp add: gamma2_vec_deriv_within[OF ass, symmetric] 3[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n             vector_derivative \\<phi> (at x) *\\<^sub>R\n             vector_derivative \\<gamma>2 (at (\\<phi> x));\n     D x \\<noteq> vector_derivative \\<phi> (at x)\\<rbrakk>\n    \\<Longrightarrow> vector_derivative \\<gamma>2 (at (\\<phi> x)) \\<bullet>\n                      b =\n                      0", "using D_props ass vector_derivative_at"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s \\<inter> {0..1}.\n     (\\<phi> has_vector_derivative D x) (at x)\n  x \\<in> {0..1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  vector_derivative ?f (at ?x) = ?f'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n             vector_derivative \\<phi> (at x) *\\<^sub>R\n             vector_derivative \\<gamma>2 (at (\\<phi> x));\n     D x \\<noteq> vector_derivative \\<phi> (at x)\\<rbrakk>\n    \\<Longrightarrow> vector_derivative \\<gamma>2 (at (\\<phi> x)) \\<bullet>\n                      b =\n                      0", "by fastforce"], ["proof (state)\nthis:\n  D x *\n  (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n   (at x within {0..1}) \\<bullet>\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b", "have c:\"\\<And>x.  x\\<in>({0..1} -((\\<phi> -` ?s') \\<union> ?s)) \\<Longrightarrow> D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b)) = \n                                    F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)", "have d: \"integral ({0..1}) (\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) = \n                                            integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} -\n                (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                 s \\<inter> {0..1}) \\<Longrightarrow>\n        D x *\n        (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative \\<gamma>2\n           (at (\\<phi> x) within {0..1}) \\<bullet>\n          b)) =\n        F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n          (at x within {0..1}) \\<bullet>\n         b)) \\<Longrightarrow>\n    integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "have \"negligible ((\\<phi> -` ?s') \\<union> ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "using finite_neg_img s(1)"], ["proof (prove)\nusing this:\n  finite (\\<phi> -` (s' \\<inter> {0..1}))\n  finite s\n\ngoal (1 subgoal):\n 1. negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "by auto"], ["proof (state)\nthis:\n  negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} -\n                (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                 s \\<inter> {0..1}) \\<Longrightarrow>\n        D x *\n        (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative \\<gamma>2\n           (at (\\<phi> x) within {0..1}) \\<bullet>\n          b)) =\n        F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n          (at x within {0..1}) \\<bullet>\n         b)) \\<Longrightarrow>\n    integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "then"], ["proof (chain)\npicking this:\n  negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "show ?thesis"], ["proof (prove)\nusing this:\n  negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "using c integral_spike"], ["proof (prove)\nusing this:\n  negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> integral ?T ?f = integral ?T ?g\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "by (metis(no_types,lifting))"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have phi_in_int: \"(\\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1}", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1}", "using v"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n  \\<phi> ` {0..1} \\<subseteq> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1}", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}", "have e: \"((\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) has_integral\n                             integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))){0..1}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have \"negligible ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible (s \\<inter> {0..1})", "using s_inter(1)"], ["proof (prove)\nusing this:\n  finite (s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. negligible (s \\<inter> {0..1})", "by auto"], ["proof (state)\nthis:\n  negligible (s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have 0: \"negligible ((\\<phi> -` ?s') \\<union> ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "using finite_neg_img s(1)"], ["proof (prove)\nusing this:\n  finite (\\<phi> -` (s' \\<inter> {0..1}))\n  finite s\n\ngoal (1 subgoal):\n 1. negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "by auto"], ["proof (state)\nthis:\n  negligible (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have c':\"\\<forall> x\\<in> {0..1} - ((\\<phi> -` ?s') \\<union> ?s). D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b)) = \n                                    F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "using c"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} -\n           (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n            s \\<inter> {0..1}) \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     D x *\n     (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n      (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n       b)) =\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have has_integral_spike_eq': \"\\<And>s t f g y. negligible s \\<Longrightarrow>\n                                                       \\<forall>x\\<in>t - s. g x = f x \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t f g y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "using has_integral_spike_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?T = (?g has_integral ?y) ?T\n\ngoal (1 subgoal):\n 1. \\<And>s t f g y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>negligible ?s; \\<forall>x\\<in>?t - ?s. ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?t = (?g has_integral ?y) ?t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using a has_integral_spike_eq'[OF 0 c']"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1} =\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   ?y)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "have f: \"((\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative  \\<gamma>1 (at x within {0..1}) \\<bullet> b)) has_integral\n                     integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n                       {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "assume ass: \"((\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) has_integral\n                            integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n                             {0..1}\""], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have *:\"\\<forall>x\\<in>{0..1} - ( ((\\<phi> -` ?s') \\<union> ?s) \\<union> {0,1}). (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) x =\n                                                  (\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "have \"\\<forall>x\\<in>{0<..<1}  - (\\<phi> -` ?s' \\<union> ?s). (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b) = (vector_derivative  (\\<gamma>1) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have i: \"open ({0<..<1}  - ((\\<phi> -` ?s') \\<union> ?s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open\n     ({0<..<1} -\n      (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1}))", "using open_diff s(1) open_greaterThanLessThan finite_neg_img"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?t; open ?s\\<rbrakk> \\<Longrightarrow> open (?s - ?t)\n  finite s\n  open {?a<..<?b}\n  finite (\\<phi> -` (s' \\<inter> {0..1}))\n\ngoal (1 subgoal):\n 1. open\n     ({0<..<1} -\n      (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1}))", "by (simp add: open_diff)"], ["proof (state)\nthis:\n  open\n   ({0<..<1} - (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have ii: \"\\<forall>x\\<in>{0<..<1::real}  - (\\<phi> -` ?s' \\<union> ?s). (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x", "using phi(1)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1}).\n       (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..<1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "assume ass: \" x \\<in> {0<..<1::real} -  ((\\<phi> -` ?s') \\<union> ?s)\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})", "have iii: \"(\\<gamma>2 \\<circ> \\<phi> has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})) (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "by (metis (no_types) Diff_iff add.commute add_strict_mono ass atLeastAtMost_iff gamma2_vec_deriv_within gamma2_vec_diffable greaterThanLessThan_iff less_irrefl not_le)"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "(*Most crucial but annoying step*)"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)", "have iv:\"(\\<gamma>1 has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})) (at x)\""], ["proof (prove)\nusing this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. (\\<gamma>1 has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "using has_derivative_transform_within_open i ii ass"], ["proof (prove)\nusing this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n  \\<lbrakk>(?f has_derivative ?f') (at ?x within ?t); open ?s; ?x \\<in> ?s;\n   \\<And>x. x \\<in> ?s \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> (?g has_derivative ?f') (at ?x within ?t)\n  open\n   ({0<..<1} - (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1}))\n  \\<forall>x\\<in>{0<..<1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\n  x \\<in> {0<..<1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. (\\<gamma>1 has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "apply(auto simp add: has_vector_derivative_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<not> 0 \\<le> \\<phi> x; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)\n 2. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<phi> x \\<notin> s'; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)\n 3. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<not> \\<phi> x \\<le> 1; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)", "apply (meson ass has_derivative_transform_within_open i ii)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<phi> x \\<notin> s'; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)\n 2. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<not> \\<phi> x \\<le> 1; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)", "apply (meson ass has_derivative_transform_within_open i ii)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open\n      ({0<..<1} -\n       (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union> s \\<inter> {0..1}));\n     \\<forall>x\\<in>{0<..<1} -\n                    (\\<phi> -` s' \\<inter> \\<phi> -` {0..1} \\<union>\n                     s \\<inter> {0..1}).\n        \\<gamma>2 (\\<phi> x) = \\<gamma>1 x;\n     0 < x; x < 1; \\<not> \\<phi> x \\<le> 1; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)", "by (meson ass has_derivative_transform_within_open i ii)"], ["proof (state)\nthis:\n  (\\<gamma>1 has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have v: \"0 \\<le> x\" \"x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& x \\<le> 1", "using ass"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} -\n          (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1})\n\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have 0: \"vector_derivative \\<gamma>1 (at x within {0..1}) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>1 (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF iv v(1) v(2) zero_less_one]"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>1 (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by force"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have 1: \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF iii v(1) v(2) zero_less_one]"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by force"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "have \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) = vector_derivative \\<gamma>1 (at x within {0..1})\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative \\<gamma>1 (at x within {0..1})", "using 0 1"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative \\<gamma>1 (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} -\n               (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                s \\<inter> {0..1}) \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})", "show \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b = vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b =\n    vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n   (at x within {0..1}) \\<bullet>\n  b =\n  vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..<1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0<..<1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have i: \"\\<forall>x\\<in>{0..1} - ( ((\\<phi> -` ?s') \\<union> ?s)\\<union>{0,1}). (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b) = (vector_derivative  (\\<gamma>1) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0<..<1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "have ii: \"\\<forall>x\\<in>{0..1} - (((\\<phi> -` ?s') \\<union> ?s)\\<union>{0,1}).  F (\\<gamma>1 x) \\<bullet> b =  F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b", "using phi(1)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "using i ii"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} -\n                   (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                    s \\<inter> {0..1} \\<union>\n                    {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b) =\n     F (\\<gamma>1 x) \\<bullet> b *\n     (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} -\n                 (\\<phi> -` (s' \\<inter> {0..1}) \\<union>\n                  s \\<inter> {0..1} \\<union>\n                  {0, 1}).\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b) =\n     F (\\<gamma>1 x) \\<bullet> b *\n     (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have **: \"negligible ((\\<phi> -` ?s') \\<union> ?s \\<union> {0, 1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible\n     (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1} \\<union>\n      {0, 1})", "using s(1) finite_neg_img"], ["proof (prove)\nusing this:\n  finite s\n  finite (\\<phi> -` (s' \\<inter> {0..1}))\n\ngoal (1 subgoal):\n 1. negligible\n     (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1} \\<union>\n      {0, 1})", "by auto"], ["proof (state)\nthis:\n  negligible\n   (\\<phi> -` (s' \\<inter> {0..1}) \\<union> s \\<inter> {0..1} \\<union>\n    {0, 1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have has_integral_spike_eq': \"\\<And>s t g f y. negligible s \\<Longrightarrow>\n                                \\<forall>x\\<in>t - s. g x = f x \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t g f y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "using has_integral_spike_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?T = (?g has_integral ?y) ?T\n\ngoal (1 subgoal):\n 1. \\<And>s t g f y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>negligible ?s; \\<forall>x\\<in>?t - ?s. ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?t = (?g has_integral ?y) ?t\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using has_integral_spike_eq'[OF ** *] ass"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1} =\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1}\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "show \"line_integral_exists F {b} \\<gamma>1\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>1", "using phi"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>1", "by(auto simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  line_integral_exists F {b} \\<gamma>1\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "have \"integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) =\n                      integral ({0..1}) (\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative \\<gamma>1  (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))", "using integral_unique[OF e] integral_unique[OF f]"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))", "by metis"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "moreover"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "have \"integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) =\n                         integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "using b d phi"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by (auto simp add:)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "ultimately"], ["proof (chain)\npicking this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "show \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\""], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "using phi"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  bij_betw \\<phi> {0..1} {0..1}\n  \\<phi> -` {0..1} \\<subseteq> {0..1}\n  \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x})\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "by(auto simp add: line_integral_def)"], ["proof (state)\nthis:\n  line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reparam_weak_eq_line_integrals:\n  assumes \"reparam_weak \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities of f*)\n    \"continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\"\n    \"line_integral_exists F {b} \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2 &&&\n    line_integral_exists F {b} \\<gamma>1", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain \\<phi> where phi: \"(\\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 o \\<phi>) x)\"\" \\<phi> piecewise_C1_differentiable_on {0..1}\"\" \\<phi>(0) = 0\"\" \\<phi>(1) = 1\"\" \\<phi> ` {0..1} = {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                    \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x;\n         \\<phi> piecewise_C1_differentiable_on {0..1}; \\<phi> 0 = 0;\n         \\<phi> 1 = 1; \\<phi> ` {0..1} = {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  reparam_weak \\<gamma>1 \\<gamma>2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<forall>x\\<in>{0..1}.\n                    \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x;\n         \\<phi> piecewise_C1_differentiable_on {0..1}; \\<phi> 0 = 0;\n         \\<phi> 1 = 1; \\<phi> ` {0..1} = {0..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: reparam_weak_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain s where s: \"finite s\" \"\\<phi> C1_differentiable_on {0..1} - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s; \\<phi> C1_differentiable_on {0..1} - s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>finite s; \\<phi> C1_differentiable_on {0..1} - s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: reparam_weak_def piecewise_C1_differentiable_on_def)"], ["proof (state)\nthis:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have cont_phi: \"continuous_on {0..1} \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<phi>", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<phi>", "by(auto simp add: reparam_weak_def piecewise_C1_differentiable_on_imp_continuous_on)"], ["proof (state)\nthis:\n  continuous_on {0..1} \\<phi>\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_differentiable: \"(\\<forall>x \\<in> {0 .. 1}. \\<gamma>2 differentiable at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<gamma>2 C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x", "by (auto simp add: valid_path_def C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x", "have gamma2_b_component_differentiable: \"(\\<forall>x \\<in> {0 .. 1}. (\\<lambda>x. (\\<gamma>2 x) \\<bullet> b) differentiable at x)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x", "have \"(\\<lambda>x. (\\<gamma>2 x) \\<bullet> b) differentiable_on {0..1}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}", "using differentiable_at_withinI"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable at x\n  ?f differentiable at ?x \\<Longrightarrow>\n  ?f differentiable at ?x within ?s\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}", "by (auto simp add: differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}", "have gama2_cont_comp: \"continuous_on {0..1} (\\<lambda>x. (\\<gamma>2 x) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. \\<gamma>2 x \\<bullet> b)", "using differentiable_imp_continuous_on"], ["proof (prove)\nusing this:\n  (\\<lambda>x. \\<gamma>2 x \\<bullet> b) differentiable_on {0..1}\n  ?f differentiable_on ?s \\<Longrightarrow> continuous_on ?s ?f\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. \\<gamma>2 x \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. \\<gamma>2 x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_cont:\"continuous_on {0..1} \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<gamma>2", "using assms(2) C1_differentiable_imp_continuous_on"], ["proof (prove)\nusing this:\n  \\<gamma>2 C1_differentiable_on {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow> continuous_on ?S ?f\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} \\<gamma>2", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} \\<gamma>2\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have iii: \"continuous_on {0..1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "have 0: \"continuous_on {0..1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)", "using assms(3) continuous_on_compose[OF gamma2_cont]"], ["proof (prove)\nusing this:\n  continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  continuous_on (\\<gamma>2 ` {0..1}) ?g \\<Longrightarrow>\n  continuous_on {0..1} (?g \\<circ> \\<gamma>2)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)", "by (auto simp add: path_image_def)"], ["proof (state)\nthis:\n  continuous_on {0..1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "obtain D where D: \"(\\<forall>x\\<in>{0..1}. (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and> continuous_on {0..1} D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D.\n        (\\<forall>x\\<in>{0..1}.\n            (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n        continuous_on {0..1} D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<gamma>2 C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        (\\<forall>x\\<in>{0..1}.\n            (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n        continuous_on {0..1} D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: C1_differentiable_on_def)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D", "have *:\"\\<forall>x\\<in>{0..1}. vector_derivative \\<gamma>2 (at x within{0..1}) = D x\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "using vector_derivative_at vector_derivative_at_within_ivl"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  vector_derivative ?f (at ?x) = ?f'\n  \\<lbrakk>(?f has_vector_derivative ?f') (at ?x); ?a \\<le> ?x; ?x \\<le> ?b;\n   ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative ?f (at ?x within {?a..?b}) = ?f'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1}.\n       vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x", "have \"continuous_on {0..1} (\\<lambda>x. vector_derivative \\<gamma>2 (at x within{0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "using continuous_on_eq D"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}.\n     vector_derivative \\<gamma>2 (at x within {0..1}) = D x\n  \\<lbrakk>continuous_on ?s ?f;\n   \\<And>x. x \\<in> ?s \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s ?g\n  (\\<forall>x\\<in>{0..1}.\n      (\\<gamma>2 has_vector_derivative D x) (at x)) \\<and>\n  continuous_on {0..1} D\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "by force"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "then"], ["proof (chain)\npicking this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))", "have 1: \"continuous_on {0..1} (\\<lambda>x. (vector_derivative \\<gamma>2 (at x within{0..1})) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x. vector_derivative \\<gamma>2 (at x within {0..1}))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "using continuous_on_mult[OF 0 1]"], ["proof (prove)\nusing this:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have iv: \"\\<phi>(0) \\<le> \\<phi>(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> 0 \\<le> \\<phi> 1", "using phi(3) phi(4)"], ["proof (prove)\nusing this:\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n\ngoal (1 subgoal):\n 1. \\<phi> 0 \\<le> \\<phi> 1", "by (simp add: reparam_weak_def)"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> \\<phi> 1\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have v: \"\\<phi>`{0..1} \\<subseteq> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ` {0..1} \\<subseteq> {0..1}", "using phi(5)"], ["proof (prove)\nusing this:\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. \\<phi> ` {0..1} \\<subseteq> {0..1}", "by (simp add: reparam_weak_def)"], ["proof (state)\nthis:\n  \\<phi> ` {0..1} \\<subseteq> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "obtain D where D_props: \"(\\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<forall>x\\<in>{0..1} - s.\n           (\\<phi> has_vector_derivative D x) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using s"], ["proof (prove)\nusing this:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<forall>x\\<in>{0..1} - s.\n           (\\<phi> has_vector_derivative D x) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: C1_differentiable_on_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)", "have \"(\\<And>x. x \\<in> ({0..1} -s) \\<Longrightarrow> (\\<phi> has_vector_derivative D x) (at x within {0..1}))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<phi> has_vector_derivative D x) (at x within {0..1})", "using has_vector_derivative_at_within"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<phi> has_vector_derivative D x) (at x within {0..1})", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})", "have vi: \"(\\<And>x. x \\<in> ({0..1} - s) \\<Longrightarrow> (\\<phi> has_real_derivative D x) (at x within {0..1}))\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "using has_field_derivative_iff_has_vector_derivative"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<phi> has_vector_derivative D ?x) (at ?x within {0..1})\n  (?f has_real_derivative ?y) ?F = (?f has_vector_derivative ?y) ?F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<phi> has_real_derivative D x) (at x within {0..1})", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<phi> has_real_derivative D ?x) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have a:\"((\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) has_integral\n              integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n              {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using has_integral_substitution_strong[OF s(1) zero_le_one iv v iii cont_phi vi]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0..1} - s \\<Longrightarrow>\n      x \\<in> {0..1} - s) \\<Longrightarrow>\n  ((\\<lambda>x.\n       D x *\\<^sub>R\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "have b: \"integral {0..1} (\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) = \n                       integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {\\<phi> 0..\\<phi> 1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by auto"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have gamma2_vec_diffable: \"\\<And>x::real. x \\<in> {0..1} -s \\<Longrightarrow> ((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "assume ass: \"x \\<in> {0..1} -s\""], ["proof (state)\nthis:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "have zer_le_x_le_1:\"0\\<le> x \\<and> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "using ass"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<and> x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n        vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n        (at x)", "show \"((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "have **: \"\\<gamma>2 differentiable at (\\<phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "using phi gamma2_differentiable"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n  \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "by (auto simp add: zer_le_x_le_1)"], ["proof (state)\nthis:\n  \\<gamma>2 differentiable at (\\<phi> x)\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "have ***: \" \\<phi> differentiable at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "using s ass"], ["proof (prove)\nusing this:\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "by (auto simp add: C1_differentiable_on_eq)"], ["proof (state)\nthis:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "then"], ["proof (chain)\npicking this:\n  \\<phi> differentiable at x", "show \"((\\<gamma>2 o \\<phi>) has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x)) (at x)\""], ["proof (prove)\nusing this:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "using differentiable_chain_at[OF *** **]"], ["proof (prove)\nusing this:\n  \\<phi> differentiable at x\n  \\<gamma>2 \\<circ> \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n     (at x)", "by (auto simp add: vector_derivative_works)"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)", "have gamma2_vec_deriv_within: \"\\<And>x::real. x \\<in> {0..1} -s \\<Longrightarrow> vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF gamma2_vec_diffable]"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n  \\<lbrakk>?x \\<in> {0..1} - s; ?a \\<le> ?x; ?x \\<le> ?b; ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                     (at ?x within {?a..?b}) =\n                    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x within {0..1})\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have \"\\<forall>x\\<in>{0..1} - s. D x * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) = (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "assume ass: \"x \\<in> {0..1} -s\""], ["proof (state)\nthis:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0..1} - s", "have 0: \"\\<phi> differentiable (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "using s"], ["proof (prove)\nusing this:\n  x \\<in> {0..1} - s\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<phi> differentiable at x", "by (auto simp add: C1_differentiable_on_def differentiable_def has_vector_derivative_def)"], ["proof (state)\nthis:\n  \\<phi> differentiable at x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "obtain D2 where \"(\\<phi> has_vector_derivative D2) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D2.\n        (\\<phi> has_vector_derivative D2) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using D_props ass"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. (\\<And>D2.\n        (\\<phi> has_vector_derivative D2) (at x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<phi> has_vector_derivative D2) (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "have \"\\<phi> x \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> x \\<in> {0..1}", "using phi(5) ass"], ["proof (prove)\nusing this:\n  \\<phi> ` {0..1} = {0..1}\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. \\<phi> x \\<in> {0..1}", "by (auto simp add: reparam_weak_def)"], ["proof (state)\nthis:\n  \\<phi> x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "then"], ["proof (chain)\npicking this:\n  \\<phi> x \\<in> {0..1}", "have 1: \"\\<gamma>2 differentiable (at (\\<phi> x))\""], ["proof (prove)\nusing this:\n  \\<phi> x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "using gamma2_differentiable"], ["proof (prove)\nusing this:\n  \\<phi> x \\<in> {0..1}\n  \\<forall>x\\<in>{0..1}. \\<gamma>2 differentiable at x\n\ngoal (1 subgoal):\n 1. \\<gamma>2 differentiable at (\\<phi> x)", "by auto"], ["proof (state)\nthis:\n  \\<gamma>2 differentiable at (\\<phi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "have 3:\" vector_derivative \\<gamma>2 (at (\\<phi> x)) =  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "have *:\"0\\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "using phi(5) ass"], ["proof (prove)\nusing this:\n  \\<phi> ` {0..1} = {0..1}\n  x \\<in> {0..1} - s\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "then"], ["proof (chain)\npicking this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1", "have **:\"(\\<gamma>2 has_vector_derivative (vector_derivative \\<gamma>2 (at (\\<phi> x)))) (at (\\<phi> x))\""], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 has_vector_derivative\n     vector_derivative \\<gamma>2 (at (\\<phi> x)))\n     (at (\\<phi> x))", "using 1 vector_derivative_works"], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n  \\<gamma>2 differentiable at (\\<phi> x)\n  (?f differentiable ?net) =\n  (?f has_vector_derivative vector_derivative ?f ?net) ?net\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 has_vector_derivative\n     vector_derivative \\<gamma>2 (at (\\<phi> x)))\n     (at (\\<phi> x))", "by auto"], ["proof (state)\nthis:\n  (\\<gamma>2 has_vector_derivative\n   vector_derivative \\<gamma>2 (at (\\<phi> x)))\n   (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "using * vector_derivative_at_within_ivl[OF **]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<phi> x \\<and> \\<phi> x \\<le> 1\n  \\<lbrakk>?a \\<le> \\<phi> x; \\<phi> x \\<le> ?b; ?a < ?b\\<rbrakk>\n  \\<Longrightarrow> vector_derivative \\<gamma>2\n                     (at (\\<phi> x) within {?a..?b}) =\n                    vector_derivative \\<gamma>2 (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n    vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>2 (at (\\<phi> x)) =\n  vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n        b) =\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b", "show \"D x * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x *\n    (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n     b) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b", "using vector_derivative_chain_at[OF 0 1]"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n  vector_derivative \\<phi> (at x) *\\<^sub>R\n  vector_derivative \\<gamma>2 (at (\\<phi> x))\n\ngoal (1 subgoal):\n 1. D x *\n    (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n     b) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b", "apply (auto simp add: gamma2_vec_deriv_within[OF ass, symmetric] 3[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n             vector_derivative \\<phi> (at x) *\\<^sub>R\n             vector_derivative \\<gamma>2 (at (\\<phi> x));\n     D x \\<noteq> vector_derivative \\<phi> (at x)\\<rbrakk>\n    \\<Longrightarrow> vector_derivative \\<gamma>2 (at (\\<phi> x)) \\<bullet>\n                      b =\n                      0", "using D_props ass vector_derivative_at"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s. (\\<phi> has_vector_derivative D x) (at x)\n  x \\<in> {0..1} - s\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  vector_derivative ?f (at ?x) = ?f'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x) =\n             vector_derivative \\<phi> (at x) *\\<^sub>R\n             vector_derivative \\<gamma>2 (at (\\<phi> x));\n     D x \\<noteq> vector_derivative \\<phi> (at x)\\<rbrakk>\n    \\<Longrightarrow> vector_derivative \\<gamma>2 (at (\\<phi> x)) \\<bullet>\n                      b =\n                      0", "by fastforce"], ["proof (state)\nthis:\n  D x *\n  (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n   (at x within {0..1}) \\<bullet>\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..1} - s.\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b", "have c:\"\\<And>x.  x\\<in>({0..1} -s) \\<Longrightarrow> D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b)) = \n                                    F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - s.\n     D x *\n     (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n      b) =\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..1} - s \\<Longrightarrow>\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)", "have d: \"integral ({0..1}) (\\<lambda>x. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b))) = \n                                            integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} - s \\<Longrightarrow>\n        D x *\n        (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative \\<gamma>2\n           (at (\\<phi> x) within {0..1}) \\<bullet>\n          b)) =\n        F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n          (at x within {0..1}) \\<bullet>\n         b)) \\<Longrightarrow>\n    integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "have \"negligible s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible s", "using s(1)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. negligible s", "by auto"], ["proof (state)\nthis:\n  negligible s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} - s \\<Longrightarrow>\n        D x *\n        (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative \\<gamma>2\n           (at (\\<phi> x) within {0..1}) \\<bullet>\n          b)) =\n        F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n          (at x within {0..1}) \\<bullet>\n         b)) \\<Longrightarrow>\n    integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "then"], ["proof (chain)\npicking this:\n  negligible s", "show ?thesis"], ["proof (prove)\nusing this:\n  negligible s\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "using c integral_spike"], ["proof (prove)\nusing this:\n  negligible s\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> integral ?T ?f = integral ?T ?g\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         D x *\n         (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n          (vector_derivative \\<gamma>2\n            (at (\\<phi> x) within {0..1}) \\<bullet>\n           b))) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b))", "by (metis(no_types,lifting))"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "have phi_in_int: \"(\\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1}", "using phi"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..1} \\<Longrightarrow> \\<phi> x \\<in> {0..1}", "by(auto simp add:)"], ["proof (state)\nthis:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}", "have e: \"((\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) has_integral\n                             integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))){0..1}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} \\<Longrightarrow> \\<phi> ?x \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have 0:\"negligible s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible s", "using s(1)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. negligible s", "by auto"], ["proof (state)\nthis:\n  negligible s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have c':\"\\<forall> x\\<in> {0..1} -s. D x * (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet> b)) = \n                                    F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "using c"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  D ?x *\n  (F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n   (vector_derivative \\<gamma>2 (at (\\<phi> ?x) within {0..1}) \\<bullet>\n    b)) =\n  F (\\<gamma>2 (\\<phi> ?x)) \\<bullet> b *\n  (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n    (at ?x within {0..1}) \\<bullet>\n   b)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - s.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b)) =\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - s.\n     D x *\n     (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n      (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n       b)) =\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have has_integral_spike_eq': \"\\<And>s t f g y. negligible s \\<Longrightarrow>\n                                               \\<forall>x\\<in>t - s. g x = f x \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t f g y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "using has_integral_spike_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?T = (?g has_integral ?y) ?T\n\ngoal (1 subgoal):\n 1. \\<And>s t f g y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>negligible ?s; \\<forall>x\\<in>?t - ?s. ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?t = (?g has_integral ?y) ?t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {0..1} \\<Longrightarrow>\n        \\<phi> x \\<in> {0..1}) \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using a has_integral_spike_eq'[OF 0 c']"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1} =\n  ((\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) has_integral\n   ?y)\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "have f: \"((\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative  \\<gamma>1 (at x within {0..1}) \\<bullet> b)) has_integral\n                     integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n                       {0..1}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "assume ass: \"((\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) has_integral\n                            integral {\\<phi> 0..\\<phi> 1} (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n                             {0..1}\""], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have *:\"\\<forall>x\\<in>{0..1} - (s\\<union>{0,1}). (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) x =\n                                                  (\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "have \"\\<forall>x\\<in>{0<..<1} - s. (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b) = (vector_derivative  (\\<gamma>1) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} - s.\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have i: \"open ({0<..<1} - s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open ({0<..<1} - s)", "using open_diff s open_greaterThanLessThan"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?t; open ?s\\<rbrakk> \\<Longrightarrow> open (?s - ?t)\n  finite s\n  \\<phi> C1_differentiable_on {0..1} - s\n  open {?a<..<?b}\n\ngoal (1 subgoal):\n 1. open ({0<..<1} - s)", "by blast"], ["proof (state)\nthis:\n  open ({0<..<1} - s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have ii: \"\\<forall>x\\<in>{0<..<1::real} - s. (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} - s. (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x", "using phi(1)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..<1} - s. (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..<1} - s. (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "fix x::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "assume ass: \" x \\<in> {0<..<1::real} - s\""], ["proof (state)\nthis:\n  x \\<in> {0<..<1} - s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<1} - s", "have iii: \"(\\<gamma>2 \\<circ> \\<phi> has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})) (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} - s\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "using has_vector_derivative_at_within gamma2_vec_deriv_within gamma2_vec_diffable"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} - s\n  (?f has_vector_derivative ?f') (at ?x) \\<Longrightarrow>\n  (?f has_vector_derivative ?f') (at ?x within ?S)\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x within {0..1})\n  ?x \\<in> {0..1} - s \\<Longrightarrow>\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at ?x))\n   (at ?x)\n\ngoal (1 subgoal):\n 1. (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "by auto"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "(*Most crucial but annoying step*)"], ["proof (state)\nthis:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)", "have iv:\"(\\<gamma>1 has_vector_derivative vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})) (at x)\""], ["proof (prove)\nusing this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. (\\<gamma>1 has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "using has_derivative_transform_within_open i ii ass"], ["proof (prove)\nusing this:\n  (\\<gamma>2 \\<circ> \\<phi> has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n  \\<lbrakk>(?f has_derivative ?f') (at ?x within ?t); open ?s; ?x \\<in> ?s;\n   \\<And>x. x \\<in> ?s \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> (?g has_derivative ?f') (at ?x within ?t)\n  open ({0<..<1} - s)\n  \\<forall>x\\<in>{0<..<1} - s. (\\<gamma>2 \\<circ> \\<phi>) x = \\<gamma>1 x\n  x \\<in> {0<..<1} - s\n\ngoal (1 subgoal):\n 1. (\\<gamma>1 has_vector_derivative\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n     (at x)", "apply(auto simp add: has_vector_derivative_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<gamma>2 \\<circ> \\<phi> has_derivative\n              (\\<lambda>xa.\n                  xa *\\<^sub>R\n                  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                   (at x within {0..1})))\n              (at x);\n     \\<And>f f' x t s g.\n        \\<lbrakk>(f has_derivative f') (at x within t); open s; x \\<in> s;\n         \\<And>x. x \\<in> s \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> (g has_derivative f') (at x within t);\n     open ({0<..<1} - s);\n     \\<forall>x\\<in>{0<..<1} - s. \\<gamma>2 (\\<phi> x) = \\<gamma>1 x; 0 < x;\n     x < 1; x \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> (\\<gamma>1 has_derivative\n                       (\\<lambda>xa.\n                           xa *\\<^sub>R\n                           vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n                            (at x within {0..1})))\n                       (at x)", "by force"], ["proof (state)\nthis:\n  (\\<gamma>1 has_vector_derivative\n   vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}))\n   (at x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have v: \"0 \\<le> x\" \"x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& x \\<le> 1", "using ass"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1} - s\n\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& x \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x\n  x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have 0: \"vector_derivative \\<gamma>1 (at x within {0..1}) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>1 (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF iv v(1) v(2) zero_less_one]"], ["proof (prove)\nusing this:\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative \\<gamma>1 (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by force"], ["proof (state)\nthis:\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have 1: \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) = vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "using vector_derivative_at_within_ivl[OF iii v(1) v(2) zero_less_one]"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "by force"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})", "have \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) = vector_derivative \\<gamma>1 (at x within {0..1})\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative \\<gamma>1 (at x within {0..1})", "using 0 1"], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n  vector_derivative \\<gamma>1 (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n    vector_derivative \\<gamma>1 (at x within {0..1})", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0<..<1} - s \\<Longrightarrow>\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "then"], ["proof (chain)\npicking this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})", "show \"vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b = vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\""], ["proof (prove)\nusing this:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) =\n  vector_derivative \\<gamma>1 (at x within {0..1})\n\ngoal (1 subgoal):\n 1. vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n     (at x within {0..1}) \\<bullet>\n    b =\n    vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n   (at x within {0..1}) \\<bullet>\n  b =\n  vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..<1} - s.\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0<..<1} - s.\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "have i: \"\\<forall>x\\<in>{0..1} - (s\\<union>{0,1}). (vector_derivative  (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b) = (vector_derivative  (\\<gamma>1) (at x within {0..1}) \\<bullet> b)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0<..<1} - s.\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n        (at x within {0..1}) \\<bullet>\n       b =\n       vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "have ii: \"\\<forall>x\\<in>{0..1} - (s\\<union>{0,1}).  F (\\<gamma>1 x) \\<bullet> b =  F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b", "using phi(1)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "using i ii"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n      (at x within {0..1}) \\<bullet>\n     b =\n     vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     F (\\<gamma>1 x) \\<bullet> b = F (\\<gamma>2 (\\<phi> x)) \\<bullet> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b) =\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b) =\n     F (\\<gamma>1 x) \\<bullet> b *\n     (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..1} - (s \\<union> {0, 1}).\n     F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n     (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n       (at x within {0..1}) \\<bullet>\n      b) =\n     F (\\<gamma>1 x) \\<bullet> b *\n     (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have **: \"negligible (s\\<union>{0,1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible (s \\<union> {0, 1})", "using s(1)"], ["proof (prove)\nusing this:\n  finite s\n\ngoal (1 subgoal):\n 1. negligible (s \\<union> {0, 1})", "by auto"], ["proof (state)\nthis:\n  negligible (s \\<union> {0, 1})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "have has_integral_spike_eq': \"\\<And>s t g f y. negligible s \\<Longrightarrow>\n                                \\<forall>x\\<in>t - s. g x = f x \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t g f y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "using has_integral_spike_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>negligible ?S;\n   \\<And>x. x \\<in> ?T - ?S \\<Longrightarrow> ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?T = (?g has_integral ?y) ?T\n\ngoal (1 subgoal):\n 1. \\<And>s t g f y.\n       \\<lbrakk>negligible s; \\<forall>x\\<in>t - s. g x = f x\\<rbrakk>\n       \\<Longrightarrow> (f has_integral y) t = (g has_integral y) t", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>negligible ?s; \\<forall>x\\<in>?t - ?s. ?g x = ?f x\\<rbrakk>\n  \\<Longrightarrow> (?f has_integral ?y) ?t = (?g has_integral ?y) ?t\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1} \\<Longrightarrow>\n    ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "using has_integral_spike_eq'[OF ** *] ass"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1} =\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   ?y)\n   {0..1}\n  ((\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n          b)) has_integral\n     integral {\\<phi> 0..\\<phi> 1}\n      (\\<lambda>x.\n          F (\\<gamma>2 x) \\<bullet> b *\n          (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n     {0..1}", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (2 subgoals):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n 2. line_integral_exists F {b} \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}", "show \"line_integral_exists F {b} \\<gamma>1\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>1", "using phi"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet>\n        b)) has_integral\n   integral {\\<phi> 0..\\<phi> 1}\n    (\\<lambda>x.\n        F (\\<gamma>2 x) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b)))\n   {0..1}\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>1", "by(auto simp add: line_integral_exists_def)"], ["proof (state)\nthis:\n  line_integral_exists F {b} \\<gamma>1\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "have \"integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) =\n                      integral ({0..1}) (\\<lambda>x. F (\\<gamma>1 x) \\<bullet> b * (vector_derivative \\<gamma>1  (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))", "using integral_unique[OF e] integral_unique[OF f]"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b)) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>1 x) \\<bullet> b *\n         (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))", "by metis"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "moreover"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "have \"integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 (\\<phi> x)) \\<bullet> b * (vector_derivative (\\<gamma>2 \\<circ> \\<phi>) (at x within {0..1}) \\<bullet> b)) =\n                         integral ({0..1}) (\\<lambda>x. F (\\<gamma>2 x) \\<bullet> b * (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "using b d phi"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {\\<phi> 0..\\<phi> 1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       D x *\n       (F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n        (vector_derivative \\<gamma>2 (at (\\<phi> x) within {0..1}) \\<bullet>\n         b))) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b))\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n         (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n           (at x within {0..1}) \\<bullet>\n          b)) =\n    integral {0..1}\n     (\\<lambda>x.\n         F (\\<gamma>2 x) \\<bullet> b *\n         (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "by (auto simp add:)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "ultimately"], ["proof (chain)\npicking this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))", "show \"line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\""], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "using phi"], ["proof (prove)\nusing this:\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>1 x) \\<bullet> b *\n       (vector_derivative \\<gamma>1 (at x within {0..1}) \\<bullet> b))\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 (\\<phi> x)) \\<bullet> b *\n       (vector_derivative (\\<gamma>2 \\<circ> \\<phi>)\n         (at x within {0..1}) \\<bullet>\n        b)) =\n  integral {0..1}\n   (\\<lambda>x.\n       F (\\<gamma>2 x) \\<bullet> b *\n       (vector_derivative \\<gamma>2 (at x within {0..1}) \\<bullet> b))\n  \\<forall>x\\<in>{0..1}. \\<gamma>1 x = (\\<gamma>2 \\<circ> \\<phi>) x\n  \\<phi> piecewise_C1_differentiable_on {0..1}\n  \\<phi> 0 = 0\n  \\<phi> 1 = 1\n  \\<phi> ` {0..1} = {0..1}\n\ngoal (1 subgoal):\n 1. line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2", "by(auto simp add: line_integral_def)"], ["proof (state)\nthis:\n  line_integral F {b} \\<gamma>1 = line_integral F {b} \\<gamma>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_sum_basis:\n  assumes \"finite (basis::('a::euclidean_space) set)\"  \"\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>\"\n  shows \"line_integral F basis \\<gamma> = (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\"\n        \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>) &&&\n    line_integral_exists F basis \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  finite basis\n  \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>) &&&\n    line_integral_exists F basis \\<gamma>", "proof(induction basis)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n    line_integral F {} \\<gamma> =\n    (\\<Sum>b\\<in>{}. line_integral F {b} \\<gamma>)\n 2. \\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n    line_integral_exists F {} \\<gamma>\n 3. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 4. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "show \"line_integral F {} \\<gamma> = (\\<Sum>b\\<in>{}. line_integral F {b} \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F {} \\<gamma> =\n    (\\<Sum>b\\<in>{}. line_integral F {b} \\<gamma>)", "by(auto simp add: line_integral_def)"], ["proof (state)\nthis:\n  line_integral F {} \\<gamma> =\n  (\\<Sum>b\\<in>{}. line_integral F {b} \\<gamma>)\n\ngoal (3 subgoals):\n 1. \\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n    line_integral_exists F {} \\<gamma>\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 3. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "show \"\\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow> line_integral_exists F {} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n    line_integral_exists F {} \\<gamma>", "by(simp add: line_integral_exists_def integrable_0)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>{}. line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral_exists F {} \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "fix basis::\"('a::euclidean_space) set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "fix x::\"'a::euclidean_space\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "fix  \\<gamma>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "assume ind_hyp: \"(\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma> \\<Longrightarrow> line_integral_exists F basis \\<gamma>)\"\n    \"(\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma> \\<Longrightarrow> line_integral F basis \\<gamma> = (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>))\""], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "assume step: \"finite basis\"\n    \"x \\<notin> basis\"\n    \"\\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>\""], ["proof (state)\nthis:\n  finite basis\n  x \\<notin> basis\n  \\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "then"], ["proof (chain)\npicking this:\n  finite basis\n  x \\<notin> basis\n  \\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>", "have 0: \"line_integral_exists F {x} \\<gamma>\""], ["proof (prove)\nusing this:\n  finite basis\n  x \\<notin> basis\n  \\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F {x} \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F {x} \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "have 1:\"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using ind_hyp step"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n  finite basis\n  x \\<notin> basis\n  \\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral_exists F (insert x Fa) \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F (insert x basis) \\<gamma>\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F (insert x basis) \\<gamma>", "using step(1) step(2) line_integral_sum_gen(2)[OF _ 0 1]"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma>\n  finite basis\n  x \\<notin> basis\n  \\<lbrakk>finite ?basis; {x} \\<union> basis = ?basis;\n   {x} \\<inter> basis = {}\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F ?basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F (insert x basis) \\<gamma>", "by simp"], ["proof (state)\nthis:\n  line_integral_exists F (insert x basis) \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)", "have 3: \"finite (insert x basis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (insert x basis)", "using step(1)"], ["proof (prove)\nusing this:\n  finite basis\n\ngoal (1 subgoal):\n 1. finite (insert x basis)", "by auto"], ["proof (state)\nthis:\n  finite (insert x basis)\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)", "have \"line_integral F basis \\<gamma> = (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)", "using ind_hyp step"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n  finite basis\n  x \\<notin> basis\n  \\<forall>b\\<in>insert x basis. line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral F Fa \\<gamma> =\n        (\\<Sum>b\\<in>Fa. line_integral F {b} \\<gamma>);\n        \\<forall>b\\<in>Fa.\n           line_integral_exists F {b} \\<gamma> \\<Longrightarrow>\n        line_integral_exists F Fa \\<gamma>;\n        \\<forall>b\\<in>insert x Fa.\n           line_integral_exists F {b} \\<gamma>\\<rbrakk>\n       \\<Longrightarrow> line_integral F (insert x Fa) \\<gamma> =\n                         (\\<Sum>b\\<in>insert x Fa.\n                            line_integral F {b} \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)", "show \"line_integral F (insert x basis) \\<gamma> = (\\<Sum>b\\<in>insert x basis. line_integral F {b} \\<gamma>)\""], ["proof (prove)\nusing this:\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F (insert x basis) \\<gamma> =\n    (\\<Sum>b\\<in>insert x basis. line_integral F {b} \\<gamma>)", "using step(1) step(2) line_integral_sum_gen(1)[OF 3 0 1]"], ["proof (prove)\nusing this:\n  line_integral F basis \\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral F {b} \\<gamma>)\n  finite basis\n  x \\<notin> basis\n  \\<lbrakk>{x} \\<union> basis = insert x basis;\n   {x} \\<inter> basis = {}\\<rbrakk>\n  \\<Longrightarrow> line_integral F (insert x basis) \\<gamma> =\n                    line_integral F {x} \\<gamma> +\n                    line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F (insert x basis) \\<gamma> =\n    (\\<Sum>b\\<in>insert x basis. line_integral F {b} \\<gamma>)", "by force"], ["proof (state)\nthis:\n  line_integral F (insert x basis) \\<gamma> =\n  (\\<Sum>b\\<in>insert x basis. line_integral F {b} \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reparam_weak_eq_line_integrals_basis:\n  assumes \"reparam_weak \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities*)\n    \"\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n  shows \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\"\n    \"line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2 &&&\n    line_integral_exists F basis \\<gamma>1", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\n 2. line_integral_exists F basis \\<gamma>1", "show \"line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>1", "using reparam_weak_eq_line_integrals(2)[OF assms(1) assms(2)] assms(3-4) line_integral_sum_basis(2)[OF assms(4)]"], ["proof (prove)\nusing this:\n  continuous_on (path_image \\<gamma>2)\n   (\\<lambda>x. ?F x \\<bullet> ?b) \\<Longrightarrow>\n  line_integral_exists ?F {?b} \\<gamma>1\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  \\<forall>b\\<in>basis.\n     line_integral_exists ?F {b} ?\\<gamma> \\<Longrightarrow>\n  line_integral_exists ?F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>1", "by(simp add: subset_iff)"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "show \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "using reparam_weak_eq_line_integrals[OF assms(1) assms(2)] assms(3-4) line_integral_sum_basis(1)[OF assms(4)]\n      line_integral_exists_smooth_one_base[OF assms(2)]"], ["proof (prove)\nusing this:\n  continuous_on (path_image \\<gamma>2)\n   (\\<lambda>x. ?F x \\<bullet> ?b) \\<Longrightarrow>\n  line_integral ?F {?b} \\<gamma>1 = line_integral ?F {?b} \\<gamma>2\n  continuous_on (path_image \\<gamma>2)\n   (\\<lambda>x. ?F x \\<bullet> ?b) \\<Longrightarrow>\n  line_integral_exists ?F {?b} \\<gamma>1\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  \\<forall>b\\<in>basis.\n     line_integral_exists ?F {b} ?\\<gamma> \\<Longrightarrow>\n  line_integral ?F basis ?\\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral ?F {b} ?\\<gamma>)\n  continuous_on (path_image \\<gamma>2)\n   (\\<lambda>x. ?F x \\<bullet> ?b) \\<Longrightarrow>\n  line_integral_exists ?F {?b} \\<gamma>2\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "by(simp add: subset_iff)"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reparam_eq_line_integrals_basis:\n  assumes \"reparam \\<gamma>1 \\<gamma>2\"\n    \"\\<gamma>2 piecewise_C1_differentiable_on {0..1}\" \n    \"\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n    \"\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\" (*We need to remove this and work on special cases like conservative fields and field/line combinations that satisfy the improper integrals theorem assumptions*)\n  shows \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\"\n    \"line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2 &&&\n    line_integral_exists F basis \\<gamma>1", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\n 2. line_integral_exists F basis \\<gamma>1", "show \"line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>1", "using reparam_eq_line_integrals(2)[OF assms(1) assms(2)] assms(3-5) line_integral_sum_basis(2)[OF assms(4)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on (path_image \\<gamma>2)\n            (\\<lambda>x. ?F x \\<bullet> ?b);\n   line_integral_exists ?F {?b} \\<gamma>2\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F {?b} \\<gamma>1\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists ?F {b} ?\\<gamma> \\<Longrightarrow>\n  line_integral_exists ?F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>1", "by(simp add: subset_iff)"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "show \"line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "using reparam_eq_line_integrals[OF assms(1) assms(2)] assms(3-5) line_integral_sum_basis(1)[OF assms(4)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on (path_image \\<gamma>2)\n            (\\<lambda>x. ?F x \\<bullet> ?b);\n   line_integral_exists ?F {?b} \\<gamma>2\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F {?b} \\<gamma>1 =\n                    line_integral ?F {?b} \\<gamma>2\n  \\<lbrakk>continuous_on (path_image \\<gamma>2)\n            (\\<lambda>x. ?F x \\<bullet> ?b);\n   line_integral_exists ?F {?b} \\<gamma>2\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F {?b} \\<gamma>1\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists ?F {b} ?\\<gamma> \\<Longrightarrow>\n  line_integral ?F basis ?\\<gamma> =\n  (\\<Sum>b\\<in>basis. line_integral ?F {b} ?\\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2", "by(simp add: subset_iff)"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma>1 = line_integral F basis \\<gamma>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma line_integral_exists_smooth:\n  assumes \"\\<gamma> C1_differentiable_on {0..1}\" (*To generalise this to valid_path we need a version of has_integral_substitution_strong that allows finite discontinuities*)\n    \"\\<forall>(b::'a::euclidean_space) \\<in>basis. continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"\n  shows \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "using reparam_weak_eq_line_integrals_basis(2)[OF reparam_weak_eq_refl[where ?\\<gamma>1.0 = \\<gamma>]] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<gamma> C1_differentiable_on {0..1};\n   \\<forall>b\\<in>?basis.\n      continuous_on (path_image \\<gamma>) (\\<lambda>x. ?F x \\<bullet> b);\n   finite ?basis\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis \\<gamma>\n  \\<gamma> C1_differentiable_on {0..1}\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "by fastforce"], ["", "lemma smooth_path_imp_reverse:\n  assumes \"g C1_differentiable_on {0..1}\"\n  shows \"(reversepath g) C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath g C1_differentiable_on {0..1}", "using assms continuous_on_const"], ["proof (prove)\nusing this:\n  g C1_differentiable_on {0..1}\n  continuous_on ?s (\\<lambda>x. ?c)\n\ngoal (1 subgoal):\n 1. reversepath g C1_differentiable_on {0..1}", "apply (auto simp: reversepath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. g C1_differentiable_on {0..1} \\<Longrightarrow>\n    (\\<lambda>x. g (1 - x)) C1_differentiable_on {0..1}", "apply (rule C1_differentiable_compose [of \"\\<lambda>x::real. 1-x\" _ g, unfolded o_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. g C1_differentiable_on {0..1} \\<Longrightarrow>\n    (-) 1 C1_differentiable_on {0..1}\n 2. g C1_differentiable_on {0..1} \\<Longrightarrow>\n    g C1_differentiable_on (-) 1 ` {0..1}\n 3. \\<And>x.\n       g C1_differentiable_on {0..1} \\<Longrightarrow>\n       finite ({0..1} \\<inter> (-) 1 -` {x})", "apply (auto simp: C1_differentiable_on_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>{0..1}. g differentiable at x;\n        continuous_on {0..1}\n         (\\<lambda>x. vector_derivative g (at x))\\<rbrakk>\n       \\<Longrightarrow> finite ({0..1} \\<inter> (-) 1 -` {x})", "apply (simp add: finite_vimageI inj_on_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma piecewise_smooth_path_imp_reverse:\n  assumes \"g piecewise_C1_differentiable_on {0..1}\"\n  shows \"(reversepath g) piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath g piecewise_C1_differentiable_on {0..1}", "using assms valid_path_reversepath"], ["proof (prove)\nusing this:\n  g piecewise_C1_differentiable_on {0..1}\n  valid_path (reversepath ?g) = valid_path ?g\n\ngoal (1 subgoal):\n 1. reversepath g piecewise_C1_differentiable_on {0..1}", "using valid_path_def"], ["proof (prove)\nusing this:\n  g piecewise_C1_differentiable_on {0..1}\n  valid_path (reversepath ?g) = valid_path ?g\n  valid_path ?f \\<equiv> ?f piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. reversepath g piecewise_C1_differentiable_on {0..1}", "by blast"], ["", "definition chain_reparam_weak_chain where\n  \"chain_reparam_weak_chain one_chain1 one_chain2 \\<equiv>\n      \\<exists>f. bij f \\<and> f ` one_chain1 = one_chain2 \\<and> (\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = fst (f(k,\\<gamma>)) then reparam_weak \\<gamma> (snd (f(k,\\<gamma>))) else reparam_weak \\<gamma> (reversepath (snd (f(k,\\<gamma>)))))\""], ["", "lemma chain_reparam_weak_chain_line_integral:\n  assumes \"chain_reparam_weak_chain one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 C1_differentiable_on {0..1}\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2.\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n  and bound1: \"boundary_chain one_chain1\"\n  and bound2: \"boundary_chain one_chain2\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "obtain f where f: \"bij f\"\n    \"(\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = fst (f(k,\\<gamma>)) then reparam_weak \\<gamma> (snd (f(k,\\<gamma>))) else reparam_weak \\<gamma> (reversepath (snd (f(k,\\<gamma>)))))\"\n    \"f ` one_chain1 = one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij f;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = fst (f (k, \\<gamma>))\n            then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n            else reparam_weak \\<gamma>\n                  (reversepath (snd (f (k, \\<gamma>))));\n         f ` one_chain1 = one_chain2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  chain_reparam_weak_chain one_chain1 one_chain2\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij f;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = fst (f (k, \\<gamma>))\n            then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n            else reparam_weak \\<gamma>\n                  (reversepath (snd (f (k, \\<gamma>))));\n         f ` one_chain1 = one_chain2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: chain_reparam_weak_chain_def)"], ["proof (state)\nthis:\n  bij f\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam_weak \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n  f ` one_chain1 = one_chain2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 0:\" \\<forall>x\\<in>one_chain1. (case x of (k, \\<gamma>) \\<Rightarrow> (real_of_int k * line_integral F basis \\<gamma>) = (case f x of (k, \\<gamma>) \\<Rightarrow> real_of_int k * line_integral F basis \\<gamma>) \\<and>\n                                                        line_integral_exists F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1.\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "fix k1 \\<gamma>1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "assume ass1: \"(k1,\\<gamma>1) \\<in>one_chain1\""], ["proof (state)\nthis:\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case (f (k1,\\<gamma>1)) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                      line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass2: \"k1 = 1\""], ["proof (state)\nthis:\n  k1 = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?k2 = \"fst (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?\\<gamma>2 = \"snd (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2\\<and>\n                              line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass3: \"?k2 = 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = 1", "have 0: \"reparam_weak \\<gamma>1 ?\\<gamma>2\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam_weak \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "by auto"], ["proof (state)\nthis:\n  reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"?\\<gamma>2 C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}", "using f(3) assms(2) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image ?\\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_weak_eq_line_integrals_basis[OF 0 1 2 assms(4)]\n              ass2 ass3"], ["proof (prove)\nusing this:\n  chain_reparam_weak_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (snd (f (k1, \\<gamma>1)))\n  line_integral_exists F basis \\<gamma>1\n  k1 = 1\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"?k2 \\<noteq> 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1", "have ass3: \"?k2 = -1\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "using bound2 ass1 f(3)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  boundary_chain one_chain2\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "by force"], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = - 1", "have 0: \"reparam_weak \\<gamma>1 (reversepath ?\\<gamma>2)\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam_weak \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"(reversepath ?\\<gamma>2) C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}", "using f(3) assms(2) ass1 smooth_path_imp_reverse"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n  ?g C1_differentiable_on {0..1} \\<Longrightarrow>\n  reversepath ?g C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image (reversepath ?\\<gamma>2)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1 path_image_reversepath"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n  path_image (reversepath ?g) = path_image ?g\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 3: \"line_integral F basis ?\\<gamma>2 = - line_integral F basis (reversepath ?\\<gamma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "have i:\"valid_path (reversepath ?\\<gamma>2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "using 1 C1_differentiable_imp_piecewise"], ["proof (prove)\nusing this:\n  reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow>\n  ?f piecewise_C1_differentiable_on ?S\n\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  valid_path (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "using line_integral_on_reverse_path(1)[OF i line_integral_exists_smooth[OF 1 2 ]] assms"], ["proof (prove)\nusing this:\n  finite basis \\<Longrightarrow>\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1)))) =\n  - line_integral F basis\n     (reversepath (reversepath (snd (f (k1, \\<gamma>1)))))\n  chain_reparam_weak_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_weak_eq_line_integrals_basis[OF 0 1 2 assms(4)]\n              ass2 ass3 3"], ["proof (prove)\nusing this:\n  chain_reparam_weak_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  line_integral_exists F basis \\<gamma>1\n  k1 = 1\n  fst (f (k1, \\<gamma>1)) = - 1\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case f (k1, \\<gamma>1) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                                   line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\nusing this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by (simp add: case_prod_beta')"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"k1 \\<noteq> 1\""], ["proof (state)\nthis:\n  k1 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  k1 \\<noteq> 1", "have ass2: \"k1 = -1\""], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k1 = - 1", "using bound1 ass1 f(3)"], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n  boundary_chain one_chain1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. k1 = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. k1 = - 1", "by force"], ["proof (state)\nthis:\n  k1 = - 1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?k2 = \"fst (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?\\<gamma>2 = \"snd (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                              line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass3: \"?k2 = 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = 1", "have 0: \"reparam_weak \\<gamma>1 (reversepath ?\\<gamma>2)\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam_weak \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  reparam_weak \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"(reversepath ?\\<gamma>2) C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}", "using f(3) assms(2) ass1 smooth_path_imp_reverse"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n  ?g C1_differentiable_on {0..1} \\<Longrightarrow>\n  reversepath ?g C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image (reversepath ?\\<gamma>2)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1 path_image_reversepath"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n  path_image (reversepath ?g) = path_image ?g\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 3: \"line_integral F basis ?\\<gamma>2 = - line_integral F basis (reversepath ?\\<gamma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "have i:\"valid_path (reversepath ?\\<gamma>2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "using 1 C1_differentiable_imp_piecewise"], ["proof (prove)\nusing this:\n  reversepath (snd (f (k1, \\<gamma>1))) C1_differentiable_on {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow>\n  ?f piecewise_C1_differentiable_on ?S\n\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  valid_path (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "using line_integral_on_reverse_path(1)[OF i line_integral_exists_smooth[OF 1 2 assms(4)]]"], ["proof (prove)\nusing this:\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1)))) =\n  - line_integral F basis\n     (reversepath (reversepath (snd (f (k1, \\<gamma>1)))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_weak_eq_line_integrals_basis[OF 0 1 2 assms(4)]\n              ass2 ass3 3"], ["proof (prove)\nusing this:\n  chain_reparam_weak_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = 1\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"?k2 \\<noteq> 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1", "have ass3: \"?k2 = -1\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "using bound2 ass1 f(3)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  boundary_chain one_chain2\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "by force"], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = - 1", "have 0: \"reparam_weak \\<gamma>1 ?\\<gamma>2\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam_weak \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam_weak \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "by auto"], ["proof (state)\nthis:\n  reparam_weak \\<gamma>1 (snd (f (k1, \\<gamma>1)))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"?\\<gamma>2 C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}", "using f(3) assms(2) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  snd (f (k1, \\<gamma>1)) C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image ?\\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_weak_eq_line_integrals_basis[OF 0 1 2 assms(4)]  ass2 ass3"], ["proof (prove)\nusing this:\n  chain_reparam_weak_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (snd (f (k1, \\<gamma>1)))\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case f (k1, \\<gamma>1) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                                   line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\nusing this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by (simp add: case_prod_beta')"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "}"], ["proof (state)\nthis:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2", "show \"\\<And>x. x \\<in> one_chain1 \\<Longrightarrow>\n                                (case x of (k, \\<gamma>) \\<Rightarrow> (real_of_int k * line_integral F basis \\<gamma>) = (case f x of (k, \\<gamma>) \\<Rightarrow> real_of_int k * line_integral F basis \\<gamma>) \\<and>\n                                                        line_integral_exists F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "by (auto simp add: case_prod_beta')"], ["proof (state)\nthis:\n  ?x \\<in> one_chain1 \\<Longrightarrow>\n  case ?x of\n  (k, \\<gamma>) \\<Rightarrow>\n    real_of_int k * line_integral F basis \\<gamma> =\n    (case f ?x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma>) \\<and>\n    line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using 0"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by(simp add: one_chain_line_integral_def sum_bij[OF f(1) _ f(3)] split_beta)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "using 0"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition chain_reparam_chain where\n  \"chain_reparam_chain one_chain1 one_chain2 \\<equiv>\n      \\<exists>f. bij f \\<and> f ` one_chain1 = one_chain2 \\<and> (\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = fst (f(k,\\<gamma>)) then reparam \\<gamma> (snd (f(k,\\<gamma>))) else reparam \\<gamma> (reversepath (snd (f(k,\\<gamma>)))))\""], ["", "definition chain_reparam_weak_path::\"((real) \\<Rightarrow> (real * real)) \\<Rightarrow> ((int * ((real) \\<Rightarrow> (real * real))) set) \\<Rightarrow> bool\" where\n  \"chain_reparam_weak_path \\<gamma> one_chain\n           \\<equiv> \\<exists>l. set l = one_chain \\<and> distinct l \\<and> reparam \\<gamma> (rec_join l) \\<and> valid_chain_list l \\<and> l \\<noteq> []\""], ["", "lemma chain_reparam_chain_line_integral:\n  assumes \"chain_reparam_chain one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 piecewise_C1_differentiable_on {0..1}\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2.\\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n  and bound1: \"boundary_chain one_chain1\"\n  and bound2: \"boundary_chain one_chain2\"\n  and line: \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. (\\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "obtain f where f: \"bij f\"\n    \"(\\<forall>(k,\\<gamma>)\\<in>one_chain1. if k = fst (f(k,\\<gamma>)) then reparam \\<gamma> (snd (f(k,\\<gamma>))) else reparam \\<gamma> (reversepath (snd (f(k,\\<gamma>)))))\"\n    \"f ` one_chain1 = one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij f;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = fst (f (k, \\<gamma>))\n            then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n            else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))));\n         f ` one_chain1 = one_chain2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij f;\n         \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n            if k = fst (f (k, \\<gamma>))\n            then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n            else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))));\n         f ` one_chain1 = one_chain2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: chain_reparam_chain_def)"], ["proof (state)\nthis:\n  bij f\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n  f ` one_chain1 = one_chain2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have integ_exist_b: \"\\<forall>(k1,\\<gamma>1)\\<in>one_chain1. \\<forall>b\\<in>basis. line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       \\<forall>b\\<in>basis.\n          line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))", "using line f"], ["proof (prove)\nusing this:\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  bij f\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       \\<forall>b\\<in>basis.\n          line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have valid_cubes: \"\\<forall>(k1,\\<gamma>1)\\<in>one_chain1. valid_path (snd (f (k1, \\<gamma>1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       valid_path (snd (f (k1, \\<gamma>1)))", "using assms(2) f(3) valid_path_def"], ["proof (prove)\nusing this:\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  f ` one_chain1 = one_chain2\n  valid_path ?f \\<equiv> ?f piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       valid_path (snd (f (k1, \\<gamma>1)))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     valid_path (snd (f (k1, \\<gamma>1)))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have integ_rev_exist_b: \"\\<forall>(k1,\\<gamma>1)\\<in>one_chain1. \\<forall>b\\<in>basis. line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       \\<forall>b\\<in>basis.\n          line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))", "using line_integral_on_reverse_path(2) integ_exist_b valid_cubes"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     valid_path (snd (f (k1, \\<gamma>1)))\n\ngoal (1 subgoal):\n 1. \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n       \\<forall>b\\<in>basis.\n          line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 0:\" \\<forall>x\\<in>one_chain1. (case x of (k, \\<gamma>) \\<Rightarrow> (real_of_int k * line_integral F basis \\<gamma>) = (case f x of (k, \\<gamma>) \\<Rightarrow> real_of_int k * line_integral F basis \\<gamma>) \\<and>\n                                                        line_integral_exists F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1.\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "fix k1 \\<gamma>1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "assume ass1: \"(k1,\\<gamma>1) \\<in>one_chain1\""], ["proof (state)\nthis:\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case (f (k1,\\<gamma>1)) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                      line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass2: \"k1 = 1\""], ["proof (state)\nthis:\n  k1 = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?k2 = \"fst (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?\\<gamma>2 = \"snd (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2\\<and>\n                              line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass3: \"?k2 = 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = 1", "have 0: \"reparam \\<gamma>1 ?\\<gamma>2\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "by auto"], ["proof (state)\nthis:\n  reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"?\\<gamma>2 piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}", "using f(3) assms(2) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image ?\\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_eq_line_integrals_basis[OF 0 1 2 assms(4)] integ_exist_b\n              ass1 ass2 ass3"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (snd (f (k1, \\<gamma>1)))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"?k2 \\<noteq> 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1", "have ass3: \"?k2 = -1\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "using bound2 ass1 f(3)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  boundary_chain one_chain2\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "by force"], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = - 1", "have 0: \"reparam \\<gamma>1 (reversepath ?\\<gamma>2)\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"(reversepath ?\\<gamma>2) piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n    {0..1}", "using f(3) assms(2) ass1 piecewise_smooth_path_imp_reverse"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n  ?g piecewise_C1_differentiable_on {0..1} \\<Longrightarrow>\n  reversepath ?g piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n    {0..1}", "by force"], ["proof (state)\nthis:\n  reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image (reversepath ?\\<gamma>2)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1 path_image_reversepath"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n  path_image (reversepath ?g) = path_image ?g\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 3: \"line_integral F basis ?\\<gamma>2 = - line_integral F basis (reversepath ?\\<gamma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "have i:\"valid_path (reversepath ?\\<gamma>2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "using 1 C1_differentiable_imp_piecewise"], ["proof (prove)\nusing this:\n  reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n  {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow>\n  ?f piecewise_C1_differentiable_on ?S\n\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  valid_path (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "have ii: \"line_integral_exists F basis (snd (f (k1, \\<gamma>1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (snd (f (k1, \\<gamma>1)))", "using assms(4) line_integral_sum_basis(2) integ_exist_b ass1"], ["proof (prove)\nusing this:\n  finite basis\n  \\<lbrakk>finite ?basis;\n   \\<forall>b\\<in>?basis. line_integral_exists ?F {b} ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (snd (f (k1, \\<gamma>1)))", "by fastforce"], ["proof (state)\nthis:\n  line_integral_exists F basis (snd (f (k1, \\<gamma>1)))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "using i ii line_integral_on_reverse_path(1) valid_path_reversepath"], ["proof (prove)\nusing this:\n  valid_path (reversepath (snd (f (k1, \\<gamma>1))))\n  line_integral_exists F basis (snd (f (k1, \\<gamma>1)))\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  valid_path (reversepath ?g) = valid_path ?g\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "by blast"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_eq_line_integrals_basis[OF 0 1 2 assms(4)] integ_rev_exist_b\n              ass1 ass2 ass3 3"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = 1\n  fst (f (k1, \\<gamma>1)) = - 1\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case f (k1, \\<gamma>1) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                                   line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\nusing this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by (simp add: case_prod_beta')"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"k1 \\<noteq> 1\""], ["proof (state)\nthis:\n  k1 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  k1 \\<noteq> 1", "have ass2: \"k1 = -1\""], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k1 = - 1", "using bound1 ass1 f(3)"], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n  boundary_chain one_chain1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. k1 = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  k1 \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. k1 = - 1", "by force"], ["proof (state)\nthis:\n  k1 = - 1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?k2 = \"fst (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "let ?\\<gamma>2 = \"snd (f (k1, \\<gamma>1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                              line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume ass3: \"?k2 = 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = 1", "have 0: \"reparam \\<gamma>1 (reversepath ?\\<gamma>2)\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))", "by auto"], ["proof (state)\nthis:\n  reparam \\<gamma>1 (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"(reversepath ?\\<gamma>2) piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n    {0..1}", "using f(3) assms(2) ass1 piecewise_smooth_path_imp_reverse"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n  ?g piecewise_C1_differentiable_on {0..1} \\<Longrightarrow>\n  reversepath ?g piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n    {0..1}", "by force"], ["proof (state)\nthis:\n  reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n  {0..1}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image (reversepath ?\\<gamma>2)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1 path_image_reversepath"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n  path_image (reversepath ?g) = path_image ?g\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (reversepath (snd (f (k1, \\<gamma>1)))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 3: \"line_integral F basis ?\\<gamma>2 = - line_integral F basis (reversepath ?\\<gamma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "have i:\"valid_path (reversepath ?\\<gamma>2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "using 1 C1_differentiable_imp_piecewise"], ["proof (prove)\nusing this:\n  reversepath (snd (f (k1, \\<gamma>1))) piecewise_C1_differentiable_on\n  {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow>\n  ?f piecewise_C1_differentiable_on ?S\n\ngoal (1 subgoal):\n 1. valid_path (reversepath (snd (f (k1, \\<gamma>1))))", "by (auto simp add: valid_path_def)"], ["proof (state)\nthis:\n  valid_path (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "using line_integral_on_reverse_path(1)[OF i] integ_rev_exist_b"], ["proof (prove)\nusing this:\n  line_integral_exists ?F ?basis\n   (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral ?F ?basis (reversepath (snd (f (k1, \\<gamma>1)))) =\n  - line_integral ?F ?basis\n     (reversepath (reversepath (snd (f (k1, \\<gamma>1)))))\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "using ass1 assms(4) line_integral_sum_basis(2)"], ["proof (prove)\nusing this:\n  line_integral_exists ?F ?basis\n   (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral ?F ?basis (reversepath (snd (f (k1, \\<gamma>1)))) =\n  - line_integral ?F ?basis\n     (reversepath (reversepath (snd (f (k1, \\<gamma>1)))))\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\n  (k1, \\<gamma>1) \\<in> one_chain1\n  finite basis\n  \\<lbrakk>finite ?basis;\n   \\<forall>b\\<in>?basis. line_integral_exists ?F {b} ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis (snd (f (k1, \\<gamma>1))) =\n    - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))", "by fastforce"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1\n 2. \\<not> ?P \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_eq_line_integrals_basis[OF 0 1 2 assms(4)]\n              ass2 ass3 3"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = 1\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using ass1 integ_rev_exist_b"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b}\n      (reversepath (snd (f (k1, \\<gamma>1)))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = 1\n  line_integral F basis (snd (f (k1, \\<gamma>1))) =\n  - line_integral F basis (reversepath (snd (f (k1, \\<gamma>1))))\n  (k1, \\<gamma>1) \\<in> one_chain1\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (reversepath (snd (f (k1, \\<gamma>1))))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "assume \"?k2 \\<noteq> 1\""], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1", "have ass3: \"?k2 = -1\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "using bound2 ass1 f(3)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  boundary_chain one_chain2\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) \\<noteq> 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. k = 1 \\<or> k = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  f ` one_chain1 = one_chain2\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) = - 1", "by force"], ["proof (state)\nthis:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  fst (f (k1, \\<gamma>1)) = - 1", "have 0: \"reparam \\<gamma>1 ?\\<gamma>2\""], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "using ass1 ass2 f(2)"], ["proof (prove)\nusing this:\n  fst (f (k1, \\<gamma>1)) = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  k1 = - 1\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     if k = fst (f (k, \\<gamma>))\n     then reparam \\<gamma> (snd (f (k, \\<gamma>)))\n     else reparam \\<gamma> (reversepath (snd (f (k, \\<gamma>))))\n\ngoal (1 subgoal):\n 1. reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))", "by auto"], ["proof (state)\nthis:\n  reparam \\<gamma>1 (snd (f (k1, \\<gamma>1)))\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 1: \"?\\<gamma>2 piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}", "using f(3) assms(2) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}", "by force"], ["proof (state)\nthis:\n  snd (f (k1, \\<gamma>1)) piecewise_C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "have 2: \"\\<forall>b\\<in>basis. continuous_on (path_image ?\\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "using f(3) assms(3) ass1"], ["proof (prove)\nusing this:\n  f ` one_chain1 = one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  (k1, \\<gamma>1) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n        (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (snd (f (k1, \\<gamma>1))))\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. fst (f (k1, \\<gamma>1)) \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = real_of_int ?k2 * line_integral F basis ?\\<gamma>2 \\<and>\n                                     line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using assms reparam_eq_line_integrals_basis[OF 0 1 2 assms(4)]\n              ass2 ass3"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (snd (f (k1, \\<gamma>1)))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = - 1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "using ass1 integ_exist_b"], ["proof (prove)\nusing this:\n  chain_reparam_chain one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 piecewise_C1_differentiable_on {0..1}\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis. line_integral_exists F {b} \\<gamma>2\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral F basis \\<gamma>1 =\n  line_integral F basis (snd (f (k1, \\<gamma>1)))\n  \\<forall>b\\<in>basis.\n     line_integral_exists F {b} (snd (f (k1, \\<gamma>1))) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>1\n  k1 = - 1\n  fst (f (k1, \\<gamma>1)) = - 1\n  (k1, \\<gamma>1) \\<in> one_chain1\n  \\<forall>(k1, \\<gamma>1)\\<in>one_chain1.\n     \\<forall>b\\<in>basis.\n        line_integral_exists F {b} (snd (f (k1, \\<gamma>1)))\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    real_of_int (fst (f (k1, \\<gamma>1))) *\n    line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by auto"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> 1 \\<Longrightarrow>\n    real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "then"], ["proof (chain)\npicking this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1", "show \"real_of_int k1 * line_integral F basis \\<gamma>1 = (case f (k1, \\<gamma>1) of (k2, \\<gamma>2) \\<Rightarrow> real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n                                   line_integral_exists F basis \\<gamma>1\""], ["proof (prove)\nusing this:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  real_of_int (fst (f (k1, \\<gamma>1))) *\n  line_integral F basis (snd (f (k1, \\<gamma>1))) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. real_of_int k1 * line_integral F basis \\<gamma>1 =\n    (case f (k1, \\<gamma>1) of\n     (k2, \\<gamma>2) \\<Rightarrow>\n       real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n    line_integral_exists F basis \\<gamma>1", "by (simp add: case_prod_beta')"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int k1 * line_integral F basis \\<gamma>1 =\n  (case f (k1, \\<gamma>1) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis \\<gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "}"], ["proof (state)\nthis:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2", "show \"\\<And>x. x \\<in> one_chain1 \\<Longrightarrow>\n                                (case x of (k, \\<gamma>) \\<Rightarrow> (real_of_int k * line_integral F basis \\<gamma>) = (case f x of (k, \\<gamma>) \\<Rightarrow> real_of_int k * line_integral F basis \\<gamma>) \\<and>\n                                                        line_integral_exists F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  (?k1.2, ?\\<gamma>1.2) \\<in> one_chain1 \\<Longrightarrow>\n  real_of_int ?k1.2 * line_integral F basis ?\\<gamma>1.2 =\n  (case f (?k1.2, ?\\<gamma>1.2) of\n   (k2, \\<gamma>2) \\<Rightarrow>\n     real_of_int k2 * line_integral F basis \\<gamma>2) \\<and>\n  line_integral_exists F basis ?\\<gamma>1.2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> one_chain1 \\<Longrightarrow>\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         real_of_int k * line_integral F basis \\<gamma> =\n         (case f x of\n          (k, \\<gamma>) \\<Rightarrow>\n            real_of_int k * line_integral F basis \\<gamma>) \\<and>\n         line_integral_exists F basis \\<gamma>", "by (auto simp add: case_prod_beta')"], ["proof (state)\nthis:\n  ?x \\<in> one_chain1 \\<Longrightarrow>\n  case ?x of\n  (k, \\<gamma>) \\<Rightarrow>\n    real_of_int k * line_integral F basis \\<gamma> =\n    (case f ?x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma>) \\<and>\n    line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using 0"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by (simp add: one_chain_line_integral_def sum_bij[OF f(1) _ f(3)] prod.case_eq_if)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "using 0"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>one_chain1.\n     case x of\n     (k, \\<gamma>) \\<Rightarrow>\n       real_of_int k * line_integral F basis \\<gamma> =\n       (case f x of\n        (k, \\<gamma>) \\<Rightarrow>\n          real_of_int k * line_integral F basis \\<gamma>) \\<and>\n       line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_image_rec_join:\n  fixes \\<gamma>::\"real \\<Rightarrow> (real \\<times> real)\"\n  fixes k::int\n  fixes l\n  shows \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_chain_list l \\<Longrightarrow> path_image \\<gamma> \\<subseteq> path_image (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> set l; valid_chain_list l\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join l)", "proof(induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> set []; valid_chain_list []\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join [])\n 2. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "case Nil"], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> set []\n  valid_chain_list []\n\ngoal (2 subgoals):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> set []; valid_chain_list []\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join [])\n 2. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> set []\n  valid_chain_list []", "show ?case"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> set []\n  valid_chain_list []\n\ngoal (1 subgoal):\n 1. path_image \\<gamma> \\<subseteq> path_image (rec_join [])", "by auto"], ["proof (state)\nthis:\n  path_image \\<gamma> \\<subseteq> path_image (rec_join [])\n\ngoal (1 subgoal):\n 1. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "case ass: (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> set l; valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> path_image ?\\<gamma> \\<subseteq> path_image (rec_join l)\n  (k, \\<gamma>) \\<in> set (a # l)\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "obtain k' \\<gamma>' where a: \"a = (k',\\<gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' \\<gamma>'.\n        a = (k', \\<gamma>') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "have \"path_image \\<gamma> \\<subseteq> path_image (rec_join ((k',\\<gamma>') # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n 2. \\<not> ?P \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "assume \"l=[]\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n 2. \\<not> ?P \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "then"], ["proof (chain)\npicking this:\n  l = []", "show \"path_image \\<gamma> \\<subseteq> path_image (rec_join ((k',\\<gamma>') # l))\""], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "using ass(2-3) a"], ["proof (prove)\nusing this:\n  l = []\n  (k, \\<gamma>) \\<in> set (a # l)\n  valid_chain_list (a # l)\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "by(auto simp add:)"], ["proof (state)\nthis:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "assume \"l\\<noteq>[]\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain b l' where b_l: \"l = b # l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>b l'. l = b # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = b # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "obtain k'' \\<gamma>'' where b: \"b = (k'',\\<gamma>'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'' \\<gamma>''.\n        b = (k'', \\<gamma>'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  b = (k'', \\<gamma>'')\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "using ass path_image_reversepath b_l path_image_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> set l; valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> path_image ?\\<gamma> \\<subseteq> path_image (rec_join l)\n  (k, \\<gamma>) \\<in> set (a # l)\n  valid_chain_list (a # l)\n  path_image (reversepath ?g) = path_image ?g\n  l = b # l'\n  pathfinish ?g1.0 = pathstart ?g2.0 \\<Longrightarrow>\n  path_image (?g1.0 +++ ?g2.0) = path_image ?g1.0 \\<union> path_image ?g2.0\n\ngoal (1 subgoal):\n 1. path_image \\<gamma>\n    \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "by(fastforce simp add: a)"], ["proof (state)\nthis:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l k \\<gamma>.\n       \\<lbrakk>\\<And>k \\<gamma>.\n                   \\<lbrakk>(k, \\<gamma>) \\<in> set l;\n                    valid_chain_list l\\<rbrakk>\n                   \\<Longrightarrow> path_image \\<gamma>\n                                     \\<subseteq> path_image (rec_join l);\n        (k, \\<gamma>) \\<in> set (a # l); valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image \\<gamma>\n                         \\<subseteq> path_image (rec_join (a # l))", "then"], ["proof (chain)\npicking this:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))", "show ?case"], ["proof (prove)\nusing this:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n\ngoal (1 subgoal):\n 1. path_image \\<gamma> \\<subseteq> path_image (rec_join (a # l))", "using a"], ["proof (prove)\nusing this:\n  path_image \\<gamma>\n  \\<subseteq> path_image (rec_join ((k', \\<gamma>') # l))\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. path_image \\<gamma> \\<subseteq> path_image (rec_join (a # l))", "by auto"], ["proof (state)\nthis:\n  path_image \\<gamma> \\<subseteq> path_image (rec_join (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_image_rec_join_2:\n  fixes l\n  shows \"l \\<noteq> [] \\<Longrightarrow> valid_chain_list l \\<Longrightarrow> path_image (rec_join l) \\<subseteq> (\\<Union>(k, \\<gamma>) \\<in> set l. path_image \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n    \\<Longrightarrow> path_image (rec_join l)\n                      \\<subseteq> (\\<Union>(k, \\<gamma>)\\<in>set l.\npath_image \\<gamma>)", "proof(induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; valid_chain_list []\\<rbrakk>\n    \\<Longrightarrow> path_image (rec_join [])\n                      \\<subseteq> (\\<Union>(k, y)\\<in>set []. path_image y)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n  valid_chain_list []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; valid_chain_list []\\<rbrakk>\n    \\<Longrightarrow> path_image (rec_join [])\n                      \\<subseteq> (\\<Union>(k, y)\\<in>set []. path_image y)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "then"], ["proof (chain)\npicking this:\n  [] \\<noteq> []\n  valid_chain_list []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n  valid_chain_list []\n\ngoal (1 subgoal):\n 1. path_image (rec_join [])\n    \\<subseteq> (\\<Union>a\\<in>set [].\n                    case a of (k, a) \\<Rightarrow> path_image a)", "by auto"], ["proof (state)\nthis:\n  path_image (rec_join [])\n  \\<subseteq> (\\<Union>a\\<in>set [].\n                  case a of (k, a) \\<Rightarrow> path_image a)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "case ass: (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> path_image (rec_join l)\n                    \\<subseteq> (\\<Union>a\\<in>set l.\n                                    case a of\n                                    (k, a) \\<Rightarrow> path_image a)\n  a # l \\<noteq> []\n  valid_chain_list (a # l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "obtain k' \\<gamma>' where a: \"a = (k',\\<gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' \\<gamma>'.\n        a = (k', \\<gamma>') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "have \"path_image (rec_join (a # l)) \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n 2. \\<not> ?P \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "assume \"l=[]\""], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n 2. \\<not> ?P \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "then"], ["proof (chain)\npicking this:\n  l = []", "show \"path_image (rec_join (a # l)) \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\""], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "using step a"], ["proof (prove)\nusing this:\n  l = []\n  ?x \\<in> ccpo_class.iterates ?f \\<Longrightarrow>\n  ?f ?x \\<in> ccpo_class.iterates ?f\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "by(auto simp add:)"], ["proof (state)\nthis:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "assume \"l\\<noteq>[]\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> []", "obtain b l' where b_l: \"l = b # l'\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>b l'. l = b # l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rec_join.elims)"], ["proof (state)\nthis:\n  l = b # l'\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "obtain k'' \\<gamma>'' where b: \"b = (k'',\\<gamma>'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'' \\<gamma>''.\n        b = (k'', \\<gamma>'') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  b = (k'', \\<gamma>'')\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "using ass\n        path_image_reversepath b_l path_image_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n  \\<Longrightarrow> path_image (rec_join l)\n                    \\<subseteq> (\\<Union>a\\<in>set l.\n                                    case a of\n                                    (k, a) \\<Rightarrow> path_image a)\n  a # l \\<noteq> []\n  valid_chain_list (a # l)\n  path_image (reversepath ?g) = path_image ?g\n  l = b # l'\n  pathfinish ?g1.0 = pathstart ?g2.0 \\<Longrightarrow>\n  path_image (?g1.0 +++ ?g2.0) = path_image ?g1.0 \\<union> path_image ?g2.0\n\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "apply(auto simp add: a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba k baa.\n       \\<lbrakk>path_image (rec_join ((k, baa) # l'))\n                \\<subseteq> path_image baa \\<union>\n                            (\\<Union>x\\<in>set l'.\n                                case x of\n                                (k, x) \\<Rightarrow> path_image x);\n        l = (k, baa) # l';\n        \\<And>g1 g2.\n           pathfinish g1 = pathstart g2 \\<Longrightarrow>\n           path_image (g1 +++ g2) = path_image g1 \\<union> path_image g2;\n        pathfinish \\<gamma>' = pathstart (rec_join ((k, baa) # l'));\n        valid_chain_list ((k, baa) # l'); k' = 1;\n        (a, ba) \\<in> path_image (\\<gamma>' +++ rec_join ((k, baa) # l'));\n        (a, ba) \\<notin> path_image \\<gamma>';\n        \\<forall>x\\<in>set l'.\n           (a, ba) \\<notin> (case x of (k, x) \\<Rightarrow> path_image x);\n        b = (k, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> path_image baa\n 2. \\<And>a ba k baa.\n       \\<lbrakk>path_image (rec_join ((k, baa) # l'))\n                \\<subseteq> path_image baa \\<union>\n                            (\\<Union>x\\<in>set l'.\n                                case x of\n                                (k, x) \\<Rightarrow> path_image x);\n        l = (k, baa) # l';\n        \\<And>g1 g2.\n           pathfinish g1 = pathstart g2 \\<Longrightarrow>\n           path_image (g1 +++ g2) = path_image g1 \\<union> path_image g2;\n        pathstart \\<gamma>' = pathstart (rec_join ((k, baa) # l'));\n        valid_chain_list ((k, baa) # l'); k' \\<noteq> 1;\n        (a, ba)\n        \\<in> path_image\n               (reversepath \\<gamma>' +++ rec_join ((k, baa) # l'));\n        (a, ba) \\<notin> path_image \\<gamma>';\n        \\<forall>x\\<in>set l'.\n           (a, ba) \\<notin> (case x of (k, x) \\<Rightarrow> path_image x);\n        b = (k, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> path_image baa", "(*Excuse the ugliness of the next script*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba k baa.\n       \\<lbrakk>path_image (rec_join ((k, baa) # l'))\n                \\<subseteq> path_image baa \\<union>\n                            (\\<Union>x\\<in>set l'.\n                                case x of\n                                (k, x) \\<Rightarrow> path_image x);\n        l = (k, baa) # l';\n        \\<And>g1 g2.\n           pathfinish g1 = pathstart g2 \\<Longrightarrow>\n           path_image (g1 +++ g2) = path_image g1 \\<union> path_image g2;\n        pathfinish \\<gamma>' = pathstart (rec_join ((k, baa) # l'));\n        valid_chain_list ((k, baa) # l'); k' = 1;\n        (a, ba) \\<in> path_image (\\<gamma>' +++ rec_join ((k, baa) # l'));\n        (a, ba) \\<notin> path_image \\<gamma>';\n        \\<forall>x\\<in>set l'.\n           (a, ba) \\<notin> (case x of (k, x) \\<Rightarrow> path_image x);\n        b = (k, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> path_image baa\n 2. \\<And>a ba k baa.\n       \\<lbrakk>path_image (rec_join ((k, baa) # l'))\n                \\<subseteq> path_image baa \\<union>\n                            (\\<Union>x\\<in>set l'.\n                                case x of\n                                (k, x) \\<Rightarrow> path_image x);\n        l = (k, baa) # l';\n        \\<And>g1 g2.\n           pathfinish g1 = pathstart g2 \\<Longrightarrow>\n           path_image (g1 +++ g2) = path_image g1 \\<union> path_image g2;\n        pathstart \\<gamma>' = pathstart (rec_join ((k, baa) # l'));\n        valid_chain_list ((k, baa) # l'); k' \\<noteq> 1;\n        (a, ba)\n        \\<in> path_image\n               (reversepath \\<gamma>' +++ rec_join ((k, baa) # l'));\n        (a, ba) \\<notin> path_image \\<gamma>';\n        \\<forall>x\\<in>set l'.\n           (a, ba) \\<notin> (case x of (k, x) \\<Rightarrow> path_image x);\n        b = (k, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> path_image baa", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba k baa.\n       \\<lbrakk>path_image (rec_join ((k, baa) # l'))\n                \\<subseteq> path_image baa \\<union>\n                            (\\<Union>x\\<in>set l'.\n                                case x of\n                                (k, x) \\<Rightarrow> path_image x);\n        l = (k, baa) # l';\n        \\<And>g1 g2.\n           pathfinish g1 = pathstart g2 \\<Longrightarrow>\n           path_image (g1 +++ g2) = path_image g1 \\<union> path_image g2;\n        pathstart \\<gamma>' = pathstart (rec_join ((k, baa) # l'));\n        valid_chain_list ((k, baa) # l'); k' \\<noteq> 1;\n        (a, ba)\n        \\<in> path_image\n               (reversepath \\<gamma>' +++ rec_join ((k, baa) # l'));\n        (a, ba) \\<notin> path_image \\<gamma>';\n        \\<forall>x\\<in>set l'.\n           (a, ba) \\<notin> (case x of (k, x) \\<Rightarrow> path_image x);\n        b = (k, baa)\\<rbrakk>\n       \\<Longrightarrow> (a, ba) \\<in> path_image baa", "by fastforce"], ["proof (state)\nthis:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>l \\<noteq> []; valid_chain_list l\\<rbrakk>\n                \\<Longrightarrow> path_image (rec_join l)\n                                  \\<subseteq> (\\<Union>(k, y)\\<in>set l.\n            path_image y);\n        a # l \\<noteq> []; valid_chain_list (a # l)\\<rbrakk>\n       \\<Longrightarrow> path_image (rec_join (a # l))\n                         \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l).\n   path_image y)", "then"], ["proof (chain)\npicking this:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)", "show ?case"], ["proof (prove)\nusing this:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>a\\<in>set (a # l).\n                    case a of (k, a) \\<Rightarrow> path_image a)", "using a"], ["proof (prove)\nusing this:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>(k, y)\\<in>set (a # l). path_image y)\n  a = (k', \\<gamma>')\n\ngoal (1 subgoal):\n 1. path_image (rec_join (a # l))\n    \\<subseteq> (\\<Union>a\\<in>set (a # l).\n                    case a of (k, a) \\<Rightarrow> path_image a)", "by auto"], ["proof (state)\nthis:\n  path_image (rec_join (a # l))\n  \\<subseteq> (\\<Union>a\\<in>set (a # l).\n                  case a of (k, a) \\<Rightarrow> path_image a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_closed_UN:\n  assumes \"finite S\"\n  shows \"((\\<And>s. s \\<in> S \\<Longrightarrow> closed s) \\<Longrightarrow> (\\<And>s. s \\<in> S \\<Longrightarrow> continuous_on s f) \\<Longrightarrow> continuous_on (\\<Union>S) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s. s \\<in> S \\<Longrightarrow> closed s;\n     \\<And>s. s \\<in> S \\<Longrightarrow> continuous_on s f\\<rbrakk>\n    \\<Longrightarrow> continuous_on (\\<Union> S) f", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s. s \\<in> S \\<Longrightarrow> closed s;\n     \\<And>s. s \\<in> S \\<Longrightarrow> continuous_on s f\\<rbrakk>\n    \\<Longrightarrow> continuous_on (\\<Union> S) f", "proof(induction S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s. s \\<in> {} \\<Longrightarrow> closed s;\n     \\<And>s. s \\<in> {} \\<Longrightarrow> continuous_on s f\\<rbrakk>\n    \\<Longrightarrow> continuous_on (\\<Union> {}) f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n         \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n        \\<Longrightarrow> continuous_on (\\<Union> F) f;\n        \\<And>s. s \\<in> insert x F \\<Longrightarrow> closed s;\n        \\<And>s.\n           s \\<in> insert x F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n       \\<Longrightarrow> continuous_on (\\<Union> (insert x F)) f", "case empty"], ["proof (state)\nthis:\n  ?s \\<in> {} \\<Longrightarrow> closed ?s\n  ?s \\<in> {} \\<Longrightarrow> continuous_on ?s f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s. s \\<in> {} \\<Longrightarrow> closed s;\n     \\<And>s. s \\<in> {} \\<Longrightarrow> continuous_on s f\\<rbrakk>\n    \\<Longrightarrow> continuous_on (\\<Union> {}) f\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n         \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n        \\<Longrightarrow> continuous_on (\\<Union> F) f;\n        \\<And>s. s \\<in> insert x F \\<Longrightarrow> closed s;\n        \\<And>s.\n           s \\<in> insert x F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n       \\<Longrightarrow> continuous_on (\\<Union> (insert x F)) f", "then"], ["proof (chain)\npicking this:\n  ?s \\<in> {} \\<Longrightarrow> closed ?s\n  ?s \\<in> {} \\<Longrightarrow> continuous_on ?s f", "show ?case"], ["proof (prove)\nusing this:\n  ?s \\<in> {} \\<Longrightarrow> closed ?s\n  ?s \\<in> {} \\<Longrightarrow> continuous_on ?s f\n\ngoal (1 subgoal):\n 1. continuous_on (\\<Union> {}) f", "by auto"], ["proof (state)\nthis:\n  continuous_on (\\<Union> {}) f\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n         \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n        \\<Longrightarrow> continuous_on (\\<Union> F) f;\n        \\<And>s. s \\<in> insert x F \\<Longrightarrow> closed s;\n        \\<And>s.\n           s \\<in> insert x F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n       \\<Longrightarrow> continuous_on (\\<Union> (insert x F)) f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n         \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n        \\<Longrightarrow> continuous_on (\\<Union> F) f;\n        \\<And>s. s \\<in> insert x F \\<Longrightarrow> closed s;\n        \\<And>s.\n           s \\<in> insert x F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n       \\<Longrightarrow> continuous_on (\\<Union> (insert x F)) f", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n   \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n  \\<Longrightarrow> continuous_on (\\<Union> F) f\n  ?s \\<in> insert x F \\<Longrightarrow> closed ?s\n  ?s \\<in> insert x F \\<Longrightarrow> continuous_on ?s f\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n         \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n        \\<Longrightarrow> continuous_on (\\<Union> F) f;\n        \\<And>s. s \\<in> insert x F \\<Longrightarrow> closed s;\n        \\<And>s.\n           s \\<in> insert x F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n       \\<Longrightarrow> continuous_on (\\<Union> (insert x F)) f", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n   \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n  \\<Longrightarrow> continuous_on (\\<Union> F) f\n  ?s \\<in> insert x F \\<Longrightarrow> closed ?s\n  ?s \\<in> insert x F \\<Longrightarrow> continuous_on ?s f", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n   \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n  \\<Longrightarrow> continuous_on (\\<Union> F) f\n  ?s \\<in> insert x F \\<Longrightarrow> closed ?s\n  ?s \\<in> insert x F \\<Longrightarrow> continuous_on ?s f\n\ngoal (1 subgoal):\n 1. continuous_on (\\<Union> (insert x F)) f", "using continuous_on_closed_Un closed_Union"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<And>s. s \\<in> F \\<Longrightarrow> closed s;\n   \\<And>s. s \\<in> F \\<Longrightarrow> continuous_on s f\\<rbrakk>\n  \\<Longrightarrow> continuous_on (\\<Union> F) f\n  ?s \\<in> insert x F \\<Longrightarrow> closed ?s\n  ?s \\<in> insert x F \\<Longrightarrow> continuous_on ?s f\n  \\<lbrakk>closed ?s; closed ?t; continuous_on ?s ?f;\n   continuous_on ?t ?f\\<rbrakk>\n  \\<Longrightarrow> continuous_on (?s \\<union> ?t) ?f\n  \\<lbrakk>finite ?S; \\<forall>T\\<in>?S. closed T\\<rbrakk>\n  \\<Longrightarrow> closed (\\<Union> ?S)\n\ngoal (1 subgoal):\n 1. continuous_on (\\<Union> (insert x F)) f", "by (simp add: closed_Union continuous_on_closed_Un)"], ["proof (state)\nthis:\n  continuous_on (\\<Union> (insert x F)) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_reparam_weak_path_line_integral:\n  assumes path_eq_chain: \"chain_reparam_weak_path \\<gamma> one_chain\" and\n    boundary_chain: \"boundary_chain one_chain\" and\n    line_integral_exists: \"\\<forall>b\\<in>basis. \\<forall>(k::int, \\<gamma>) \\<in> one_chain. line_integral_exists F {b} \\<gamma>\" and\n    valid_path: \"\\<forall>(k::int, \\<gamma>) \\<in> one_chain. valid_path \\<gamma>\" and\n    finite_basis: \"finite basis\" and \n    cont: \"\\<forall>b\\<in>basis. \\<forall>(k,\\<gamma>2)\\<in>one_chain. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\" and\n    finite_one_chain: \"finite one_chain\"\n  shows \"line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\"\n    \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain &&&\n    line_integral_exists F basis \\<gamma>", "(*\"valid_path \\<gamma>\" This cannot be proven, see the crappy assumption of derivs/eq_pw_smooth :( *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain &&&\n    line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain\n 2. line_integral_exists F basis \\<gamma>", "obtain l where l_props: \"set l = one_chain\" \"distinct l\" \"reparam \\<gamma> (rec_join l)\" \"valid_chain_list l\" \"l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l;\n         reparam \\<gamma> (rec_join l); valid_chain_list l;\n         l \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain_reparam_weak_path_def assms"], ["proof (prove)\nusing this:\n  chain_reparam_weak_path ?\\<gamma> ?one_chain \\<equiv>\n  \\<exists>l.\n     set l = ?one_chain \\<and>\n     distinct l \\<and>\n     reparam ?\\<gamma> (rec_join l) \\<and>\n     valid_chain_list l \\<and> l \\<noteq> []\n  chain_reparam_weak_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite one_chain\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>set l = one_chain; distinct l;\n         reparam \\<gamma> (rec_join l); valid_chain_list l;\n         l \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain\n 2. line_integral_exists F basis \\<gamma>", "have bchain_l: \"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "using l_props boundary_chain"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  boundary_chain one_chain\n\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by (simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain\n 2. line_integral_exists F basis \\<gamma>", "have cont_forall: \"\\<forall>b\\<in>basis. continuous_on (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on\n        (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n        (\\<lambda>x. F x \\<bullet> b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       continuous_on\n        (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n        (\\<lambda>x. F x \\<bullet> b)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       continuous_on\n        (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n        (\\<lambda>x. F x \\<bullet> b)", "assume ass: \"b \\<in> basis\""], ["proof (state)\nthis:\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       continuous_on\n        (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n        (\\<lambda>x. F x \\<bullet> b)", "have \"continuous_on (\\<Union>((path_image \\<circ> snd) ` one_chain))  (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (\\<Union> ((path_image \\<circ> snd) ` one_chain))\n     (\\<lambda>x. F x \\<bullet> b)", "apply(rule continuous_on_closed_UN[where ?S = \"(path_image o snd) ` one_chain\" ])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite ((path_image \\<circ> snd) ` one_chain)\n 2. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       closed s\n 3. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. finite one_chain\n 2. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       closed s\n 3. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "show \"finite one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite one_chain", "using finite_one_chain"], ["proof (prove)\nusing this:\n  finite one_chain\n\ngoal (1 subgoal):\n 1. finite one_chain", "by auto"], ["proof (state)\nthis:\n  finite one_chain\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       closed s\n 2. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "show \"\\<And>s. s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow> closed s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       closed s", "using  closed_valid_path_image[OF] valid_path"], ["proof (prove)\nusing this:\n  valid_path ?g \\<Longrightarrow> closed (path_image ?g)\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       closed s", "by fastforce"], ["proof (state)\nthis:\n  ?s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow> closed ?s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "show \"\\<And>s. s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow> continuous_on s (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "using cont ass"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n       continuous_on s (\\<lambda>x. F x \\<bullet> b)", "by force"], ["proof (state)\nthis:\n  ?s \\<in> (path_image \\<circ> snd) ` one_chain \\<Longrightarrow>\n  continuous_on ?s (\\<lambda>x. F x \\<bullet> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on (\\<Union> ((path_image \\<circ> snd) ` one_chain))\n   (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       continuous_on\n        (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n        (\\<lambda>x. F x \\<bullet> b)", "then"], ["proof (chain)\npicking this:\n  continuous_on (\\<Union> ((path_image \\<circ> snd) ` one_chain))\n   (\\<lambda>x. F x \\<bullet> b)", "show \"continuous_on (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\nusing this:\n  continuous_on (\\<Union> ((path_image \\<circ> snd) ` one_chain))\n   (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. continuous_on (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n     (\\<lambda>x. F x \\<bullet> b)", "by (auto simp add: Union_eq case_prod_beta)"], ["proof (state)\nthis:\n  continuous_on (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n   (\\<lambda>x. F x \\<bullet> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on\n      (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n      (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain\n 2. line_integral_exists F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma>", "proof (rule reparam_eq_line_integrals_basis[OF l_props(3) _ _  finite_basis])"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 3. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "let ?\\<gamma>2.0=\"rec_join l\""], ["proof (state)\ngoal (3 subgoals):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 3. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"?\\<gamma>2.0 piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}", "apply(simp only: valid_path_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "apply(rule joined_is_valid)"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (set l)\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. valid_chain_list l", "using assms l_props"], ["proof (prove)\nusing this:\n  chain_reparam_weak_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite one_chain\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (3 subgoals):\n 1. boundary_chain (set l)\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. valid_chain_list l", "by auto"], ["proof (state)\nthis:\n  rec_join l piecewise_C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 2. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"\\<forall>b\\<in>basis. continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "using path_image_rec_join_2[OF l_props(5) l_props(4)] l_props(1)"], ["proof (prove)\nusing this:\n  path_image (rec_join l)\n  \\<subseteq> (\\<Union>(k, \\<gamma>)\\<in>set l. path_image \\<gamma>)\n  set l = one_chain\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "using cont_forall continuous_on_subset"], ["proof (prove)\nusing this:\n  path_image (rec_join l)\n  \\<subseteq> (\\<Union>(k, \\<gamma>)\\<in>set l. path_image \\<gamma>)\n  set l = one_chain\n  \\<forall>b\\<in>basis.\n     continuous_on\n      (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n      (\\<lambda>x. F x \\<bullet> b)\n  \\<lbrakk>continuous_on ?s ?f; ?t \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?t ?f\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"\\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "assume ass: \"b\\<in>basis\""], ["proof (state)\nthis:\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "show \"line_integral_exists F {b} (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F {b} (rec_join l)", "proof (rule line_integral_exists_on_rec_join)"], ["proof (state)\ngoal (4 subgoals):\n 1. boundary_chain (set l)\n 2. valid_chain_list l\n 3. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 4. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "using l_props boundary_chain"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  boundary_chain one_chain\n\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by auto"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (3 subgoals):\n 1. valid_chain_list l\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list l", "using l_props"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_chain_list l", "by auto"], ["proof (state)\nthis:\n  valid_chain_list l\n\ngoal (2 subgoals):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "using l_props assms"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  chain_reparam_weak_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite one_chain\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "using l_props line_integral_exists ass"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F {b} (rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "show \"line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "have i: \"line_integral F basis (rec_join l) = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis (rec_join l) =\n    one_chain_line_integral F basis one_chain", "proof (rule one_chain_line_integral_rec_join)"], ["proof (state)\ngoal (7 subgoals):\n 1. set l = one_chain\n 2. distinct l\n 3. valid_chain_list l\n 4. boundary_chain one_chain\n 5. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>\n 6. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n 7. finite basis", "show \"set l = one_chain\" \"distinct l\" \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l = one_chain &&& distinct l &&& valid_chain_list l", "using l_props"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. set l = one_chain &&& distinct l &&& valid_chain_list l", "by auto"], ["proof (state)\nthis:\n  set l = one_chain\n  distinct l\n  valid_chain_list l\n\ngoal (4 subgoals):\n 1. boundary_chain one_chain\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n 4. finite basis", "show \"boundary_chain one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain one_chain", "using boundary_chain"], ["proof (prove)\nusing this:\n  boundary_chain one_chain\n\ngoal (1 subgoal):\n 1. boundary_chain one_chain", "by auto"], ["proof (state)\nthis:\n  boundary_chain one_chain\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n 3. finite basis", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "using line_integral_sum_basis(2)[OF finite_basis] line_integral_exists"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>basis.\n     line_integral_exists ?F {b} ?\\<gamma> \\<Longrightarrow>\n  line_integral_exists ?F basis ?\\<gamma>\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain.\n       line_integral_exists F basis \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain.\n     line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n 2. finite basis", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>", "using valid_path"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. finite basis", "show \"finite basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite basis", "using finite_basis"], ["proof (prove)\nusing this:\n  finite basis\n\ngoal (1 subgoal):\n 1. finite basis", "by auto"], ["proof (state)\nthis:\n  finite basis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "have ii: \"line_integral F basis \\<gamma> = line_integral F basis (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> = line_integral F basis (rec_join l)", "proof (rule reparam_eq_line_integrals_basis[OF l_props(3) _ _  finite_basis])"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 3. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "let ?\\<gamma>2.0=\"rec_join l\""], ["proof (state)\ngoal (3 subgoals):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 3. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"?\\<gamma>2.0 piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join l piecewise_C1_differentiable_on {0..1}", "apply(simp only: valid_path_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (rec_join l)", "apply(rule joined_is_valid)"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (set l)\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. valid_chain_list l", "using assms l_props"], ["proof (prove)\nusing this:\n  chain_reparam_weak_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite one_chain\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (3 subgoals):\n 1. boundary_chain (set l)\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. valid_chain_list l", "by auto"], ["proof (state)\nthis:\n  rec_join l piecewise_C1_differentiable_on {0..1}\n\ngoal (2 subgoals):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n 2. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"\\<forall>b\\<in>basis. continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "using path_image_rec_join_2[OF l_props(5) l_props(4)] l_props(1)"], ["proof (prove)\nusing this:\n  path_image (rec_join l)\n  \\<subseteq> (\\<Union>(k, \\<gamma>)\\<in>set l. path_image \\<gamma>)\n  set l = one_chain\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "using cont_forall continuous_on_subset"], ["proof (prove)\nusing this:\n  path_image (rec_join l)\n  \\<subseteq> (\\<Union>(k, \\<gamma>)\\<in>set l. path_image \\<gamma>)\n  set l = one_chain\n  \\<forall>b\\<in>basis.\n     continuous_on\n      (\\<Union>(k, \\<gamma>)\\<in>one_chain. path_image \\<gamma>)\n      (\\<lambda>x. F x \\<bullet> b)\n  \\<lbrakk>continuous_on ?s ?f; ?t \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?t ?f\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     continuous_on (path_image (rec_join l)) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "show \"\\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "assume ass: \"b\\<in>basis\""], ["proof (state)\nthis:\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> basis \\<Longrightarrow>\n       line_integral_exists F {b} (rec_join l)", "show \"line_integral_exists F {b} (rec_join l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F {b} (rec_join l)", "proof (rule line_integral_exists_on_rec_join)"], ["proof (state)\ngoal (4 subgoals):\n 1. boundary_chain (set l)\n 2. valid_chain_list l\n 3. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 4. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"boundary_chain (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "using l_props boundary_chain"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  boundary_chain one_chain\n\ngoal (1 subgoal):\n 1. boundary_chain (set l)", "by auto"], ["proof (state)\nthis:\n  boundary_chain (set l)\n\ngoal (3 subgoals):\n 1. valid_chain_list l\n 2. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 3. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"valid_chain_list l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_chain_list l", "using l_props"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_chain_list l", "by auto"], ["proof (state)\nthis:\n  valid_chain_list l\n\ngoal (2 subgoals):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"\\<And>k \\<gamma>. (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "using l_props assms"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  chain_reparam_weak_path \\<gamma> one_chain\n  boundary_chain one_chain\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain. valid_path \\<gamma>\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>one_chain.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite one_chain\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> set l \\<Longrightarrow> valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> set l \\<Longrightarrow> valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "using l_props line_integral_exists ass"], ["proof (prove)\nusing this:\n  set l = one_chain\n  distinct l\n  reparam \\<gamma> (rec_join l)\n  valid_chain_list l\n  l \\<noteq> []\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain.\n        line_integral_exists F {b} \\<gamma>\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>set l. line_integral_exists F {b} \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F {b} (rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis. line_integral_exists F {b} (rec_join l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> = line_integral F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "show \"line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "using i ii"], ["proof (prove)\nusing this:\n  line_integral F basis (rec_join l) =\n  one_chain_line_integral F basis one_chain\n  line_integral F basis \\<gamma> = line_integral F basis (rec_join l)\n\ngoal (1 subgoal):\n 1. line_integral F basis \\<gamma> =\n    one_chain_line_integral F basis one_chain", "by auto"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral F basis \\<gamma> = one_chain_line_integral F basis one_chain\n\ngoal:\nNo subgoals!", "qed"], ["", "definition chain_reparam_chain' where\n  \"chain_reparam_chain' one_chain1 subdiv\n       \\<equiv> \\<exists>f. ((\\<Union>(f ` one_chain1)) = subdiv) \\<and>\n              (\\<forall>cube \\<in> one_chain1. chain_reparam_weak_path (rec_join [cube]) (f cube)) \\<and>\n              (\\<forall>p\\<in>one_chain1. \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n              (\\<forall>x \\<in> one_chain1. finite (f x))\""], ["", "lemma chain_reparam_chain'_imp_finite_subdiv:\n  assumes \"finite one_chain1\"\n    \"chain_reparam_chain' one_chain1 subdiv\"\n  shows \"finite subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite subdiv", "using assms"], ["proof (prove)\nusing this:\n  finite one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n\ngoal (1 subgoal):\n 1. finite subdiv", "by(auto simp add: chain_reparam_chain'_def)"], ["", "lemma chain_reparam_chain'_line_integral:\n  assumes chain1_eq_chain2: \"chain_reparam_chain' one_chain1 subdiv\" and\n    boundary_chain1: \"boundary_chain one_chain1\" and\n    boundary_chain2: \"boundary_chain subdiv\" and\n    line_integral_exists_on_chain2: \"\\<forall>b\\<in>basis. \\<forall>(k::int, \\<gamma>) \\<in> subdiv. line_integral_exists F {b} \\<gamma>\" and\n    valid_path: \"\\<forall>(k, \\<gamma>) \\<in> subdiv. valid_path \\<gamma>\" and\n    valid_path_2: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. valid_path \\<gamma>\" and\n    finite_chain1: \"finite one_chain1\" and\n    finite_basis: \"finite basis\" and\n    cont_field: \" \\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>2)\\<in>subdiv. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\"\n    \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "obtain f where f_props:\n    \"((\\<Union>(f ` one_chain1)) = subdiv)\"\n    \"(\\<forall>cube \\<in> one_chain1. chain_reparam_weak_path (rec_join [cube]) (f cube))\"\n    \"(\\<forall>p\\<in>one_chain1. \\<forall>p'\\<in>one_chain1. p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {})\"\n    \"(\\<forall>x \\<in> one_chain1. finite (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>cube\\<in>one_chain1.\n            chain_reparam_weak_path (rec_join [cube]) (f cube);\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain1_eq_chain2"], ["proof (prove)\nusing this:\n  chain_reparam_chain' one_chain1 subdiv\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<Union> (f ` one_chain1) = subdiv;\n         \\<forall>cube\\<in>one_chain1.\n            chain_reparam_weak_path (rec_join [cube]) (f cube);\n         \\<forall>p\\<in>one_chain1.\n            \\<forall>p'\\<in>one_chain1.\n               p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {};\n         \\<forall>x\\<in>one_chain1. finite (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: chain_reparam_chain'_def)"], ["proof (state)\nthis:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>cube\\<in>one_chain1.\n     chain_reparam_weak_path (rec_join [cube]) (f cube)\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>cube\\<in>one_chain1.\n     chain_reparam_weak_path (rec_join [cube]) (f cube)\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)", "have 0: \"one_chain_line_integral F basis subdiv = one_chain_line_integral F basis (\\<Union>(f ` one_chain1))\""], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>cube\\<in>one_chain1.\n     chain_reparam_weak_path (rec_join [cube]) (f cube)\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis subdiv =\n    one_chain_line_integral F basis (\\<Union> (f ` one_chain1))", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis subdiv =\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "{"], ["proof (state)\nthis:\n  one_chain_line_integral F basis subdiv =\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1))\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "assume ass:\"(k, \\<gamma>) \\<in> one_chain1\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have \"line_integral_exists F basis \\<gamma> \\<and>\n               one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "proof(cases \"k = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume k_eq_1: \"k = 1\""], ["proof (state)\nthis:\n  k = 1\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = 1", "have i:\"chain_reparam_weak_path \\<gamma> (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = 1\n\ngoal (1 subgoal):\n 1. chain_reparam_weak_path \\<gamma> (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = 1\n  \\<forall>cube\\<in>one_chain1.\n     chain_reparam_weak_path (rec_join [cube]) (f cube)\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_reparam_weak_path \\<gamma> (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_reparam_weak_path \\<gamma> (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. k = 1 \\<or> k = - 1\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. k = 1 \\<or> k = - 1\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). k = 1 \\<or> k = - 1", "by blast"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have iii:\"\\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n          line_integral_exists F {b} \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n          line_integral_exists F {b} \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n        line_integral_exists F {b} \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have v: \"\\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>). continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n          continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n          continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"line_integral_exists F basis \\<gamma> \\<and> one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "using chain_reparam_weak_path_line_integral[OF i ii iii iv finite_basis v] ass f_props(4)"], ["proof (prove)\nusing this:\n  finite (f (k, \\<gamma>)) \\<Longrightarrow>\n  line_integral F basis \\<gamma> =\n  one_chain_line_integral F basis (f (k, \\<gamma>))\n  finite (f (k, \\<gamma>)) \\<Longrightarrow>\n  line_integral_exists F basis \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain1\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis \\<gamma>", "by (auto)"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. k = 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>\n 2. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma> \\<and> one_chain_line_integral F basis (f (k, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_1"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis \\<gamma>\n  k = 1\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "have k_eq_neg1: \"k = -1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k = - 1", "using ass boundary_chain1"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  (k, \\<gamma>) \\<in> one_chain1\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. k = - 1", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  k = - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k = - 1", "have i:\"chain_reparam_weak_path (reversepath \\<gamma>) (f(k,\\<gamma>))\""], ["proof (prove)\nusing this:\n  k = - 1\n\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "using f_props(2) ass"], ["proof (prove)\nusing this:\n  k = - 1\n  \\<forall>cube\\<in>one_chain1.\n     chain_reparam_weak_path (rec_join [cube]) (f cube)\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. chain_reparam_weak_path (reversepath \\<gamma>) (f (k, \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  chain_reparam_weak_path (reversepath \\<gamma>) (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have ii:\"boundary_chain (f(k,\\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. boundary_chain (f (k, \\<gamma>))", "unfolding boundary_chain_def"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. k = 1 \\<or> k = - 1\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. k = 1 \\<or> k = - 1\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). k = 1 \\<or> k = - 1", "by blast"], ["proof (state)\nthis:\n  boundary_chain (f (k, \\<gamma>))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have iii:\"\\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n          line_integral_exists F {b} \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n          line_integral_exists F {b} \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>).\n        line_integral_exists F {b} \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"iv\": \" \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>f (k, \\<gamma>). valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have v: \"\\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>). continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n          continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n          continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "by blast"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>f (k, \\<gamma>).\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have x:\"line_integral_exists F basis (reversepath \\<gamma>) \\<and> one_chain_line_integral F basis (f (k, \\<gamma>)) = line_integral F basis (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>) \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "using chain_reparam_weak_path_line_integral[OF i ii iii iv finite_basis v] ass f_props(4)"], ["proof (prove)\nusing this:\n  finite (f (k, \\<gamma>)) \\<Longrightarrow>\n  line_integral F basis (reversepath \\<gamma>) =\n  one_chain_line_integral F basis (f (k, \\<gamma>))\n  finite (f (k, \\<gamma>)) \\<Longrightarrow>\n  line_integral_exists F basis (reversepath \\<gamma>)\n  (k, \\<gamma>) \\<in> one_chain1\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis (reversepath \\<gamma>) \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    line_integral F basis (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis (reversepath \\<gamma>) \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "have \"valid_path (reversepath \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "using f_props(1) ass assms"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  (k, \\<gamma>) \\<in> one_chain1\n  chain_reparam_chain' one_chain1 subdiv\n  boundary_chain one_chain1\n  boundary_chain subdiv\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>subdiv. line_integral_exists F {b} \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  finite one_chain1\n  finite basis\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (1 subgoal):\n 1. valid_path (reversepath \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  valid_path (reversepath \\<gamma>)", "have \"line_integral_exists F basis \\<gamma> \\<and> one_chain_line_integral F basis (f (k, \\<gamma>)) = - (line_integral F basis \\<gamma>)\""], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "using line_integral_on_reverse_path reversepath_reversepath x ass"], ["proof (prove)\nusing this:\n  valid_path (reversepath \\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral ?F ?basis ?\\<gamma> =\n                    - line_integral ?F ?basis (reversepath ?\\<gamma>)\n  \\<lbrakk>valid_path ?\\<gamma>;\n   line_integral_exists ?F ?basis ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis (reversepath ?\\<gamma>)\n  reversepath (reversepath ?g) = ?g\n  line_integral_exists F basis (reversepath \\<gamma>) \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  line_integral F basis (reversepath \\<gamma>)\n  (k, \\<gamma>) \\<in> one_chain1\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    - line_integral F basis \\<gamma>", "by metis"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow>\n    line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>", "show \"line_integral_exists F basis \\<gamma> \\<and> one_chain_line_integral F basis (f (k::int, \\<gamma>)) = k * line_integral F basis \\<gamma>\""], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "using k_eq_neg1"], ["proof (prove)\nusing this:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  - line_integral F basis \\<gamma>\n  k = - 1\n\ngoal (1 subgoal):\n 1. line_integral_exists F basis \\<gamma> \\<and>\n    one_chain_line_integral F basis (f (k, \\<gamma>)) =\n    real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  line_integral_exists F basis \\<gamma> \\<and>\n  one_chain_line_integral F basis (f (k, \\<gamma>)) =\n  real_of_int k * line_integral F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "}"], ["proof (state)\nthis:\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "note cube_line_integ = this"], ["proof (state)\nthis:\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have finite_chain2: \"finite subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite subdiv", "using finite_chain1 f_props(1) f_props(4)"], ["proof (prove)\nusing this:\n  finite one_chain1\n  \\<Union> (f ` one_chain1) = subdiv\n  \\<forall>x\\<in>one_chain1. finite (f x)\n\ngoal (1 subgoal):\n 1. finite subdiv", "by auto"], ["proof (state)\nthis:\n  finite subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show line_integral_exists_on_chain1: \"\\<forall>(k, \\<gamma>) \\<in> one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "using cube_line_integ"], ["proof (prove)\nusing this:\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "have 1: \"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) = one_chain_line_integral F basis one_chain1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "have 0:\"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) = \n                           (\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have finite: \"\\<forall>chain \\<in> (f ` one_chain1). finite chain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>chain\\<in>f ` one_chain1. finite chain", "using f_props(1) finite_chain2"], ["proof (prove)\nusing this:\n  \\<Union> (f ` one_chain1) = subdiv\n  finite subdiv\n\ngoal (1 subgoal):\n 1. \\<forall>chain\\<in>f ` one_chain1. finite chain", "by (meson Sup_upper finite_subset)"], ["proof (state)\nthis:\n  \\<forall>chain\\<in>f ` one_chain1. finite chain\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have disj: \" \\<forall>A\\<in>f ` one_chain1. \\<forall>B\\<in>f ` one_chain1. A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>f ` one_chain1.\n       \\<forall>B\\<in>f ` one_chain1.\n          A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}", "apply(simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       (\\<exists>x\\<in>one_chain1. A = f x) \\<longrightarrow>\n       (\\<forall>B.\n           (\\<exists>x\\<in>one_chain1. B = f x) \\<longrightarrow>\n           A \\<noteq> B \\<longrightarrow> A \\<inter> B = {})", "using f_props(3)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       (\\<exists>x\\<in>one_chain1. A = f x) \\<longrightarrow>\n       (\\<forall>B.\n           (\\<exists>x\\<in>one_chain1. B = f x) \\<longrightarrow>\n           A \\<noteq> B \\<longrightarrow> A \\<inter> B = {})", "by metis"], ["proof (state)\nthis:\n  \\<forall>A\\<in>f ` one_chain1.\n     \\<forall>B\\<in>f ` one_chain1.\n        A \\<noteq> B \\<longrightarrow> A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "show \"one_chain_line_integral F basis (\\<Union>(f ` one_chain1)) = \n                                (\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "using Groups_Big.comm_monoid_add_class.sum.Union_disjoint[OF finite disj]\n          one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  sum ?g (\\<Union> (f ` one_chain1)) = (sum \\<circ> sum) ?g (f ` one_chain1)\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "have 1:\"(\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain) = \n                            one_chain_line_integral F basis one_chain1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "have \"(\\<Sum>one_chain \\<in> (f ` one_chain1). one_chain_line_integral F basis one_chain) = \n                                     (\\<Sum>(k,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have i:\"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) = \n                                       (\\<Sum>(k,\\<gamma>)\\<in>one_chain1 - {p. f p = {}}. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"inj_on f (one_chain1 - {p. f p = {}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (one_chain1 - {p. f p = {}})", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1 - {p. f p = {}}.\n       \\<forall>y\\<in>one_chain1 - {p. f p = {}}.\n          f x = f y \\<longrightarrow> x = y", "using f_props(3)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>one_chain1.\n     \\<forall>p'\\<in>one_chain1.\n        p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>one_chain1 - {p. f p = {}}.\n       \\<forall>y\\<in>one_chain1 - {p. f p = {}}.\n          f x = f y \\<longrightarrow> x = y", "by force"], ["proof (state)\nthis:\n  inj_on f (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  inj_on f (one_chain1 - {p. f p = {}})", "have 0: \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain)\n                                                       = (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). one_chain_line_integral F basis (f (k, \\<gamma>)))\""], ["proof (prove)\nusing this:\n  inj_on f (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>)))", "using Groups_Big.comm_monoid_add_class.sum.reindex"], ["proof (prove)\nusing this:\n  inj_on f (one_chain1 - {p. f p = {}})\n  inj_on ?h ?A \\<Longrightarrow> sum ?g (?h ` ?A) = sum (?g \\<circ> ?h) ?A\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>)))", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>)))\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> k \\<gamma>. (k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n                                                     one_chain_line_integral F basis (f(k, \\<gamma>)) = k* (line_integral F basis \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "using cube_line_integ"], ["proof (prove)\nusing this:\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n       one_chain_line_integral F basis (f (k, \\<gamma>)) =\n       real_of_int k * line_integral F basis \\<gamma>", "by auto"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>", "have \"(\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). one_chain_line_integral F basis (f (k, \\<gamma>)))\n                   = (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). k* (line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> one_chain1 - {p. f p = {}} \\<Longrightarrow>\n  one_chain_line_integral F basis (f (?k, ?\\<gamma>)) =\n  real_of_int ?k * line_integral F basis ?\\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       one_chain_line_integral F basis (f (k, \\<gamma>))) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "by (auto intro!: Finite_Cartesian_Product.sum_cong_aux)"], ["proof (state)\nthis:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)", "show \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                     (\\<Sum>(k, \\<gamma>) \\<in> (one_chain1 - {p. f p = {}}). k* (line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "using 0"], ["proof (prove)\nusing this:\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>))) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     one_chain_line_integral F basis (f (k, \\<gamma>)))\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int k * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> (k::int) \\<gamma>. (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> (f (k, \\<gamma>) = {}) \\<Longrightarrow> (k, \\<gamma>) \\<in> {(k',\\<gamma>'). k'* (line_integral F basis \\<gamma>') = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "fix k::\"int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "fix \\<gamma>::\"real\\<Rightarrow>real*real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "assume ass:\"(k, \\<gamma>) \\<in> one_chain1\"\n            \"(f (k, \\<gamma>) = {})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}", "have zero_line_integral:\"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> (k, \\<gamma>)\n                         \\<in> {(k', \\<gamma>').\n                                real_of_int k' *\n                                line_integral F basis \\<gamma>' =\n                                0}", "show \"(k, \\<gamma>) \\<in> {(k'::int, \\<gamma>'). k' * line_integral F basis \\<gamma>' = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, \\<gamma>)\n    \\<in> {(x, \\<gamma>').\n           real_of_int x * line_integral F basis \\<gamma>' = 0}", "using zero_line_integral cube_line_integ ass"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. (k, \\<gamma>)\n    \\<in> {(x, \\<gamma>').\n           real_of_int x * line_integral F basis \\<gamma>' = 0}", "by force"], ["proof (state)\nthis:\n  (k, \\<gamma>)\n  \\<in> {(x, \\<gamma>').\n         real_of_int x * line_integral F basis \\<gamma>' = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}", "have ii:\"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                          (\\<Sum>one_chain \\<in> (f ` (one_chain1)). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> (?k, ?\\<gamma>)\n                    \\<in> {(k', \\<gamma>').\n                           real_of_int k' *\n                           line_integral F basis \\<gamma>' =\n                           0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "have \"\\<And>one_chain. one_chain \\<in> (f ` (one_chain1)) - (f ` (one_chain1 - {p. f p = {}})) \\<Longrightarrow>\n                                                         one_chain_line_integral F basis one_chain = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "fix one_chain"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "assume \"one_chain \\<in> (f ` (one_chain1)) - (f ` (one_chain1 - {p. f p = {}}))\""], ["proof (state)\nthis:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "then"], ["proof (chain)\npicking this:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})", "have \"one_chain = {}\""], ["proof (prove)\nusing this:\n  one_chain \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. one_chain = {}", "by auto"], ["proof (state)\nthis:\n  one_chain = {}\n\ngoal (1 subgoal):\n 1. \\<And>one_chain.\n       one_chain\n       \\<in> f ` one_chain1 -\n             f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       one_chain_line_integral F basis one_chain = 0", "then"], ["proof (chain)\npicking this:\n  one_chain = {}", "show \"one_chain_line_integral F basis one_chain = 0\""], ["proof (prove)\nusing this:\n  one_chain = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain = 0", "by (auto simp add: one_chain_line_integral_def)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0", "have 0:\"(\\<Sum>one_chain \\<in> f ` (one_chain1) - (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) \n                                                       = 0\""], ["proof (prove)\nusing this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0", "using Groups_Big.comm_monoid_add_class.sum.neutral"], ["proof (prove)\nusing this:\n  ?one_chain\n  \\<in> f ` one_chain1 - f ` (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  one_chain_line_integral F basis ?one_chain = 0\n  \\<forall>x\\<in>?A. ?g x = (0::?'a) \\<Longrightarrow> sum ?g ?A = (0::?'a)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0", "have \"(\\<Sum>one_chain \\<in> f ` (one_chain1). one_chain_line_integral F basis one_chain)\n                                                      - (\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) \n                                                       = 0\""], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0 \\<Longrightarrow>\n    sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "have finte: \"finite (f ` one_chain1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f ` one_chain1)", "using finite_chain1"], ["proof (prove)\nusing this:\n  finite one_chain1\n\ngoal (1 subgoal):\n 1. finite (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  finite (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n    0 \\<Longrightarrow>\n    sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "using Groups_Big.sum_diff[OF finte, of \" (f ` (one_chain1 - {p. f p = {}}))\"\n                  \"one_chain_line_integral F basis\"]\n                0"], ["proof (prove)\nusing this:\n  f ` (one_chain1 - {p. f p = {}})\n  \\<subseteq> f ` one_chain1 \\<Longrightarrow>\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}}))\n  sum (one_chain_line_integral F basis)\n   (f ` one_chain1 - f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) -\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    0", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> (k, \\<gamma>)\n                          \\<in> {(k', \\<gamma>').\n                                 real_of_int k' *\n                                 line_integral F basis \\<gamma>' =\n                                 0}) \\<Longrightarrow>\n    sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0", "show \"(\\<Sum>one_chain \\<in> (f ` (one_chain1 - {p. f p = {}})). one_chain_line_integral F basis one_chain) =\n                                                          (\\<Sum>one_chain \\<in> (f ` (one_chain1)). one_chain_line_integral F basis one_chain)\""], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) -\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  0\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis)\n     (f ` (one_chain1 - {p. f p = {}})) =\n    sum (one_chain_line_integral F basis) (f ` one_chain1)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "have \"\\<And> (k::int) \\<gamma>. (k, \\<gamma>) \\<in> one_chain1 \\<Longrightarrow> (f (k, \\<gamma>) = {}) \\<Longrightarrow> f (k, \\<gamma>) \\<in> {chain. one_chain_line_integral F basis chain = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "fix k::\"int\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "fix \\<gamma>::\"real\\<Rightarrow>real*real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "assume ass:\"(k, \\<gamma>) \\<in> one_chain1\"  \"(f (k, \\<gamma>) = {})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}", "have \"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1\n  f (k, \\<gamma>) = {}\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n        f (k, \\<gamma>) = {}\\<rbrakk>\n       \\<Longrightarrow> f (k, \\<gamma>)\n                         \\<in> {chain.\n                                one_chain_line_integral F basis chain = 0}", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "show \"f (k, \\<gamma>) \\<in> {p'. (one_chain_line_integral F basis p' = 0)}\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. f (k, \\<gamma>) \\<in> {p'. one_chain_line_integral F basis p' = 0}", "by auto"], ["proof (state)\nthis:\n  f (k, \\<gamma>) \\<in> {p'. one_chain_line_integral F basis p' = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}", "have iii:\"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1 - {p. f p = {}}. k*(line_integral F basis \\<gamma>))\n                                                 = (\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> one_chain1; f (?k, ?\\<gamma>) = {}\\<rbrakk>\n  \\<Longrightarrow> f (?k, ?\\<gamma>)\n                    \\<in> {chain. one_chain_line_integral F basis chain = 0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "have \"\\<And> k \\<gamma>. (k,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}})\n                                                    \\<Longrightarrow> k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "fix k \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "assume ass: \"(k,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}})\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})", "have \"f(k, \\<gamma>) = {}\""], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. f (k, \\<gamma>) = {}", "by auto"], ["proof (state)\nthis:\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  f (k, \\<gamma>) = {}", "have \"one_chain_line_integral F basis (f(k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  f (k, \\<gamma>) = {}\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by (auto simp add: one_chain_line_integral_def)"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "have zero_line_integral:\"one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>)\n       \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n       real_of_int k * line_integral F basis \\<gamma> = 0", "then"], ["proof (chain)\npicking this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0", "show \"k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n\ngoal (1 subgoal):\n 1. real_of_int k * line_integral F basis \\<gamma> = 0", "using zero_line_integral cube_line_integ ass"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n  one_chain_line_integral F basis (f (k, \\<gamma>)) = 0\n  (?k2, ?\\<gamma>2) \\<in> one_chain1 \\<Longrightarrow>\n  line_integral_exists F basis ?\\<gamma>2 \\<and>\n  one_chain_line_integral F basis (f (?k2, ?\\<gamma>2)) =\n  real_of_int ?k2 * line_integral F basis ?\\<gamma>2\n  (k, \\<gamma>) \\<in> one_chain1 - (one_chain1 - {p. f p = {}})\n\ngoal (1 subgoal):\n 1. real_of_int k * line_integral F basis \\<gamma> = 0", "by force"], ["proof (state)\nthis:\n  real_of_int k * line_integral F basis \\<gamma> = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0", "have \"\\<forall>(k::int,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n                       k* (line_integral F basis \\<gamma>) = 0\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>)\n  \\<in> one_chain1 - (one_chain1 - {p. f p = {}}) \\<Longrightarrow>\n  real_of_int ?k * line_integral F basis ?\\<gamma> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma> = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0", "have \"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}). k*(line_integral F basis \\<gamma>)) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "using Groups_Big.comm_monoid_add_class.sum.neutral\n              [of \"one_chain1 - (one_chain1 - {p. f p = {}})\" \"(\\<lambda>(k::int,\\<gamma>). k* (line_integral F basis \\<gamma>))\"]"], ["proof (prove)\nusing this:\n  \\<forall>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma> = 0\n  \\<forall>x\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     (case x of\n      (x, \\<gamma>) \\<Rightarrow>\n        real_of_int x * line_integral F basis \\<gamma>) =\n     0 \\<Longrightarrow>\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0", "have \"(\\<Sum>(k::int,\\<gamma>)\\<in>one_chain1. k*(line_integral F basis \\<gamma>)) -\n                                                    (\\<Sum>(k::int,\\<gamma>)\\<in> (one_chain1 - {p. f p = {}}). k*(line_integral F basis \\<gamma>))  = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>) -\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "using Groups_Big.sum_diff[OF finite_chain1]"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}).\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n  ?B \\<subseteq> one_chain1 \\<Longrightarrow>\n  sum ?f (one_chain1 - ?B) = sum ?f one_chain1 - sum ?f ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>) -\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    0", "by (metis (no_types) Diff_subset \\<open>(\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - (one_chain1 - {p. f p = {}}). k * line_integral F basis \\<gamma>) = 0\\<close> \\<open>\\<And>f B. B \\<subseteq> one_chain1 \\<Longrightarrow> sum f (one_chain1 - B) = sum f one_chain1 - sum f B\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>(k, \\<gamma>) \\<in> one_chain1;\n         f (k, \\<gamma>) = {}\\<rbrakk>\n        \\<Longrightarrow> f (k, \\<gamma>)\n                          \\<in> {chain.\n                                 one_chain_line_integral F basis chain =\n                                 0}) \\<Longrightarrow>\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>) -\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n       real_of_int x * line_integral F basis \\<gamma>) =\n    (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n       real_of_int x * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "using i ii iii"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int k * line_integral F basis \\<gamma>)\n  sum (one_chain_line_integral F basis) (f ` (one_chain1 - {p. f p = {}})) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1 - {p. f p = {}}.\n     real_of_int x * line_integral F basis \\<gamma>) =\n  (\\<Sum>(x, \\<gamma>)\\<in>one_chain1.\n     real_of_int x * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n       real_of_int k * line_integral F basis \\<gamma>)", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "then"], ["proof (chain)\npicking this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "using one_chain_line_integral_def"], ["proof (prove)\nusing this:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  (\\<Sum>(k, \\<gamma>)\\<in>one_chain1.\n     real_of_int k * line_integral F basis \\<gamma>)\n  one_chain_line_integral ?F ?b ?C \\<equiv>\n  \\<Sum>(k, g)\\<in>?C. real_of_int k * line_integral ?F ?b g\n\ngoal (1 subgoal):\n 1. sum (one_chain_line_integral F basis) (f ` one_chain1) =\n    one_chain_line_integral F basis one_chain1", "by auto"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "using 0 1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  sum (one_chain_line_integral F basis) (f ` one_chain1)\n  sum (one_chain_line_integral F basis) (f ` one_chain1) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n    one_chain_line_integral F basis one_chain1", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "using 0 1"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis subdiv =\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1))\n  one_chain_line_integral F basis (\\<Union> (f ` one_chain1)) =\n  one_chain_line_integral F basis one_chain1\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis subdiv", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis subdiv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_reparam_chain'_line_integral_smooth_cubes:\n  assumes \"chain_reparam_chain' one_chain1 one_chain2\"\n    \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. \\<gamma>2 C1_differentiable_on {0..1}\"\n    \"\\<forall>b\\<in>basis.\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"finite basis\"                                                                     \n    \"finite one_chain1\"\n    \"boundary_chain one_chain1\"\n    \"boundary_chain one_chain2\"\n    \"\\<forall>(k,\\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "assume \"b \\<in> basis\""], ["proof (state)\nthis:\n  b \\<in> basis\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "fix k \\<gamma>"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "assume \"(k, \\<gamma>)\\<in>one_chain2\""], ["proof (state)\nthis:\n  (k, \\<gamma>) \\<in> one_chain2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have \"line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line_integral_exists F {b} \\<gamma>", "apply(rule line_integral_exists_smooth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<gamma> C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>{b}.\n       continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n 3. finite {b}", "using \\<open>(k, \\<gamma>) \\<in> one_chain2\\<close> assms(2)"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n\ngoal (3 subgoals):\n 1. \\<gamma> C1_differentiable_on {0..1}\n 2. \\<forall>b\\<in>{b}.\n       continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n 3. finite {b}", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>b\\<in>{b}.\n       continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n 2. finite {b}", "using assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>b\\<in>basis.\n     \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  finite one_chain1\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<forall>b\\<in>{b}.\n       continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n 2. finite {b}", "using \\<open>(k, \\<gamma>) \\<in> one_chain2\\<close> \\<open>b \\<in> basis\\<close>"], ["proof (prove)\nusing this:\n  chain_reparam_chain' one_chain1 one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n  \\<forall>b\\<in>basis.\n     \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  finite basis\n  finite one_chain1\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  (k, \\<gamma>) \\<in> one_chain2\n  b \\<in> basis\n\ngoal (2 subgoals):\n 1. \\<forall>b\\<in>{b}.\n       continuous_on (path_image \\<gamma>) (\\<lambda>x. F x \\<bullet> b)\n 2. finite {b}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {b}", "using \\<open>b \\<in> basis\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. finite {b}", "by blast"], ["proof (state)\nthis:\n  line_integral_exists F {b} \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?b2 \\<in> basis; (?k2, ?\\<gamma>2) \\<in> one_chain2\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F {?b2} ?\\<gamma>2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?b2 \\<in> basis; (?k2, ?\\<gamma>2) \\<in> one_chain2\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F {?b2} ?\\<gamma>2", "have a: \"\\<forall>b\\<in>basis. \\<forall>(k, \\<gamma>)\\<in>one_chain2. line_integral_exists F {b} \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?b2 \\<in> basis; (?k2, ?\\<gamma>2) \\<in> one_chain2\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists F {?b2} ?\\<gamma>2\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n          line_integral_exists F {b} \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k, \\<gamma>)\\<in>one_chain2.\n        line_integral_exists F {b} \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have b: \"\\<forall>(k2,\\<gamma>2)\\<in>one_chain2. valid_path \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k2, \\<gamma>2)\\<in>one_chain2. valid_path \\<gamma>2", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<gamma>2 C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>(k2, \\<gamma>2)\\<in>one_chain2. valid_path \\<gamma>2", "by (simp add: C1_differentiable_imp_piecewise case_prod_beta valid_path_def)"], ["proof (state)\nthis:\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2. valid_path \\<gamma>2\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by (rule chain_reparam_chain'_line_integral[OF assms(1) assms(6) assms(7) a b assms(8) assms(5) assms(4) assms(3)])"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by (rule chain_reparam_chain'_line_integral[OF assms(1) assms(6) assms(7) a b assms(8) assms(5) assms(4) assms(3)])"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_subdiv_path_pathimg_subset:\n  assumes \"chain_subdiv_path \\<gamma> subdiv\"\n  shows \"\\<forall>(k',\\<gamma>')\\<in>subdiv. (path_image \\<gamma>') \\<subseteq> path_image \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k', \\<gamma>')\\<in>subdiv.\n       path_image \\<gamma>' \\<subseteq> path_image \\<gamma>", "using assms chain_subdiv_path.simps path_image_rec_join"], ["proof (prove)\nusing this:\n  chain_subdiv_path \\<gamma> subdiv\n  chain_subdiv_path ?a1.0 ?a2.0 =\n  (\\<exists>l \\<gamma>.\n      ?a1.0 = \\<gamma> \\<and>\n      ?a2.0 = set l \\<and>\n      distinct l \\<and> rec_join l = \\<gamma> \\<and> valid_chain_list l)\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> set ?l; valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> path_image ?\\<gamma>\n                    \\<subseteq> path_image (rec_join ?l)\n\ngoal (1 subgoal):\n 1. \\<forall>(k', \\<gamma>')\\<in>subdiv.\n       path_image \\<gamma>' \\<subseteq> path_image \\<gamma>", "by(auto simp add: chain_subdiv_path.simps)"], ["", "lemma reparam_path_image:\n  assumes \"reparam \\<gamma>1 \\<gamma>2\"\n  shows \"path_image \\<gamma>1 = path_image \\<gamma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image \\<gamma>1 = path_image \\<gamma>2", "using assms"], ["proof (prove)\nusing this:\n  reparam \\<gamma>1 \\<gamma>2\n\ngoal (1 subgoal):\n 1. path_image \\<gamma>1 = path_image \\<gamma>2", "apply (auto simp add: reparam_def path_image_def image_def bij_betw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> xa.\n       \\<lbrakk>\\<forall>x\\<in>{0..1}. \\<gamma>1 x = \\<gamma>2 (\\<phi> x);\n        \\<phi> piecewise_C1_differentiable_on {0..1}; \\<phi> 0 = 0;\n        \\<phi> 1 = 1; inj_on \\<phi> {0..1};\n        {y. \\<exists>x\\<in>{0..1}. y = \\<phi> x} = {0..1};\n        \\<phi> -` {0..1} \\<subseteq> {0..1};\n        \\<forall>x\\<in>{0..1}. finite (\\<phi> -` {x}); 0 \\<le> xa;\n        xa \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{0..1}.\n                            \\<gamma>2 xa = \\<gamma>2 (\\<phi> x)", "apply (force dest!: equalityD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chain_reparam_weak_path_pathimg_subset:\n  assumes \"chain_reparam_weak_path \\<gamma> subdiv\"\n  shows \"\\<forall>(k',\\<gamma>')\\<in>subdiv. (path_image \\<gamma>') \\<subseteq> path_image \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k', \\<gamma>')\\<in>subdiv.\n       path_image \\<gamma>' \\<subseteq> path_image \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  chain_reparam_weak_path \\<gamma> subdiv\n\ngoal (1 subgoal):\n 1. \\<forall>(k', \\<gamma>')\\<in>subdiv.\n       path_image \\<gamma>' \\<subseteq> path_image \\<gamma>", "apply(auto simp add: chain_reparam_weak_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba l.\n       \\<lbrakk>(a, b) \\<in> set l; (aa, ba) \\<in> path_image b;\n        subdiv = set l; distinct l; reparam \\<gamma> (rec_join l);\n        valid_chain_list l; l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> path_image \\<gamma>", "using path_image_rec_join reparam_path_image"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?\\<gamma>) \\<in> set ?l; valid_chain_list ?l\\<rbrakk>\n  \\<Longrightarrow> path_image ?\\<gamma>\n                    \\<subseteq> path_image (rec_join ?l)\n  reparam ?\\<gamma>1.0 ?\\<gamma>2.0 \\<Longrightarrow>\n  path_image ?\\<gamma>1.0 = path_image ?\\<gamma>2.0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba l.\n       \\<lbrakk>(a, b) \\<in> set l; (aa, ba) \\<in> path_image b;\n        subdiv = set l; distinct l; reparam \\<gamma> (rec_join l);\n        valid_chain_list l; l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> path_image \\<gamma>", "by blast"], ["", "lemma chain_subdiv_chain_pathimg_subset':\n  assumes \"chain_subdiv_chain one_chain subdiv\"\n  assumes \"(k,\\<gamma>)\\<in> subdiv\"\n  shows \" \\<exists>k' \\<gamma>'. (k',\\<gamma>')\\<in> one_chain \\<and> path_image \\<gamma> \\<subseteq> path_image \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k' \\<gamma>'.\n       (k', \\<gamma>') \\<in> one_chain \\<and>\n       path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "using assms"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain subdiv\n  (k, \\<gamma>) \\<in> subdiv\n\ngoal (1 subgoal):\n 1. \\<exists>k' \\<gamma>'.\n       (k', \\<gamma>') \\<in> one_chain \\<and>\n       path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "unfolding chain_subdiv_chain_def  pairwise_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<Union> (f ` one_chain) = subdiv \\<and>\n     (\\<forall>c\\<in>one_chain.\n         chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n     (\\<forall>x\\<in>one_chain.\n         \\<forall>y\\<in>one_chain.\n            x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {}) \\<and>\n     (\\<forall>x\\<in>one_chain. finite (f x))\n  (k, \\<gamma>) \\<in> subdiv\n\ngoal (1 subgoal):\n 1. \\<exists>k' \\<gamma>'.\n       (k', \\<gamma>') \\<in> one_chain \\<and>\n       path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       \\<lbrakk>subdiv = \\<Union> (f ` one_chain); (a, b) \\<in> one_chain;\n        (k, \\<gamma>) \\<in> f (a, b);\n        \\<forall>c\\<in>one_chain.\n           chain_subdiv_path (coeff_cube_to_path c) (f c);\n        \\<forall>x\\<in>one_chain.\n           \\<forall>y\\<in>one_chain.\n              x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {};\n        \\<forall>x\\<in>one_chain. finite (f x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k' \\<gamma>'.\n                            (k', \\<gamma>') \\<in> one_chain \\<and>\n                            path_image \\<gamma>\n                            \\<subseteq> path_image \\<gamma>'", "by (metis chain_subdiv_path.cases coeff_cube_to_path.simps path_image_rec_join path_image_reversepath)"], ["", "lemma chain_subdiv_chain_pathimg_subset:\n  assumes \"chain_subdiv_chain one_chain subdiv\"\n  shows \"\\<Union> (path_image ` {\\<gamma>. \\<exists>k. (k,\\<gamma>)\\<in> subdiv}) \\<subseteq> \\<Union> (path_image ` {\\<gamma>. \\<exists>k. (k,\\<gamma>)\\<in> one_chain})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (path_image ` {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> subdiv})\n    \\<subseteq> \\<Union>\n                 (path_image `\n                  {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> one_chain})", "using assms"], ["proof (prove)\nusing this:\n  chain_subdiv_chain one_chain subdiv\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (path_image ` {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> subdiv})\n    \\<subseteq> \\<Union>\n                 (path_image `\n                  {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> one_chain})", "unfolding chain_subdiv_chain_def pairwise_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<Union> (f ` one_chain) = subdiv \\<and>\n     (\\<forall>c\\<in>one_chain.\n         chain_subdiv_path (coeff_cube_to_path c) (f c)) \\<and>\n     (\\<forall>x\\<in>one_chain.\n         \\<forall>y\\<in>one_chain.\n            x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {}) \\<and>\n     (\\<forall>x\\<in>one_chain. finite (f x))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (path_image ` {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> subdiv})\n    \\<subseteq> \\<Union>\n                 (path_image `\n                  {\\<gamma>. \\<exists>k. (k, \\<gamma>) \\<in> one_chain})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x f k aa ba.\n       \\<lbrakk>(a, b) \\<in> path_image x;\n        subdiv = \\<Union> (f ` one_chain); (aa, ba) \\<in> one_chain;\n        (k, x) \\<in> f (aa, ba);\n        \\<forall>c\\<in>one_chain.\n           chain_subdiv_path (coeff_cube_to_path c) (f c);\n        \\<forall>x\\<in>one_chain.\n           \\<forall>y\\<in>one_chain.\n              x \\<noteq> y \\<longrightarrow> f x \\<inter> f y = {};\n        \\<forall>x\\<in>one_chain. finite (f x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>k. (k, x) \\<in> one_chain) \\<and>\n                            (a, b) \\<in> path_image x", "by (metis UN_iff assms chain_subdiv_chain_pathimg_subset' subsetCE case_prodI2)"], ["", "lemma chain_reparam_chain'_pathimg_subset':\n  assumes \"chain_reparam_chain' one_chain subdiv\"\n  assumes \"(k,\\<gamma>)\\<in> subdiv\"\n  shows \" \\<exists>k' \\<gamma>'. (k',\\<gamma>')\\<in> one_chain \\<and> path_image \\<gamma> \\<subseteq> path_image \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k' \\<gamma>'.\n       (k', \\<gamma>') \\<in> one_chain \\<and>\n       path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "using assms chain_reparam_weak_path_pathimg_subset"], ["proof (prove)\nusing this:\n  chain_reparam_chain' one_chain subdiv\n  (k, \\<gamma>) \\<in> subdiv\n  chain_reparam_weak_path ?\\<gamma> ?subdiv \\<Longrightarrow>\n  \\<forall>(k', \\<gamma>')\\<in>?subdiv.\n     path_image \\<gamma>' \\<subseteq> path_image ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>k' \\<gamma>'.\n       (k', \\<gamma>') \\<in> one_chain \\<and>\n       path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "apply(auto simp add: chain_reparam_chain'_def set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>(k, \\<gamma>) \\<in> subdiv;\n        \\<And>\\<gamma> subdiv.\n           chain_reparam_weak_path \\<gamma> subdiv \\<Longrightarrow>\n           \\<forall>x\\<in>subdiv.\n              case x of\n              (k', \\<gamma>') \\<Rightarrow>\n                path_image \\<gamma>' \\<subseteq> path_image \\<gamma>;\n        \\<forall>a b.\n           (\\<exists>x\\<in>one_chain. (a, b) \\<in> f x) =\n           ((a, b) \\<in> subdiv);\n        \\<forall>cube\\<in>one_chain.\n           chain_reparam_weak_path (coeff_cube_to_path cube) (f cube);\n        \\<forall>p\\<in>one_chain.\n           \\<forall>p'\\<in>one_chain.\n              p \\<noteq> p' \\<longrightarrow>\n              (\\<forall>a b.\n                  (a, b) \\<in> f p \\<longrightarrow> (a, b) \\<notin> f p');\n        \\<forall>x\\<in>one_chain. finite (f x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k' \\<gamma>'.\n                            (k', \\<gamma>') \\<in> one_chain \\<and>\n                            path_image \\<gamma>\n                            \\<subseteq> path_image \\<gamma>'", "using  path_image_reversepath case_prodE case_prodD old.prod.exhaust"], ["proof (prove)\nusing this:\n  path_image (reversepath ?g) = path_image ?g\n  \\<lbrakk>case ?p of (a, b) \\<Rightarrow> ?c a b;\n   \\<And>x y.\n      \\<lbrakk>?p = (x, y); ?c x y\\<rbrakk> \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n  case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d \\<Longrightarrow> ?f ?a ?b\n  (\\<And>a b. ?y = (a, b) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>(k, \\<gamma>) \\<in> subdiv;\n        \\<And>\\<gamma> subdiv.\n           chain_reparam_weak_path \\<gamma> subdiv \\<Longrightarrow>\n           \\<forall>x\\<in>subdiv.\n              case x of\n              (k', \\<gamma>') \\<Rightarrow>\n                path_image \\<gamma>' \\<subseteq> path_image \\<gamma>;\n        \\<forall>a b.\n           (\\<exists>x\\<in>one_chain. (a, b) \\<in> f x) =\n           ((a, b) \\<in> subdiv);\n        \\<forall>cube\\<in>one_chain.\n           chain_reparam_weak_path (coeff_cube_to_path cube) (f cube);\n        \\<forall>p\\<in>one_chain.\n           \\<forall>p'\\<in>one_chain.\n              p \\<noteq> p' \\<longrightarrow>\n              (\\<forall>a b.\n                  (a, b) \\<in> f p \\<longrightarrow> (a, b) \\<notin> f p');\n        \\<forall>x\\<in>one_chain. finite (f x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k' \\<gamma>'.\n                            (k', \\<gamma>') \\<in> one_chain \\<and>\n                            path_image \\<gamma>\n                            \\<subseteq> path_image \\<gamma>'", "apply (simp add: list.distinct(1) list.inject rec_join.elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>(k, \\<gamma>) \\<in> subdiv;\n        \\<And>\\<gamma> subdiv.\n           chain_reparam_weak_path \\<gamma> subdiv \\<Longrightarrow>\n           \\<forall>x\\<in>subdiv.\n              case x of\n              (k', \\<gamma>') \\<Rightarrow>\n                path_image \\<gamma>' \\<subseteq> path_image \\<gamma>;\n        \\<forall>a b.\n           (\\<exists>x\\<in>one_chain. (a, b) \\<in> f x) =\n           ((a, b) \\<in> subdiv);\n        \\<forall>cube\\<in>one_chain.\n           chain_reparam_weak_path (coeff_cube_to_path cube) (f cube);\n        \\<forall>p\\<in>one_chain.\n           \\<forall>p'\\<in>one_chain.\n              p \\<noteq> p' \\<longrightarrow>\n              (\\<forall>a b.\n                  (a, b) \\<in> f p \\<longrightarrow> (a, b) \\<notin> f p');\n        \\<forall>x\\<in>one_chain. finite (f x);\n        \\<And>c p Q.\n           \\<lbrakk>case p of (x, xa) \\<Rightarrow> c x xa;\n            \\<And>x y.\n               \\<lbrakk>p = (x, y); c x y\\<rbrakk>\n               \\<Longrightarrow> Q\\<rbrakk>\n           \\<Longrightarrow> Q;\n        \\<And>f a b. f a b \\<Longrightarrow> f a b;\n        \\<And>y P.\n           (\\<And>a b. y = (a, b) \\<Longrightarrow> P) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k' \\<gamma>'.\n                            (k', \\<gamma>') \\<in> one_chain \\<and>\n                            path_image \\<gamma>\n                            \\<subseteq> path_image \\<gamma>'", "by (smt case_prodD coeff_cube_to_path.simps rec_join.simps(2) reversepath_simps(2) surj_pair)"], ["", "definition common_reparam_exists:: \"(int \\<times> (real \\<Rightarrow> real \\<times> real)) set \\<Rightarrow> (int \\<times> (real \\<Rightarrow> real \\<times> real)) set \\<Rightarrow> bool\" where\n    \"common_reparam_exists one_chain1 one_chain2 \\<equiv>\n    (\\<exists>subdiv ps1 ps2.\n    chain_reparam_chain' (one_chain1 - ps1) subdiv \\<and>\n    chain_reparam_chain' (one_chain2 - ps2) subdiv \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>subdiv.  \\<gamma> C1_differentiable_on {0..1}) \\<and>\n    boundary_chain subdiv \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n    (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>))\""], ["", "lemma common_reparam_exists_imp_eq_line_integral:\n  assumes finite_basis: \"finite basis\" and \n    \"finite one_chain1\"\n    \"finite one_chain2\"\n    \"boundary_chain (one_chain1::(int \\<times> (real \\<Rightarrow> real \\<times> real)) set)\"\n    \"boundary_chain (one_chain2::(int \\<times> (real \\<Rightarrow> real \\<times> real)) set)\"\n    \" \\<forall>(k2, \\<gamma>2)\\<in>one_chain2. \\<forall>b\\<in>basis. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\"\n    \"(common_reparam_exists one_chain1 one_chain2)\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>one_chain1.  valid_path \\<gamma>)\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>one_chain2.  valid_path \\<gamma>)\"\n  shows \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\"\n    \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2 &&&\n    \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "obtain subdiv ps1 ps2 where props:\n    \"chain_reparam_chain' (one_chain1 - ps1) subdiv\"\n    \"chain_reparam_chain' (one_chain2 - ps2) subdiv \"\n    \"(\\<forall>(k, \\<gamma>)\\<in>subdiv.  \\<gamma> C1_differentiable_on {0..1})\"\n    \"boundary_chain subdiv\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>)\"\n    \"(\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps1 subdiv ps2.\n        \\<lbrakk>chain_reparam_chain' (one_chain1 - ps1) subdiv;\n         chain_reparam_chain' (one_chain2 - ps2) subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv.\n            \\<gamma> C1_differentiable_on {0..1};\n         boundary_chain subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>;\n         \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>ps1 subdiv ps2.\n        \\<lbrakk>chain_reparam_chain' (one_chain1 - ps1) subdiv;\n         chain_reparam_chain' (one_chain2 - ps2) subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>subdiv.\n            \\<gamma> C1_differentiable_on {0..1};\n         boundary_chain subdiv;\n         \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>;\n         \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: common_reparam_exists_def)"], ["proof (state)\nthis:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have subdiv_valid: \"(\\<forall>(k, \\<gamma>)\\<in>subdiv.  valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>", "apply(simp add: valid_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>subdiv.\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         \\<gamma> piecewise_C1_differentiable_on {0..1}", "using props(3)"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>subdiv.\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         \\<gamma> piecewise_C1_differentiable_on {0..1}", "using C1_differentiable_imp_piecewise"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  ?f C1_differentiable_on ?S \\<Longrightarrow>\n  ?f piecewise_C1_differentiable_on ?S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>subdiv.\n       case x of\n       (k, \\<gamma>) \\<Rightarrow>\n         \\<gamma> piecewise_C1_differentiable_on {0..1}", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have onechain_boundary1: \"boundary_chain (one_chain1 - ps1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (one_chain1 - ps1)", "using assms(4)"], ["proof (prove)\nusing this:\n  boundary_chain one_chain1\n\ngoal (1 subgoal):\n 1. boundary_chain (one_chain1 - ps1)", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (one_chain1 - ps1)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have onechain_boundary2: \"boundary_chain (one_chain2 - ps1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (one_chain2 - ps1)", "using assms(5)"], ["proof (prove)\nusing this:\n  boundary_chain one_chain2\n\ngoal (1 subgoal):\n 1. boundary_chain (one_chain2 - ps1)", "by (auto simp add: boundary_chain_def)"], ["proof (state)\nthis:\n  boundary_chain (one_chain2 - ps1)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "{"], ["proof (state)\nthis:\n  boundary_chain (one_chain2 - ps1)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "fix k2 \\<gamma>2 b"], ["proof (state)\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "assume ass: \"(k2, \\<gamma>2)\\<in>subdiv \"\" b\\<in>basis\""], ["proof (state)\nthis:\n  (k2, \\<gamma>2) \\<in> subdiv\n  b \\<in> basis\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have \"\\<And> k \\<gamma>. (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow> \\<exists>k' \\<gamma>'. (k', \\<gamma>') \\<in> one_chain2 \\<and> path_image \\<gamma> \\<subseteq> path_image \\<gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k \\<gamma>.\n       (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n       \\<exists>k' \\<gamma>'.\n          (k', \\<gamma>') \\<in> one_chain2 \\<and>\n          path_image \\<gamma> \\<subseteq> path_image \\<gamma>'", "by (meson chain_reparam_chain'_pathimg_subset' props Diff_subset subsetCE)"], ["proof (state)\nthis:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  \\<exists>k' \\<gamma>'.\n     (k', \\<gamma>') \\<in> one_chain2 \\<and>\n     path_image ?\\<gamma> \\<subseteq> path_image \\<gamma>'\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  \\<exists>k' \\<gamma>'.\n     (k', \\<gamma>') \\<in> one_chain2 \\<and>\n     path_image ?\\<gamma> \\<subseteq> path_image \\<gamma>'", "have \"continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  \\<exists>k' \\<gamma>'.\n     (k', \\<gamma>') \\<in> one_chain2 \\<and>\n     path_image ?\\<gamma> \\<subseteq> path_image \\<gamma>'\n\ngoal (1 subgoal):\n 1. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "using assms(6) continuous_on_subset[where ?f = \" (\\<lambda>x. F x \\<bullet> b)\"] ass"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> subdiv \\<Longrightarrow>\n  \\<exists>k' \\<gamma>'.\n     (k', \\<gamma>') \\<in> one_chain2 \\<and>\n     path_image ?\\<gamma> \\<subseteq> path_image \\<gamma>'\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  \\<lbrakk>continuous_on ?s (\\<lambda>x. F x \\<bullet> b);\n   ?t \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?t (\\<lambda>x. F x \\<bullet> b)\n  (k2, \\<gamma>2) \\<in> subdiv\n  b \\<in> basis\n\ngoal (1 subgoal):\n 1. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "apply(auto simp add:  subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k \\<gamma>.\n                (k, \\<gamma>) \\<in> subdiv \\<Longrightarrow>\n                \\<exists>k' \\<gamma>'.\n                   (k', \\<gamma>') \\<in> one_chain2 \\<and>\n                   (\\<forall>a b.\n                       (a, b) \\<in> path_image \\<gamma> \\<longrightarrow>\n                       (a, b) \\<in> path_image \\<gamma>');\n     \\<forall>x\\<in>one_chain2.\n        case x of\n        (k2, \\<gamma>2) \\<Rightarrow>\n          \\<forall>b\\<in>basis.\n             continuous_on (path_image \\<gamma>2)\n              (\\<lambda>x. F x \\<bullet> b);\n     \\<And>s t.\n        \\<lbrakk>continuous_on s (\\<lambda>x. F x \\<bullet> b);\n         \\<forall>a b.\n            (a, b) \\<in> t \\<longrightarrow> (a, b) \\<in> s\\<rbrakk>\n        \\<Longrightarrow> continuous_on t (\\<lambda>x. F x \\<bullet> b);\n     (k2, \\<gamma>2) \\<in> subdiv; b \\<in> basis\\<rbrakk>\n    \\<Longrightarrow> continuous_on (path_image \\<gamma>2)\n                       (\\<lambda>x. F x \\<bullet> b)", "by (metis (mono_tags, lifting) case_prodD)"], ["proof (state)\nthis:\n  continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?k2.2, ?\\<gamma>2.2) \\<in> subdiv; ?b2 \\<in> basis\\<rbrakk>\n  \\<Longrightarrow> continuous_on (path_image ?\\<gamma>2.2)\n                     (\\<lambda>x. F x \\<bullet> ?b2)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?k2.2, ?\\<gamma>2.2) \\<in> subdiv; ?b2 \\<in> basis\\<rbrakk>\n  \\<Longrightarrow> continuous_on (path_image ?\\<gamma>2.2)\n                     (\\<lambda>x. F x \\<bullet> ?b2)", "have cont_field: \"\\<forall>b\\<in>basis. \\<forall>(k2, \\<gamma>2)\\<in>subdiv. continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k2.2, ?\\<gamma>2.2) \\<in> subdiv; ?b2 \\<in> basis\\<rbrakk>\n  \\<Longrightarrow> continuous_on (path_image ?\\<gamma>2.2)\n                     (\\<lambda>x. F x \\<bullet> ?b2)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>basis.\n       \\<forall>(k2, \\<gamma>2)\\<in>subdiv.\n          continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)", "by auto"], ["proof (state)\nthis:\n  \\<forall>b\\<in>basis.\n     \\<forall>(k2, \\<gamma>2)\\<in>subdiv.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have one_chain1_ps_valid: \"(\\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.  valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have one_chain2_ps_valid: \"(\\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps1.  valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps1. valid_path \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps1. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps1. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 0: \"one_chain_line_integral F basis (one_chain1 - ps1) = one_chain_line_integral F basis subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain1 - ps1) =\n    one_chain_line_integral F basis subdiv", "apply(rule chain_reparam_chain'_line_integral_smooth_cubes[OF props(1) props(3) cont_field finite_basis])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (one_chain1 - ps1)\n 2. boundary_chain (one_chain1 - ps1)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (4 subgoals):\n 1. finite (one_chain1 - ps1)\n 2. boundary_chain (one_chain1 - ps1)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using onechain_boundary1"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n  boundary_chain (one_chain1 - ps1)\n\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using one_chain1_ps_valid"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (one_chain1 - ps1) =\n  one_chain_line_integral F basis subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 1:\"\\<forall>(k, \\<gamma>)\\<in>(one_chain1 - ps1). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n       line_integral_exists F basis \\<gamma>", "apply(rule chain_reparam_chain'_line_integral_smooth_cubes[OF props(1) props(3) cont_field finite_basis])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (one_chain1 - ps1)\n 2. boundary_chain (one_chain1 - ps1)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (4 subgoals):\n 1. finite (one_chain1 - ps1)\n 2. boundary_chain (one_chain1 - ps1)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using onechain_boundary1"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n  boundary_chain (one_chain1 - ps1)\n\ngoal (3 subgoals):\n 1. boundary_chain (one_chain1 - ps1)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "using one_chain1_ps_valid"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1. valid_path \\<gamma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n     line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 2: \"one_chain_line_integral F basis (one_chain2 - ps2) = one_chain_line_integral F basis subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis (one_chain2 - ps2) =\n    one_chain_line_integral F basis subdiv", "apply(rule chain_reparam_chain'_line_integral_smooth_cubes[OF props(2) props(3) cont_field finite_basis])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (one_chain2 - ps2)\n 2. boundary_chain (one_chain2 - ps2)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (4 subgoals):\n 1. finite (one_chain2 - ps2)\n 2. boundary_chain (one_chain2 - ps2)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (one_chain2 - ps2)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply (simp add: assms(5) boundary_chain_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply (simp add: props(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "by (simp add: assms(9))"], ["proof (state)\nthis:\n  one_chain_line_integral F basis (one_chain2 - ps2) =\n  one_chain_line_integral F basis subdiv\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "have 3:\"\\<forall>(k, \\<gamma>)\\<in>(one_chain2 - ps2). line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n       line_integral_exists F basis \\<gamma>", "apply(rule chain_reparam_chain'_line_integral_smooth_cubes[OF props(2) props(3) cont_field finite_basis])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (one_chain2 - ps2)\n 2. boundary_chain (one_chain2 - ps2)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "using props assms"], ["proof (prove)\nusing this:\n  chain_reparam_chain' (one_chain1 - ps1) subdiv\n  chain_reparam_chain' (one_chain2 - ps2) subdiv\n  \\<forall>(k, \\<gamma>)\\<in>subdiv. \\<gamma> C1_differentiable_on {0..1}\n  boundary_chain subdiv\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n  finite basis\n  finite one_chain1\n  finite one_chain2\n  boundary_chain one_chain1\n  boundary_chain one_chain2\n  \\<forall>(k2, \\<gamma>2)\\<in>one_chain2.\n     \\<forall>b\\<in>basis.\n        continuous_on (path_image \\<gamma>2) (\\<lambda>x. F x \\<bullet> b)\n  common_reparam_exists one_chain1 one_chain2\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1. valid_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2. valid_path \\<gamma>\n\ngoal (4 subgoals):\n 1. finite (one_chain2 - ps2)\n 2. boundary_chain (one_chain2 - ps2)\n 3. boundary_chain subdiv\n 4. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. boundary_chain (one_chain2 - ps2)\n 2. boundary_chain subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply (simp add: assms(5) boundary_chain_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. boundary_chain subdiv\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "apply (simp add: props(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2. valid_path \\<gamma>", "by (simp add: assms(9))"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n\ngoal (2 subgoals):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2\n 2. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "show line_int_ex_chain1: \"\\<forall>(k, \\<gamma>)\\<in>one_chain1. line_integral_exists F basis \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "using 0"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (one_chain1 - ps1) =\n  one_chain_line_integral F basis subdiv\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "using \"1\" finite_basis line_integral_exists_point_path props(5)"], ["proof (prove)\nusing this:\n  one_chain_line_integral F basis (one_chain1 - ps1) =\n  one_chain_line_integral F basis subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n     line_integral_exists F basis \\<gamma>\n  finite basis\n  \\<lbrakk>finite ?basis; point_path ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> line_integral_exists ?F ?basis ?\\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n       line_integral_exists F basis \\<gamma>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "then"], ["proof (chain)\npicking this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>", "show \"one_chain_line_integral F basis one_chain1 = one_chain_line_integral F basis one_chain2\""], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using 0 1 2 3"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  one_chain_line_integral F basis (one_chain1 - ps1) =\n  one_chain_line_integral F basis subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n     line_integral_exists F basis \\<gamma>\n  one_chain_line_integral F basis (one_chain2 - ps2) =\n  one_chain_line_integral F basis subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "using assms(2-3) finite_basis one_chain_line_integral_point_paths props(5) props(6)"], ["proof (prove)\nusing this:\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1.\n     line_integral_exists F basis \\<gamma>\n  one_chain_line_integral F basis (one_chain1 - ps1) =\n  one_chain_line_integral F basis subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain1 - ps1.\n     line_integral_exists F basis \\<gamma>\n  one_chain_line_integral F basis (one_chain2 - ps2) =\n  one_chain_line_integral F basis subdiv\n  \\<forall>(k, \\<gamma>)\\<in>one_chain2 - ps2.\n     line_integral_exists F basis \\<gamma>\n  finite one_chain1\n  finite one_chain2\n  finite basis\n  \\<lbrakk>finite ?one_chain; finite ?basis;\n   \\<forall>(k, \\<gamma>)\\<in>?ps. point_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> one_chain_line_integral ?F ?basis (?one_chain - ?ps) =\n                    one_chain_line_integral ?F ?basis ?one_chain\n  \\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>\n  \\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>\n\ngoal (1 subgoal):\n 1. one_chain_line_integral F basis one_chain1 =\n    one_chain_line_integral F basis one_chain2", "by auto"], ["proof (state)\nthis:\n  one_chain_line_integral F basis one_chain1 =\n  one_chain_line_integral F basis one_chain2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition subcube :: \"real \\<Rightarrow> real \\<Rightarrow> (int \\<times> (real \\<Rightarrow> real \\<times> real)) \\<Rightarrow> (int \\<times> (real \\<Rightarrow> real \\<times> real))\" where\n  \"subcube a b cube = (fst cube, subpath a b (snd cube))\""], ["", "lemma subcube_valid_path:\n  assumes \"valid_path (snd cube)\" \"a \\<in> {0..1}\" \"b \\<in> {0..1}\"\n  shows \"valid_path (snd (subcube a b cube))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (snd (subcube a b cube))", "using valid_path_subpath[OF assms]"], ["proof (prove)\nusing this:\n  valid_path (subpath a b (snd cube))\n\ngoal (1 subgoal):\n 1. valid_path (snd (subcube a b cube))", "by (auto simp add: subcube_def)"], ["", "end"]]}