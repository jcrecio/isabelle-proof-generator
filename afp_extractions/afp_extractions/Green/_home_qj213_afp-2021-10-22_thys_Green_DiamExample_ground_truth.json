{"file_name": "/home/qj213/afp-2021-10-22/thys/Green/DiamExample.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Green", "problem_names": ["lemma abs_if':\n  fixes a :: \"'a :: {abs_if,ordered_ab_group_add}\"\n  shows \"\\<bar>a\\<bar> = (if a \\<le> 0 then - a else a)\"", "lemma diamond_y_gen_valid:\n  assumes \"a \\<le> 0\" \"0 \\<le> b\"\n  shows \"diamond_y_gen piecewise_C1_differentiable_on {a..b}\"", "lemma diamond_cube_gen_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary (diamond_cube_gen)\"\n  shows \"valid_path \\<gamma>\"", "lemma diamond_eq_characterisations:\n  shows \"diamond_cube (x,y)= diamond_cube_gen (x,y)\"", "lemma diamond_eq_characterisations_fun: \"diamond_cube = diamond_cube_gen\"", "lemma diamond_y_valid:\n  shows \"diamond_y piecewise_C1_differentiable_on {-d/2..d/2}\"         (is ?P)\n        \"(\\<lambda>x. diamond_y x) piecewise_C1_differentiable_on {-d/2..d/2}\" (is ?Q)", "lemma diamond_cube_boundary_valid:\n  assumes \"(k,\\<gamma>) \\<in> boundary (diamond_cube)\"\n  shows \"valid_path \\<gamma>\"", "lemma diamond_cube_is_type_I:\n  shows \"typeI_twoCube (diamond_cube)\"", "lemma diamond_cube_valid_two_cube:\n  shows \"valid_two_cube (diamond_cube)\"", "lemma rot_diamond_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary (rot_diamond_cube)\"\n  shows \"valid_path \\<gamma>\"", "lemma rot_diamond_cube_is_type_II:\n  shows \"typeII_twoCube (rot_diamond_cube)\"", "lemma rot_diamond_cube_valid_two_cube: \"valid_two_cube (rot_diamond_cube)\"", "lemma diamond_cube_boundary_explicit:\n    \"boundary (diamond_cube ) =\n           {diamond_top_edges,\n           diamond_bot_edges,\n    (- 1::int, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n     (1::int, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))}\"", "lemma diamond_edges_are_valid:\n   \"valid_path (snd (diamond_top_left_edge))\"\n    \"valid_path (snd (diamond_top_right_edge))\"\n    \"valid_path (snd (diamond_bot_left_edge))\"\n    \"valid_path (snd (diamond_bot_right_edge))\"", "lemma rot_diam_edge_1:\n     \"(1::int, \\<lambda>x::real. ((x::real) * (2 * diamond_y (diamond_x 0)) - 1 * diamond_y (diamond_x 0), diamond_x 0)) =\n      (1, \\<lambda>x. (x * (2 * diamond_y (diamond_x 0)) -  (diamond_y (diamond_x 0)), diamond_x 0))\"", "lemma rot_diamond_cube_boundary_explicit:\n     \"boundary (rot_diamond_cube) = {(1::int, \\<lambda>x::real. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n                                     (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n                                     diamond_left_edges, diamond_right_edges}\"", "lemma rot_diamond_cube_vertical_boundary_explicit:\n     \"vertical_boundary (rot_diamond_cube) = {diamond_left_edges, diamond_right_edges}\"", "lemma diamond_boundaries_reparam_map_bij:\n     \"bij (diamond_boundaries_reparam_map)\"", "lemma diamond_bot_edges_neq_diamond_top_edges:\n     \"diamond_bot_edges \\<noteq>  diamond_top_edges\"", "lemma diamond_top_left_edge_neq_diamond_top_right_edge:\n     \"diamond_top_left_edge \\<noteq> diamond_top_right_edge\"", "lemma neqs1:\n  shows \"(\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\"\n  and \"(\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)) \\<noteq> (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\"\n  and \"(\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2))) \\<noteq> (\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2)))\"", "lemma neqs2:\n  shows \"(\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))\"\n  and \"(\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0))\"", "lemma diamond_cube_is_only_horizontal_div_of_rot:\n  shows \"only_horizontal_division (boundary (diamond_cube)) {rot_diamond_cube}\"", "lemma rot_y_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_y x y \\<and> rot_y x y \\<le> 1\"", "lemma diamond_gen_eq_rot_diamond:\n  assumes\"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(diamond_cube_gen (x, y)) = (rot_diamond_cube (rot_y x y, rot_x x y))\"", "lemma rot_diamond_eq_diamond_gen:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"rot_diamond_cube (x, y) = diamond_cube_gen (rot_x y x, rot_y y x)\"", "lemma rot_img_eq: \"cubeImage (diamond_cube_gen) = cubeImage (rot_diamond_cube)\"", "lemma rot_diamond_gen_div_diamond_gen:\n  shows \"gen_division (cubeImage (diamond_cube_gen)) (cubeImage ` {rot_diamond_cube})\"", "lemma rot_diamond_gen_div_diamond:\n  shows \"gen_division (cubeImage (diamond_cube)) (cubeImage ` {rot_diamond_cube})\"", "lemma GreenThm_diamond:\n  assumes \"analytically_valid (cubeImage (diamond_cube)) (\\<lambda>x. F x \\<bullet> i) j\"\n    \"analytically_valid (cubeImage (diamond_cube)) (\\<lambda>x. F x \\<bullet> j) i\"\n  shows \"integral (cubeImage (diamond_cube)) (\\<lambda>x. partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x - partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n         one_chain_line_integral F {i, j} (boundary (diamond_cube))\""], "translations": [["", "lemma abs_if':\n  fixes a :: \"'a :: {abs_if,ordered_ab_group_add}\"\n  shows \"\\<bar>a\\<bar> = (if a \\<le> 0 then - a else a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>a\\<bar> = (if a \\<le> (0::'a) then - a else a)", "by (simp add: abs_if dual_order.order_iff_strict)"], ["", "locale diamond = R2 +\n  fixes d::real\n  assumes d_gt_0: \"0 < d\"\nbegin"], ["", "definition diamond_y_gen :: \"real \\<Rightarrow> real\" where\n  \"diamond_y_gen \\<equiv>\\<lambda>t.  1/2 - \\<bar>t\\<bar>\""], ["", "definition diamond_cube_gen:: \"((real * real) \\<Rightarrow> (real * real))\" where\n  \"diamond_cube_gen \\<equiv> (\\<lambda>(x,y). (d * x_coord x, (2 * y - 1) * (d * diamond_y_gen (x_coord x))))\""], ["", "lemma diamond_y_gen_valid:\n  assumes \"a \\<le> 0\" \"0 \\<le> b\"\n  shows \"diamond_y_gen piecewise_C1_differentiable_on {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y_gen piecewise_C1_differentiable_on {a..b}", "unfolding piecewise_C1_differentiable_on_def diamond_y_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - S)", "proof (intro conjI exI)"], ["proof (state)\ngoal (3 subgoals):\n 1. continuous_on {a..b} (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>)\n 2. finite ?S1\n 3. (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - ?S1", "show \"continuous_on {a..b} (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>)", "by (intro continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {a..b} (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>)\n\ngoal (2 subgoals):\n 1. finite ?S1\n 2. (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - ?S1", "show \"finite{0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'a}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'a1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - {0}", "show \"(\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - {0}", "by (intro derivative_intros) auto"], ["proof (state)\nthis:\n  (\\<lambda>t. 1 / 2 - \\<bar>t\\<bar>) C1_differentiable_on {a..b} - {0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diamond_cube_gen_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary (diamond_cube_gen)\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  (k, \\<gamma>) \\<in> boundary diamond_cube_gen\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "proof (auto simp add: valid_path_def boundary_def horizontal_boundary_def vertical_boundary_def diamond_cube_gen_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k = 1;\n     \\<gamma> =\n     (\\<lambda>x.\n         (d * x_coord x, - (d * diamond_y_gen (x_coord x))))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           - (d *\n                              diamond_y_gen\n                               (x_coord x)))) piecewise_C1_differentiable_on\n                      {0..1}\n 2. \\<lbrakk>k = - 1;\n     \\<gamma> =\n     (\\<lambda>x. (d * x_coord x, d * diamond_y_gen (x_coord x)))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           d *\n                           diamond_y_gen\n                            (x_coord x))) piecewise_C1_differentiable_on\n                      {0..1}", "have rw2: \"(\\<lambda>x. diamond_y_gen (x_coord x)) = diamond_y_gen o x_coord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. diamond_y_gen (x_coord x)) = diamond_y_gen \\<circ> x_coord", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. diamond_y_gen (x_coord x)) = diamond_y_gen \\<circ> x_coord\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k = 1;\n     \\<gamma> =\n     (\\<lambda>x.\n         (d * x_coord x, - (d * diamond_y_gen (x_coord x))))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           - (d *\n                              diamond_y_gen\n                               (x_coord x)))) piecewise_C1_differentiable_on\n                      {0..1}\n 2. \\<lbrakk>k = - 1;\n     \\<gamma> =\n     (\\<lambda>x. (d * x_coord x, d * diamond_y_gen (x_coord x)))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           d *\n                           diamond_y_gen\n                            (x_coord x))) piecewise_C1_differentiable_on\n                      {0..1}", "note [derivative_intros] = C1_differentiable_on_pair pair_prod_smooth_pw_smooth scale_piecewise_C1_differentiable_on piecewise_C1_differentiable_neg piecewise_C1_differentiable_compose diamond_y_gen_valid"], ["proof (state)\nthis:\n  \\<lbrakk>?f C1_differentiable_on ?S; ?g C1_differentiable_on ?S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. (?f x, ?g x)) C1_differentiable_on ?S\n  \\<lbrakk>?f C1_differentiable_on ?s;\n   ?g piecewise_C1_differentiable_on ?s\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x.\n                        (?f x, ?g x)) piecewise_C1_differentiable_on\n                    ?s\n  ?f piecewise_C1_differentiable_on ?s \\<Longrightarrow>\n  (\\<lambda>x. ?c * ?f x) piecewise_C1_differentiable_on ?s\n  ?f piecewise_C1_differentiable_on ?S \\<Longrightarrow>\n  (\\<lambda>x. - ?f x) piecewise_C1_differentiable_on ?S\n  \\<lbrakk>?f piecewise_C1_differentiable_on ?S;\n   ?g piecewise_C1_differentiable_on ?f ` ?S;\n   \\<And>x. finite (?S \\<inter> ?f -` {x})\\<rbrakk>\n  \\<Longrightarrow> ?g \\<circ> ?f piecewise_C1_differentiable_on ?S\n  \\<lbrakk>?a \\<le> 0; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> diamond_y_gen piecewise_C1_differentiable_on {?a..?b}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k = 1;\n     \\<gamma> =\n     (\\<lambda>x.\n         (d * x_coord x, - (d * diamond_y_gen (x_coord x))))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           - (d *\n                              diamond_y_gen\n                               (x_coord x)))) piecewise_C1_differentiable_on\n                      {0..1}\n 2. \\<lbrakk>k = - 1;\n     \\<gamma> =\n     (\\<lambda>x. (d * x_coord x, d * diamond_y_gen (x_coord x)))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           d *\n                           diamond_y_gen\n                            (x_coord x))) piecewise_C1_differentiable_on\n                      {0..1}", "show \"(\\<lambda>x. (d * x_coord x, - (d * diamond_y_gen (x_coord x)))) piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * x_coord x,\n         - (d * diamond_y_gen (x_coord x)))) piecewise_C1_differentiable_on\n    {0..1}", "apply(auto intro!: derivative_intros)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. x_coord C1_differentiable_on {0..1}\n 2. (\\<lambda>x. diamond_y_gen (x_coord x)) piecewise_C1_differentiable_on\n    {0..1}", "apply (auto simp add: x_coord_smooth rw2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y_gen \\<circ> x_coord piecewise_C1_differentiable_on {0..1}", "by(auto intro!: derivative_intros simp add: x_coord_img x_coord_back_img C1_differentiable_imp_piecewise[OF x_coord_smooth])+"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (d * x_coord x,\n       - (d * diamond_y_gen (x_coord x)))) piecewise_C1_differentiable_on\n  {0..1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k = - 1;\n     \\<gamma> =\n     (\\<lambda>x. (d * x_coord x, d * diamond_y_gen (x_coord x)))\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          (d * x_coord x,\n                           d *\n                           diamond_y_gen\n                            (x_coord x))) piecewise_C1_differentiable_on\n                      {0..1}", "show \"(\\<lambda>x. (d * x_coord x, d * diamond_y_gen (x_coord x))) piecewise_C1_differentiable_on {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (d * x_coord x,\n         d * diamond_y_gen (x_coord x))) piecewise_C1_differentiable_on\n    {0..1}", "apply(auto intro!: derivative_intros)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. x_coord C1_differentiable_on {0..1}\n 2. (\\<lambda>x. diamond_y_gen (x_coord x)) piecewise_C1_differentiable_on\n    {0..1}", "apply (auto simp add: x_coord_smooth rw2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y_gen \\<circ> x_coord piecewise_C1_differentiable_on {0..1}", "by(auto intro!: derivative_intros simp add: x_coord_img x_coord_back_img C1_differentiable_imp_piecewise[OF x_coord_smooth])+"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (d * x_coord x,\n       d * diamond_y_gen (x_coord x))) piecewise_C1_differentiable_on\n  {0..1}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition diamond_x where\n  \"diamond_x \\<equiv> \\<lambda>t. (t - 1/2) * d\""], ["", "definition diamond_y where\n  \"diamond_y \\<equiv> \\<lambda>t. d/2 - \\<bar>t\\<bar>\""], ["", "definition diamond_cube where\n  \"diamond_cube = (\\<lambda>(x,y). (diamond_x x, (2 * y - 1) * (diamond_y (diamond_x x))))\""], ["", "definition rot_diamond_cube where\n  \"rot_diamond_cube = prod.swap o (diamond_cube) o prod.swap\""], ["", "lemma diamond_eq_characterisations:\n  shows \"diamond_cube (x,y)= diamond_cube_gen (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_cube (x, y) = diamond_cube_gen (x, y)", "by(auto simp add: diamond_cube_def diamond_cube_gen_def diamond_x_def x_coord_def diamond_y_def diamond_y_gen_def d_gt_0 field_simps mult_le_0_iff abs_if split: if_split_asm)"], ["", "lemma diamond_eq_characterisations_fun: \"diamond_cube = diamond_cube_gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_cube = diamond_cube_gen", "using diamond_eq_characterisations"], ["proof (prove)\nusing this:\n  diamond_cube (?x, ?y) = diamond_cube_gen (?x, ?y)\n\ngoal (1 subgoal):\n 1. diamond_cube = diamond_cube_gen", "by auto"], ["", "lemma diamond_y_valid:\n  shows \"diamond_y piecewise_C1_differentiable_on {-d/2..d/2}\"         (is ?P)\n        \"(\\<lambda>x. diamond_y x) piecewise_C1_differentiable_on {-d/2..d/2}\" (is ?Q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2} &&&\n    diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n 2. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}", "have f0: \"finite {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'a}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'a1}\n\ngoal (2 subgoals):\n 1. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n 2. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}", "show ?P ?Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2} &&&\n    diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}", "unfolding piecewise_C1_differentiable_on_def diamond_y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {- d / 2..d / 2}\n     (\\<lambda>t. d / 2 - \\<bar>t\\<bar>) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>t. d / 2 - \\<bar>t\\<bar>) C1_differentiable_on\n        {- d / 2..d / 2} - S) &&&\n    continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. d / 2 - \\<bar>x\\<bar>) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>x. d / 2 - \\<bar>x\\<bar>) C1_differentiable_on\n        {- d / 2..d / 2} - S)", "by (fastforce intro!: f0 continuous_intros derivative_intros)+"], ["proof (state)\nthis:\n  diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n  diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diamond_cube_boundary_valid:\n  assumes \"(k,\\<gamma>) \\<in> boundary (diamond_cube)\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using diamond_cube_gen_boundary_valid assms d_gt_0"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube_gen \\<Longrightarrow>\n  valid_path ?\\<gamma>\n  (k, \\<gamma>) \\<in> boundary diamond_cube\n  0 < d\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by(simp add: diamond_eq_characterisations_fun)"], ["", "lemma diamond_cube_is_type_I:\n  shows \"typeI_twoCube (diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeI_twoCube diamond_cube", "unfolding typeI_twoCube_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b g1 g2.\n       a < b \\<and>\n       (\\<forall>x\\<in>{a..b}. g2 x \\<le> g1 x) \\<and>\n       diamond_cube =\n       (\\<lambda>(x, y).\n           ((1 - x) * a + x * b,\n            (1 - y) * g2 ((1 - x) * a + x * b) +\n            y * g1 ((1 - x) * a + x * b))) \\<and>\n       g1 piecewise_C1_differentiable_on {a..b} \\<and>\n       g2 piecewise_C1_differentiable_on {a..b}", "proof (intro exI conjI ballI)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?a < ?b1\n 2. \\<And>x. x \\<in> {?a..?b1} \\<Longrightarrow> ?g2.3 x \\<le> ?g1.2 x\n 3. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * ?a + x * ?b1,\n         (1 - y) * ?g2.3 ((1 - x) * ?a + x * ?b1) +\n         y * ?g1.2 ((1 - x) * ?a + x * ?b1)))\n 4. ?g1.2 piecewise_C1_differentiable_on {?a..?b1}\n 5. ?g2.3 piecewise_C1_differentiable_on {?a..?b1}", "show \"-d/2 < d/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - d / 2 < d / 2", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. - d / 2 < d / 2", "by auto"], ["proof (state)\nthis:\n  - d / 2 < d / 2\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow> ?g2.3 x \\<le> ?g1.2 x\n 2. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * ?g2.3 ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * ?g1.2 ((1 - x) * (- d / 2) + x * (d / 2))))\n 3. ?g1.2 piecewise_C1_differentiable_on {- d / 2..d / 2}\n 4. ?g2.3 piecewise_C1_differentiable_on {- d / 2..d / 2}", "show \"\\<And>x. x \\<in> {- d / 2..d / 2} \\<Longrightarrow> - diamond_y x \\<le> diamond_y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n       - diamond_y x \\<le> diamond_y x", "using diamond_y_def"], ["proof (prove)\nusing this:\n  diamond_y \\<equiv> \\<lambda>t. d / 2 - \\<bar>t\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n       - diamond_y x \\<le> diamond_y x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {- d / 2..d / 2} \\<Longrightarrow>\n  - diamond_y ?x \\<le> diamond_y ?x\n\ngoal (3 subgoals):\n 1. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))\n 2. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n 3. (\\<lambda>x. - diamond_y x) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "have f0: \"finite {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0::'a}", "by simp"], ["proof (state)\nthis:\n  finite {0::?'a1}\n\ngoal (3 subgoals):\n 1. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))\n 2. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n 3. (\\<lambda>x. - diamond_y x) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "show \"diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\"\n       \"(\\<lambda>x. - diamond_y x) piecewise_C1_differentiable_on {- d / 2..d / 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2} &&&\n    (\\<lambda>x. - diamond_y x) piecewise_C1_differentiable_on\n    {- d / 2..d / 2}", "unfolding diamond_y_def piecewise_C1_differentiable_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {- d / 2..d / 2}\n     (\\<lambda>t. d / 2 - \\<bar>t\\<bar>) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>t. d / 2 - \\<bar>t\\<bar>) C1_differentiable_on\n        {- d / 2..d / 2} - S) &&&\n    continuous_on {- d / 2..d / 2}\n     (\\<lambda>x. - (d / 2 - \\<bar>x\\<bar>)) \\<and>\n    (\\<exists>S.\n        finite S \\<and>\n        (\\<lambda>x. - (d / 2 - \\<bar>x\\<bar>)) C1_differentiable_on\n        {- d / 2..d / 2} - S)", "by (rule conjI exI f0 continuous_intros derivative_intros | force)+"], ["proof (state)\nthis:\n  diamond_y piecewise_C1_differentiable_on {- d / 2..d / 2}\n  (\\<lambda>x. - diamond_y x) piecewise_C1_differentiable_on\n  {- d / 2..d / 2}\n\ngoal (1 subgoal):\n 1. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))", "show \"diamond_cube =\n    (\\<lambda>(x, y). ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_cube =\n    (\\<lambda>(x, y).\n        ((1 - x) * (- d / 2) + x * (d / 2),\n         (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n         y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))", "by (auto simp: diamond_cube_def diamond_x_def diamond_y_def divide_simps algebra_simps)"], ["proof (state)\nthis:\n  diamond_cube =\n  (\\<lambda>(x, y).\n      ((1 - x) * (- d / 2) + x * (d / 2),\n       (1 - y) * - diamond_y ((1 - x) * (- d / 2) + x * (d / 2)) +\n       y * diamond_y ((1 - x) * (- d / 2) + x * (d / 2))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diamond_cube_valid_two_cube:\n  shows \"valid_two_cube (diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_cube diamond_cube", "apply (auto simp add: valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def diamond_cube_def \n      diamond_x_def card_insert_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>y. (d / 2, (2 * y - 1) * diamond_y (d / 2))) =\n    (\\<lambda>x.\n        ((x - 1 / 2) * d, - diamond_y ((x - 1 / 2) * d))) \\<Longrightarrow>\n    False\n 2. \\<lbrakk>(\\<lambda>y. (d / 2, (2 * y - 1) * diamond_y (d / 2))) \\<noteq>\n             (\\<lambda>x. ((x - 1 / 2) * d, - diamond_y ((x - 1 / 2) * d)));\n     (\\<lambda>y. (- (d / 2), (2 * y - 1) * diamond_y (- (d / 2)))) =\n     (\\<lambda>x. ((x - 1 / 2) * d, diamond_y ((x - 1 / 2) * d)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (no_types, hide_lams) cancel_comm_monoid_add_class.diff_cancel d_gt_0 mult.commute mult_2 mult_zero_right order_less_irrefl prod.inject field_sum_of_halves)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>y. (d / 2, (2 * y - 1) * diamond_y (d / 2))) \\<noteq>\n             (\\<lambda>x. ((x - 1 / 2) * d, - diamond_y ((x - 1 / 2) * d)));\n     (\\<lambda>y. (- (d / 2), (2 * y - 1) * diamond_y (- (d / 2)))) =\n     (\\<lambda>x. ((x - 1 / 2) * d, diamond_y ((x - 1 / 2) * d)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (no_types, hide_lams) add_diff_cancel_right' d_gt_0 mult_cancel_left mult_zero_right order_less_irrefl prod.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rot_diamond_cube_boundary_valid:\n  assumes \"(k,\\<gamma>)\\<in>boundary (rot_diamond_cube)\"\n  shows \"valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using d_gt_0 swap_valid_boundaries diamond_cube_boundary_valid"], ["proof (prove)\nusing this:\n  0 < d\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>boundary ?C. valid_path \\<gamma>;\n   (?k, ?\\<gamma>)\n   \\<in> boundary (prod.swap \\<circ> ?C \\<circ> prod.swap)\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "using assms diamond_cube_is_type_I rot_diamond_cube_def"], ["proof (prove)\nusing this:\n  0 < d\n  \\<lbrakk>\\<forall>(k, \\<gamma>)\\<in>boundary ?C. valid_path \\<gamma>;\n   (?k, ?\\<gamma>)\n   \\<in> boundary (prod.swap \\<circ> ?C \\<circ> prod.swap)\\<rbrakk>\n  \\<Longrightarrow> valid_path ?\\<gamma>\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n  (k, \\<gamma>) \\<in> boundary rot_diamond_cube\n  typeI_twoCube diamond_cube\n  rot_diamond_cube = prod.swap \\<circ> diamond_cube \\<circ> prod.swap\n\ngoal (1 subgoal):\n 1. valid_path \\<gamma>", "by fastforce"], ["", "lemma rot_diamond_cube_is_type_II:\n  shows \"typeII_twoCube (rot_diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeII_twoCube rot_diamond_cube", "using d_gt_0 swap_typeI_is_typeII diamond_cube_is_type_I"], ["proof (prove)\nusing this:\n  0 < d\n  typeI_twoCube ?C \\<Longrightarrow>\n  typeII_twoCube (prod.swap \\<circ> ?C \\<circ> prod.swap)\n  typeI_twoCube diamond_cube\n\ngoal (1 subgoal):\n 1. typeII_twoCube rot_diamond_cube", "by (auto simp add: rot_diamond_cube_def)"], ["", "lemma rot_diamond_cube_valid_two_cube: \"valid_two_cube (rot_diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_cube rot_diamond_cube", "using valid_cube_valid_swap diamond_cube_valid_two_cube d_gt_0 rot_diamond_cube_def"], ["proof (prove)\nusing this:\n  valid_two_cube ?C \\<Longrightarrow>\n  valid_two_cube (prod.swap \\<circ> ?C \\<circ> prod.swap)\n  valid_two_cube diamond_cube\n  0 < d\n  rot_diamond_cube = prod.swap \\<circ> diamond_cube \\<circ> prod.swap\n\ngoal (1 subgoal):\n 1. valid_two_cube rot_diamond_cube", "by force"], ["", "definition diamond_top_edges where\n  \"diamond_top_edges = (- 1::int, \\<lambda>x. (diamond_x x, diamond_y (diamond_x x)))\""], ["", "definition diamond_bot_edges where\n  \"diamond_bot_edges = (1::int,  \\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\""], ["", "lemma diamond_cube_boundary_explicit:\n    \"boundary (diamond_cube ) =\n           {diamond_top_edges,\n           diamond_bot_edges,\n    (- 1::int, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n     (1::int, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary diamond_cube =\n    {diamond_top_edges, diamond_bot_edges,\n     (- 1,\n      \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n     (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))}", "by (auto simp only: diamond_top_edges_def diamond_bot_edges_def valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def diamond_cube_def Un_iff algebra_simps)"], ["", "definition diamond_top_left_edge where\n  \"diamond_top_left_edge = (- 1::int, (\\<lambda>x. (diamond_x (1/2 * x),  (diamond_x (1/2 * x)) + d/2)))\""], ["", "definition diamond_top_right_edge where\n  \"diamond_top_right_edge = (- 1::int, (\\<lambda>x. (diamond_x (1/2 * x + 1/2),  (-(diamond_x (1/2 * x + 1/2)) + d/2))))\""], ["", "definition diamond_bot_left_edge where\n  \"diamond_bot_left_edge = (1::int, (\\<lambda>x. (diamond_x (1/2 * x), - (diamond_x (1/2 * x) + d/2))))\""], ["", "definition diamond_bot_right_edge where\n  \"diamond_bot_right_edge = (1::int, (\\<lambda>x. (diamond_x (1/2 * x + 1/2), - (-(diamond_x (1/2 * x + 1/2)) + d/2))))\""], ["", "lemma diamond_edges_are_valid:\n   \"valid_path (snd (diamond_top_left_edge))\"\n    \"valid_path (snd (diamond_top_right_edge))\"\n    \"valid_path (snd (diamond_bot_left_edge))\"\n    \"valid_path (snd (diamond_bot_right_edge))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_path (snd diamond_top_left_edge) &&&\n     valid_path (snd diamond_top_right_edge)) &&&\n    valid_path (snd diamond_bot_left_edge) &&&\n    valid_path (snd diamond_bot_right_edge)", "by (auto simp add: valid_path_def diamond_top_left_edge_def diamond_bot_right_edge_def diamond_bot_left_edge_def diamond_top_right_edge_def diamond_x_def)"], ["", "definition diamond_cube_boundary_to_subdiv where\n  \"diamond_cube_boundary_to_subdiv (gamma::(int \\<times> (real \\<Rightarrow> real \\<times> real))) \\<equiv>\n if (gamma = diamond_top_edges) then\n       {diamond_top_left_edge, diamond_top_right_edge}\n else if (gamma = diamond_bot_edges) then\n   {diamond_bot_left_edge, diamond_bot_right_edge}\n else {}\""], ["", "lemma rot_diam_edge_1:\n     \"(1::int, \\<lambda>x::real. ((x::real) * (2 * diamond_y (diamond_x 0)) - 1 * diamond_y (diamond_x 0), diamond_x 0)) =\n      (1, \\<lambda>x. (x * (2 * diamond_y (diamond_x 0)) -  (diamond_y (diamond_x 0)), diamond_x 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, \\<lambda>x.\n           (x * (2 * diamond_y (diamond_x 0)) - 1 * diamond_y (diamond_x 0),\n            diamond_x 0)) =\n    (1, \\<lambda>x.\n           (x * (2 * diamond_y (diamond_x 0)) - diamond_y (diamond_x 0),\n            diamond_x 0))", "by (auto simp add: algebra_simps)"], ["", "definition diamond_left_edges where\n  \"diamond_left_edges = (- 1, \\<lambda>y. (- diamond_y (diamond_x y), diamond_x y))\""], ["", "definition diamond_right_edges where\n  \"diamond_right_edges = (1, \\<lambda>y. ( diamond_y (diamond_x y), diamond_x y))\""], ["", "lemma rot_diamond_cube_boundary_explicit:\n     \"boundary (rot_diamond_cube) = {(1::int, \\<lambda>x::real. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n                                     (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n                                     diamond_left_edges, diamond_right_edges}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary rot_diamond_cube =\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n     diamond_left_edges, diamond_right_edges}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. boundary rot_diamond_cube =\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n     diamond_left_edges, diamond_right_edges}", "have \"boundary (rot_diamond_cube) = { (1::int, \\<lambda>x::real. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n              (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n              (- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n              (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary rot_diamond_cube =\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n     (- 1,\n      \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n     (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}", "by (auto simp only: valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def rot_diamond_cube_def diamond_cube_def o_def swap_simp Un_iff)"], ["proof (state)\nthis:\n  boundary rot_diamond_cube =\n  {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n   (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n   (- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\n\ngoal (1 subgoal):\n 1. boundary rot_diamond_cube =\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n     diamond_left_edges, diamond_right_edges}", "then"], ["proof (chain)\npicking this:\n  boundary rot_diamond_cube =\n  {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n   (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n   (- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}", "show ?thesis"], ["proof (prove)\nusing this:\n  boundary rot_diamond_cube =\n  {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n   (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n   (- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\n\ngoal (1 subgoal):\n 1. boundary rot_diamond_cube =\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n     diamond_left_edges, diamond_right_edges}", "by (auto simp add: diamond_left_edges_def diamond_right_edges_def)"], ["proof (state)\nthis:\n  boundary rot_diamond_cube =\n  {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n   (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)),\n   diamond_left_edges, diamond_right_edges}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_diamond_cube_vertical_boundary_explicit:\n     \"vertical_boundary (rot_diamond_cube) = {diamond_left_edges, diamond_right_edges}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube =\n    {diamond_left_edges, diamond_right_edges}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube =\n    {diamond_left_edges, diamond_right_edges}", "have \"vertical_boundary (rot_diamond_cube) = {(- 1::int, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n                                                (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube =\n    {(- 1,\n      \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n     (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}", "by (auto simp only: valid_two_cube_def boundary_def horizontal_boundary_def vertical_boundary_def rot_diamond_cube_def diamond_cube_def o_def swap_simp Un_iff)"], ["proof (state)\nthis:\n  vertical_boundary rot_diamond_cube =\n  {(- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\n\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube =\n    {diamond_left_edges, diamond_right_edges}", "then"], ["proof (chain)\npicking this:\n  vertical_boundary rot_diamond_cube =\n  {(- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}", "show ?thesis"], ["proof (prove)\nusing this:\n  vertical_boundary rot_diamond_cube =\n  {(- 1, \\<lambda>y. ((2 * 0 - 1) * diamond_y (diamond_x y), diamond_x y)),\n   (1, \\<lambda>y. ((2 * 1 - 1) * diamond_y (diamond_x y), diamond_x y))}\n\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube =\n    {diamond_left_edges, diamond_right_edges}", "by (auto simp add: diamond_left_edges_def diamond_right_edges_def)"], ["proof (state)\nthis:\n  vertical_boundary rot_diamond_cube =\n  {diamond_left_edges, diamond_right_edges}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rot_diamond_cube_boundary_to_subdiv where\n  \"rot_diamond_cube_boundary_to_subdiv (gamma::(int \\<times> (real \\<Rightarrow> real \\<times> real))) \\<equiv>\n     if (gamma = diamond_left_edges ) then {diamond_bot_left_edge , diamond_top_left_edge}\n     else if (gamma = diamond_right_edges) then {diamond_bot_right_edge, diamond_top_right_edge}\n     else {}\""], ["", "definition diamond_boundaries_reparam_map where\n  \"diamond_boundaries_reparam_map \\<equiv> id\""], ["", "lemma diamond_boundaries_reparam_map_bij:\n     \"bij (diamond_boundaries_reparam_map)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij diamond_boundaries_reparam_map", "by(auto simp add: bij_def full_SetCompr_eq[symmetric] diamond_boundaries_reparam_map_def)"], ["", "lemma diamond_bot_edges_neq_diamond_top_edges:\n     \"diamond_bot_edges \\<noteq>  diamond_top_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_bot_edges \\<noteq> diamond_top_edges", "by(simp add: diamond_bot_edges_def diamond_top_edges_def)"], ["", "lemma diamond_top_left_edge_neq_diamond_top_right_edge:\n     \"diamond_top_left_edge \\<noteq> diamond_top_right_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_top_left_edge \\<noteq> diamond_top_right_edge", "apply (simp add: diamond_top_left_edge_def diamond_top_right_edge_def diamond_x_def diamond_y_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        ((x / 2 - 1 / 2) * d, (x / 2 - 1 / 2) * d + d / 2)) \\<noteq>\n    (\\<lambda>x. (x * d / 2, d / 2 - x * d / 2))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        ((x / 2 - 1 / 2) * d, (x / 2 - 1 / 2) * d + d / 2)) \\<noteq>\n    (\\<lambda>x. (x * d / 2, d / 2 - x * d / 2))", "apply (auto simp add: algebra_simps divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < d;\n     (\\<lambda>x. ((x * d - d) / 2, x * d / 2)) =\n     (\\<lambda>x. (x * d / 2, (d - x * d) / 2))\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (no_types, hide_lams) diff_zero div_0 divide_divide_eq_right order_less_irrefl prod.inject field_sum_of_halves)"], ["", "lemma neqs1:\n  shows \"(\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\"\n  and \"(\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)) \\<noteq> (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\"\n  and \"(\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2))) \\<noteq> (\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2))\"\n  and \"(\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2)) \\<noteq> (\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq>\n     (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) &&&\n     (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)) \\<noteq>\n     (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y)) &&&\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2),\n          diamond_x (x / 2 + 1 / 2) - d / 2)) \\<noteq>\n     (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))) &&&\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2),\n         d / 2 - diamond_x (x / 2 + 1 / 2))) \\<noteq>\n    (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) &&&\n    (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) \\<noteq>\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)) &&&\n    (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) \\<noteq>\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq>\n     (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) &&&\n     (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)) \\<noteq>\n     (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y)) &&&\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2),\n          diamond_x (x / 2 + 1 / 2) - d / 2)) \\<noteq>\n     (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))) &&&\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2),\n         d / 2 - diamond_x (x / 2 + 1 / 2))) \\<noteq>\n    (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) &&&\n    (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) \\<noteq>\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)) &&&\n    (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) \\<noteq>\n    (\\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))", "by (auto simp: diamond_x_def diamond_y_def dest: fun_cong [where x = \"1/2\"])"], ["", "lemma neqs2:\n  shows \"(\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))\"\n  and \"(\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) \\<noteq> (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq>\n    (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)) &&&\n    (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) \\<noteq>\n    (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))) \\<noteq>\n    (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1)) &&&\n    (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x))) \\<noteq>\n    (\\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0))", "by (auto simp: diamond_x_def diamond_y_def dest: fun_cong [where x = \"1\"])"], ["", "lemma diamond_cube_is_only_horizontal_div_of_rot:\n  shows \"only_horizontal_division (boundary (diamond_cube)) {rot_diamond_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. only_horizontal_division (boundary diamond_cube) {rot_diamond_cube}", "unfolding only_horizontal_division_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<H> \\<V>.\n       finite \\<H> \\<and>\n       finite \\<V> \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>\\<H>.\n           \\<exists>(k', \\<gamma>')\n                    \\<in>two_chain_horizontal_boundary {rot_diamond_cube}.\n              \\<exists>a\\<in>{0..1}.\n                 \\<exists>b\\<in>{0..1}.\n                    a \\<le> b \\<and>\n                    subpath a b \\<gamma>' = \\<gamma>) \\<and>\n       (common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n         \\<V> \\<or>\n        common_reparam_exists \\<V>\n         (two_chain_vertical_boundary {rot_diamond_cube})) \\<and>\n       boundary_chain \\<V> \\<and>\n       boundary diamond_cube = \\<H> \\<union> \\<V> \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>\\<V>. valid_path \\<gamma>)", "proof (rule exI [of _ \"{}\"], simp, intro conjI ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (boundary diamond_cube)\n 2. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})\n 3. boundary_chain (boundary diamond_cube)\n 4. \\<And>x.\n       x \\<in> boundary diamond_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"finite (boundary diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (boundary diamond_cube)", "by (simp add: boundary_def horizontal_boundary_def vertical_boundary_def)"], ["proof (state)\nthis:\n  finite (boundary diamond_cube)\n\ngoal (3 subgoals):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})\n 2. boundary_chain (boundary diamond_cube)\n 3. \\<And>x.\n       x \\<in> boundary diamond_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"boundary_chain (boundary diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (boundary diamond_cube)", "by (simp add: two_cube_boundary_is_boundary)"], ["proof (state)\nthis:\n  boundary_chain (boundary diamond_cube)\n\ngoal (2 subgoals):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})\n 2. \\<And>x.\n       x \\<in> boundary diamond_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "show \"\\<And>x. x \\<in> boundary diamond_cube \\<Longrightarrow> case x of (k, x) \\<Rightarrow> valid_path x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> boundary diamond_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "using diamond_cube_boundary_valid"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> boundary diamond_cube \\<Longrightarrow>\n       case x of (k, x) \\<Rightarrow> valid_path x", "by blast"], ["proof (state)\nthis:\n  ?x2 \\<in> boundary diamond_cube \\<Longrightarrow>\n  case ?x2 of (k, x) \\<Rightarrow> valid_path x\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "let ?\\<V> = \"(boundary (diamond_cube))\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "have 0: \"finite ?\\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (boundary diamond_cube)", "by (auto simp add: boundary_def horizontal_boundary_def vertical_boundary_def)"], ["proof (state)\nthis:\n  finite (boundary diamond_cube)\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "have 1: \"boundary_chain ?\\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain (boundary diamond_cube)", "using two_cube_boundary_is_boundary"], ["proof (prove)\nusing this:\n  boundary_chain (boundary ?C)\n\ngoal (1 subgoal):\n 1. boundary_chain (boundary diamond_cube)", "by auto"], ["proof (state)\nthis:\n  boundary_chain (boundary diamond_cube)\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "let ?subdiv = \"{diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge, diamond_bot_right_edge}\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "let ?pi = \"{(1::int, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n              (- 1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "let ?pj = \"{(-1::int, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n              (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "let ?f = \"diamond_cube_boundary_to_subdiv\""], ["proof (state)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "have 2: \"common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube}) ?\\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube)", "unfolding common_sudiv_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>subdiv ps1 ps2.\n       chain_subdiv_chain\n        (two_chain_vertical_boundary {rot_diamond_cube} - ps1) subdiv \\<and>\n       chain_subdiv_chain (boundary diamond_cube - ps2) subdiv \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>subdiv. valid_path \\<gamma>) \\<and>\n       boundary_chain subdiv \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>ps1. point_path \\<gamma>) \\<and>\n       (\\<forall>(k, \\<gamma>)\\<in>ps2. point_path \\<gamma>)", "proof (intro exI conjI)"], ["proof (state)\ngoal (6 subgoals):\n 1. chain_subdiv_chain\n     (two_chain_vertical_boundary {rot_diamond_cube} - ?ps1.1) ?subdiv\n 2. chain_subdiv_chain (boundary diamond_cube - ?ps2.2) ?subdiv\n 3. \\<forall>(k, \\<gamma>)\\<in>?subdiv. valid_path \\<gamma>\n 4. boundary_chain ?subdiv\n 5. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 6. \\<forall>(k, \\<gamma>)\\<in>?ps2.2. point_path \\<gamma>", "show \"chain_subdiv_chain (boundary (diamond_cube) - ?pj) ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_chain\n     (boundary diamond_cube -\n      {(- 1,\n        \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n       (1, \\<lambda>y.\n              (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}", "unfolding chain_subdiv_chain_character"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union>\n        (f `\n         (boundary diamond_cube -\n          {(- 1,\n            \\<lambda>y.\n               (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n           (1, \\<lambda>y.\n                  (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})) =\n       {diamond_top_left_edge, diamond_top_right_edge,\n        diamond_bot_left_edge, diamond_bot_right_edge} \\<and>\n       (\\<forall>(k, \\<gamma>)\n                 \\<in>boundary diamond_cube -\n                      {(- 1,\n                        \\<lambda>y.\n                           (diamond_x 0,\n                            (2 * y - 1) * diamond_y (diamond_x 0))),\n                       (1, \\<lambda>y.\n                              (diamond_x 1,\n                               (2 * y - 1) * diamond_y (diamond_x 1)))}.\n           if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n           else chain_subdiv_path (reversepath \\<gamma>)\n                 (f (k, \\<gamma>))) \\<and>\n       (\\<forall>p\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n           \\<forall>p'\\<in>boundary diamond_cube -\n                           {(- 1,\n                             \\<lambda>y.\n                                (diamond_x 0,\n                                 (2 * y - 1) * diamond_y (diamond_x 0))),\n                            (1, \\<lambda>y.\n                                   (diamond_x 1,\n                                    (2 * y - 1) *\n                                    diamond_y (diamond_x 1)))}.\n              p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n       (\\<forall>x\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n           finite (f x))", "proof (intro exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (boundary diamond_cube -\n       {(- 1,\n         \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n        (1, \\<lambda>y.\n               (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\n 3. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (?f x)", "have 1: \"(boundary (diamond_cube)) - ?pj = {diamond_top_edges, diamond_bot_edges}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary diamond_cube -\n    {(- 1,\n      \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n     (1, \\<lambda>y.\n            (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))} =\n    {diamond_top_edges, diamond_bot_edges}", "apply (auto simp add: diamond_cube_boundary_explicit diamond_x_def diamond_top_edges_def diamond_bot_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. ((x - 1 / 2) * d, diamond_y ((x - 1 / 2) * d))) =\n    (\\<lambda>y.\n        (- (d / 2), (2 * y - 1) * diamond_y (- (d / 2)))) \\<Longrightarrow>\n    False\n 2. (\\<lambda>x. ((x - 1 / 2) * d, - diamond_y ((x - 1 / 2) * d))) =\n    (\\<lambda>y. (d / 2, (2 * y - 1) * diamond_y (d / 2))) \\<Longrightarrow>\n    False", "apply (metis (no_types, hide_lams) abs_zero cancel_comm_monoid_add_class.diff_cancel diamond_x_def diamond_y_def diff_0 minus_diff_eq mult.commute mult_zero_right prod.inject neqs2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ((x - 1 / 2) * d, - diamond_y ((x - 1 / 2) * d))) =\n    (\\<lambda>y. (d / 2, (2 * y - 1) * diamond_y (d / 2))) \\<Longrightarrow>\n    False", "by (metis (no_types, hide_lams) cancel_comm_monoid_add_class.diff_cancel d_gt_0 divide_eq_0_iff linorder_not_le mult.commute mult_zero_right order_refl prod.sel(1) zero_neq_numeral)"], ["proof (state)\nthis:\n  boundary diamond_cube -\n  {(- 1, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n   (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))} =\n  {diamond_top_edges, diamond_bot_edges}\n\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (boundary diamond_cube -\n       {(- 1,\n         \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n        (1, \\<lambda>y.\n               (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\n 3. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (?f x)", "then"], ["proof (chain)\npicking this:\n  boundary diamond_cube -\n  {(- 1, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n   (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))} =\n  {diamond_top_edges, diamond_bot_edges}", "show \"\\<Union> (?f ` (boundary (diamond_cube) - ?pj)) = ?subdiv\""], ["proof (prove)\nusing this:\n  boundary diamond_cube -\n  {(- 1, \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n   (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))} =\n  {diamond_top_edges, diamond_bot_edges}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (diamond_cube_boundary_to_subdiv `\n      (boundary diamond_cube -\n       {(- 1,\n         \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n        (1, \\<lambda>y.\n               (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}", "by (auto simp add: diamond_top_edges_def diamond_bot_edges_def diamond_cube_boundary_to_subdiv_def)"], ["proof (state)\nthis:\n  \\<Union>\n   (diamond_cube_boundary_to_subdiv `\n    (boundary diamond_cube -\n     {(- 1,\n       \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n      (1, \\<lambda>y.\n             (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})) =\n  {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n   diamond_bot_right_edge}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow>\n          diamond_cube_boundary_to_subdiv p \\<inter>\n          diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (diamond_cube_boundary_to_subdiv x)", "have \"chain_subdiv_path (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n                 {(- 1::int, \\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2)),\n                  (- 1::int, \\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "let ?F = \"\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "let ?G = \"\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have dist: \"distinct [(-1, ?F), (-1, ?G)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [(- (1::'a),\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n      (- (1::'a),\n       \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))]", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. distinct\n     [(- (1::'a),\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n      (- (1::'a),\n       \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))]", "by (auto simp: diamond_x_def diamond_y_def dest: fun_cong)"], ["proof (state)\nthis:\n  distinct\n   [(- (1::?'a3),\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n    (- (1::?'a3),\n     \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have rj: \"rec_join [(-1, ?F), (-1, ?G)] = reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join\n     [(- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))] =\n    reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x)))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. rec_join\n     [(- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))] =\n    reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x)))", "by (auto simp add: subpath_def diamond_x_def diamond_y_def joinpaths_def reversepath_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  rec_join\n   [(- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))] =\n  reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x)))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have \"pathstart ?F = pathfinish ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n    pathfinish (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. pathstart\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n    pathfinish (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))", "by(auto simp add: subpath_def diamond_x_def diamond_y_def pathfinish_def pathstart_def)"], ["proof (state)\nthis:\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "then"], ["proof (chain)\npicking this:\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))", "have val: \"valid_chain_list [(-1, ?F), (-1, ?G)]\""], ["proof (prove)\nusing this:\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))\n\ngoal (1 subgoal):\n 1. valid_chain_list\n     [(- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))]", "by (auto simp add:  join_subpaths_middle)"], ["proof (state)\nthis:\n  valid_chain_list\n   [(- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "using chain_subdiv_path.I [OF dist rj val]"], ["proof (prove)\nusing this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   (set [(- 1,\n          \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              d / 2 - diamond_x (x / 2 + 1 / 2))),\n         (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n     {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow>\n          diamond_cube_boundary_to_subdiv p \\<inter>\n          diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (diamond_cube_boundary_to_subdiv x)", "moreover"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow>\n          diamond_cube_boundary_to_subdiv p \\<inter>\n          diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (diamond_cube_boundary_to_subdiv x)", "have \"chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n                           {(1::int, \\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)),\n                            (1::int, \\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "let ?F = \"\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "let ?G = \"\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "have dist: \"distinct [(1, ?F), (1, ?G)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [(1::'a, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1::'a,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))]", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. distinct\n     [(1::'a, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1::'a,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))]", "by (auto simp: diamond_x_def diamond_y_def dest: fun_cong)"], ["proof (state)\nthis:\n  distinct\n   [(1::?'a3, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1::?'a3,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "have rj: \"rec_join [(1, ?F), (1, ?G)] = (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join\n     [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))] =\n    (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. rec_join\n     [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))] =\n    (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))", "by (auto simp add: subpath_def diamond_x_def diamond_y_def joinpaths_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  rec_join\n   [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2),\n            diamond_x (x / 2 + 1 / 2) - d / 2))] =\n  (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "have \"pathfinish ?F = pathstart ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish\n     (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) =\n    pathstart\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. pathfinish\n     (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) =\n    pathstart\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "by(auto simp add: subpath_def diamond_x_def diamond_y_def pathfinish_def pathstart_def)"], ["proof (state)\nthis:\n  pathfinish\n   (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) =\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "then"], ["proof (chain)\npicking this:\n  pathfinish\n   (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) =\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "have val: \"valid_chain_list [(1, ?F), (1, ?G)]\""], ["proof (prove)\nusing this:\n  pathfinish\n   (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)) =\n  pathstart\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. valid_chain_list\n     [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))]", "by (auto simp add:  join_subpaths_middle)"], ["proof (state)\nthis:\n  valid_chain_list\n   [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "using chain_subdiv_path.I [OF dist rj val]"], ["proof (prove)\nusing this:\n  chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n   (set [(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n         (1, \\<lambda>x.\n                (diamond_x (x / 2 + 1 / 2),\n                 diamond_x (x / 2 + 1 / 2) - d / 2))])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2))}", "by simp"], ["proof (state)\nthis:\n  chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow>\n          diamond_cube_boundary_to_subdiv p \\<inter>\n          diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (diamond_cube_boundary_to_subdiv x)", "ultimately"], ["proof (chain)\npicking this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n  chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))}", "show **:\n        \"\\<forall>(k::int, \\<gamma>)\\<in>boundary (diamond_cube) - ?pj.\n            if k = (1::int) then chain_subdiv_path \\<gamma> (?f (k::int, \\<gamma>))\n            else chain_subdiv_path (reversepath \\<gamma>) (?f (k::int, \\<gamma>))\"\n        \"\\<forall>p\\<in>boundary (diamond_cube) - ?pj. \\<forall>p'\\<in>boundary (diamond_cube) - ?pj.\n                                      p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\"\n        \"\\<forall>x\\<in>boundary (diamond_cube) - ?pj. finite (?f x)\""], ["proof (prove)\nusing this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>x. (diamond_x x, diamond_y (diamond_x x))))\n   {(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n  chain_subdiv_path (\\<lambda>x. (diamond_x x, - diamond_y (diamond_x x)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>boundary diamond_cube -\n                  {(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (diamond_cube_boundary_to_subdiv (k, \\<gamma>)) &&&\n    \\<forall>p\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       \\<forall>p'\\<in>boundary diamond_cube -\n                       {(- 1,\n                         \\<lambda>y.\n                            (diamond_x 0,\n                             (2 * y - 1) * diamond_y (diamond_x 0))),\n                        (1, \\<lambda>y.\n                               (diamond_x 1,\n                                (2 * y - 1) * diamond_y (diamond_x 1)))}.\n          p \\<noteq> p' \\<longrightarrow>\n          diamond_cube_boundary_to_subdiv p \\<inter>\n          diamond_cube_boundary_to_subdiv p' =\n          {} &&&\n    \\<forall>x\\<in>boundary diamond_cube -\n                   {(- 1,\n                     \\<lambda>y.\n                        (diamond_x 0,\n                         (2 * y - 1) * diamond_y (diamond_x 0))),\n                    (1, \\<lambda>y.\n                           (diamond_x 1,\n                            (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       finite (diamond_cube_boundary_to_subdiv x)", "by(simp_all add: diamond_cube_boundary_to_subdiv_def UNION_eq 1 diamond_top_edges_def diamond_bot_edges_def diamond_bot_left_edge_def diamond_bot_right_edge_def diamond_top_left_edge_def diamond_top_right_edge_def neqs1)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>boundary diamond_cube -\n                {(- 1,\n                  \\<lambda>y.\n                     (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n                 (1, \\<lambda>y.\n                        (diamond_x 1,\n                         (2 * y - 1) * diamond_y (diamond_x 1)))}.\n     if k = 1\n     then chain_subdiv_path \\<gamma>\n           (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>)\n           (diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n  \\<forall>p\\<in>boundary diamond_cube -\n                 {(- 1,\n                   \\<lambda>y.\n                      (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n                  (1, \\<lambda>y.\n                         (diamond_x 1,\n                          (2 * y - 1) * diamond_y (diamond_x 1)))}.\n     \\<forall>p'\\<in>boundary diamond_cube -\n                     {(- 1,\n                       \\<lambda>y.\n                          (diamond_x 0,\n                           (2 * y - 1) * diamond_y (diamond_x 0))),\n                      (1, \\<lambda>y.\n                             (diamond_x 1,\n                              (2 * y - 1) * diamond_y (diamond_x 1)))}.\n        p \\<noteq> p' \\<longrightarrow>\n        diamond_cube_boundary_to_subdiv p \\<inter>\n        diamond_cube_boundary_to_subdiv p' =\n        {}\n  \\<forall>x\\<in>boundary diamond_cube -\n                 {(- 1,\n                   \\<lambda>y.\n                      (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n                  (1, \\<lambda>y.\n                         (diamond_x 1,\n                          (2 * y - 1) * diamond_y (diamond_x 1)))}.\n     finite (diamond_cube_boundary_to_subdiv x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_chain\n   (boundary diamond_cube -\n    {(- 1,\n      \\<lambda>y. (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n     (1, \\<lambda>y. (diamond_x 1, (2 * y - 1) * diamond_y (diamond_x 1)))})\n   {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n    diamond_bot_right_edge}\n\ngoal (5 subgoals):\n 1. chain_subdiv_chain\n     (two_chain_vertical_boundary {rot_diamond_cube} - ?ps1.1)\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>{diamond_top_left_edge, diamond_top_right_edge,\n                   diamond_bot_left_edge, diamond_bot_right_edge}.\n       valid_path \\<gamma>\n 3. boundary_chain\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 4. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 5. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "have *: \"\\<And>f. \\<Union> (f ` {rot_diamond_cube}) = f (rot_diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. \\<Union> (f ` {rot_diamond_cube}) = f rot_diamond_cube", "by auto"], ["proof (state)\nthis:\n  \\<Union> (?f2 ` {rot_diamond_cube}) = ?f2 rot_diamond_cube\n\ngoal (5 subgoals):\n 1. chain_subdiv_chain\n     (two_chain_vertical_boundary {rot_diamond_cube} - ?ps1.1)\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>{diamond_top_left_edge, diamond_top_right_edge,\n                   diamond_bot_left_edge, diamond_bot_right_edge}.\n       valid_path \\<gamma>\n 3. boundary_chain\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 4. \\<forall>(k, \\<gamma>)\\<in>?ps1.1. point_path \\<gamma>\n 5. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "show \"chain_subdiv_chain (two_chain_vertical_boundary {rot_diamond_cube} - ?pi) ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_chain\n     (two_chain_vertical_boundary {rot_diamond_cube} -\n      {(1, \\<lambda>x.\n              ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n       (- 1,\n        \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}", "unfolding chain_subdiv_chain_character two_chain_vertical_boundary_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<Union>\n        (f `\n         (vertical_boundary rot_diamond_cube -\n          {(1, \\<lambda>x.\n                  ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n           (- 1,\n            \\<lambda>x.\n               ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n       {diamond_top_left_edge, diamond_top_right_edge,\n        diamond_bot_left_edge, diamond_bot_right_edge} \\<and>\n       (\\<forall>(k, \\<gamma>)\n                 \\<in>vertical_boundary rot_diamond_cube -\n                      {(1, \\<lambda>x.\n                              ((2 * x - 1) * diamond_y (diamond_x 0),\n                               diamond_x 0)),\n                       (- 1,\n                        \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 1),\n                            diamond_x 1))}.\n           if k = 1 then chain_subdiv_path \\<gamma> (f (k, \\<gamma>))\n           else chain_subdiv_path (reversepath \\<gamma>)\n                 (f (k, \\<gamma>))) \\<and>\n       (\\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n           \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                           {(1, \\<lambda>x.\n                                   ((2 * x - 1) * diamond_y (diamond_x 0),\n                                    diamond_x 0)),\n                            (- 1,\n                             \\<lambda>x.\n                                ((2 * x - 1) * diamond_y (diamond_x 1),\n                                 diamond_x 1))}.\n              p \\<noteq> p' \\<longrightarrow> f p \\<inter> f p' = {}) \\<and>\n       (\\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n           finite (f x))", "proof (intro exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (vertical_boundary rot_diamond_cube -\n       {(1, \\<lambda>x.\n               ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n        (- 1,\n         \\<lambda>x.\n            ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\n 3. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (?f x)", "let ?f = \"rot_diamond_cube_boundary_to_subdiv\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (vertical_boundary rot_diamond_cube -\n       {(1, \\<lambda>x.\n               ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n        (- 1,\n         \\<lambda>x.\n            ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\n 3. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (?f x)", "have 1: \"(vertical_boundary (rot_diamond_cube) - ?pi) = {diamond_left_edges, diamond_right_edges}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_boundary rot_diamond_cube -\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))} =\n    {diamond_left_edges, diamond_right_edges}", "apply (auto simp add: rot_diamond_cube_vertical_boundary_explicit  diamond_left_edges_def diamond_right_edges_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)) =\n    (\\<lambda>x.\n        ((2 * x - 1) * diamond_y (diamond_x 1),\n         diamond_x 1)) \\<Longrightarrow>\n    False\n 2. (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y)) =\n    (\\<lambda>x.\n        ((2 * x - 1) * diamond_y (diamond_x 0),\n         diamond_x 0)) \\<Longrightarrow>\n    False", "apply (metis (no_types, hide_lams) add.inverse_inverse add_diff_cancel_right' diff_numeral_special(11) mult.left_neutral mult.right_neutral prod.inject neqs1(2) uminus_add_conv_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y)) =\n    (\\<lambda>x.\n        ((2 * x - 1) * diamond_y (diamond_x 0),\n         diamond_x 0)) \\<Longrightarrow>\n    False", "by (metis (no_types, hide_lams) diff_0 mult.left_neutral mult_minus_left mult_zero_right prod.inject neqs1(2))"], ["proof (state)\nthis:\n  vertical_boundary rot_diamond_cube -\n  {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n   (- 1,\n    \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))} =\n  {diamond_left_edges, diamond_right_edges}\n\ngoal (4 subgoals):\n 1. \\<Union>\n     (?f `\n      (vertical_boundary rot_diamond_cube -\n       {(1, \\<lambda>x.\n               ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n        (- 1,\n         \\<lambda>x.\n            ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\n 3. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\n 4. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (?f x)", "show \"\\<Union> (?f ` (vertical_boundary (rot_diamond_cube) - ?pi)) = ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (rot_diamond_cube_boundary_to_subdiv `\n      (vertical_boundary rot_diamond_cube -\n       {(1, \\<lambda>x.\n               ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n        (- 1,\n         \\<lambda>x.\n            ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n    {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n     diamond_bot_right_edge}", "apply (simp add: rot_diamond_cube_boundary_to_subdiv_def 1 UNION_eq subpath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (diamond_right_edges = diamond_left_edges \\<longrightarrow>\n     {diamond_bot_left_edge, diamond_top_left_edge} =\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}) \\<and>\n    (diamond_right_edges \\<noteq> diamond_left_edges \\<longrightarrow>\n     {diamond_bot_left_edge, diamond_top_left_edge, diamond_bot_right_edge,\n      diamond_top_right_edge} =\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge})", "apply (auto simp add: set_eq_iff diamond_right_edges_def diamond_left_edges_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Union>\n   (rot_diamond_cube_boundary_to_subdiv `\n    (vertical_boundary rot_diamond_cube -\n     {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n      (- 1,\n       \\<lambda>x.\n          ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})) =\n  {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n   diamond_bot_right_edge}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_diamond_cube_boundary_to_subdiv p \\<inter>\n          rot_diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (rot_diamond_cube_boundary_to_subdiv x)", "have \"chain_subdiv_path (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n                           {(1, \\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)),\n                            (-1, \\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "let ?F = \"\\<lambda>x. (diamond_x(x/2), - diamond_x(x/2) - d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "let ?G = \"\\<lambda>x. (diamond_x(x/2), diamond_x(x/2) + d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "have dist: \"distinct [(-1, ?G), (1::int, ?F)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))]", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. distinct\n     [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))]", "by simp"], ["proof (state)\nthis:\n  distinct\n   [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "have rj: \"rec_join [(-1, ?G), (1::int, ?F)] = reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join\n     [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))] =\n    reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. rec_join\n     [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))] =\n    reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y))", "by (auto simp add: subpath_def diamond_x_def diamond_y_def joinpaths_def reversepath_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  rec_join\n   [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))] =\n  reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "have \"pathstart ?G = pathstart ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) =\n    pathstart (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. pathstart (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) =\n    pathstart (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))", "by(auto simp add: subpath_def diamond_x_def diamond_y_def pathstart_def)"], ["proof (state)\nthis:\n  pathstart (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) =\n  pathstart (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "then"], ["proof (chain)\npicking this:\n  pathstart (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) =\n  pathstart (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))", "have val: \"valid_chain_list [(-1, ?G), (1::int, ?F)]\""], ["proof (prove)\nusing this:\n  pathstart (\\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)) =\n  pathstart (\\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. valid_chain_list\n     [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n      (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))]", "by (auto simp add:  join_subpaths_middle)"], ["proof (state)\nthis:\n  valid_chain_list\n   [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n    (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "using chain_subdiv_path.I [OF dist rj val]"], ["proof (prove)\nusing this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   (set [(- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2)),\n         (1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2))])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path\n     (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n     {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n      (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_diamond_cube_boundary_to_subdiv p \\<inter>\n          rot_diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (rot_diamond_cube_boundary_to_subdiv x)", "moreover"], ["proof (state)\nthis:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_diamond_cube_boundary_to_subdiv p \\<inter>\n          rot_diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (rot_diamond_cube_boundary_to_subdiv x)", "have \"chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n                           {(1, \\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2)),\n                            (-1, \\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "let ?F = \"\\<lambda>x. (diamond_x(x/2 + 1/2), d/2 - diamond_x(x/2 + 1/2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "let ?G = \"\\<lambda>x. (diamond_x(x/2 + 1/2), diamond_x(x/2 + 1/2) - d/2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have dist: \"distinct [(1::int, ?G), (-1, ?F)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     [(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))]", "by simp"], ["proof (state)\nthis:\n  distinct\n   [(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have rj: \"rec_join [(1::int, ?G), (-1, ?F)] = (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_join\n     [(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))] =\n    (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. rec_join\n     [(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))] =\n    (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))", "by (auto simp add: subpath_def diamond_x_def diamond_y_def joinpaths_def reversepath_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  rec_join\n   [(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))] =\n  (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "have \"pathfinish ?F = pathfinish ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n    pathfinish\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. pathfinish\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n    pathfinish\n     (\\<lambda>x.\n         (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "by(auto simp add: subpath_def diamond_x_def diamond_y_def pathfinish_def pathstart_def)"], ["proof (state)\nthis:\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "then"], ["proof (chain)\npicking this:\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))", "have val: \"valid_chain_list [(1::int, ?G), (-1, ?F)]\""], ["proof (prove)\nusing this:\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2))) =\n  pathfinish\n   (\\<lambda>x.\n       (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2))\n\ngoal (1 subgoal):\n 1. valid_chain_list\n     [(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))]", "by (auto simp add:  join_subpaths_middle)"], ["proof (state)\nthis:\n  valid_chain_list\n   [(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))]\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "using chain_subdiv_path.I [OF dist rj val]"], ["proof (prove)\nusing this:\n  chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n   (set [(1, \\<lambda>x.\n                (diamond_x (x / 2 + 1 / 2),\n                 diamond_x (x / 2 + 1 / 2) - d / 2)),\n         (- 1,\n          \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              d / 2 - diamond_x (x / 2 + 1 / 2)))])\n\ngoal (1 subgoal):\n 1. chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n     {(1, \\<lambda>x.\n             (diamond_x (x / 2 + 1 / 2),\n              diamond_x (x / 2 + 1 / 2) - d / 2)),\n      (- 1,\n       \\<lambda>x.\n          (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "by simp"], ["proof (state)\nthis:\n  chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n   {(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n   {(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal (3 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n 2. \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_diamond_cube_boundary_to_subdiv p \\<inter>\n          rot_diamond_cube_boundary_to_subdiv p' =\n          {}\n 3. \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (rot_diamond_cube_boundary_to_subdiv x)", "ultimately"], ["proof (chain)\npicking this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}\n  chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n   {(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}", "show \"\\<forall>(k, \\<gamma>)\\<in>vertical_boundary (rot_diamond_cube) - ?pi.\n                           if k = 1 then chain_subdiv_path \\<gamma> (?f (k, \\<gamma>))\n                           else chain_subdiv_path (reversepath \\<gamma>) (?f (k, \\<gamma>))\"\n        \"\\<forall>p\\<in>vertical_boundary (rot_diamond_cube) - ?pi.\n                         \\<forall>p'\\<in>vertical_boundary (rot_diamond_cube) - ?pi.\n                              p \\<noteq> p' \\<longrightarrow> ?f p \\<inter> ?f p' = {}\"\n        \"\\<forall>x\\<in>vertical_boundary (rot_diamond_cube) - ?pi. finite (?f x)\""], ["proof (prove)\nusing this:\n  chain_subdiv_path\n   (reversepath (\\<lambda>y. (- diamond_y (diamond_x y), diamond_x y)))\n   {(1, \\<lambda>x. (diamond_x (x / 2), - diamond_x (x / 2) - d / 2)),\n    (- 1, \\<lambda>x. (diamond_x (x / 2), diamond_x (x / 2) + d / 2))}\n  chain_subdiv_path (\\<lambda>y. (diamond_y (diamond_x y), diamond_x y))\n   {(1, \\<lambda>x.\n           (diamond_x (x / 2 + 1 / 2), diamond_x (x / 2 + 1 / 2) - d / 2)),\n    (- 1,\n     \\<lambda>x.\n        (diamond_x (x / 2 + 1 / 2), d / 2 - diamond_x (x / 2 + 1 / 2)))}\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>vertical_boundary rot_diamond_cube -\n                  {(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       if k = 1\n       then chain_subdiv_path \\<gamma>\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n       else chain_subdiv_path (reversepath \\<gamma>)\n             (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>)) &&&\n    \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                       {(1, \\<lambda>x.\n                               ((2 * x - 1) * diamond_y (diamond_x 0),\n                                diamond_x 0)),\n                        (- 1,\n                         \\<lambda>x.\n                            ((2 * x - 1) * diamond_y (diamond_x 1),\n                             diamond_x 1))}.\n          p \\<noteq> p' \\<longrightarrow>\n          rot_diamond_cube_boundary_to_subdiv p \\<inter>\n          rot_diamond_cube_boundary_to_subdiv p' =\n          {} &&&\n    \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                   {(1, \\<lambda>x.\n                           ((2 * x - 1) * diamond_y (diamond_x 0),\n                            diamond_x 0)),\n                    (- 1,\n                     \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 1),\n                         diamond_x 1))}.\n       finite (rot_diamond_cube_boundary_to_subdiv x)", "by(auto simp add: rot_diamond_cube_boundary_to_subdiv_def 1 diamond_left_edges_def \n            diamond_right_edges_def diamond_bot_left_edge_def diamond_bot_right_edge_def \n            diamond_top_left_edge_def diamond_top_right_edge_def neqs1)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>vertical_boundary rot_diamond_cube -\n                {(1, \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 0),\n                         diamond_x 0)),\n                 (- 1,\n                  \\<lambda>x.\n                     ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))}.\n     if k = 1\n     then chain_subdiv_path \\<gamma>\n           (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n     else chain_subdiv_path (reversepath \\<gamma>)\n           (rot_diamond_cube_boundary_to_subdiv (k, \\<gamma>))\n  \\<forall>p\\<in>vertical_boundary rot_diamond_cube -\n                 {(1, \\<lambda>x.\n                         ((2 * x - 1) * diamond_y (diamond_x 0),\n                          diamond_x 0)),\n                  (- 1,\n                   \\<lambda>x.\n                      ((2 * x - 1) * diamond_y (diamond_x 1),\n                       diamond_x 1))}.\n     \\<forall>p'\\<in>vertical_boundary rot_diamond_cube -\n                     {(1, \\<lambda>x.\n                             ((2 * x - 1) * diamond_y (diamond_x 0),\n                              diamond_x 0)),\n                      (- 1,\n                       \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 1),\n                           diamond_x 1))}.\n        p \\<noteq> p' \\<longrightarrow>\n        rot_diamond_cube_boundary_to_subdiv p \\<inter>\n        rot_diamond_cube_boundary_to_subdiv p' =\n        {}\n  \\<forall>x\\<in>vertical_boundary rot_diamond_cube -\n                 {(1, \\<lambda>x.\n                         ((2 * x - 1) * diamond_y (diamond_x 0),\n                          diamond_x 0)),\n                  (- 1,\n                   \\<lambda>x.\n                      ((2 * x - 1) * diamond_y (diamond_x 1),\n                       diamond_x 1))}.\n     finite (rot_diamond_cube_boundary_to_subdiv x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain_subdiv_chain\n   (two_chain_vertical_boundary {rot_diamond_cube} -\n    {(1, \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 0), diamond_x 0)),\n     (- 1,\n      \\<lambda>x. ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))})\n   {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n    diamond_bot_right_edge}\n\ngoal (4 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{diamond_top_left_edge, diamond_top_right_edge,\n                   diamond_bot_left_edge, diamond_bot_right_edge}.\n       valid_path \\<gamma>\n 2. boundary_chain\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 3. \\<forall>(k, \\<gamma>)\n             \\<in>{(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       point_path \\<gamma>\n 4. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "show \"(\\<forall>(k::int, \\<gamma>)\\<in>?subdiv. valid_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{diamond_top_left_edge, diamond_top_right_edge,\n                   diamond_bot_left_edge, diamond_bot_right_edge}.\n       valid_path \\<gamma>", "by (simp add: diamond_edges_are_valid prod.case_eq_if set_eq_iff)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>{diamond_top_left_edge, diamond_top_right_edge,\n                 diamond_bot_left_edge, diamond_bot_right_edge}.\n     valid_path \\<gamma>\n\ngoal (3 subgoals):\n 1. boundary_chain\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>{(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       point_path \\<gamma>\n 3. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "show \"boundary_chain ?subdiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. boundary_chain\n     {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n      diamond_bot_right_edge}", "by (auto simp add: boundary_chain_def diamond_top_left_edge_def diamond_top_right_edge_def diamond_bot_left_edge_def diamond_bot_right_edge_def)"], ["proof (state)\nthis:\n  boundary_chain\n   {diamond_top_left_edge, diamond_top_right_edge, diamond_bot_left_edge,\n    diamond_bot_right_edge}\n\ngoal (2 subgoals):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       point_path \\<gamma>\n 2. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "show \"(\\<forall>(k, \\<gamma>)\\<in>?pi. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       point_path \\<gamma>", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(1, \\<lambda>x.\n                          ((2 * x - 1) * diamond_y (diamond_x 0),\n                           diamond_x 0)),\n                   (- 1,\n                    \\<lambda>x.\n                       ((2 * x - 1) * diamond_y (diamond_x 1),\n                        diamond_x 1))}.\n       point_path \\<gamma>", "by (auto simp add: point_path_def diamond_x_def diamond_y_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>{(1, \\<lambda>x.\n                        ((2 * x - 1) * diamond_y (diamond_x 0),\n                         diamond_x 0)),\n                 (- 1,\n                  \\<lambda>x.\n                     ((2 * x - 1) * diamond_y (diamond_x 1), diamond_x 1))}.\n     point_path \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "show \"(\\<forall>(k, \\<gamma>)\\<in>?pj. point_path \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "using d_gt_0"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\n             \\<in>{(- 1,\n                    \\<lambda>y.\n                       (diamond_x 0,\n                        (2 * y - 1) * diamond_y (diamond_x 0))),\n                   (1, \\<lambda>y.\n                          (diamond_x 1,\n                           (2 * y - 1) * diamond_y (diamond_x 1)))}.\n       point_path \\<gamma>", "by (auto simp add: point_path_def diamond_x_def diamond_y_def)"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\n           \\<in>{(- 1,\n                  \\<lambda>y.\n                     (diamond_x 0, (2 * y - 1) * diamond_y (diamond_x 0))),\n                 (1, \\<lambda>y.\n                        (diamond_x 1,\n                         (2 * y - 1) * diamond_y (diamond_x 1)))}.\n     point_path \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n   (boundary diamond_cube)\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "show \"common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube}) (boundary diamond_cube) \\<or>\n        common_reparam_exists (boundary diamond_cube) (two_chain_vertical_boundary {rot_diamond_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "using 0 1 2 diamond_cube_boundary_valid"], ["proof (prove)\nusing this:\n  finite (boundary diamond_cube)\n  boundary_chain (boundary diamond_cube)\n  common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n   (boundary diamond_cube)\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n\ngoal (1 subgoal):\n 1. common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n     (boundary diamond_cube) \\<or>\n    common_reparam_exists (boundary diamond_cube)\n     (two_chain_vertical_boundary {rot_diamond_cube})", "by auto"], ["proof (state)\nthis:\n  common_sudiv_exists (two_chain_vertical_boundary {rot_diamond_cube})\n   (boundary diamond_cube) \\<or>\n  common_reparam_exists (boundary diamond_cube)\n   (two_chain_vertical_boundary {rot_diamond_cube})\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"rot_y t1 t2 \\<equiv> (t1 - 1/2) / (2* diamond_y_gen (x_coord (rot_x t1 t2))) + 1/2\""], ["", "lemma rot_y_ivl:\n  assumes \"(0::real) \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"0 \\<le> rot_y x y \\<and> rot_y x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) +\n            1 / 2 \\<and>\n    (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2 \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) +\n            1 / 2 \\<and>\n    (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2 \\<le> 1", "apply(auto simp add: x_coord_def diamond_y_gen_def algebra_simps divide_simps linorder_class.not_le abs_if)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * 2 < 1 + x * (y * 4); 1 + x * (y * 4) \\<noteq> x * 2\\<rbrakk>\n    \\<Longrightarrow> 16 + x * (y * 32) \\<le> x * 32\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 2) < x; x * (y * 4) < 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x\n 3. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 4) < 1 + x * 2; x * (y * 4) \\<noteq> 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x * (y * 2)\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 5. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 6. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 7. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "using mult_nonneg_nonneg"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?a * ?b\n\ngoal (7 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * 2 < 1 + x * (y * 4); 1 + x * (y * 4) \\<noteq> x * 2\\<rbrakk>\n    \\<Longrightarrow> 16 + x * (y * 32) \\<le> x * 32\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 2) < x; x * (y * 4) < 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x\n 3. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 4) < 1 + x * 2; x * (y * 4) \\<noteq> 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x * (y * 2)\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 5. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 6. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 7. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "apply fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 2) < x; x * (y * 4) < 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 4) < 1 + x * 2; x * (y * 4) \\<noteq> 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x * (y * 2)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 5. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 6. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "using dual_order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 2) < x; x * (y * 4) < 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 4) < 1 + x * 2; x * (y * 4) \\<noteq> 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x * (y * 2)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 5. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 6. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     \\<not> x * (y * 4) < 1 + x * 2; x * (y * 4) \\<noteq> 1 + x * 2\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> x * (y * 2)\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 5. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "apply (sos \"(((((A<0 * A<1) * R<1) + (((A<=4 * (A<1 * R<1)) * (R<1/2 * [1]^2)) + (((A<=3 * (A<0 * R<1)) * (R<1/2 * [1]^2)) + ((A<=0 * (A<=2 * (A<=3 * R<1))) * (R<1 * [1]^2)))))) & ((((A<0 * A<1) * R<1) + (((A<=4 * (A<1 * R<1)) * (R<1/3 * [1]^2)) + (((A<=4 * (A<0 * R<1)) * (R<1/3 * [1]^2)) + ((A<=3 * (A<=4 * R<1)) * (R<1/3 * [1]^2)))))))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "using assms(1) mult_left_le_one_le"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) \\<le> ?y; ?y \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?y * ?x \\<le> ?x\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     x * 4 + y * 8 < 4 + x * (y * 8);\n     1 + x * (y * 4) < x * 2 + y * 4\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> y\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "using affine_ineq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> (1::?'a); ?v \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> ?v + ?x * ?u \\<le> ?u + ?x * ?v\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> 1 + x * (y * 4) < x * 2 + y * 4;\n     x * 2 + y * 4 \\<noteq> 1 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 8 + y * 8 \\<le> 4 + x * (y * 8)\n 2. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 4 + y * 8 < 4 + x * (y * 8);\n     x * 2 + y * 4 < 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> x * 32 + y * 32 \\<le> 32 + x * (y * 32)\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; 1 < x * 2;\n     \\<not> x * 2 + y * 4 < 3 + x * (y * 4);\n     x * 2 + y * 4 \\<noteq> 3 + x * (y * 4)\\<rbrakk>\n    \\<Longrightarrow> 4 + x * (y * 8) \\<le> y * 8", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma diamond_gen_eq_rot_diamond:\n  assumes\"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"(diamond_cube_gen (x, y)) = (rot_diamond_cube (rot_y x y, rot_x x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_cube_gen (x, y) =\n    rot_diamond_cube\n     ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n      rot_x x y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (diamond_cube_gen (x, y)) =\n    fst (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))\n 2. snd (diamond_cube_gen (x, y)) =\n    snd (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "show \"snd (diamond_cube_gen (x, y)) = snd (rot_diamond_cube (rot_y x y, rot_x x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (diamond_cube_gen (x, y)) =\n    snd (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "apply(simp only: rot_diamond_cube_def diamond_eq_characterisations_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (diamond_cube_gen (x, y)) =\n    snd ((prod.swap \\<circ> diamond_cube_gen \\<circ> prod.swap)\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "by(auto simp add:  diamond_cube_gen_def x_coord_def diamond_y_gen_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  snd (diamond_cube_gen (x, y)) =\n  snd (rot_diamond_cube\n        ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n         rot_x x y))\n\ngoal (1 subgoal):\n 1. fst (diamond_cube_gen (x, y)) =\n    fst (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "show \"fst (diamond_cube_gen (x, y)) = fst (rot_diamond_cube (rot_y x y, rot_x x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (diamond_cube_gen (x, y)) =\n    fst (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. fst (diamond_cube_gen (x, y)) =\n    fst (rot_diamond_cube\n          ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n           rot_x x y))", "apply(auto simp add: diamond_cube_gen_def rot_diamond_cube_def diamond_eq_characterisations_fun)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     diamond_y_gen (x_coord ((2 * y - 1) * x + 1 / 2)) = 0;\n     x_coord x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 2. \\<lbrakk>0 \\<le> x; 0 \\<le> y; y \\<le> 1; x * 2 \\<le> 1;\n     diamond_y_gen (x_coord ((2 * y - 1) * x + 1 / 2)) \\<noteq> 0;\n     x_coord x * 2 \\<noteq> 2 * x - 1\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; \\<not> x * 2 \\<le> 1;\n     diamond_y_gen (x_coord (2 * y - 2 * x * y + x - 1 / 2)) = 0;\n     x_coord x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; \\<not> x * 2 \\<le> 1;\n     diamond_y_gen (x_coord (2 * y - 2 * x * y + x - 1 / 2)) \\<noteq> 0;\n     x_coord x * 2 \\<noteq> 2 * x - 1\\<rbrakk>\n    \\<Longrightarrow> d = 0", "apply(auto simp add: x_coord_def diamond_y_gen_def algebra_simps divide_simps abs_if split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x * 2 \\<noteq> 1; 0 \\<le> x; 0 \\<le> y; y \\<le> 1;\n     x * 2 \\<le> 1; 4 + x * (y * 16) = x * 8\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 2. \\<lbrakk>x * 2 \\<noteq> 1; 0 \\<le> x; 0 \\<le> y; y \\<le> 1;\n     x * 2 \\<le> 1; x * (y * 16) = 4 + x * 8\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 3. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; \\<not> x * 2 \\<le> 1;\n     x * 8 + y * 16 = 4 + x * (y * 16)\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 4. \\<lbrakk>x \\<le> 1; 0 \\<le> y; y \\<le> 1; \\<not> x * 2 \\<le> 1;\n     x * 8 + y * 16 = 12 + x * (y * 16)\\<rbrakk>\n    \\<Longrightarrow> d = 0", "apply sos+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fst (diamond_cube_gen (x, y)) =\n  fst (rot_diamond_cube\n        ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n         rot_x x y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_diamond_eq_diamond_gen:\n  assumes \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \n  shows \"rot_diamond_cube (x, y) = diamond_cube_gen (rot_x y x, rot_y y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_diamond_cube (x, y) =\n    diamond_cube_gen\n     (rot_x y x,\n      (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (rot_diamond_cube (x, y)) =\n    fst (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))\n 2. snd (rot_diamond_cube (x, y)) =\n    snd (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "show \"fst (rot_diamond_cube (x, y)) = fst (diamond_cube_gen (rot_x y x, rot_y y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (rot_diamond_cube (x, y)) =\n    fst (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "apply(simp only: rot_diamond_cube_def diamond_eq_characterisations_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ((prod.swap \\<circ> diamond_cube_gen \\<circ> prod.swap) (x, y)) =\n    fst (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "by(auto simp add:  diamond_cube_gen_def x_coord_def diamond_y_gen_def algebra_simps divide_simps)"], ["proof (state)\nthis:\n  fst (rot_diamond_cube (x, y)) =\n  fst (diamond_cube_gen\n        (rot_x y x,\n         (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))\n\ngoal (1 subgoal):\n 1. snd (rot_diamond_cube (x, y)) =\n    snd (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "show \"snd (rot_diamond_cube (x, y)) = snd (diamond_cube_gen (rot_x y x, rot_y y x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (rot_diamond_cube (x, y)) =\n    snd (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n\ngoal (1 subgoal):\n 1. snd (rot_diamond_cube (x, y)) =\n    snd (diamond_cube_gen\n          (rot_x y x,\n           (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))", "apply(auto simp add: diamond_cube_gen_def rot_diamond_cube_def diamond_eq_characterisations_fun)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y * 2 \\<le> 1;\n     diamond_y_gen (x_coord ((2 * x - 1) * y + 1 / 2)) = 0;\n     x_coord y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 2. \\<lbrakk>0 \\<le> x; x \\<le> 1; 0 \\<le> y; y * 2 \\<le> 1;\n     diamond_y_gen (x_coord ((2 * x - 1) * y + 1 / 2)) \\<noteq> 0;\n     x_coord y * 2 \\<noteq> 2 * y - 1\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 3. \\<lbrakk>0 \\<le> x; x \\<le> 1; y \\<le> 1; \\<not> y * 2 \\<le> 1;\n     diamond_y_gen (x_coord (2 * x - 2 * y * x + y - 1 / 2)) = 0;\n     x_coord y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 4. \\<lbrakk>0 \\<le> x; x \\<le> 1; y \\<le> 1; \\<not> y * 2 \\<le> 1;\n     diamond_y_gen (x_coord (2 * x - 2 * y * x + y - 1 / 2)) \\<noteq> 0;\n     x_coord y * 2 \\<noteq> 2 * y - 1\\<rbrakk>\n    \\<Longrightarrow> d = 0", "apply(auto simp add: x_coord_def diamond_y_gen_def algebra_simps divide_simps abs_if split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>y * 2 \\<noteq> 1; 0 \\<le> x; x \\<le> 1; 0 \\<le> y;\n     y * 2 \\<le> 1; 4 + x * (y * 16) = y * 8\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 2. \\<lbrakk>y * 2 \\<noteq> 1; 0 \\<le> x; x \\<le> 1; 0 \\<le> y;\n     y * 2 \\<le> 1; x * (y * 16) = 4 + y * 8\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 3. \\<lbrakk>0 \\<le> x; x \\<le> 1; y \\<le> 1; \\<not> y * 2 \\<le> 1;\n     y * 8 + x * 16 = 4 + x * (y * 16)\\<rbrakk>\n    \\<Longrightarrow> d = 0\n 4. \\<lbrakk>0 \\<le> x; x \\<le> 1; y \\<le> 1; \\<not> y * 2 \\<le> 1;\n     y * 8 + x * 16 = 12 + x * (y * 16)\\<rbrakk>\n    \\<Longrightarrow> d = 0", "apply sos+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd (rot_diamond_cube (x, y)) =\n  snd (diamond_cube_gen\n        (rot_x y x,\n         (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_img_eq: \"cubeImage (diamond_cube_gen) = cubeImage (rot_diamond_cube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cubeImage diamond_cube_gen = cubeImage rot_diamond_cube", "proof(auto simp add: cubeImage_def image_def cbox_def real_pair_basis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>0 \\<le> aa; aa \\<le> 1; 0 \\<le> ba; ba \\<le> 1;\n        (a, b) = diamond_cube_gen (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<ge>0.\n                            a \\<le> 1 \\<and>\n                            (\\<exists>b\\<ge>0.\n                                b \\<le> 1 \\<and>\n                                diamond_cube_gen (aa, ba) =\n                                rot_diamond_cube (a, b))\n 2. \\<And>a b aa ba.\n       \\<lbrakk>0 \\<le> aa; aa \\<le> 1; 0 \\<le> ba; ba \\<le> 1;\n        (a, b) = rot_diamond_cube (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<ge>0.\n                            a \\<le> 1 \\<and>\n                            (\\<exists>b\\<ge>0.\n                                b \\<le> 1 \\<and>\n                                rot_diamond_cube (aa, ba) =\n                                diamond_cube_gen (a, b))", "show \"\\<exists>a\\<ge>0. a \\<le> 1 \\<and> (\\<exists>b\\<ge>0. b \\<le> 1 \\<and> diamond_cube_gen (x, y) = rot_diamond_cube (a, b))\"\n    if \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \"(a, b) = diamond_cube_gen (x, y)\"\n    for a b x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<ge>0.\n       a \\<le> 1 \\<and>\n       (\\<exists>b\\<ge>0.\n           b \\<le> 1 \\<and>\n           diamond_cube_gen (x, y) = rot_diamond_cube (a, b))", "proof (intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. diamond_cube_gen (x, y) = rot_diamond_cube (?a, ?b3)", "let ?a = \"rot_y x y\""], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. diamond_cube_gen (x, y) = rot_diamond_cube (?a, ?b3)", "let ?b = \"rot_x x y\""], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. diamond_cube_gen (x, y) = rot_diamond_cube (?a, ?b3)", "show \"0 \\<le> ?a\" \"?a \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) +\n            1 / 2 &&&\n    (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2 \\<le> 1", "using rot_y_ivl that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> (?x - 1 / 2) /\n                            (2 * diamond_y_gen (x_coord (rot_x ?x ?y))) +\n                            1 / 2 \\<and>\n                    (?x - 1 / 2) /\n                    (2 * diamond_y_gen (x_coord (rot_x ?x ?y))) +\n                    1 / 2\n                    \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = diamond_cube_gen (x, y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) +\n            1 / 2 &&&\n    (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2 \\<le> 1", "by blast+"], ["proof (state)\nthis:\n  0 \\<le> (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2\n  (x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2 \\<le> 1\n\ngoal (3 subgoals):\n 1. 0 \\<le> ?b3\n 2. ?b3 \\<le> 1\n 3. diamond_cube_gen (x, y) =\n    rot_diamond_cube\n     ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2, ?b3)", "show \"0 \\<le> ?b\" \"?b \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y &&& rot_x x y \\<le> 1", "using rot_x_ivl that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> rot_x ?x ?y \\<and> rot_x ?x ?y \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = diamond_cube_gen (x, y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x x y &&& rot_x x y \\<le> 1", "by blast+"], ["proof (state)\nthis:\n  0 \\<le> rot_x x y\n  rot_x x y \\<le> 1\n\ngoal (1 subgoal):\n 1. diamond_cube_gen (x, y) =\n    rot_diamond_cube\n     ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n      rot_x x y)", "show \"diamond_cube_gen (x, y) = rot_diamond_cube (?a, ?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diamond_cube_gen (x, y) =\n    rot_diamond_cube\n     ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n      rot_x x y)", "using that d_gt_0 diamond_gen_eq_rot_diamond"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = diamond_cube_gen (x, y)\n  0 < d\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> diamond_cube_gen (?x, ?y) =\n                    rot_diamond_cube\n                     ((?x - 1 / 2) /\n                      (2 * diamond_y_gen (x_coord (rot_x ?x ?y))) +\n                      1 / 2,\n                      rot_x ?x ?y)\n\ngoal (1 subgoal):\n 1. diamond_cube_gen (x, y) =\n    rot_diamond_cube\n     ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n      rot_x x y)", "by auto"], ["proof (state)\nthis:\n  diamond_cube_gen (x, y) =\n  rot_diamond_cube\n   ((x - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x x y))) + 1 / 2,\n    rot_x x y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x2; ?x2 \\<le> 1; 0 \\<le> ?y2; ?y2 \\<le> 1;\n   (?a2, ?b2) = diamond_cube_gen (?x2, ?y2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<ge>0.\n                       a \\<le> 1 \\<and>\n                       (\\<exists>b\\<ge>0.\n                           b \\<le> 1 \\<and>\n                           diamond_cube_gen (?x2, ?y2) =\n                           rot_diamond_cube (a, b))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>0 \\<le> aa; aa \\<le> 1; 0 \\<le> ba; ba \\<le> 1;\n        (a, b) = rot_diamond_cube (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<ge>0.\n                            a \\<le> 1 \\<and>\n                            (\\<exists>b\\<ge>0.\n                                b \\<le> 1 \\<and>\n                                rot_diamond_cube (aa, ba) =\n                                diamond_cube_gen (a, b))", "show \"\\<exists>a\\<ge>0. a \\<le> 1 \\<and> (\\<exists>b\\<ge>0. b \\<le> 1 \\<and> rot_diamond_cube (x, y) = diamond_cube_gen (a, b))\"\n    if \"0 \\<le> x\" \"x \\<le> 1\" \"0 \\<le> y\" \"y \\<le> 1\" \"(a, b) = rot_diamond_cube (x, y)\" for a b x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<ge>0.\n       a \\<le> 1 \\<and>\n       (\\<exists>b\\<ge>0.\n           b \\<le> 1 \\<and>\n           rot_diamond_cube (x, y) = diamond_cube_gen (a, b))", "proof (intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. rot_diamond_cube (x, y) = diamond_cube_gen (?a, ?b3)", "let ?a = \"rot_x y x\""], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. rot_diamond_cube (x, y) = diamond_cube_gen (?a, ?b3)", "let ?b = \"rot_y y x\""], ["proof (state)\ngoal (5 subgoals):\n 1. 0 \\<le> ?a\n 2. ?a \\<le> 1\n 3. 0 \\<le> ?b3\n 4. ?b3 \\<le> 1\n 5. rot_diamond_cube (x, y) = diamond_cube_gen (?a, ?b3)", "show \"0 \\<le> ?a\" \"?a \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x y x &&& rot_x y x \\<le> 1", "using rot_x_ivl that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> rot_x ?x ?y \\<and> rot_x ?x ?y \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = rot_diamond_cube (x, y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> rot_x y x &&& rot_x y x \\<le> 1", "by blast+"], ["proof (state)\nthis:\n  0 \\<le> rot_x y x\n  rot_x y x \\<le> 1\n\ngoal (3 subgoals):\n 1. 0 \\<le> ?b3\n 2. ?b3 \\<le> 1\n 3. rot_diamond_cube (x, y) = diamond_cube_gen (rot_x y x, ?b3)", "show \"0 \\<le> ?b\" \"?b \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) +\n            1 / 2 &&&\n    (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2 \\<le> 1", "using rot_y_ivl that"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> (?x - 1 / 2) /\n                            (2 * diamond_y_gen (x_coord (rot_x ?x ?y))) +\n                            1 / 2 \\<and>\n                    (?x - 1 / 2) /\n                    (2 * diamond_y_gen (x_coord (rot_x ?x ?y))) +\n                    1 / 2\n                    \\<le> 1\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = rot_diamond_cube (x, y)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) +\n            1 / 2 &&&\n    (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2 \\<le> 1", "by blast+"], ["proof (state)\nthis:\n  0 \\<le> (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2\n  (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2 \\<le> 1\n\ngoal (1 subgoal):\n 1. rot_diamond_cube (x, y) =\n    diamond_cube_gen\n     (rot_x y x,\n      (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2)", "show \"rot_diamond_cube (x, y) = diamond_cube_gen (?a, ?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot_diamond_cube (x, y) =\n    diamond_cube_gen\n     (rot_x y x,\n      (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2)", "using that d_gt_0 rot_diamond_eq_diamond_gen"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<le> 1\n  0 \\<le> y\n  y \\<le> 1\n  (a, b) = rot_diamond_cube (x, y)\n  0 < d\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> 1; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> rot_diamond_cube (?x, ?y) =\n                    diamond_cube_gen\n                     (rot_x ?y ?x,\n                      (?y - 1 / 2) /\n                      (2 * diamond_y_gen (x_coord (rot_x ?y ?x))) +\n                      1 / 2)\n\ngoal (1 subgoal):\n 1. rot_diamond_cube (x, y) =\n    diamond_cube_gen\n     (rot_x y x,\n      (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2)", "by auto"], ["proof (state)\nthis:\n  rot_diamond_cube (x, y) =\n  diamond_cube_gen\n   (rot_x y x,\n    (y - 1 / 2) / (2 * diamond_y_gen (x_coord (rot_x y x))) + 1 / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x2; ?x2 \\<le> 1; 0 \\<le> ?y2; ?y2 \\<le> 1;\n   (?a2, ?b2) = rot_diamond_cube (?x2, ?y2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<ge>0.\n                       a \\<le> 1 \\<and>\n                       (\\<exists>b\\<ge>0.\n                           b \\<le> 1 \\<and>\n                           rot_diamond_cube (?x2, ?y2) =\n                           diamond_cube_gen (a, b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rot_diamond_gen_div_diamond_gen:\n  shows \"gen_division (cubeImage (diamond_cube_gen)) (cubeImage ` {rot_diamond_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube_gen)\n     (cubeImage ` {rot_diamond_cube})", "using rot_img_eq"], ["proof (prove)\nusing this:\n  cubeImage diamond_cube_gen = cubeImage rot_diamond_cube\n\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube_gen)\n     (cubeImage ` {rot_diamond_cube})", "by(auto simp add: gen_division_def)"], ["", "lemma rot_diamond_gen_div_diamond:\n  shows \"gen_division (cubeImage (diamond_cube)) (cubeImage ` {rot_diamond_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})", "using rot_diamond_gen_div_diamond_gen"], ["proof (prove)\nusing this:\n  gen_division (cubeImage diamond_cube_gen) (cubeImage ` {rot_diamond_cube})\n\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})", "by(simp only: diamond_eq_characterisations_fun)"], ["", "lemma GreenThm_diamond:\n  assumes \"analytically_valid (cubeImage (diamond_cube)) (\\<lambda>x. F x \\<bullet> i) j\"\n    \"analytically_valid (cubeImage (diamond_cube)) (\\<lambda>x. F x \\<bullet> j) i\"\n  shows \"integral (cubeImage (diamond_cube)) (\\<lambda>x. partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x - partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n         one_chain_line_integral F {i, j} (boundary (diamond_cube))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have 0: \"\\<forall>(k, \\<gamma>)\\<in>boundary (diamond_cube). valid_path \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>boundary diamond_cube. valid_path \\<gamma>", "using diamond_cube_boundary_valid d_gt_0"], ["proof (prove)\nusing this:\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<forall>(k, \\<gamma>)\\<in>boundary diamond_cube. valid_path \\<gamma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>(k, \\<gamma>)\\<in>boundary diamond_cube. valid_path \\<gamma>\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"\\<And>twoCube. twoCube \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube twoCube\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>twoCube.\n       twoCube \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube twoCube", "using assms diamond_cube_is_type_I"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> j)\n   i\n  typeI_twoCube diamond_cube\n\ngoal (1 subgoal):\n 1. \\<And>twoCube.\n       twoCube \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube twoCube", "by auto"], ["proof (state)\nthis:\n  ?twoCube2 \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube ?twoCube2\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  ?twoCube2 \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube ?twoCube2\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"valid_two_chain {diamond_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_chain {diamond_cube}", "using assms(1) diamond_cube_valid_two_cube valid_two_chain_def"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  valid_two_cube diamond_cube\n  valid_two_chain ?twoChain \\<equiv>\n  (\\<forall>twoCube\\<in>?twoChain. valid_two_cube twoCube) \\<and>\n  pairwise (\\<lambda>c1 c2. boundary c1 \\<inter> boundary c2 = {})\n   ?twoChain \\<and>\n  inj_on cubeImage ?twoChain\n\ngoal (1 subgoal):\n 1. valid_two_chain {diamond_cube}", "by auto"], ["proof (state)\nthis:\n  valid_two_chain {diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  valid_two_chain {diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"gen_division (cubeImage (diamond_cube)) (cubeImage ` {diamond_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})", "by (simp add: gen_division_def)"], ["proof (state)\nthis:\n  gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"(\\<forall>twoCube\\<in>({rot_diamond_cube}). typeII_twoCube twoCube)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube", "using assms rot_diamond_cube_is_type_II"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> j)\n   i\n  typeII_twoCube rot_diamond_cube\n\ngoal (1 subgoal):\n 1. \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube", "by auto"], ["proof (state)\nthis:\n  \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"valid_two_chain {rot_diamond_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_two_chain {rot_diamond_cube}", "using assms(1) rot_diamond_cube_valid_two_cube valid_two_chain_def"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  valid_two_cube rot_diamond_cube\n  valid_two_chain ?twoChain \\<equiv>\n  (\\<forall>twoCube\\<in>?twoChain. valid_two_cube twoCube) \\<and>\n  pairwise (\\<lambda>c1 c2. boundary c1 \\<inter> boundary c2 = {})\n   ?twoChain \\<and>\n  inj_on cubeImage ?twoChain\n\ngoal (1 subgoal):\n 1. valid_two_chain {rot_diamond_cube}", "by auto"], ["proof (state)\nthis:\n  valid_two_chain {rot_diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  valid_two_chain {rot_diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have \"gen_division (cubeImage (diamond_cube)) (cubeImage ` {rot_diamond_cube})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})", "using rot_diamond_gen_div_diamond"], ["proof (prove)\nusing this:\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n\ngoal (1 subgoal):\n 1. gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})", "by auto"], ["proof (state)\nthis:\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have 3: \"only_vertical_division (boundary (diamond_cube)) {diamond_cube}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. only_vertical_division (boundary diamond_cube) {diamond_cube}", "using twoChainVertDiv_of_itself[of \"{diamond_cube}\"] diamond_cube_boundary_valid assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {diamond_cube};\n   \\<forall>(k, \\<gamma>)\\<in>two_chain_boundary {diamond_cube}.\n      valid_path \\<gamma>\\<rbrakk>\n  \\<Longrightarrow> only_vertical_division\n                     (two_chain_boundary {diamond_cube}) {diamond_cube}\n  (?k, ?\\<gamma>) \\<in> boundary diamond_cube \\<Longrightarrow>\n  valid_path ?\\<gamma>\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> j)\n   i\n\ngoal (1 subgoal):\n 1. only_vertical_division (boundary diamond_cube) {diamond_cube}", "by(auto simp add: two_chain_boundary_def)"], ["proof (state)\nthis:\n  only_vertical_division (boundary diamond_cube) {diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  only_vertical_division (boundary diamond_cube) {diamond_cube}\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have 4: \"\\<forall>twoC\\<in>{diamond_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>twoC\\<in>{diamond_cube}.\n       analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j", "using assms"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> j)\n   i\n\ngoal (1 subgoal):\n 1. \\<forall>twoC\\<in>{diamond_cube}.\n       analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>twoC\\<in>{diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "moreover"], ["proof (state)\nthis:\n  \\<forall>twoC\\<in>{diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "have 5: \"\\<forall>twoC\\<in>{rot_diamond_cube}. analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>twoC\\<in>{rot_diamond_cube}.\n       analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i", "using assms diamond_eq_characterisations_fun rot_img_eq"], ["proof (prove)\nusing this:\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> i)\n   j\n  analytically_valid (cubeImage diamond_cube) (\\<lambda>x. F x \\<bullet> j)\n   i\n  diamond_cube = diamond_cube_gen\n  cubeImage diamond_cube_gen = cubeImage rot_diamond_cube\n\ngoal (1 subgoal):\n 1. \\<forall>twoC\\<in>{rot_diamond_cube}.\n       analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i", "by auto"], ["proof (state)\nthis:\n  \\<forall>twoC\\<in>{rot_diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "ultimately"], ["proof (chain)\npicking this:\n  ?twoCube2 \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube ?twoCube2\n  valid_two_chain {diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})\n  \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube\n  valid_two_chain {rot_diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n  only_vertical_division (boundary diamond_cube) {diamond_cube}\n  \\<forall>twoC\\<in>{diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n  \\<forall>twoC\\<in>{rot_diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?twoCube2 \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube ?twoCube2\n  valid_two_chain {diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})\n  \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube\n  valid_two_chain {rot_diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n  only_vertical_division (boundary diamond_cube) {diamond_cube}\n  \\<forall>twoC\\<in>{diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n  \\<forall>twoC\\<in>{rot_diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "using green_typeI_typeII_chain.GreenThm_typeI_typeII_divisible_region_finite_holes[of \"(cubeImage (diamond_cube))\" i j F \"{diamond_cube}\" \"{rot_diamond_cube}\", OF _ 0 3 diamond_cube_is_only_horizontal_div_of_rot _]\n      R2_axioms"], ["proof (prove)\nusing this:\n  ?twoCube2 \\<in> {diamond_cube} \\<Longrightarrow> typeI_twoCube ?twoCube2\n  valid_two_chain {diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {diamond_cube})\n  \\<forall>twoCube\\<in>{rot_diamond_cube}. typeII_twoCube twoCube\n  valid_two_chain {rot_diamond_cube}\n  gen_division (cubeImage diamond_cube) (cubeImage ` {rot_diamond_cube})\n  only_vertical_division (boundary diamond_cube) {diamond_cube}\n  \\<forall>twoC\\<in>{diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> i) j\n  \\<forall>twoC\\<in>{rot_diamond_cube}.\n     analytically_valid (cubeImage twoC) (\\<lambda>x. F x \\<bullet> j) i\n  \\<lbrakk>green_typeI_typeII_chain (cubeImage diamond_cube) i j F\n            {diamond_cube} {rot_diamond_cube};\n   cubeImage diamond_cube = cubeImage diamond_cube\\<rbrakk>\n  \\<Longrightarrow> integral (cubeImage diamond_cube)\n                     (\\<lambda>x.\n                         partial_vector_derivative\n                          (\\<lambda>x. F x \\<bullet> j) i x -\n                         partial_vector_derivative\n                          (\\<lambda>x. F x \\<bullet> i) j x) =\n                    one_chain_line_integral F {i, j} (boundary diamond_cube)\n  R2 i j\n\ngoal (1 subgoal):\n 1. integral (cubeImage diamond_cube)\n     (\\<lambda>x.\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n         partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n    one_chain_line_integral F {i, j} (boundary diamond_cube)", "by(auto simp add: green_typeI_typeII_chain_def green_typeI_chain_def green_typeII_chain_def green_typeI_chain_axioms_def green_typeII_chain_axioms_def)"], ["proof (state)\nthis:\n  integral (cubeImage diamond_cube)\n   (\\<lambda>x.\n       partial_vector_derivative (\\<lambda>x. F x \\<bullet> j) i x -\n       partial_vector_derivative (\\<lambda>x. F x \\<bullet> i) j x) =\n  one_chain_line_integral F {i, j} (boundary diamond_cube)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}