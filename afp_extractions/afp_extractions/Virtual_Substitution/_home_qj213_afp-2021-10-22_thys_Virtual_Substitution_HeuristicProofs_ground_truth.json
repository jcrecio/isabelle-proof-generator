{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/HeuristicProofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma the_real_step_augment:\n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  shows \"(\\<exists>xs. (length xs = amount \\<and> eval (list_disj (map(\\<lambda>(L,F,n). ExN n (list_conj (map fm.Atom L @ F))) F))  (xs @ \\<Gamma>))) = (eval (the_real_step_augment step amount F)  \\<Gamma>)\"", "lemma step_converter : \n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  shows \"\\<And>var L F \\<Gamma>. (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (step var L F) (xs @ \\<Gamma>))\"", "lemma step_augmenter_eval : \n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  assumes heuristic: \"\\<And>n var L F. heuristic n L F = var \\<Longrightarrow> var \\<le> n\"\n  shows \"\\<And>var amount L F \\<Gamma>.\n      amount \\<le> var + 1 \\<Longrightarrow>\n      (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (step_augment step heuristic amount var L F) (xs @ \\<Gamma>))\"", "lemma qe_eq_repeat_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment qe_eq_repeat IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\"", "lemma qe_eq_repeat_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (qe_eq_repeat var L F) (xs @ \\<Gamma>))\"", "lemma gen_qe_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment gen_qe IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\"", "lemma gen_qe_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (gen_qe var L F) (xs @ \\<Gamma>))\"", "lemma luckyFind_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment luckyFind' IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\"", "lemma luckyFind_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (luckyFind' var L F) (xs @ \\<Gamma>))\"", "lemma luckiestFind_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (luckiestFind var L F) (xs @ \\<Gamma>))\"", "lemma sortedListMember : \"sorted_list_of_fset b = var # list \\<Longrightarrow> fmember var b \"", "lemma rangeHeuristic : \n  assumes \"heuristicPicker n L F = Some (var, step)\"\n  shows \"var\\<le>n\"", "lemma pickedOneOfThem : \n  assumes \"heuristicPicker n L F = Some (var, step)\"\n  shows \"step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\"", "lemma superPicker_eval : \n  \"amount\\<le> var+1 \\<Longrightarrow> (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (superPicker amount var L F) (xs @ \\<Gamma>))\"", "lemma brownHueristic_less_than: \"brownsHeuristic n L F = var \\<Longrightarrow> var\\<le> n\""], "translations": [["", "lemma the_real_step_augment:\n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  shows \"(\\<exists>xs. (length xs = amount \\<and> eval (list_disj (map(\\<lambda>(L,F,n). ExN n (list_conj (map fm.Atom L @ F))) F))  (xs @ \\<Gamma>))) = (eval (the_real_step_augment step amount F)  \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = amount \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>(L, F, n). ExN n (list_conj (map fm.Atom L @ F)))\n             F))\n         (xs @ \\<Gamma>)) =\n    eval (the_real_step_augment step amount F) \\<Gamma>", "proof(induction amount arbitrary: F \\<Gamma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>F \\<Gamma>.\n       (\\<exists>xs.\n           length xs = 0 \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step 0 F) \\<Gamma>\n 2. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>F \\<Gamma>.\n       (\\<exists>xs.\n           length xs = 0 \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step 0 F) \\<Gamma>\n 2. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = 0 \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>a.\n                    case a of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n             F))\n         (xs @ \\<Gamma>)) =\n    eval (the_real_step_augment step 0 F) \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = 0 \\<and>\n      eval\n       (list_disj\n         (map (\\<lambda>a.\n                  case a of\n                  (L, F, n) \\<Rightarrow>\n                    ExN n (list_conj (map fm.Atom L @ F)))\n           F))\n       (xs @ \\<Gamma>)) =\n  eval (the_real_step_augment step 0 F) \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "case (Suc amount)"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = amount \\<and>\n      eval\n       (list_disj\n         (map (\\<lambda>a.\n                  case a of\n                  (L, F, n) \\<Rightarrow>\n                    ExN n (list_conj (map fm.Atom L @ F)))\n           ?F))\n       (xs @ ?\\<Gamma>)) =\n  eval (the_real_step_augment step amount ?F) ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "have h1 : \"\\<And>F. (\\<exists>x xs. length xs = amount \\<and> F (xs @ x # \\<Gamma>)) = (\\<exists>xs. length xs = Suc amount \\<and> F (xs @  \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       (\\<exists>x xs. length xs = amount \\<and> F (xs @ x # \\<Gamma>)) =\n       (\\<exists>xs. length xs = Suc amount \\<and> F (xs @ \\<Gamma>))", "by (smt (z3) Suc_inject append.assoc append_Cons append_Nil2 append_eq_conv_conj length_append_singleton lessI self_append_conv2 take_hd_drop)"], ["proof (state)\nthis:\n  (\\<exists>x xs. length xs = amount \\<and> ?F (xs @ x # \\<Gamma>)) =\n  (\\<exists>xs. length xs = Suc amount \\<and> ?F (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "have h2: \"\\<And>X x \\<Gamma>. (\\<exists>f\\<in>set (dnf_modified X).\n         eval (case f of (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F))) (x @ \\<Gamma>)) = (\\<exists>(al, fl, n)\\<in>set (dnf_modified X). \\<exists>L. length L = n \\<and> (\\<forall>a\\<in>set al. aEval a (L @ (x @ \\<Gamma>))) \\<and> (\\<forall>f\\<in>set fl. eval f (L @ (x @ \\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x \\<Gamma>.\n       (\\<exists>f\\<in>set (dnf_modified X).\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            (x @ \\<Gamma>)) =\n       (\\<exists>(al, fl, n)\\<in>set (dnf_modified X).\n           \\<exists>L.\n              length L = n \\<and>\n              (\\<forall>a\\<in>set al. aEval a (L @ x @ \\<Gamma>)) \\<and>\n              (\\<forall>f\\<in>set fl. eval f (L @ x @ \\<Gamma>)))", "subgoal for X x \\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (dnf_modified X).\n        eval\n         (case f of\n          (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n         (x @ \\<Gamma>)) =\n    (\\<exists>(al, fl, n)\\<in>set (dnf_modified X).\n        \\<exists>L.\n           length L = n \\<and>\n           (\\<forall>a\\<in>set al. aEval a (L @ x @ \\<Gamma>)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (L @ x @ \\<Gamma>)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (dnf_modified X) = set (dnf_modified X)\n 2. \\<And>f.\n       f \\<in> set (dnf_modified X) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        (x @ \\<Gamma>) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x @ \\<Gamma>)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x @ \\<Gamma>)))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (dnf_modified X) \\<Longrightarrow>\n       eval\n        (case f of\n         (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n        (x @ \\<Gamma>) =\n       (case f of\n        (al, fl, n) \\<Rightarrow>\n          \\<exists>L.\n             length L = n \\<and>\n             (\\<forall>a\\<in>set al. aEval a (L @ x @ \\<Gamma>)) \\<and>\n             (\\<forall>f\\<in>set fl. eval f (L @ x @ \\<Gamma>)))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (dnf_modified X) \\<Longrightarrow>\n    eval\n     (case f of\n      (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n     (x @ \\<Gamma>) =\n    (case f of\n     (al, fl, n) \\<Rightarrow>\n       \\<exists>L.\n          length L = n \\<and>\n          (\\<forall>a\\<in>set al. aEval a (L @ x @ \\<Gamma>)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (L @ x @ \\<Gamma>)))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>f \\<in> set (dnf_modified X); f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case f of\n                           (L, F, n) \\<Rightarrow>\n                             ExN n (list_conj (map fm.Atom L @ F)))\n                          (x @ \\<Gamma>) =\n                         (case f of\n                          (al, fl, n) \\<Rightarrow>\n                            \\<exists>L.\n                               length L = n \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (L @ x @ \\<Gamma>)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (L @ x @ \\<Gamma>)))", "apply(auto simp add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l.\n       \\<lbrakk>(a, b, length l) \\<in> set (dnf_modified X);\n        f = (a, b, length l);\n        \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n           eval f (l @ x @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L.\n                            length L = length l \\<and>\n                            (\\<forall>a\\<in>set a.\n                                aEval a (L @ x @ \\<Gamma>)) \\<and>\n                            (\\<forall>f\\<in>set b.\n                                eval f (L @ x @ \\<Gamma>))", "by (metis Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>f\\<in>set (dnf_modified ?X).\n      eval\n       (case f of\n        (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n       (?x @ ?\\<Gamma>)) =\n  (\\<exists>(al, fl, n)\\<in>set (dnf_modified ?X).\n      \\<exists>L.\n         length L = n \\<and>\n         (\\<forall>a\\<in>set al. aEval a (L @ ?x @ ?\\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (L @ ?x @ ?\\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "have h3 : \"\\<And>G. (\\<exists>x. \\<exists>f\\<in>set F. G x f) = (\\<exists>f\\<in>set F. \\<exists>x. G x f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G.\n       (\\<exists>x. \\<exists>f\\<in>set F. G x f) =\n       (\\<exists>f\\<in>set F. \\<exists>x. G x f)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. \\<exists>f\\<in>set F. ?G x f) =\n  (\\<exists>f\\<in>set F. \\<exists>x. ?G x f)\n\ngoal (1 subgoal):\n 1. \\<And>amount F \\<Gamma>.\n       (\\<And>F \\<Gamma>.\n           (\\<exists>xs.\n               length xs = amount \\<and>\n               eval\n                (list_disj\n                  (map (\\<lambda>(L, F, n).\n                           ExN n (list_conj (map fm.Atom L @ F)))\n                    F))\n                (xs @ \\<Gamma>)) =\n           eval (the_real_step_augment step amount F)\n            \\<Gamma>) \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc amount \\<and>\n           eval\n            (list_disj\n              (map (\\<lambda>(L, F, n).\n                       ExN n (list_conj (map fm.Atom L @ F)))\n                F))\n            (xs @ \\<Gamma>)) =\n       eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc amount \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>a.\n                    case a of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n             F))\n         (xs @ \\<Gamma>)) =\n    eval (the_real_step_augment step (Suc amount) F) \\<Gamma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc amount \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>a.\n                    case a of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n             F))\n         (xs @ \\<Gamma>)) =\n    (\\<exists>x.\n        eval\n         (the_real_step_augment step amount\n           (dnf_modified\n             (push_forall\n               (nnf (unpower 0\n                      (groupQuantifiers\n                        (clearQuantifiers\n                          (list_disj\n                            (map (\\<lambda>(L, F, n).\n                                     ExN n (step (n + amount) L F))\n                              F)))))))))\n         (x # \\<Gamma>))", "unfolding Suc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc amount \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>a.\n                    case a of\n                    (L, F, n) \\<Rightarrow>\n                      ExN n (list_conj (map fm.Atom L @ F)))\n             F))\n         (xs @ \\<Gamma>)) =\n    (\\<exists>x xs.\n        length xs = amount \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>(L, F, n). ExN n (list_conj (map fm.Atom L @ F)))\n             (dnf_modified\n               (push_forall\n                 (nnf (unpower 0\n                        (groupQuantifiers\n                          (clearQuantifiers\n                            (list_disj\n                              (map (\\<lambda>(L, F, n).\n ExN n (step (n + amount) L F))\n                                F))))))))))\n         (xs @ x # \\<Gamma>))", "unfolding eval_list_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc amount \\<and>\n        (\\<exists>f\\<in>set (map (\\<lambda>(L, F, n).\n                                     ExN n (list_conj (map fm.Atom L @ F)))\n                              F).\n            eval f (xs @ \\<Gamma>))) =\n    (\\<exists>x xs.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set (map (\\<lambda>(L, F, n).\n                                     ExN n (list_conj (map fm.Atom L @ F)))\n                              (dnf_modified\n                                (push_forall\n                                  (nnf (unpower 0\n   (groupQuantifiers\n     (clearQuantifiers\n       (list_disj\n         (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F))\n           F))))))))).\n            eval f (xs @ x # \\<Gamma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc amount \\<and>\n        (\\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ \\<Gamma>))) =\n    (\\<exists>x xs.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set (dnf_modified\n                              (push_forall\n                                (nnf (unpower 0\n (groupQuantifiers\n   (clearQuantifiers\n     (list_disj\n       (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>)))", "unfolding h1[symmetric, of \"\\<lambda>x. (\\<exists>f\\<in>set F. eval (case f of (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F))) x)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x xs.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (\\<exists>x xs.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set (dnf_modified\n                              (push_forall\n                                (nnf (unpower 0\n (groupQuantifiers\n   (clearQuantifiers\n     (list_disj\n       (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>)))", "unfolding HOL.ex_comm[of \"\\<lambda>x xs. length xs = amount \\<and> (\\<exists>f\\<in>set F. eval (case f of (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F))) (xs @ x # \\<Gamma>))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs x.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (\\<exists>x xs.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set (dnf_modified\n                              (push_forall\n                                (nnf (unpower 0\n (groupQuantifiers\n   (clearQuantifiers\n     (list_disj\n       (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>)))", "unfolding HOL.ex_comm[of \"\\<lambda>x xs. length xs = amount \\<and>\n        (\\<exists>f\\<in>set (dnf_modified (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers(list_disj (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval (case f of (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F))) (xs @ x # \\<Gamma>))\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs x.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (\\<exists>xs x.\n        length xs = amount \\<and>\n        (\\<exists>f\\<in>set (dnf_modified\n                              (push_forall\n                                (nnf (unpower 0\n (groupQuantifiers\n   (clearQuantifiers\n     (list_disj\n       (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<exists>x.\n           length xs = amount \\<and>\n           (\\<exists>f\\<in>set F.\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ x # \\<Gamma>))) =\n       (\\<exists>x.\n           length xs = amount \\<and>\n           (\\<exists>f\\<in>set (dnf_modified\n                                 (push_forall\n                                   (nnf (unpower 0\n    (groupQuantifiers\n      (clearQuantifiers\n        (list_disj\n          (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F))\n            F)))))))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ x # \\<Gamma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (length xs = amount \\<and>\n        (\\<exists>x.\n            \\<exists>f\\<in>set F.\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ x # \\<Gamma>))) =\n       (length xs = amount \\<and>\n        (\\<exists>x.\n            \\<exists>f\\<in>set (dnf_modified\n                                 (push_forall\n                                   (nnf (unpower 0\n    (groupQuantifiers\n      (clearQuantifiers\n        (list_disj\n          (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F))\n            F)))))))).\n               eval\n                (case f of\n                 (L, F, n) \\<Rightarrow>\n                   ExN n (list_conj (map fm.Atom L @ F)))\n                (xs @ x # \\<Gamma>)))", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set (dnf_modified\n                              (push_forall\n                                (nnf (unpower 0\n (groupQuantifiers\n   (clearQuantifiers\n     (list_disj\n       (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>)))", "unfolding h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>(al, fl, n)\n                  \\<in>set (dnf_modified\n                             (push_forall\n                               (nnf (unpower 0\n(groupQuantifiers\n  (clearQuantifiers\n    (list_disj\n      (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F)))))))).\n            \\<exists>L.\n               length L = n \\<and>\n               (\\<forall>a\\<in>set al.\n                   aEval a (L @ xs @ x # \\<Gamma>)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (L @ xs @ x # \\<Gamma>))))", "unfolding dnf_modified_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         eval\n          (push_forall\n            (nnf (unpower 0\n                   (groupQuantifiers\n                     (clearQuantifiers\n                       (list_disj\n                         (map (\\<lambda>(L, F, n).\n                                  ExN n (step (n + amount) L F))\n                           F)))))))\n          (xs @ x # \\<Gamma>)))", "unfolding opt'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         eval\n          (list_disj\n            (map (\\<lambda>(L, F, n). ExN n (step (n + amount) L F)) F))\n          (xs @ x # \\<Gamma>)))", "unfolding eval_list_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set (map (\\<lambda>(L, F, n).\n                                     ExN n (step (n + amount) L F))\n                              F).\n            eval f (xs @ x # \\<Gamma>)))", "unfolding List.set_map Set.bex_simps(7)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>f\\<in>set F.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>x.\n         \\<exists>xa\\<in>set F.\n            eval\n             (case xa of\n              (L, F, n) \\<Rightarrow> ExN n (step (n + amount) L F))\n             (xs @ x # \\<Gamma>)))", "unfolding h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (step (n + amount) L F))\n             (xs @ x # \\<Gamma>)))", "apply(cases \"length xs = amount\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs = amount \\<Longrightarrow>\n    (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (step (n + amount) L F))\n             (xs @ x # \\<Gamma>)))\n 2. length xs \\<noteq> amount \\<Longrightarrow>\n    (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n             (xs @ x # \\<Gamma>))) =\n    (length xs = amount \\<and>\n     (\\<exists>f\\<in>set F.\n         \\<exists>x.\n            eval\n             (case f of\n              (L, F, n) \\<Rightarrow> ExN n (step (n + amount) L F))\n             (xs @ x # \\<Gamma>)))", "apply (simp_all add:opt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = amount \\<Longrightarrow>\n    (\\<exists>f\\<in>set F.\n        \\<exists>x.\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (list_conj (map fm.Atom L @ F)))\n            (xs @ x # \\<Gamma>)) =\n    (\\<exists>f\\<in>set F.\n        \\<exists>x.\n           eval\n            (case f of\n             (L, F, n) \\<Rightarrow> ExN n (step (n + amount) L F))\n            (xs @ x # \\<Gamma>))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs = amount \\<Longrightarrow> set F = set F\n 2. \\<And>f.\n       \\<lbrakk>length xs = amount; f \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (list_conj (map fm.Atom L @ F)))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (step (n + amount) L F))\n                              (xs @ x # \\<Gamma>))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>length xs = amount; f \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (list_conj (map fm.Atom L @ F)))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (step (n + amount) L F))\n                              (xs @ x # \\<Gamma>))", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; f \\<in> set F\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval\n                           (case f of\n                            (L, F, n) \\<Rightarrow>\n                              ExN n (list_conj (map fm.Atom L @ F)))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval\n                           (case f of\n                            (L, F, n) \\<Rightarrow>\n                              ExN n (step (n + amount) L F))\n                           (xs @ x # \\<Gamma>))", "apply(cases f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>length xs = amount; f \\<in> set F; f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (list_conj (map fm.Atom L @ F)))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval\n                              (case f of\n                               (L, F, n) \\<Rightarrow>\n                                 ExN n (step (n + amount) L F))\n                              (xs @ x # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x l.\n                             length l = c \\<and>\n                             eval (list_conj (map fm.Atom a @ b))\n                              (l @ xs @ x # \\<Gamma>)) =\n                         (\\<exists>x l.\n                             length l = c \\<and>\n                             eval (step (c + amount) a b)\n                              (l @ xs @ x # \\<Gamma>))", "subgoal for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x l.\n                          length l = c \\<and>\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ x # \\<Gamma>)) =\n                      (\\<exists>x l.\n                          length l = c \\<and>\n                          eval (step (c + amount) a b)\n                           (l @ xs @ x # \\<Gamma>))", "unfolding HOL.ex_comm[of \"\\<lambda>x l. length l = c \\<and> eval (list_conj (map fm.Atom a @ b)) (l @ xs @ x # \\<Gamma>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l x.\n                          length l = c \\<and>\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ x # \\<Gamma>)) =\n                      (\\<exists>x l.\n                          length l = c \\<and>\n                          eval (step (c + amount) a b)\n                           (l @ xs @ x # \\<Gamma>))", "unfolding HOL.ex_comm[of \"\\<lambda>x l. length l = c \\<and> eval (step (c + amount) a b) (l @ xs @ x # \\<Gamma>)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>l x.\n                          length l = c \\<and>\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ x # \\<Gamma>)) =\n                      (\\<exists>l x.\n                          length l = c \\<and>\n                          eval (step (c + amount) a b)\n                           (l @ xs @ x # \\<Gamma>))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             length l = c \\<and>\n                             eval (list_conj (map fm.Atom a @ b))\n                              (l @ xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             length l = c \\<and>\n                             eval (step (c + amount) a b)\n                              (l @ xs @ x # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n        f = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (length l = c \\<and>\n                          (\\<exists>x.\n                              eval (list_conj (map fm.Atom a @ b))\n                               (l @ xs @ x # \\<Gamma>))) =\n                         (length l = c \\<and>\n                          (\\<exists>x.\n                              eval (step (c + amount) a b)\n                               (l @ xs @ x # \\<Gamma>)))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F;\n     f = (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (list_conj (map fm.Atom a @ b))\n                            (l @ xs @ x # \\<Gamma>))) =\n                      (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (step (c + amount) a b)\n                            (l @ xs @ x # \\<Gamma>)))", "apply(cases \"length l = c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F; f = (a, b, c);\n     length l = c\\<rbrakk>\n    \\<Longrightarrow> (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (list_conj (map fm.Atom a @ b))\n                            (l @ xs @ x # \\<Gamma>))) =\n                      (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (step (c + amount) a b)\n                            (l @ xs @ x # \\<Gamma>)))\n 2. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F; f = (a, b, c);\n     length l \\<noteq> c\\<rbrakk>\n    \\<Longrightarrow> (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (list_conj (map fm.Atom a @ b))\n                            (l @ xs @ x # \\<Gamma>))) =\n                      (length l = c \\<and>\n                       (\\<exists>x.\n                           eval (step (c + amount) a b)\n                            (l @ xs @ x # \\<Gamma>)))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F; f = (a, b, c);\n     length l = c\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (step (c + amount) a b)\n                           (l @ xs @ x # \\<Gamma>))", "using steph[of \"l @ xs\" \"c + amount\" a b \\<Gamma>]"], ["proof (prove)\nusing this:\n  length (l @ xs) = c + amount \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom a @ b)) ((l @ xs) @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (step (c + amount) a b) ((l @ xs) @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = amount; (a, b, c) \\<in> set F; f = (a, b, c);\n     length l = c\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom a @ b))\n                           (l @ xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (step (c + amount) a b)\n                           (l @ xs @ x # \\<Gamma>))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc amount \\<and>\n      eval\n       (list_disj\n         (map (\\<lambda>a.\n                  case a of\n                  (L, F, n) \\<Rightarrow>\n                    ExN n (list_conj (map fm.Atom L @ F)))\n           F))\n       (xs @ \\<Gamma>)) =\n  eval (the_real_step_augment step (Suc amount) F) \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_converter : \n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  shows \"\\<And>var L F \\<Gamma>. (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (step var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma>.\n       (\\<exists>xs.\n           length xs = var + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = var + 1 \\<and> eval (step var L F) (xs @ \\<Gamma>))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix var L F \\<Gamma> xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h : \"length xs = var + 1\"\n    \"eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = var + 1\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h1 : \"length (take var xs) = var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take var xs) = var", "using h"], ["proof (prove)\nusing this:\n  length xs = var + 1\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. length (take var xs) = var", "by auto"], ["proof (state)\nthis:\n  length (take var xs) = var\n\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h2 : \"(\\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>)", "using h steph[OF h1]"], ["proof (prove)\nusing this:\n  length xs = var + 1\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F))\n       (take var xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (step var ?L ?F) (take var xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>)", "by (metis Cons_nth_drop_Suc One_nat_def add.right_neutral add_Suc_right append.assoc append_Cons append_Nil append_take_drop_id drop_all lessI order_refl)"], ["proof (state)\nthis:\n  \\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>)", "obtain x where h3: \"eval (step var L F) (take var xs @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>x. eval (step var L F) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (step var L F) (take var xs @ x # \\<Gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (step var L F) (take var xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (step var L F) (xs @ \\<Gamma>)\n 2. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = var + 1 \\<and> eval (step var L F) (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = var + 1 \\<and> eval (step var L F) (xs @ \\<Gamma>)", "apply(rule exI[where x=\"take var xs @[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take var xs @ [x]) = var + 1 \\<and>\n    eval (step var L F) ((take var xs @ [x]) @ \\<Gamma>)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. min (length xs) var = var\n 2. eval (step var L F) (take var xs @ x # \\<Gamma>)", "using h(1)"], ["proof (prove)\nusing this:\n  length xs = var + 1\n\ngoal (2 subgoals):\n 1. min (length xs) var = var\n 2. eval (step var L F) (take var xs @ x # \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (step var L F) (take var xs @ x # \\<Gamma>)", "using h3"], ["proof (prove)\nusing this:\n  eval (step var L F) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (step var L F) (take var xs @ x # \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = var + 1 \\<and> eval (step var L F) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix var L F \\<Gamma> xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h: \"length xs = var + 1\"\n    \"eval (step var L F) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = var + 1\n  eval (step var L F) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h1 : \"length (take var xs) = var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take var xs) = var", "using h"], ["proof (prove)\nusing this:\n  length xs = var + 1\n  eval (step var L F) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. length (take var xs) = var", "by auto"], ["proof (state)\nthis:\n  length (take var xs) = var\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h2 : \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "using h steph[OF h1]"], ["proof (prove)\nusing this:\n  length xs = var + 1\n  eval (step var L F) (xs @ \\<Gamma>)\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F))\n       (take var xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (step var ?L ?F) (take var xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "by (metis Cons_nth_drop_Suc One_nat_def add.right_neutral add_Suc_right append.assoc append_Cons append_Nil append_take_drop_id drop_all lessI order_refl)"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "obtain x where h3: \"eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (list_conj (map fm.Atom L @ F))\n         (take var xs @ x # \\<Gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> xs.\n       \\<lbrakk>length xs = var + 1;\n        eval (step var L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = var + 1 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = var + 1 \\<and>\n       eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)", "apply(rule exI[where x=\"take var xs @[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take var xs @ [x]) = var + 1 \\<and>\n    eval (list_conj (map fm.Atom L @ F)) ((take var xs @ [x]) @ \\<Gamma>)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. min (length xs) var = var\n 2. eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "using h(1)"], ["proof (prove)\nusing this:\n  length xs = var + 1\n\ngoal (2 subgoals):\n 1. min (length xs) var = var\n 2. eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "using h3"], ["proof (prove)\nusing this:\n  eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F)) (take var xs @ x # \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = var + 1 \\<and>\n     eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_augmenter_eval : \n  assumes  steph : \"\\<And>xs var L F \\<Gamma>. length xs = var \\<Longrightarrow> (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. eval (step var L F) (xs @ x # \\<Gamma>))\"\n  assumes heuristic: \"\\<And>n var L F. heuristic n L F = var \\<Longrightarrow> var \\<le> n\"\n  shows \"\\<And>var amount L F \\<Gamma>.\n      amount \\<le> var + 1 \\<Longrightarrow>\n      (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (step_augment step heuristic amount var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var amount L F \\<Gamma>.\n       amount \\<le> var + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = var + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = var + 1 \\<and>\n           eval (step_augment step heuristic amount var L F)\n            (xs @ \\<Gamma>))", "subgoal for var amount L F \\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> var + 1 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (step_augment step heuristic amount var L F) (xs @ \\<Gamma>))", "proof(induction var arbitrary: L F \\<Gamma> amount)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L F \\<Gamma> amount.\n       amount \\<le> 0 + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "case 0"], ["proof (state)\nthis:\n  amount \\<le> 0 + 1\n\ngoal (2 subgoals):\n 1. \\<And>L F \\<Gamma> amount.\n       amount \\<le> 0 + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  amount \\<le> 0 + 1", "have \"amount = 0 \\<or> amount = Suc 0\""], ["proof (prove)\nusing this:\n  amount \\<le> 0 + 1\n\ngoal (1 subgoal):\n 1. amount = 0 \\<or> amount = Suc 0", "by auto"], ["proof (state)\nthis:\n  amount = 0 \\<or> amount = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>L F \\<Gamma> amount.\n       amount \\<le> 0 + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  amount = 0 \\<or> amount = Suc 0", "show ?case"], ["proof (prove)\nusing this:\n  amount = 0 \\<or> amount = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = 0 + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = 0 + 1 \\<and>\n        eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount = 0 \\<or> amount = Suc 0 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))", "using steph[of \"[]\" 0 L F \\<Gamma>]"], ["proof (prove)\nusing this:\n  length [] = 0 \\<Longrightarrow>\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) ([] @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (step 0 L F) ([] @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. amount = 0 \\<or> amount = Suc 0 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xs.\n       \\<lbrakk>amount = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        eval (step 0 L F) (xa # \\<Gamma>); length xs = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (step 0 L F) (xs @ \\<Gamma>)\n 2. \\<And>x xa xs.\n       \\<lbrakk>amount = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        eval (step 0 L F) (xa # \\<Gamma>); length xs = Suc 0;\n        eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)\n 3. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (step 0 L F) (xs @ \\<Gamma>)\n 4. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0; eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "apply (metis append_Cons length_Cons list.size(3) self_append_conv2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xs.\n       \\<lbrakk>amount = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        eval (step 0 L F) (xa # \\<Gamma>); length xs = Suc 0;\n        eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (step 0 L F) (xs @ \\<Gamma>)\n 3. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0; eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "apply (metis append_Cons length_Cons list.size(3) self_append_conv2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0;\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (step 0 L F) (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0; eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "apply (metis Suc_length_conv append_Cons length_0_conv self_append_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>amount = Suc 0;\n        \\<forall>x.\n           \\<not> eval (list_conj (map fm.Atom L @ F)) (x # \\<Gamma>);\n        \\<forall>x. \\<not> eval (step 0 L F) (x # \\<Gamma>);\n        length xs = Suc 0; eval (step 0 L F) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc 0 \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "by (metis Suc_length_conv append_Cons append_self_conv2 length_0_conv)"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (step_augment step heuristic amount 0 L F) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "case (Suc var)"], ["proof (state)\nthis:\n  ?amount \\<le> var + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = var + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = var + 1 \\<and>\n      eval (step_augment step heuristic ?amount var ?L ?F) (xs @ ?\\<Gamma>))\n  amount \\<le> Suc var + 1\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "define heu where \"heu = heuristic (Suc var) L F\""], ["proof (state)\nthis:\n  heu = heuristic (Suc var) L F\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "have heurange : \"heu \\<le> Suc var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heu \\<le> Suc var", "unfolding heu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heuristic (Suc var) L F \\<le> Suc var", "by (simp add: heuristic)"], ["proof (state)\nthis:\n  heu \\<le> Suc var\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "have lessThan1 : \"1 \\<le> var + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> var + 1", "by auto"], ["proof (state)\nthis:\n  1 \\<le> var + 1\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "{"], ["proof (state)\nthis:\n  1 \\<le> var + 1\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "fix amount"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "assume amountLessThan: \"amount \\<le> var + 1\""], ["proof (state)\nthis:\n  amount \\<le> var + 1\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "have \"(\\<exists>xs. length xs = Suc (Suc var) \\<and>\n          eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) = (\\<exists>xs. length xs = Suc (Suc var) \\<and>\n          eval\n           (step (Suc var) (map (swap_atom (Suc var) heu) L)\n             (map (swap_fm (Suc var) heu) F))\n           (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>))", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h: \"length (xs::real list) = Suc (Suc var)\" \"eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)", "have length : \"length (take (Suc var) (swap_list (Suc var) heu xs)) = Suc var\""], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. length (take (Suc var) (swap_list (Suc var) heu xs)) = Suc var", "by auto"], ["proof (state)\nthis:\n  length (take (Suc var) (swap_list (Suc var) heu xs)) = Suc var\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have take: \"(take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma>) = (swap_list (Suc var) heu (xs @ \\<Gamma>)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma> =\n    swap_list (Suc var) heu (xs @ \\<Gamma>)", "using h(1)"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n\ngoal (1 subgoal):\n 1. take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma> =\n    swap_list (Suc var) heu (xs @ \\<Gamma>)", "unfolding swap_list.simps"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n\ngoal (1 subgoal):\n 1. take (Suc var) (xs[heu := xs ! Suc var, Suc var := xs ! heu]) @\n    xs ! heu # \\<Gamma> =\n    (xs @ \\<Gamma>)\n    [heu := (xs @ \\<Gamma>) ! Suc var, Suc var := (xs @ \\<Gamma>) ! heu]", "by (smt (verit, ccfv_threshold) Cons_nth_drop_Suc append.right_neutral append_Nil2 append_assoc append_eq_conv_conj append_self_conv2 append_take_drop_id drop0 heu_def heurange le_imp_less_Suc length_greater_0_conv length_list_update lessI list.sel(1) list.sel(3) list.simps(3) list.size(3) list_update_append nth_Cons_0 nth_append nth_append_length nth_list_update_eq take0 take_hd_drop)"], ["proof (state)\nthis:\n  take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma> =\n  swap_list (Suc var) heu (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have length1 : \"Suc var < length (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc var < length (xs @ \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. Suc var < length (xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  Suc var < length (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have length2 : \"heu < length (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heu < length (xs @ \\<Gamma>)", "using h heurange"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n  heu \\<le> Suc var\n\ngoal (1 subgoal):\n 1. heu < length (xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  heu < length (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h1: \"(\\<exists>x. eval\n        (step (Suc var) (map (swap_atom (Suc var) heu) L)\n          (map (swap_fm (Suc var) heu) F))\n        (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (step (Suc var) (map (swap_atom (Suc var) heu) L)\n          (map (swap_fm (Suc var) heu) F))\n        (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)", "unfolding steph[OF length, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (list_conj\n          (map fm.Atom (map (swap_atom (Suc var) heu) L) @\n           map (swap_fm (Suc var) heu) F))\n        (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)", "apply(rule exI[where x=\"nth xs heu\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (list_conj\n       (map fm.Atom (map (swap_atom (Suc var) heu) L) @\n        map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval\n     (list_conj\n       (map fm.Atom (map (swap_atom (Suc var) heu) L) @\n        map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (swap_list (Suc var) heu xs) @ xs ! heu # \\<Gamma>)", "unfolding eval_list_conj take"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  \\<forall>f\\<in>set (map fm.Atom L @ F). eval f (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set (map fm.Atom (map (swap_atom (Suc var) heu) L) @\n                        map (swap_fm (Suc var) heu) F).\n       eval f (swap_list (Suc var) heu (xs @ \\<Gamma>))", "apply (auto simp del:swap_list.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ \\<Gamma>);\n        x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> aEval (swap_atom (Suc var) heu x)\n                          (swap_list (Suc var) heu (xs @ \\<Gamma>))\n 2. \\<And>x.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ \\<Gamma>);\n        x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> eval (swap_fm (Suc var) heu x)\n                          (swap_list (Suc var) heu (xs @ \\<Gamma>))", "unfolding swap_fm[OF length1 length2,symmetric] swap_atom[OF length1 length2,symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ \\<Gamma>);\n        x \\<in> set L\\<rbrakk>\n       \\<Longrightarrow> aEval x (xs @ \\<Gamma>)\n 2. \\<And>x.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ \\<Gamma>);\n        x \\<in> set F\\<rbrakk>\n       \\<Longrightarrow> eval x (xs @ \\<Gamma>)", "by (meson UnCI eval.simps(1) imageI)+"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)", "obtain x where heval: \"eval\n       (step (Suc var) (map (swap_atom (Suc var) heu) L)\n         (map (swap_fm (Suc var) heu) F))\n       (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (take (Suc var) (swap_list (Suc var) heu xs) @\n          x # \\<Gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F))\n   (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval\n                             (step (Suc var)\n                               (map (swap_atom (Suc var) heu) L)\n                               (map (swap_fm (Suc var) heu) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = Suc (Suc var) \\<and>\n               eval\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F))\n                (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc var) \\<and>\n       eval\n        (step (Suc var) (map (swap_atom (Suc var) heu) L)\n          (map (swap_fm (Suc var) heu) F))\n        (xs @ \\<Gamma>)", "apply(rule exI[where x=\"take (Suc var) (swap_list (Suc var) heu xs) @ [x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc var) (swap_list (Suc var) heu xs) @ [x]) =\n    Suc (Suc var) \\<and>\n    eval\n     (step (Suc var) (map (swap_atom (Suc var) heu) L)\n       (map (swap_fm (Suc var) heu) F))\n     ((take (Suc var) (swap_list (Suc var) heu xs) @ [x]) @ \\<Gamma>)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. min (length xs) (Suc var) = Suc var\n 2. eval\n     (step (Suc var) (map (swap_atom (Suc var) heu) L)\n       (map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (xs[heu := xs ! Suc var]) @ x # \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. min (length xs) (Suc var) = Suc var\n 2. eval\n     (step (Suc var) (map (swap_atom (Suc var) heu) L)\n       (map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (xs[heu := xs ! Suc var]) @ x # \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (step (Suc var) (map (swap_atom (Suc var) heu) L)\n       (map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (xs[heu := xs ! Suc var]) @ x # \\<Gamma>)", "using heval"], ["proof (prove)\nusing this:\n  eval\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F))\n   (take (Suc var) (swap_list (Suc var) heu xs) @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval\n     (step (Suc var) (map (swap_atom (Suc var) heu) L)\n       (map (swap_fm (Suc var) heu) F))\n     (take (Suc var) (xs[heu := xs ! Suc var]) @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc var) \\<and>\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h : \"length xs = Suc (Suc var)\"\"\n          eval\n           (step (Suc var) (map (swap_atom (Suc var) heu) L)\n             (map (swap_fm (Suc var) heu) F))\n           (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc var)\n  eval\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F))\n   (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "define choppedXS where \"choppedXS = take (Suc var) xs\""], ["proof (state)\nthis:\n  choppedXS = take (Suc var) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  choppedXS = take (Suc var) xs", "have length : \"length choppedXS = Suc var\""], ["proof (prove)\nusing this:\n  choppedXS = take (Suc var) xs\n\ngoal (1 subgoal):\n 1. length choppedXS = Suc var", "using h(1)"], ["proof (prove)\nusing this:\n  choppedXS = take (Suc var) xs\n  length xs = Suc (Suc var)\n\ngoal (1 subgoal):\n 1. length choppedXS = Suc var", "by force"], ["proof (state)\nthis:\n  length choppedXS = Suc var\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have \"(\\<exists>x. eval (step (Suc var) (map (swap_atom (Suc var) heu) L) (map (swap_fm (Suc var) heu) F)) (choppedXS @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (step (Suc var) (map (swap_atom (Suc var) heu) L)\n          (map (swap_fm (Suc var) heu) F))\n        (choppedXS @ x # \\<Gamma>)", "using h(2) choppedXS_def"], ["proof (prove)\nusing this:\n  eval\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F))\n   (xs @ \\<Gamma>)\n  choppedXS = take (Suc var) xs\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (step (Suc var) (map (swap_atom (Suc var) heu) L)\n          (map (swap_fm (Suc var) heu) F))\n        (choppedXS @ x # \\<Gamma>)", "by (metis append.assoc append_Cons append_Nil2 append_eq_conv_conj h(1) lessI take_hd_drop)"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (choppedXS @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (choppedXS @ x # \\<Gamma>)", "have \"\\<exists>x. (\\<forall>l\\<in> set L. aEval (swap_atom (Suc var) heu l) (choppedXS@x#\\<Gamma>)) \\<and> (\\<forall>f\\<in> set F. eval (swap_fm (Suc var) heu f) (choppedXS@x#\\<Gamma>))\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     eval\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F))\n      (choppedXS @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (\\<forall>l\\<in>set L.\n           aEval (swap_atom (Suc var) heu l)\n            (choppedXS @ x # \\<Gamma>)) \\<and>\n       (\\<forall>f\\<in>set F.\n           eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))", "unfolding steph[symmetric, OF length, of \"(map (swap_atom (Suc var) heu) L)\" \"(map (swap_fm (Suc var) heu) F)\" \\<Gamma>] eval_list_conj"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<forall>f\\<in>set (map fm.Atom (map (swap_atom (Suc var) heu) L) @\n                         map (swap_fm (Suc var) heu) F).\n        eval f (choppedXS @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (\\<forall>l\\<in>set L.\n           aEval (swap_atom (Suc var) heu l)\n            (choppedXS @ x # \\<Gamma>)) \\<and>\n       (\\<forall>f\\<in>set F.\n           eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>f\\<in>(\\<lambda>x. fm.Atom (swap_atom (Suc var) heu x)) `\n                      set L \\<union>\n                      swap_fm (Suc var) heu ` set F.\n          eval f (choppedXS @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          (\\<forall>l\\<in>set L.\n              aEval (swap_atom (Suc var) heu l)\n               (choppedXS @ x # \\<Gamma>)) \\<and>\n          (\\<forall>f\\<in>set F.\n              eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))", "by (metis Un_iff eval.simps(1) imageI)"], ["proof (state)\nthis:\n  \\<exists>x.\n     (\\<forall>l\\<in>set L.\n         aEval (swap_atom (Suc var) heu l)\n          (choppedXS @ x # \\<Gamma>)) \\<and>\n     (\\<forall>f\\<in>set F.\n         eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     (\\<forall>l\\<in>set L.\n         aEval (swap_atom (Suc var) heu l)\n          (choppedXS @ x # \\<Gamma>)) \\<and>\n     (\\<forall>f\\<in>set F.\n         eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))", "obtain x where x : \"(\\<forall>l\\<in>set L. aEval (swap_atom (Suc var) heu l) (choppedXS @ x # \\<Gamma>)) \\<and>\n      (\\<forall>f\\<in>set F. eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     (\\<forall>l\\<in>set L.\n         aEval (swap_atom (Suc var) heu l)\n          (choppedXS @ x # \\<Gamma>)) \\<and>\n     (\\<forall>f\\<in>set F.\n         eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (\\<forall>l\\<in>set L.\n            aEval (swap_atom (Suc var) heu l)\n             (choppedXS @ x # \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set F.\n            eval (swap_fm (Suc var) heu f)\n             (choppedXS @ x # \\<Gamma>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<forall>l\\<in>set L.\n      aEval (swap_atom (Suc var) heu l) (choppedXS @ x # \\<Gamma>)) \\<and>\n  (\\<forall>f\\<in>set F.\n      eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have length1 : \"Suc var < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc var < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "by (simp add: length)"], ["proof (state)\nthis:\n  Suc var < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have length2 : \"heu < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heu < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "using \\<open>Suc var < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\\<close> heurange"], ["proof (prove)\nusing this:\n  Suc var < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\n  heu \\<le> Suc var\n\ngoal (1 subgoal):\n 1. heu < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "by linarith"], ["proof (state)\nthis:\n  heu < length (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have swapswap : \"(swap_list (Suc var) heu (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)) = (choppedXS @ [x]) @ \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_list (Suc var) heu\n     (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>) =\n    (choppedXS @ [x]) @ \\<Gamma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((choppedXS @ [x])\n     [heu := (choppedXS @ [x]) ! Suc var,\n      Suc var := (choppedXS @ [x]) ! heu] @\n     \\<Gamma>)\n    [heu :=\n       ((choppedXS @ [x])\n        [heu := (choppedXS @ [x]) ! Suc var,\n         Suc var := (choppedXS @ [x]) ! heu] @\n        \\<Gamma>) !\n       Suc var,\n     Suc var :=\n       ((choppedXS @ [x])\n        [heu := (choppedXS @ [x]) ! Suc var,\n         Suc var := (choppedXS @ [x]) ! heu] @\n        \\<Gamma>) !\n       heu] =\n    choppedXS @ x # \\<Gamma>", "by (smt (z3) Cons_nth_drop_Suc append_eq_conv_conj append_same_eq heurange id_take_nth_drop le_neq_implies_less length length1 length_append_singleton lessI list.sel(1) list_update_append1 list_update_length list_update_swap nth_append nth_append_length nth_list_update_neq swap_list.simps take_hd_drop take_update_swap upd_conv_take_nth_drop)"], ["proof (state)\nthis:\n  swap_list (Suc var) heu\n   (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>) =\n  (choppedXS @ [x]) @ \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc var);\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = Suc (Suc var) \\<and>\n               eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc var) \\<and>\n       eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)", "apply(rule exI[where x=\"swap_list (Suc var) heu (choppedXS @ [x])\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap_list (Suc var) heu (choppedXS @ [x])) =\n    Suc (Suc var) \\<and>\n    eval (list_conj (map fm.Atom L @ F))\n     (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "apply(auto simp add: eval_list_conj simp del: swap_list.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (swap_list (Suc var) heu (choppedXS @ [x])) = Suc (Suc var)\n 2. \\<And>xa.\n       xa \\<in> set L \\<Longrightarrow>\n       aEval xa (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\n 3. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval f (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "apply(simp add :length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set L \\<Longrightarrow>\n       aEval xa (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval f (swap_list (Suc var) heu (choppedXS @ [x]) @ \\<Gamma>)", "unfolding swap_atom[OF length1 length2] swap_fm[OF length1 length2] swapswap"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc var) heu xa) ((choppedXS @ [x]) @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc var) heu f) ((choppedXS @ [x]) @ \\<Gamma>)", "using x"], ["proof (prove)\nusing this:\n  (\\<forall>l\\<in>set L.\n      aEval (swap_atom (Suc var) heu l) (choppedXS @ x # \\<Gamma>)) \\<and>\n  (\\<forall>f\\<in>set F.\n      eval (swap_fm (Suc var) heu f) (choppedXS @ x # \\<Gamma>))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc var) heu xa) ((choppedXS @ [x]) @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc var) heu f) ((choppedXS @ [x]) @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc var) \\<and>\n     eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval\n       (step (Suc var) (map (swap_atom (Suc var) heu) L)\n         (map (swap_fm (Suc var) heu) F))\n       (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "also"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval\n       (step (Suc var) (map (swap_atom (Suc var) heu) L)\n         (map (swap_fm (Suc var) heu) F))\n       (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "have \"... = (\\<exists>xs. length xs = Suc (Suc var) \\<and>\n          (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n                          (map (swap_fm (Suc var) heu) F)))).\n              eval (case f of (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n               (xs @ \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        eval\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F))\n         (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                   unpower 0 \\<circ>\n                                   groupQuantifiers \\<circ>\n                                   clearQuantifiers)\n                                   (step (Suc var)\n                                     (map (swap_atom (Suc var) heu) L)\n                                     (map (swap_fm (Suc var) heu) F)))).\n            eval\n             (case f of\n              (x, xa) \\<Rightarrow>\n                step_augment step heuristic amount var x xa)\n             (xs @ \\<Gamma>)))", "unfolding opt[of \"(step (Suc var) (map (swap_atom (Suc var) heu) L) (map (swap_fm (Suc var) heu) F))\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        eval\n         ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n           groupQuantifiers \\<circ>\n           clearQuantifiers)\n           (step (Suc var) (map (swap_atom (Suc var) heu) L)\n             (map (swap_fm (Suc var) heu) F)))\n         (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                   unpower 0 \\<circ>\n                                   groupQuantifiers \\<circ>\n                                   clearQuantifiers)\n                                   (step (Suc var)\n                                     (map (swap_atom (Suc var) heu) L)\n                                     (map (swap_fm (Suc var) heu) F)))).\n            eval\n             (case f of\n              (x, xa) \\<Rightarrow>\n                step_augment step heuristic amount var x xa)\n             (xs @ \\<Gamma>)))", "unfolding dnf_eval[of \"(push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n             (map (swap_fm (Suc var) heu) F))\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        (\\<exists>(al, fl)\n                  \\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                  unpower 0 \\<circ>\n                                  groupQuantifiers \\<circ>\n                                  clearQuantifiers)\n                                  (step (Suc var)\n                                    (map (swap_atom (Suc var) heu) L)\n                                    (map (swap_fm (Suc var) heu) F)))).\n            (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))) =\n    (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                   unpower 0 \\<circ>\n                                   groupQuantifiers \\<circ>\n                                   clearQuantifiers)\n                                   (step (Suc var)\n                                     (map (swap_atom (Suc var) heu) L)\n                                     (map (swap_fm (Suc var) heu) F)))).\n            eval\n             (case f of\n              (x, xa) \\<Rightarrow>\n                step_augment step heuristic amount var x xa)\n             (xs @ \\<Gamma>)))", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>f\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                eval\n                                 (case f of\n                                  (x, xa) \\<Rightarrow>\n                                    step_augment step heuristic amount var x\n                                     xa)\n                                 (xs @ \\<Gamma>))\n 2. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "fix xs a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>f\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                eval\n                                 (case f of\n                                  (x, xa) \\<Rightarrow>\n                                    step_augment step heuristic amount var x\n                                     xa)\n                                 (xs @ \\<Gamma>))\n 2. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "assume h: \"length xs = Suc (Suc var)\"\"\n       (a, b)\n       \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F)))) \"\"\n       \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>) \"\"\n       \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc var)\n  (a, b)\n  \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                   groupQuantifiers \\<circ>\n                   clearQuantifiers)\n                   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F))))\n  \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>)\n  \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>f\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                eval\n                                 (case f of\n                                  (x, xa) \\<Rightarrow>\n                                    step_augment step heuristic amount var x\n                                     xa)\n                                 (xs @ \\<Gamma>))\n 2. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "have \"(\\<exists>xs'. length xs' = var + 1 \\<and>\n        eval (step_augment step heuristic amount var a b) (xs' @ xs ! Suc var # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       length xs' = var + 1 \\<and>\n       eval (step_augment step heuristic amount var a b)\n        (xs' @ xs ! Suc var # \\<Gamma>)", "unfolding Suc(1)[of amount a b \"nth xs (Suc var)#\\<Gamma>\", OF amountLessThan, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       length xs' = var + 1 \\<and>\n       eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)", "apply(rule exI[where x=\"take (Suc var) xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc var) xs) = var + 1 \\<and>\n    eval (list_conj (map fm.Atom a @ b))\n     (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "using h(1) h(3-4)"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>)\n  \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. length (take (Suc var) xs) = var + 1 \\<and>\n    eval (list_conj (map fm.Atom a @ b))\n     (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "apply(auto simp add: eval_list_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>); x \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> aEval x\n                          (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)\n 2. \\<And>f.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>); f \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval f\n                          (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "apply (metis Cons_nth_drop_Suc append_Cons append_eq_append_conv2 append_eq_conv_conj append_take_drop_id lessI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>length xs = Suc (Suc var);\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>); f \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> eval f\n                          (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "by (metis Cons_nth_drop_Suc append_Cons append_eq_append_conv2 append_eq_conv_conj append_take_drop_id lessI)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (step_augment step heuristic amount var a b)\n      (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>f\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                eval\n                                 (case f of\n                                  (x, xa) \\<Rightarrow>\n                                    step_augment step heuristic amount var x\n                                     xa)\n                                 (xs @ \\<Gamma>))\n 2. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (step_augment step heuristic amount var a b)\n      (xs' @ xs ! Suc var # \\<Gamma>)", "obtain xs' where xs': \"length xs' = var + 1\" \"eval (step_augment step heuristic amount var a b) (xs' @ xs ! Suc var # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (step_augment step heuristic amount var a b)\n      (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>length xs' = var + 1;\n         eval (step_augment step heuristic amount var a b)\n          (xs' @ xs ! Suc var # \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length xs' = var + 1\n  eval (step_augment step heuristic amount var a b)\n   (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>f\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                eval\n                                 (case f of\n                                  (x, xa) \\<Rightarrow>\n                                    step_augment step heuristic amount var x\n                                     xa)\n                                 (xs @ \\<Gamma>))\n 2. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "show \"\\<exists>xs. length xs = Suc (Suc var) \\<and>\n            (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n                            (map (swap_fm (Suc var) heu) F)))).\n                eval (case f of (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n                 (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc var) \\<and>\n       (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                  unpower 0 \\<circ>\n                                  groupQuantifiers \\<circ>\n                                  clearQuantifiers)\n                                  (step (Suc var)\n                                    (map (swap_atom (Suc var) heu) L)\n                                    (map (swap_fm (Suc var) heu) F)))).\n           eval\n            (case f of\n             (x, xa) \\<Rightarrow>\n               step_augment step heuristic amount var x xa)\n            (xs @ \\<Gamma>))", "apply(rule exI[where x=\"xs' @[ xs ! Suc var]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs' @ [xs ! Suc var]) = Suc (Suc var) \\<and>\n    (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                               unpower 0 \\<circ>\n                               groupQuantifiers \\<circ>\n                               clearQuantifiers)\n                               (step (Suc var)\n                                 (map (swap_atom (Suc var) heu) L)\n                                 (map (swap_fm (Suc var) heu) F)))).\n        eval\n         (case f of\n          (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n         ((xs' @ [xs ! Suc var]) @ \\<Gamma>))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs' = Suc var\n 2. \\<exists>f\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       eval\n        (case f of\n         (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n        (xs' @ xs ! Suc var # \\<Gamma>)", "using xs'"], ["proof (prove)\nusing this:\n  length xs' = var + 1\n  eval (step_augment step heuristic amount var a b)\n   (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. length xs' = Suc var\n 2. \\<exists>f\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       eval\n        (case f of\n         (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n        (xs' @ xs ! Suc var # \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       eval\n        (case f of\n         (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n        (xs' @ xs ! Suc var # \\<Gamma>)", "apply(rule bexI[where x=\"(a,b)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. eval\n     (case (a, b) of\n      (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n     (xs' @ xs ! Suc var # \\<Gamma>)\n 2. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "using xs' h"], ["proof (prove)\nusing this:\n  length xs' = var + 1\n  eval (step_augment step heuristic amount var a b)\n   (xs' @ xs ! Suc var # \\<Gamma>)\n  length xs = Suc (Suc var)\n  (a, b)\n  \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                   groupQuantifiers \\<circ>\n                   clearQuantifiers)\n                   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F))))\n  \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>)\n  \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval\n     (case (a, b) of\n      (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa)\n     (xs' @ xs ! Suc var # \\<Gamma>)\n 2. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "apply(cases amount)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length xs' = var + 1;\n     eval (step_augment step heuristic amount var a b)\n      (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                      groupQuantifiers \\<circ>\n                      clearQuantifiers)\n                      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                        (map (swap_fm (Suc var) heu) F))));\n     \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n     \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>); amount = 0\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (case (a, b) of\n                        (x, xa) \\<Rightarrow>\n                          step_augment step heuristic amount var x xa)\n                       (xs' @ xs ! Suc var # \\<Gamma>)\n 2. \\<And>nat.\n       \\<lbrakk>length xs' = var + 1;\n        eval (step_augment step heuristic amount var a b)\n         (xs' @ xs ! Suc var # \\<Gamma>);\n        length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        \\<forall>a\\<in>set a. aEval a (xs @ \\<Gamma>);\n        \\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>);\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (case (a, b) of\n                           (x, xa) \\<Rightarrow>\n                             step_augment step heuristic amount var x xa)\n                          (xs' @ xs ! Suc var # \\<Gamma>)\n 3. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "apply (simp_all add:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "using h(2)"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                   groupQuantifiers \\<circ>\n                   clearQuantifiers)\n                   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F))))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc var) \\<and>\n     (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                unpower 0 \\<circ>\n                                groupQuantifiers \\<circ>\n                                clearQuantifiers)\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F)))).\n         eval\n          (case f of\n           (x, xa) \\<Rightarrow>\n             step_augment step heuristic amount var x xa)\n          (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "fix xs a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "assume h: \"length xs = Suc (Suc var) \"\"\n       (a, b)\n       \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F)))) \"\"\n       eval (step_augment step heuristic amount var a b) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc var)\n  (a, b)\n  \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                   groupQuantifiers \\<circ>\n                   clearQuantifiers)\n                   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F))))\n  eval (step_augment step heuristic amount var a b) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "have \"(\\<exists>xs'. length xs' = var + 1 \\<and>\n        eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       length xs' = var + 1 \\<and>\n       eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)", "unfolding Suc(1)[of amount a b \"nth xs (Suc var)#\\<Gamma>\", OF amountLessThan]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       length xs' = var + 1 \\<and>\n       eval (step_augment step heuristic amount var a b)\n        (xs' @ xs ! Suc var # \\<Gamma>)", "apply(rule exI[where x=\"take (Suc var) xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc var) xs) = var + 1 \\<and>\n    eval (step_augment step heuristic amount var a b)\n     (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "using h(1) h(3)"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc var)\n  eval (step_augment step heuristic amount var a b) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. length (take (Suc var) xs) = var + 1 \\<and>\n    eval (step_augment step heuristic amount var a b)\n     (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc var);\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> eval (step_augment step heuristic amount var a b)\n                       (take (Suc var) xs @ xs ! Suc var # \\<Gamma>)", "by (metis Cons_nth_drop_Suc append.right_neutral append_Cons append_assoc append_eq_conv_conj append_self_conv2 append_take_drop_id lessI)"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)", "obtain xs' where xs': \"length xs' = var + 1\" \" eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>xs'.\n     length xs' = var + 1 \\<and>\n     eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>length xs' = var + 1;\n         eval (list_conj (map fm.Atom a @ b))\n          (xs' @ xs ! Suc var # \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length xs' = var + 1\n  eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b.\n       \\<lbrakk>length xs = Suc (Suc var);\n        (a, b)\n        \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                         groupQuantifiers \\<circ>\n                         clearQuantifiers)\n                         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F))));\n        eval (step_augment step heuristic amount var a b)\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc var) \\<and>\n                            (\\<exists>(al, fl)\n\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                groupQuantifiers \\<circ>\n                clearQuantifiers)\n                (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                  (map (swap_fm (Suc var) heu) F)))).\n                                (\\<forall>a\\<in>set al.\n                                    aEval a (xs @ \\<Gamma>)) \\<and>\n                                (\\<forall>f\\<in>set fl.\n                                    eval f (xs @ \\<Gamma>)))", "show \"\\<exists>xs. length xs = Suc (Suc var) \\<and>\n            (\\<exists>(al, fl)\n              \\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers)(step (Suc var) (map (swap_atom (Suc var) heu) L)\n                           (map (swap_fm (Suc var) heu) F)))).\n                (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n                (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc var) \\<and>\n       (\\<exists>(al, fl)\n                 \\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n           (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "apply(rule exI[where x=\"xs' @[ xs ! Suc var]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs' @ [xs ! Suc var]) = Suc (Suc var) \\<and>\n    (\\<exists>(al, fl)\n              \\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                              unpower 0 \\<circ>\n                              groupQuantifiers \\<circ>\n                              clearQuantifiers)\n                              (step (Suc var)\n                                (map (swap_atom (Suc var) heu) L)\n                                (map (swap_fm (Suc var) heu) F)))).\n        (\\<forall>a\\<in>set al.\n            aEval a ((xs' @ [xs ! Suc var]) @ \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set fl. eval f ((xs' @ [xs ! Suc var]) @ \\<Gamma>)))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs' = Suc var\n 2. \\<exists>x\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       case x of\n       (al, fl) \\<Rightarrow>\n         (\\<forall>a\\<in>set al.\n             aEval a (xs' @ xs ! Suc var # \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (xs' @ xs ! Suc var # \\<Gamma>))", "using xs'"], ["proof (prove)\nusing this:\n  length xs' = var + 1\n  eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. length xs' = Suc var\n 2. \\<exists>x\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       case x of\n       (al, fl) \\<Rightarrow>\n         (\\<forall>a\\<in>set al.\n             aEval a (xs' @ xs ! Suc var # \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (xs' @ xs ! Suc var # \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (dnf (push_forall\n                              (nnf (unpower 0\n                                     (groupQuantifiers\n (clearQuantifiers\n   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n     (map (swap_fm (Suc var) heu) F)))))))).\n       case x of\n       (al, fl) \\<Rightarrow>\n         (\\<forall>a\\<in>set al.\n             aEval a (xs' @ xs ! Suc var # \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (xs' @ xs ! Suc var # \\<Gamma>))", "apply(rule bexI[where x=\"(a,b)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. case (a, b) of\n    (al, fl) \\<Rightarrow>\n      (\\<forall>a\\<in>set al.\n          aEval a (xs' @ xs ! Suc var # \\<Gamma>)) \\<and>\n      (\\<forall>f\\<in>set fl. eval f (xs' @ xs ! Suc var # \\<Gamma>))\n 2. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "using xs' h"], ["proof (prove)\nusing this:\n  length xs' = var + 1\n  eval (list_conj (map fm.Atom a @ b)) (xs' @ xs ! Suc var # \\<Gamma>)\n  length xs = Suc (Suc var)\n  (a, b)\n  \\<in> set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n                   groupQuantifiers \\<circ>\n                   clearQuantifiers)\n                   (step (Suc var) (map (swap_atom (Suc var) heu) L)\n                     (map (swap_fm (Suc var) heu) F))))\n  eval (step_augment step heuristic amount var a b) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. case (a, b) of\n    (al, fl) \\<Rightarrow>\n      (\\<forall>a\\<in>set al.\n          aEval a (xs' @ xs ! Suc var # \\<Gamma>)) \\<and>\n      (\\<forall>f\\<in>set fl. eval f (xs' @ xs ! Suc var # \\<Gamma>))\n 2. (a, b)\n    \\<in> set (dnf (push_forall\n                     (nnf (unpower 0\n                            (groupQuantifiers\n                              (clearQuantifiers\n                                (step (Suc var)\n                                  (map (swap_atom (Suc var) heu) L)\n                                  (map (swap_fm (Suc var) heu) F))))))))", "apply (simp_all add: eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "assume \"\\<forall>f\\<in>fm.Atom ` set a \\<union> set b. eval f (xs' @ xs ! Suc var # \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)", "have \"\\<forall>f. f \\<in> fm.Atom ` set a \\<union> set b \\<longrightarrow> eval f (xs' @ xs ! Suc var # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> fm.Atom ` set a \\<union> set b \\<longrightarrow>\n       eval f (xs' @ xs ! Suc var # \\<Gamma>)", "by meson"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> fm.Atom ` set a \\<union> set b \\<longrightarrow>\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>f.\n     f \\<in> fm.Atom ` set a \\<union> set b \\<longrightarrow>\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)", "have f1: \"v \\<notin> set a \\<or> eval (fm.Atom v) (xs' @ xs ! Suc var # \\<Gamma>)\" for v"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> fm.Atom ` set a \\<union> set b \\<longrightarrow>\n     eval f (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. v \\<notin> set a \\<or> eval (fm.Atom v) (xs' @ xs ! Suc var # \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  ?v \\<notin> set a \\<or> eval (fm.Atom ?v) (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "obtain aa :: atom where\n            \"(\\<exists>v0. v0 \\<in> set a \\<and> \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) = (aa \\<in> set a \\<and> \\<not> eval (fm.Atom aa) (xs' @ xs ! Suc var # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        (\\<exists>v0.\n            v0 \\<in> set a \\<and>\n            \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) =\n        (aa \\<in> set a \\<and>\n         \\<not> eval (fm.Atom aa)\n                 (xs' @ xs ! Suc var # \\<Gamma>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<exists>v0.\n      v0 \\<in> set a \\<and>\n      \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) =\n  (aa \\<in> set a \\<and>\n   \\<not> eval (fm.Atom aa) (xs' @ xs ! Suc var # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs' = Suc var;\n     \\<forall>f\\<in>fm.Atom ` set a \\<union> set b.\n        eval f (xs' @ xs ! Suc var # \\<Gamma>);\n     length xs = Suc (Suc var);\n     (a, b)\n     \\<in> set (dnf (push_forall\n                      (nnf (unpower 0\n                             (groupQuantifiers\n                               (clearQuantifiers\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F))))))));\n     eval (step_augment step heuristic amount var a b)\n      (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set a.\n                         aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>v0.\n      v0 \\<in> set a \\<and>\n      \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) =\n  (aa \\<in> set a \\<and>\n   \\<not> eval (fm.Atom aa) (xs' @ xs ! Suc var # \\<Gamma>))", "show \"\\<forall>a\\<in>set a. aEval a (xs' @ xs ! Suc var # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      v0 \\<in> set a \\<and>\n      \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) =\n  (aa \\<in> set a \\<and>\n   \\<not> eval (fm.Atom aa) (xs' @ xs ! Suc var # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "using f1 eval.simps(1)"], ["proof (prove)\nusing this:\n  (\\<exists>v0.\n      v0 \\<in> set a \\<and>\n      \\<not> eval (fm.Atom v0) (xs' @ xs ! Suc var # \\<Gamma>)) =\n  (aa \\<in> set a \\<and>\n   \\<not> eval (fm.Atom aa) (xs' @ xs ! Suc var # \\<Gamma>))\n  ?v \\<notin> set a \\<or> eval (fm.Atom ?v) (xs' @ xs ! Suc var # \\<Gamma>)\n  eval (fm.Atom ?a) ?\\<Gamma> = aEval ?a ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set a. aEval a (xs' @ xs ! Suc var # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set a. aEval a (xs' @ xs ! Suc var # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc var) \\<and>\n     (\\<exists>(al, fl)\n               \\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                               unpower 0 \\<circ>\n                               groupQuantifiers \\<circ>\n                               clearQuantifiers)\n                               (step (Suc var)\n                                 (map (swap_atom (Suc var) heu) L)\n                                 (map (swap_fm (Suc var) heu) F)))).\n         (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval\n       (step (Suc var) (map (swap_atom (Suc var) heu) L)\n         (map (swap_fm (Suc var) heu) F))\n       (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic amount var x xa)\n           (xs @ \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic amount var x xa)\n           (xs @ \\<Gamma>)))", "have \"(\\<exists>xs. length xs = Suc (Suc var) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs. length xs = Suc (Suc var) \\<and>\n        (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 o groupQuantifiers o clearQuantifiers) (step (Suc var) (map (swap_atom (Suc var) heu) L) (map (swap_fm (Suc var) heu) F)))).\n            eval (case f of (x, xa) \\<Rightarrow> step_augment step heuristic amount var x xa) (xs @ \\<Gamma>)))\""], ["proof (prove)\nusing this:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic amount var x xa)\n           (xs @ \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc var) \\<and>\n        (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                   unpower 0 \\<circ>\n                                   groupQuantifiers \\<circ>\n                                   clearQuantifiers)\n                                   (step (Suc var)\n                                     (map (swap_atom (Suc var) heu) L)\n                                     (map (swap_fm (Suc var) heu) F)))).\n            eval\n             (case f of\n              (x, xa) \\<Rightarrow>\n                step_augment step heuristic amount var x xa)\n             (xs @ \\<Gamma>)))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic amount var x xa)\n           (xs @ \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "}"], ["proof (state)\nthis:\n  ?amountb2 \\<le> var + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic ?amountb2 var x xa)\n           (xs @ \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (step_augment step heuristic amount var L F)\n                        (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  ?amountb2 \\<le> var + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic ?amountb2 var x xa)\n           (xs @ \\<Gamma>)))", "show ?case"], ["proof (prove)\nusing this:\n  ?amountb2 \\<le> var + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc var) \\<and>\n      (\\<exists>f\\<in>set (dnf ((push_forall \\<circ> nnf \\<circ>\n                                 unpower 0 \\<circ>\n                                 groupQuantifiers \\<circ>\n                                 clearQuantifiers)\n                                 (step (Suc var)\n                                   (map (swap_atom (Suc var) heu) L)\n                                   (map (swap_fm (Suc var) heu) F)))).\n          eval\n           (case f of\n            (x, xa) \\<Rightarrow>\n              step_augment step heuristic ?amountb2 var x xa)\n           (xs @ \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc var + 1 \\<and>\n        eval (step_augment step heuristic amount (Suc var) L F)\n         (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>amountb.\n                amountb \\<le> var + 1 \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc (Suc var) \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc (Suc var) \\<and>\n                    (\\<exists>f\\<in>set (dnf\n    ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n      groupQuantifiers \\<circ>\n      clearQuantifiers)\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F)))).\n                        eval\n                         (case f of\n                          (x, xa) \\<Rightarrow>\n                            step_augment step heuristic amountb var x xa)\n                         (xs @ \\<Gamma>)));\n     amount = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc var + 1 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc var + 1 \\<and>\n                          eval\n                           (step_augment step heuristic amount (Suc var) L\n                             F)\n                           (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>amountb.\n                   amountb \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc (Suc var) \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc (Suc var) \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n         groupQuantifiers \\<circ>\n         clearQuantifiers)\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F)))).\n                           eval\n                            (case f of\n                             (x, xa) \\<Rightarrow>\n                               step_augment step heuristic amountb var x xa)\n                            (xs @ \\<Gamma>)));\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "using Suc(2)"], ["proof (prove)\nusing this:\n  amount \\<le> Suc var + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>amountb.\n                amountb \\<le> var + 1 \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc (Suc var) \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc (Suc var) \\<and>\n                    (\\<exists>f\\<in>set (dnf\n    ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n      groupQuantifiers \\<circ>\n      clearQuantifiers)\n      (step (Suc var) (map (swap_atom (Suc var) heu) L)\n        (map (swap_fm (Suc var) heu) F)))).\n                        eval\n                         (case f of\n                          (x, xa) \\<Rightarrow>\n                            step_augment step heuristic amountb var x xa)\n                         (xs @ \\<Gamma>)));\n     amount = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc var + 1 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc var + 1 \\<and>\n                          eval\n                           (step_augment step heuristic amount (Suc var) L\n                             F)\n                           (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>amountb.\n                   amountb \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc (Suc var) \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc (Suc var) \\<and>\n                       (\\<exists>f\\<in>set\n  (dnf ((push_forall \\<circ> nnf \\<circ> unpower 0 \\<circ>\n         groupQuantifiers \\<circ>\n         clearQuantifiers)\n         (step (Suc var) (map (swap_atom (Suc var) heu) L)\n           (map (swap_fm (Suc var) heu) F)))).\n                           eval\n                            (case f of\n                             (x, xa) \\<Rightarrow>\n                               step_augment step heuristic amountb var x xa)\n                            (xs @ \\<Gamma>)));\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval\n                              (step_augment step heuristic amount (Suc var)\n                                L F)\n                              (xs @ \\<Gamma>))", "by (simp_all add:eval_list_disj heu_def[symmetric])"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc var + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc var + 1 \\<and>\n      eval (step_augment step heuristic amount (Suc var) L F)\n       (xs @ \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma qe_eq_repeat_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment qe_eq_repeat IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> var + 1 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (step_augment qe_eq_repeat IdentityHeuristic amount var L F)\n         (xs @ \\<Gamma>))", "apply(rule step_augmenter_eval[of qe_eq_repeat IdentityHeuristic amount var L F \\<Gamma>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat vara L F)\n                              (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "using qe_eq_repeat_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat vara L F)\n                              (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 2. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "by auto"], ["", "lemma qe_eq_repeat_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (qe_eq_repeat var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (qe_eq_repeat var L F) (xs @ \\<Gamma>))", "apply(rule step_converter[of qe_eq_repeat var L F \\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "using qe_eq_repeat_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "by blast"], ["", "lemma gen_qe_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment gen_qe IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> var + 1 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (step_augment gen_qe IdentityHeuristic amount var L F)\n         (xs @ \\<Gamma>))", "apply(rule step_augmenter_eval[of gen_qe IdentityHeuristic amount var L F \\<Gamma>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe vara L F) (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "using gen_qe_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (gen_qe vara L F) (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 2. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "by auto"], ["", "lemma gen_qe_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (gen_qe var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and> eval (gen_qe var L F) (xs @ \\<Gamma>))", "apply(rule step_converter[of gen_qe var L F \\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "using gen_qe_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (gen_qe ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (gen_qe var L F) (xs @ x # \\<Gamma>))", "by blast"], ["", "lemma luckyFind_eval_augment : \"amount \\<le> var+1 \\<Longrightarrow>\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (step_augment luckyFind' IdentityHeuristic amount var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> var + 1 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (step_augment luckyFind' IdentityHeuristic amount var L F)\n         (xs @ \\<Gamma>))", "apply(rule step_augmenter_eval[of luckyFind' IdentityHeuristic amount var L F \\<Gamma>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (luckyFind' vara L F) (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "using luckyFind'_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (luckyFind' ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (3 subgoals):\n 1. \\<And>xs vara L F \\<Gamma>.\n       \\<lbrakk>amount \\<le> var + 1; length xs = vara\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (luckyFind' vara L F) (xs @ x # \\<Gamma>))\n 2. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 3. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n vara L F.\n       \\<lbrakk>amount \\<le> var + 1;\n        IdentityHeuristic n L F = vara\\<rbrakk>\n       \\<Longrightarrow> vara \\<le> n\n 2. amount \\<le> var + 1 \\<Longrightarrow> amount \\<le> var + 1", "by auto"], ["", "lemma luckyFind_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (luckyFind' var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (luckyFind' var L F) (xs @ \\<Gamma>))", "apply(rule step_converter[of luckyFind' var L F \\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "using luckyFind'_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (luckyFind' ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckyFind' var L F) (xs @ x # \\<Gamma>))", "by blast"], ["", "lemma luckiestFind_eval' : \"\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = var + 1) \\<and> eval (luckiestFind var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (luckiestFind var L F) (xs @ \\<Gamma>))", "apply(rule step_converter[of luckiestFind var L F \\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "using luckiestFind_eval"], ["proof (prove)\nusing this:\n  length ?xs = ?var \\<Longrightarrow>\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom ?L @ ?F)) (?xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval (luckiestFind ?var ?L ?F) (?xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>xs var L F \\<Gamma>.\n       length xs = var \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (luckiestFind var L F) (xs @ x # \\<Gamma>))", "by blast"], ["", "lemma sortedListMember : \"sorted_list_of_fset b = var # list \\<Longrightarrow> fmember var b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_fset b = var # list \\<Longrightarrow> var |\\<in>| b", "by (metis fset_of_list_elem list.set_intros(1) sorted_list_of_fset_simps(2))"], ["", "lemma rangeHeuristic : \n  assumes \"heuristicPicker n L F = Some (var, step)\"\n  shows \"var\\<le>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<le> n", "proof(cases \"aquireData n L\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. aquireData n L = (a, b, c) \\<Longrightarrow> var \\<le> n", "case (fields a b c)"], ["proof (state)\nthis:\n  aquireData n L = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c. aquireData n L = (a, b, c) \\<Longrightarrow> var \\<le> n", "then"], ["proof (chain)\npicking this:\n  aquireData n L = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  aquireData n L = (a, b, c)\n\ngoal (1 subgoal):\n 1. var \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  aquireData n L = (a, b, c)\n  heuristicPicker n L F = Some (var, step)\n\ngoal (1 subgoal):\n 1. var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest a L of\n           None \\<Rightarrow>\n             case F of\n             [] \\<Rightarrow>\n               case getBest c L of\n               None \\<Rightarrow>\n                 case getBest b L of None \\<Rightarrow> None\n                 | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n               | Some v \\<Rightarrow> Some (v, gen_qe)\n             | a # list \\<Rightarrow>\n                 case getBest b L of None \\<Rightarrow> None\n                 | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n           | Some v \\<Rightarrow> Some (v, luckyFind') of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step)\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n", "apply(cases \"getBest a L\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest a L of\n           None \\<Rightarrow>\n             case F of\n             [] \\<Rightarrow>\n               case getBest c L of\n               None \\<Rightarrow>\n                 case getBest b L of None \\<Rightarrow> None\n                 | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n               | Some v \\<Rightarrow> Some (v, gen_qe)\n             | a # list \\<Rightarrow>\n                 case getBest b L of None \\<Rightarrow> None\n                 | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n           | Some v \\<Rightarrow> Some (v, luckyFind') of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest a L of\n              None \\<Rightarrow>\n                case F of\n                [] \\<Rightarrow>\n                  case getBest c L of\n                  None \\<Rightarrow>\n                    case getBest b L of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                  | Some v \\<Rightarrow> Some (v, gen_qe)\n                | a # list \\<Rightarrow>\n                    case getBest b L of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n              | Some v \\<Rightarrow> Some (v, luckyFind') of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case F of\n           [] \\<Rightarrow>\n             case getBest c L of\n             None \\<Rightarrow>\n               case getBest b L of None \\<Rightarrow> None\n               | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n             | Some v \\<Rightarrow> Some (v, gen_qe)\n           | a # list \\<Rightarrow>\n               case getBest b L of None \\<Rightarrow> None\n               | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(cases F)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case F of\n           [] \\<Rightarrow>\n             case getBest c L of\n             None \\<Rightarrow>\n               case getBest b L of None \\<Rightarrow> None\n               | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n             | Some v \\<Rightarrow> Some (v, gen_qe)\n           | a # list \\<Rightarrow>\n               case getBest b L of None \\<Rightarrow> None\n               | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None; F = []\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case F of\n              [] \\<Rightarrow>\n                case getBest c L of\n                None \\<Rightarrow>\n                  case getBest b L of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                | Some v \\<Rightarrow> Some (v, gen_qe)\n              | a # list \\<Rightarrow>\n                  case getBest b L of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest c L of\n           None \\<Rightarrow>\n             case getBest b L of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n           | Some v \\<Rightarrow> Some (v, gen_qe) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None; F = []\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(cases \"getBest c L\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest c L of\n           None \\<Rightarrow>\n             case getBest b L of None \\<Rightarrow> None\n             | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n           | Some v \\<Rightarrow> Some (v, gen_qe) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None; F = []; getBest c L = None\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest c L of\n              None \\<Rightarrow>\n                case getBest b L of None \\<Rightarrow> None\n                | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n              | Some v \\<Rightarrow> Some (v, gen_qe) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = []; getBest c L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 4. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest b L of None \\<Rightarrow> None\n           | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None; F = []; getBest c L = None\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, gen_qe)) = Some (var, step);\n        getBest a L = None; F = []; getBest c L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 4. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(cases \"getBest b L\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>aquireData n L = (a, b, c);\n     (case case getBest b L of None \\<Rightarrow> None\n           | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n      None \\<Rightarrow> None\n      | Some (var, step) \\<Rightarrow>\n          if n < var then None else Some (var, step)) =\n     Some (var, step);\n     getBest a L = None; F = []; getBest c L = None;\n     getBest b L = None\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = []; getBest c L = None;\n        getBest b L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, gen_qe)) = Some (var, step);\n        getBest a L = None; F = []; getBest c L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 4. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 5. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, qe_eq_repeat)) =\n        Some (var, step);\n        getBest a L = None; F = []; getBest c L = None;\n        getBest b L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, gen_qe)) = Some (var, step);\n        getBest a L = None; F = []; getBest c L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 4. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply (metis not_le_imp_less option.distinct(1) option.inject prod.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, gen_qe)) = Some (var, step);\n        getBest a L = None; F = []; getBest c L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply (metis not_le_imp_less option.distinct(1) option.inject prod.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(cases \"getBest b L\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list; getBest b L = None\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa list aaa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (case case getBest b L of None \\<Rightarrow> None\n              | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n         None \\<Rightarrow> None\n         | Some (var, step) \\<Rightarrow>\n             if n < var then None else Some (var, step)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list; getBest b L = Some aaa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 3. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list aaa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aaa then None else Some (aaa, qe_eq_repeat)) =\n        Some (var, step);\n        getBest a L = None; F = aa # list; getBest b L = Some aaa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n\n 2. \\<And>aa.\n       \\<lbrakk>aquireData n L = (a, b, c);\n        (if n < aa then None else Some (aa, luckyFind')) = Some (var, step);\n        getBest a L = Some aa\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "by (metis not_le_imp_less option.distinct(1) option.inject prod.inject)+"], ["proof (state)\nthis:\n  var \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pickedOneOfThem : \n  assumes \"heuristicPicker n L F = Some (var, step)\"\n  shows \"step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'", "using assms"], ["proof (prove)\nusing this:\n  heuristicPicker n L F = Some (var, step)\n\ngoal (1 subgoal):\n 1. step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'", "apply(cases \"aquireData n L\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>heuristicPicker n L F = Some (var, step);\n        aquireData n L = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "subgoal for l e g"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heuristicPicker n L F = Some (var, step);\n     aquireData n L = (l, e, g)\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'", "using assms"], ["proof (prove)\nusing this:\n  heuristicPicker n L F = Some (var, step)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>heuristicPicker n L F = Some (var, step);\n     aquireData n L = (l, e, g)\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case case getBest l L of\n                   None \\<Rightarrow>\n                     case F of\n                     [] \\<Rightarrow>\n                       case getBest g L of\n                       None \\<Rightarrow>\n                         case getBest e L of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                       | Some v \\<Rightarrow> Some (v, gen_qe)\n                     | a # list \\<Rightarrow>\n                         case getBest e L of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                   | Some v \\<Rightarrow> Some (v, luckyFind') of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g)\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'", "apply(cases \"getBest l L\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case case getBest l L of\n                   None \\<Rightarrow>\n                     case F of\n                     [] \\<Rightarrow>\n                       case getBest g L of\n                       None \\<Rightarrow>\n                         case getBest e L of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                       | Some v \\<Rightarrow> Some (v, gen_qe)\n                     | a # list \\<Rightarrow>\n                         case getBest e L of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                   | Some v \\<Rightarrow> Some (v, luckyFind') of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(case case getBest l L of\n                      None \\<Rightarrow>\n                        case F of\n                        [] \\<Rightarrow>\n                          case getBest g L of\n                          None \\<Rightarrow>\n                            case getBest e L of None \\<Rightarrow> None\n                            | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                          | Some v \\<Rightarrow> Some (v, gen_qe)\n                        | a # list \\<Rightarrow>\n                            case getBest e L of None \\<Rightarrow> None\n                            | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                      | Some v \\<Rightarrow> Some (v, luckyFind') of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case case F of\n                   [] \\<Rightarrow>\n                     case getBest g L of\n                     None \\<Rightarrow>\n                       case getBest e L of None \\<Rightarrow> None\n                       | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                     | Some v \\<Rightarrow> Some (v, gen_qe)\n                   | a # list \\<Rightarrow>\n                       case getBest e L of None \\<Rightarrow> None\n                       | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(cases F)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(case case F of\n                   [] \\<Rightarrow>\n                     case getBest g L of\n                     None \\<Rightarrow>\n                       case getBest e L of None \\<Rightarrow> None\n                       | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                     | Some v \\<Rightarrow> Some (v, gen_qe)\n                   | a # list \\<Rightarrow>\n                       case getBest e L of None \\<Rightarrow> None\n                       | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None; F = []\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a list.\n       \\<lbrakk>(case case F of\n                      [] \\<Rightarrow>\n                        case getBest g L of\n                        None \\<Rightarrow>\n                          case getBest e L of None \\<Rightarrow> None\n                          | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                        | Some v \\<Rightarrow> Some (v, gen_qe)\n                      | a # list \\<Rightarrow>\n                          case getBest e L of None \\<Rightarrow> None\n                          | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(case case getBest g L of\n                   None \\<Rightarrow>\n                     case getBest e L of None \\<Rightarrow> None\n                     | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                   | Some v \\<Rightarrow> Some (v, gen_qe) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None; F = []\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(cases \"getBest g L\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(case case getBest g L of\n                   None \\<Rightarrow>\n                     case getBest e L of None \\<Rightarrow> None\n                     | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                   | Some v \\<Rightarrow> Some (v, gen_qe) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None; F = [];\n     getBest g L = None\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(case case getBest g L of\n                      None \\<Rightarrow>\n                        case getBest e L of None \\<Rightarrow> None\n                        | Some v \\<Rightarrow> Some (v, qe_eq_repeat)\n                      | Some v \\<Rightarrow> Some (v, gen_qe) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 4. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                   | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None; F = [];\n     getBest g L = None\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, gen_qe)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 4. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(cases \"getBest e L\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                   | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n              None \\<Rightarrow> None\n              | Some (var, step) \\<Rightarrow>\n                  if n < var then None else Some (var, step)) =\n             Some (var, step);\n     aquireData n L = (l, e, g); getBest l L = None; F = [];\n     getBest g L = None; getBest e L = None\\<rbrakk>\n    \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                      step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = None; getBest e L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, gen_qe)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 4. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 5. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, qe_eq_repeat)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = None; getBest e L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, gen_qe)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 4. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply (metis option.distinct(1) option.inject prod.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, gen_qe)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = [];\n        getBest g L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply (metis option.distinct(1) option.inject prod.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None;\n        F = a # list\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(cases \"getBest e L\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = a # list;\n        getBest e L = None\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a list aa.\n       \\<lbrakk>(case case getBest e L of None \\<Rightarrow> None\n                      | Some v \\<Rightarrow> Some (v, qe_eq_repeat) of\n                 None \\<Rightarrow> None\n                 | Some (var, step) \\<Rightarrow>\n                     if n < var then None else Some (var, step)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = a # list;\n        getBest e L = Some aa\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 3. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "apply(simp_all del: aquireData.simps getBest.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa.\n       \\<lbrakk>(if n < aa then None else Some (aa, qe_eq_repeat)) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = None; F = a # list;\n        getBest e L = Some aa\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'\n 2. \\<And>a.\n       \\<lbrakk>(if n < a then None else Some (a, luckyFind')) =\n                Some (var, step);\n        aquireData n L = (l, e, g); getBest l L = Some a\\<rbrakk>\n       \\<Longrightarrow> step = qe_eq_repeat \\<or>\n                         step = gen_qe \\<or> step = luckyFind'", "by (metis  option.distinct(1) option.inject prod.inject)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma superPicker_eval : \n  \"amount\\<le> var+1 \\<Longrightarrow> (\\<exists>xs. length xs = var + 1 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n      (\\<exists>xs. (length xs = (var + 1)) \\<and> eval (superPicker amount var L F) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> var + 1 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = var + 1 \\<and>\n        eval (superPicker amount var L F) (xs @ \\<Gamma>))", "proof(induction var arbitrary : L F \\<Gamma> amount)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L F \\<Gamma> amount.\n       amount \\<le> 0 + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (superPicker amount var L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (superPicker amount (Suc var) L F)\n                              (xs @ \\<Gamma>))", "case 0"], ["proof (state)\nthis:\n  amount \\<le> 0 + 1\n\ngoal (2 subgoals):\n 1. \\<And>L F \\<Gamma> amount.\n       amount \\<le> 0 + 1 \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = 0 + 1 \\<and>\n           eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (superPicker amount var L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (superPicker amount (Suc var) L F)\n                              (xs @ \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  amount \\<le> 0 + 1", "show ?case"], ["proof (prove)\nusing this:\n  amount \\<le> 0 + 1\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = 0 + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = 0 + 1 \\<and>\n        eval (superPicker amount 0 L F) (xs @ \\<Gamma>))", "apply(simp del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> Suc 0 \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (superPicker amount 0 L F) (xs @ \\<Gamma>))", "apply(cases \"heuristicPicker 0 L F\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>a.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = None;\n     amount = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = None;\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))\n 3. \\<And>a.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply (simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some a\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some a;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply (simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some (aa, b);\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "subgoal for var step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some (var, step);\n     a = (var, step)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))", "apply(cases var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some (var, step);\n     a = (var, step); var = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (var, step); a = (var, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>amount \\<le> Suc 0; heuristicPicker 0 L F = Some (var, step);\n     a = (var, step); var = 0; amount = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (var, step); a = (var, step); var = 0;\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))\n 3. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (var, step); a = (var, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply(simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heuristicPicker 0 L F = Some (0, step); a = (0, step); var = 0;\n     amount = Suc 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (step 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heuristicPicker 0 L F = Some (0, step); a = (0, step); var = 0;\n     amount = Suc 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (step 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "assume h: \"heuristicPicker 0 L F = Some (0, step)\""], ["proof (state)\nthis:\n  heuristicPicker 0 L F = Some (0, step)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heuristicPicker 0 L F = Some (0, step); a = (0, step); var = 0;\n     amount = Suc 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc 0 \\<and>\n                          eval (step 0 L F) (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "show \"(\\<exists>xs. length xs = Suc 0 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs. length xs = Suc 0 \\<and> eval (step 0 L F) (xs @ \\<Gamma>)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and> eval (step 0 L F) (xs @ \\<Gamma>))", "using pickedOneOfThem[OF h]"], ["proof (prove)\nusing this:\n  step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and> eval (step 0 L F) (xs @ \\<Gamma>))", "using  qe_eq_repeat_eval'[of 0 L F \\<Gamma>] gen_qe_eval'[of 0 L F \\<Gamma>] luckyFind_eval'[of 0 L F \\<Gamma>]"], ["proof (prove)\nusing this:\n  step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and> eval (qe_eq_repeat 0 L F) (xs @ \\<Gamma>))\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and> eval (gen_qe 0 L F) (xs @ \\<Gamma>))\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and> eval (luckyFind' 0 L F) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc 0 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc 0 \\<and> eval (step 0 L F) (xs @ \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc 0 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs. length xs = Suc 0 \\<and> eval (step 0 L F) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "show \"\\<And>nat. amount \\<le> Suc 0 \\<Longrightarrow>\n           heuristicPicker 0 L F = Some (Suc nat, step) \\<Longrightarrow>\n           a = (Suc nat, step) \\<Longrightarrow>\n           var = Suc nat \\<Longrightarrow>\n           (\\<exists>xs. length xs = Suc 0 \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n           (\\<exists>xs. length xs = Suc 0 \\<and> eval (superPicker amount 0 L F) (xs @ \\<Gamma>)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat; amount = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))\n 2. \\<And>nat nata.\n       \\<lbrakk>amount \\<le> Suc 0;\n        heuristicPicker 0 L F = Some (Suc nat, step); a = (Suc nat, step);\n        var = Suc nat; amount = Suc nata\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc 0 \\<and>\n                             eval (superPicker amount 0 L F)\n                              (xs @ \\<Gamma>))", "by(simp_all del:heuristicPicker.simps)"], ["proof (state)\nthis:\n  \\<lbrakk>amount \\<le> Suc 0;\n   heuristicPicker 0 L F = Some (Suc ?nat, step); a = (Suc ?nat, step);\n   var = Suc ?nat\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>xs.\n                        length xs = Suc 0 \\<and>\n                        eval (list_conj (map fm.Atom L @ F))\n                         (xs @ \\<Gamma>)) =\n                    (\\<exists>xs.\n                        length xs = Suc 0 \\<and>\n                        eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = 0 + 1 \\<and>\n      eval (superPicker amount 0 L F) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (superPicker amount var L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (superPicker amount (Suc var) L F)\n                              (xs @ \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (superPicker amount var L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (superPicker amount (Suc var) L F)\n                              (xs @ \\<Gamma>))", "case (Suc i)"], ["proof (state)\nthis:\n  ?amount \\<le> i + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (superPicker ?amount i ?L ?F) (xs @ ?\\<Gamma>))\n  amount \\<le> Suc i + 1\n\ngoal (1 subgoal):\n 1. \\<And>var L F \\<Gamma> amount.\n       \\<lbrakk>\\<And>L F \\<Gamma> amount.\n                   amount \\<le> var + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = var + 1 \\<and>\n                       eval (superPicker amount var L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc var + 1\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc var + 1 \\<and>\n                             eval (superPicker amount (Suc var) L F)\n                              (xs @ \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  ?amount \\<le> i + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (superPicker ?amount i ?L ?F) (xs @ ?\\<Gamma>))\n  amount \\<le> Suc i + 1", "show ?case"], ["proof (prove)\nusing this:\n  ?amount \\<le> i + 1 \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = i + 1 \\<and>\n      eval (superPicker ?amount i ?L ?F) (xs @ ?\\<Gamma>))\n  amount \\<le> Suc i + 1\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc i + 1 \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc i + 1 \\<and>\n        eval (superPicker amount (Suc i) L F) (xs @ \\<Gamma>))", "apply(cases \"heuristicPicker (Suc i) L F\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> i + 1 \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = i + 1 \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = i + 1 \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amount \\<le> Suc i + 1; heuristicPicker (Suc i) L F = None\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc i + 1 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc i + 1 \\<and>\n                          eval (superPicker amount (Suc i) L F)\n                           (xs @ \\<Gamma>))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> i + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc i + 1;\n        heuristicPicker (Suc i) L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> i + 1 \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = i + 1 \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = i + 1 \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amount \\<le> Suc i + 1; heuristicPicker (Suc i) L F = None;\n     amount = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc i + 1 \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc i + 1 \\<and>\n                          eval (superPicker amount (Suc i) L F)\n                           (xs @ \\<Gamma>))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> i + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc i + 1; heuristicPicker (Suc i) L F = None;\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))\n 3. \\<And>a.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> i + 1 \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = i + 1 \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc i + 1;\n        heuristicPicker (Suc i) L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc i + 1 \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amount \\<le> Suc (Suc i); heuristicPicker (Suc i) L F = Some a\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (superPicker amount (Suc i) L F)\n                           (xs @ \\<Gamma>))", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i); heuristicPicker (Suc i) L F = Some a;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b);\n        amount = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))\n 2. \\<And>aa b nat.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b);\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b nat.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b);\n        amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(cases amount)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b nat.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b);\n        amount = Suc nat; amount = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))\n 2. \\<And>aa b nat nata.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        amount \\<le> Suc (Suc i);\n        heuristicPicker (Suc i) L F = Some (aa, b); a = (aa, b);\n        amount = Suc nat; amount = Suc nata\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount (Suc i) L F)\n                              (xs @ \\<Gamma>))", "apply(simp_all del:heuristicPicker.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b nat nata.\n       \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                   amount \\<le> Suc i \\<Longrightarrow>\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (list_conj (map fm.Atom L @ F))\n                        (xs @ \\<Gamma>)) =\n                   (\\<exists>xs.\n                       length xs = Suc i \\<and>\n                       eval (superPicker amount i L F) (xs @ \\<Gamma>));\n        nat \\<le> Suc i; heuristicPicker (Suc i) L F = Some (aa, b);\n        a = (aa, b); nata = nat; amount = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval\n                              (list_disj\n                                (map (\\<lambda>(x, y).\n   superPicker nat i x y)\n                                  (dnf (push_forall\n   (nnf (unpower 0\n          (groupQuantifiers\n            (clearQuantifiers\n              (b (Suc i) (map (swap_atom (Suc i) aa) L)\n                (map (swap_fm (Suc i) aa) F))))))))))\n                              (xs @ \\<Gamma>))", "subgoal for var step amountPred amountPred'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "assume amountPred : \"amountPred \\<le> Suc i\""], ["proof (state)\nthis:\n  amountPred \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "assume ih: \"(\\<And>amount L F \\<Gamma>.\n        amount \\<le> Suc i \\<Longrightarrow>\n        (\\<exists>xs. length xs = Suc i \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n        (\\<exists>xs. length xs = Suc i \\<and> eval (superPicker amount i L F) (xs @ \\<Gamma>)))\""], ["proof (state)\nthis:\n  ?amount \\<le> Suc i \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = Suc i \\<and>\n      eval (list_conj (map fm.Atom ?L @ ?F)) (xs @ ?\\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc i \\<and>\n      eval (superPicker ?amount i ?L ?F) (xs @ ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "assume h0 : \"heuristicPicker (Suc i) L F = Some (var, step)\""], ["proof (state)\nthis:\n  heuristicPicker (Suc i) L F = Some (var, step)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have h1: \"\\<And>xs X F. (\\<exists>f\\<in>set (map (\\<lambda>(x, y). F x y)\n                     (dnf X)).\n              eval f (xs)) = (\\<exists>(al,fl)\\<in>set(dnf X).\n              eval (F al fl) (xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs X F.\n       (\\<exists>f\\<in>set (map (\\<lambda>(x, y). F x y) (dnf X)).\n           eval f xs) =\n       (\\<exists>(al, fl)\\<in>set (dnf X). eval (F al fl) xs)", "subgoal for xs X F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>set (map (\\<lambda>(x, y). F x y) (dnf X)). eval f xs) =\n    (\\<exists>(al, fl)\\<in>set (dnf X). eval (F al fl) xs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set (dnf X); eval (F a b) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set (dnf X).\n                            eval (case f of (x, xa) \\<Rightarrow> F x xa) xs", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set (dnf X); eval (F a b) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f\\<in>set (dnf X).\n                         eval (case f of (x, xa) \\<Rightarrow> F x xa) xs", "apply(rule bexI[where x=\"(a,b)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> set (dnf X); eval (F a b) xs\\<rbrakk>\n    \\<Longrightarrow> eval (case (a, b) of (x, xa) \\<Rightarrow> F x xa) xs\n 2. \\<lbrakk>(a, b) \\<in> set (dnf X); eval (F a b) xs\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> set (dnf X)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>f\\<in>set (map (\\<lambda>(x, y). ?F x y) (dnf ?X)).\n      eval f ?xs) =\n  (\\<exists>(al, fl)\\<in>set (dnf ?X). eval (?F al fl) ?xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have eval_map : \"\\<And>al fl xs \\<Gamma>.(\\<forall>f\\<in>set (map fm.Atom al @ fl). eval f (xs @ \\<Gamma>)) = ((\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and> (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al fl xs \\<Gamma>.\n       (\\<forall>f\\<in>set (map fm.Atom al @ fl). eval f (xs @ \\<Gamma>)) =\n       ((\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n        (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>al fl xs \\<Gamma> a.\n       \\<lbrakk>\\<forall>f\\<in>fm.Atom ` set al \\<union> set fl.\n                   eval f (xs @ \\<Gamma>);\n        a \\<in> set al\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs @ \\<Gamma>)", "by (meson Un_iff eval.simps(1) imageI)"], ["proof (state)\nthis:\n  (\\<forall>f\\<in>set (map fm.Atom ?al @ ?fl). eval f (?xs @ ?\\<Gamma>)) =\n  ((\\<forall>a\\<in>set ?al. aEval a (?xs @ ?\\<Gamma>)) \\<and>\n   (\\<forall>f\\<in>set ?fl. eval f (?xs @ ?\\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have rearangeExists :  \"\\<And> X F.((\\<exists>xs. length xs = Suc (Suc i) \\<and>\n               (\\<exists>(al, fl)\\<in>set (dnf X). F al fl xs)) =\n            (\\<exists>(al,fl)\\<in>set (dnf X).(\\<exists>xs. length xs = Suc (Suc i) \\<and>\n                F al fl xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X F.\n       (\\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           (\\<exists>(al, fl)\\<in>set (dnf X). F al fl xs)) =\n       (\\<exists>(al, fl)\\<in>set (dnf X).\n           \\<exists>xs. length xs = Suc (Suc i) \\<and> F al fl xs)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      (\\<exists>(al, fl)\\<in>set (dnf ?X). ?F al fl xs)) =\n  (\\<exists>(al, fl)\\<in>set (dnf ?X).\n      \\<exists>xs. length xs = Suc (Suc i) \\<and> ?F al fl xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have dropTheEnd : \"\\<And>F \\<Gamma>.(\\<exists>xs. length xs = Suc (Suc i) \\<and> F (xs @ \\<Gamma>)) = (\\<exists>x. (\\<exists>xs. length xs = i+1 \\<and> F (xs @ x#\\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F \\<Gamma>.\n       (\\<exists>xs. length xs = Suc (Suc i) \\<and> F (xs @ \\<Gamma>)) =\n       (\\<exists>x xs. length xs = i + 1 \\<and> F (xs @ x # \\<Gamma>))", "apply(safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F \\<Gamma> xs.\n       \\<lbrakk>length xs = Suc (Suc i); F (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xs.\n                            length xs = i + 1 \\<and> F (xs @ x # \\<Gamma>)\n 2. \\<And>F \\<Gamma> x xs.\n       \\<lbrakk>length xs = i + 1; F (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and> F (xs @ \\<Gamma>)", "subgoal for F \\<Gamma> xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc i); F (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x xs.\n                         length xs = i + 1 \\<and> F (xs @ x # \\<Gamma>)", "apply(rule exI[where x=\"nth xs (i+1)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc i); F (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xsa.\n                         length xsa = i + 1 \\<and>\n                         F (xsa @ xs ! (i + 1) # \\<Gamma>)", "apply(rule exI[where x=\"take (i+1) xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc i); F (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> length (take (i + 1) xs) = i + 1 \\<and>\n                      F (take (i + 1) xs @ xs ! (i + 1) # \\<Gamma>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc i); F (xs @ \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> F (take (Suc i) xs @ xs ! Suc i # \\<Gamma>)", "by (metis Cons_nth_drop_Suc append.right_neutral append_Cons append_assoc append_eq_conv_conj append_self_conv2 append_take_drop_id lessI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F \\<Gamma> x xs.\n       \\<lbrakk>length xs = i + 1; F (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and> F (xs @ \\<Gamma>)", "subgoal for F \\<Gamma> x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = i + 1; F (xs @ x # \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         length xs = Suc (Suc i) \\<and> F (xs @ \\<Gamma>)", "apply(rule exI[where x=\"xs@[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = i + 1; F (xs @ x # \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> length (xs @ [x]) = Suc (Suc i) \\<and>\n                      F ((xs @ [x]) @ \\<Gamma>)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>xs. length xs = Suc (Suc i) \\<and> ?F1 (xs @ ?\\<Gamma>1)) =\n  (\\<exists>x xs. length xs = i + 1 \\<and> ?F1 (xs @ x # ?\\<Gamma>1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have h2 : \"\\<And>X \\<Gamma> amount. amount\\<le> Suc i \\<Longrightarrow>((\\<exists>xs. length xs = Suc (Suc i) \\<and>\n          (\\<exists>(al, fl)\\<in>set (dnf X).\n              eval (superPicker amount i al fl) (xs @ \\<Gamma>)))\n          = (\\<exists>xs. length xs = Suc (Suc i) \\<and>\n          (\\<exists>(al, fl)\\<in>set (dnf X).\n              (\\<forall>a\\<in>set al. aEval a (xs@\\<Gamma>))\\<and>(\\<forall>f\\<in>set fl. eval f (xs@\\<Gamma>)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X \\<Gamma> amount.\n       amount \\<le> Suc i \\<Longrightarrow>\n       (\\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           (\\<exists>(al, fl)\\<in>set (dnf X).\n               eval (superPicker amount i al fl) (xs @ \\<Gamma>))) =\n       (\\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           (\\<exists>(al, fl)\\<in>set (dnf X).\n               (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n               (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>))))", "subgoal for X \\<Gamma> amount"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> Suc i \\<Longrightarrow>\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        (\\<exists>(al, fl)\\<in>set (dnf X).\n            eval (superPicker amount i al fl) (xs @ \\<Gamma>))) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        (\\<exists>(al, fl)\\<in>set (dnf X).\n            (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>))))", "unfolding rearangeExists"], ["proof (prove)\ngoal (1 subgoal):\n 1. amount \\<le> Suc i \\<Longrightarrow>\n    (\\<exists>(al, fl)\\<in>set (dnf X).\n        \\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           eval (superPicker amount i al fl) (xs @ \\<Gamma>)) =\n    (\\<exists>(al, fl)\\<in>set (dnf X).\n        \\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n           (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "apply(rule bex_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. amount \\<le> Suc i \\<Longrightarrow> set (dnf X) = set (dnf X)\n 2. \\<And>x.\n       \\<lbrakk>amount \\<le> Suc i; x \\<in> set (dnf X)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               eval (superPicker amount i al fl)\n                                (xs @ \\<Gamma>)) =\n                         (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (xs @ \\<Gamma>)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (xs @ \\<Gamma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>amount \\<le> Suc i; x \\<in> set (dnf X)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               eval (superPicker amount i al fl)\n                                (xs @ \\<Gamma>)) =\n                         (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (xs @ \\<Gamma>)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (xs @ \\<Gamma>)))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; x \\<in> set (dnf X)\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (al, fl) \\<Rightarrow>\n                         \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (superPicker amount i al fl)\n                             (xs @ \\<Gamma>)) =\n                      (case x of\n                       (al, fl) \\<Rightarrow>\n                         \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            (\\<forall>a\\<in>set al.\n                                aEval a (xs @ \\<Gamma>)) \\<and>\n                            (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>amount \\<le> Suc i; x \\<in> set (dnf X); x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               eval (superPicker amount i al fl)\n                                (xs @ \\<Gamma>)) =\n                         (case x of\n                          (al, fl) \\<Rightarrow>\n                            \\<exists>xs.\n                               length xs = Suc (Suc i) \\<and>\n                               (\\<forall>a\\<in>set al.\n                                   aEval a (xs @ \\<Gamma>)) \\<and>\n                               (\\<forall>f\\<in>set fl.\n                                   eval f (xs @ \\<Gamma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>amount \\<le> Suc i; (a, b) \\<in> set (dnf X);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             eval (superPicker amount i a b)\n                              (xs @ \\<Gamma>)) =\n                         (\\<exists>xs.\n                             length xs = Suc (Suc i) \\<and>\n                             (\\<forall>a\\<in>set a.\n                                 aEval a (xs @ \\<Gamma>)) \\<and>\n                             (\\<forall>f\\<in>set b. eval f (xs @ \\<Gamma>)))", "subgoal for al fl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (superPicker amount i al fl)\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "unfolding dropTheEnd"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x xs.\n                          length xs = i + 1 \\<and>\n                          eval (superPicker amount i al fl)\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>)))", "unfolding dropTheEnd[of\"\\<lambda>xs. (\\<forall>a\\<in>set al. aEval a xs) \\<and> (\\<forall>f\\<in>set fl. eval f xs)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x xs.\n                          length xs = i + 1 \\<and>\n                          eval (superPicker amount i al fl)\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x xs.\n                          length xs = i + 1 \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ x # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ x # \\<Gamma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          eval (superPicker amount i al fl)\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ x # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ x # \\<Gamma>)))", "unfolding ih[of amount al fl \"_#\\<Gamma>\",symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          eval (list_conj (map fm.Atom al @ fl))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ x # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ x # \\<Gamma>)))", "unfolding eval_list_conj"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>f\\<in>set (map fm.Atom al @ fl).\n                              eval f (xs @ x # \\<Gamma>))) =\n                      (\\<exists>x xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ x # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ x # \\<Gamma>)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n        x = (al, fl)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             length xs = Suc i \\<and>\n                             (\\<forall>f\\<in>set (map fm.Atom al @ fl).\n                                 eval f (xs @ xa # \\<Gamma>))) =\n                         (\\<exists>xs.\n                             length xs = Suc i \\<and>\n                             (\\<forall>a\\<in>set al.\n                                 aEval a (xs @ xa # \\<Gamma>)) \\<and>\n                             (\\<forall>f\\<in>set fl.\n                                 eval f (xs @ xa # \\<Gamma>)))", "subgoal for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>f\\<in>set (map fm.Atom al @ fl).\n                              eval f (xs @ xa # \\<Gamma>))) =\n                      (\\<exists>xs.\n                          length xs = Suc i \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ xa # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ xa # \\<Gamma>)))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n        x = (al, fl)\\<rbrakk>\n       \\<Longrightarrow> (length xs = Suc i \\<and>\n                          (\\<forall>f\\<in>set (map fm.Atom al @ fl).\n                              eval f (xs @ xa # \\<Gamma>))) =\n                         (length xs = Suc i \\<and>\n                          (\\<forall>a\\<in>set al.\n                              aEval a (xs @ xa # \\<Gamma>)) \\<and>\n                          (\\<forall>f\\<in>set fl.\n                              eval f (xs @ xa # \\<Gamma>)))", "subgoal for xab"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n     x = (al, fl)\\<rbrakk>\n    \\<Longrightarrow> (length xab = Suc i \\<and>\n                       (\\<forall>f\\<in>set (map fm.Atom al @ fl).\n                           eval f (xab @ xa # \\<Gamma>))) =\n                      (length xab = Suc i \\<and>\n                       (\\<forall>a\\<in>set al.\n                           aEval a (xab @ xa # \\<Gamma>)) \\<and>\n                       (\\<forall>f\\<in>set fl.\n                           eval f (xab @ xa # \\<Gamma>)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>amount \\<le> Suc i; (al, fl) \\<in> set (dnf X);\n        x = (al, fl); length xab = Suc i;\n        \\<forall>f\\<in>fm.Atom ` set al \\<union> set fl.\n           eval f (xab @ xa # \\<Gamma>);\n        a \\<in> set al\\<rbrakk>\n       \\<Longrightarrow> aEval a (xab @ xa # \\<Gamma>)", "by (meson Un_iff eval.simps(1) image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?amount2 \\<le> Suc i \\<Longrightarrow>\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      (\\<exists>(al, fl)\\<in>set (dnf ?X2).\n          eval (superPicker ?amount2 i al fl) (xs @ ?\\<Gamma>2))) =\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      (\\<exists>(al, fl)\\<in>set (dnf ?X2).\n          (\\<forall>a\\<in>set al. aEval a (xs @ ?\\<Gamma>2)) \\<and>\n          (\\<forall>f\\<in>set fl. eval f (xs @ ?\\<Gamma>2))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have h3 : \"\\<And>L F. (\\<exists>xs. length xs = Suc (Suc i) \\<and> eval (step (Suc i) L F) (xs@\\<Gamma>)) = (\\<exists>xs. length xs = Suc (Suc i) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L F.\n       (\\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           eval (step (Suc i) L F) (xs @ \\<Gamma>)) =\n       (\\<exists>xs.\n           length xs = Suc (Suc i) \\<and>\n           eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))", "subgoal for L F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (step (Suc i) L F) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))", "using pickedOneOfThem[OF h0]"], ["proof (prove)\nusing this:\n  step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (step (Suc i) L F) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))", "using  qe_eq_repeat_eval'[of \"Suc i\" L F \\<Gamma>] gen_qe_eval'[of \"Suc i\" L F \\<Gamma>] luckyFind_eval'[of \"Suc i\" L F \\<Gamma>]"], ["proof (prove)\nusing this:\n  step = qe_eq_repeat \\<or> step = gen_qe \\<or> step = luckyFind'\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (qe_eq_repeat (Suc i) L F) (xs @ \\<Gamma>))\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (gen_qe (Suc i) L F) (xs @ \\<Gamma>))\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (luckyFind' (Suc i) L F) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (step (Suc i) L F) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      eval (step (Suc i) ?L2 ?F2) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      eval (list_conj (map fm.Atom ?L2 @ ?F2)) (xs @ \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "have heurange : \"var\\<le> Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<le> Suc i", "using rangeHeuristic[OF h0]"], ["proof (prove)\nusing this:\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. var \\<le> Suc i", "by auto"], ["proof (state)\nthis:\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>amount L F \\<Gamma>.\n                amount \\<le> Suc i \\<Longrightarrow>\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n                (\\<exists>xs.\n                    length xs = Suc i \\<and>\n                    eval (superPicker amount i L F) (xs @ \\<Gamma>));\n     amountPred \\<le> Suc i; heuristicPicker (Suc i) L F = Some (var, step);\n     a = (var, step); amountPred' = amountPred;\n     amount = Suc amountPred\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ \\<Gamma>)) =\n                      (\\<exists>xs.\n                          length xs = Suc (Suc i) \\<and>\n                          eval\n                           (list_disj\n                             (map (\\<lambda>(x, y).\nsuperPicker amountPred i x y)\n                               (dnf (push_forall\n(nnf (unpower 0\n       (groupQuantifiers\n         (clearQuantifiers\n           (step (Suc i) (map (swap_atom (Suc i) var) L)\n             (map (swap_fm (Suc i) var) F))))))))))\n                           (xs @ \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval\n         (list_disj\n           (map (\\<lambda>(x, y). superPicker amountPred i x y)\n             (dnf (push_forall\n                    (nnf (unpower 0\n                           (groupQuantifiers\n                             (clearQuantifiers\n                               (step (Suc i) (map (swap_atom (Suc i) var) L)\n                                 (map (swap_fm (Suc i) var) F))))))))))\n         (xs @ \\<Gamma>))", "unfolding eval_list_disj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        (\\<exists>f\\<in>set (map (\\<lambda>(x, y).\n                                     superPicker amountPred i x y)\n                              (dnf (push_forall\n                                     (nnf\n (unpower 0\n   (groupQuantifiers\n     (clearQuantifiers\n       (step (Suc i) (map (swap_atom (Suc i) var) L)\n         (map (swap_fm (Suc i) var) F))))))))).\n            eval f (xs @ \\<Gamma>)))", "unfolding h1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        (\\<exists>(al, fl)\n                  \\<in>set (dnf (push_forall\n                                  (nnf (unpower 0\n   (groupQuantifiers\n     (clearQuantifiers\n       (step (Suc i) (map (swap_atom (Suc i) var) L)\n         (map (swap_fm (Suc i) var) F)))))))).\n            eval (superPicker amountPred i al fl) (xs @ \\<Gamma>)))", "unfolding h2[OF amountPred]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        (\\<exists>(al, fl)\n                  \\<in>set (dnf (push_forall\n                                  (nnf (unpower 0\n   (groupQuantifiers\n     (clearQuantifiers\n       (step (Suc i) (map (swap_atom (Suc i) var) L)\n         (map (swap_fm (Suc i) var) F)))))))).\n            (\\<forall>a\\<in>set al. aEval a (xs @ \\<Gamma>)) \\<and>\n            (\\<forall>f\\<in>set fl. eval f (xs @ \\<Gamma>))))", "unfolding dnf_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval\n         (push_forall\n           (nnf (unpower 0\n                  (groupQuantifiers\n                    (clearQuantifiers\n                      (step (Suc i) (map (swap_atom (Suc i) var) L)\n                        (map (swap_fm (Suc i) var) F)))))))\n         (xs @ \\<Gamma>))", "unfolding opt'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval\n         (step (Suc i) (map (swap_atom (Suc i) var) L)\n           (map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>))", "unfolding h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n    (\\<exists>xs.\n        length xs = Suc (Suc i) \\<and>\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>))", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h : \"length xs = Suc (Suc i)\" \"eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc i)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h3 : \"var < length (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs @ \\<Gamma>)", "using h heurange"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. var < length (xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  var < length (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h1: \"(swap_list (Suc i) var (xs @ \\<Gamma>)) = (swap_list (Suc i) var xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_list (Suc i) var (xs @ \\<Gamma>) =\n    swap_list (Suc i) var xs @ \\<Gamma>", "using h(1) heurange"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. swap_list (Suc i) var (xs @ \\<Gamma>) =\n    swap_list (Suc i) var xs @ \\<Gamma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc (Suc i); var \\<le> Suc i\\<rbrakk>\n    \\<Longrightarrow> (xs @ \\<Gamma>)\n                      [var := (xs @ \\<Gamma>) ! Suc i,\n                       Suc i := (xs @ \\<Gamma>) ! var] =\n                      xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>", "by (simp add: list_update_append nth_append)"], ["proof (state)\nthis:\n  swap_list (Suc i) var (xs @ \\<Gamma>) =\n  swap_list (Suc i) var xs @ \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h2 : \"Suc i < length (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < length (xs @ \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. Suc i < length (xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  Suc i < length (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval\n                             (list_conj\n                               (map fm.Atom\n                                 (map (swap_atom (Suc i) var) L) @\n                                map (swap_fm (Suc i) var) F))\n                             (xs @ \\<Gamma>)\n 2. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = Suc (Suc i) \\<and>\n               eval (list_conj (map fm.Atom (map (swap_atom (Suc i) var) L) @ map (swap_fm (Suc i) var) F)) (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc i) \\<and>\n       eval\n        (list_conj\n          (map fm.Atom (map (swap_atom (Suc i) var) L) @\n           map (swap_fm (Suc i) var) F))\n        (xs @ \\<Gamma>)", "apply(rule exI[where x=\"swap_list (Suc i) var xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap_list (Suc i) var xs) = Suc (Suc i) \\<and>\n    eval\n     (list_conj\n       (map fm.Atom (map (swap_atom (Suc i) var) L) @\n        map (swap_fm (Suc i) var) F))\n     (swap_list (Suc i) var xs @ \\<Gamma>)", "apply(auto simp add:h eval_list_conj simp del:swap_list.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (swap_list (Suc i) var xs) = Suc (Suc i)\n 2. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 3. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "apply(simp add: h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "using swap_fm[OF h2 h3] swap_atom[OF h2 h3]"], ["proof (prove)\nusing this:\n  eval ?F (xs @ \\<Gamma>) =\n  eval (swap_fm (Suc i) var ?F) (swap_list (Suc i) var (xs @ \\<Gamma>))\n  aEval ?F (xs @ \\<Gamma>) =\n  aEval (swap_atom (Suc i) var ?F) (swap_list (Suc i) var (xs @ \\<Gamma>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "unfolding h1"], ["proof (prove)\nusing this:\n  eval ?F (xs @ \\<Gamma>) =\n  eval (swap_fm (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n  aEval ?F (xs @ \\<Gamma>) =\n  aEval (swap_atom (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "using h(2)"], ["proof (prove)\nusing this:\n  eval ?F (xs @ \\<Gamma>) =\n  eval (swap_fm (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n  aEval ?F (xs @ \\<Gamma>) =\n  aEval (swap_atom (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n  eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "unfolding eval_list_conj"], ["proof (prove)\nusing this:\n  eval ?F (xs @ \\<Gamma>) =\n  eval (swap_fm (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n  aEval ?F (xs @ \\<Gamma>) =\n  aEval (swap_atom (Suc i) var ?F) (swap_list (Suc i) var xs @ \\<Gamma>)\n  \\<forall>f\\<in>set (map fm.Atom L @ F). eval f (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>x.\n       x \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var x) (swap_list (Suc i) var xs @ \\<Gamma>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set L;\n        \\<And>F.\n           eval F (xs @ \\<Gamma>) =\n           eval (swap_fm (Suc i) var F)\n            (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>);\n        \\<And>F.\n           aEval F (xs @ \\<Gamma>) =\n           aEval (swap_atom (Suc i) var F)\n            (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>);\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval (swap_fm (Suc i) var f)\n            (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> aEval (swap_atom (Suc i) var x)\n                          (xs[var := xs ! Suc i, Suc i := xs ! var] @\n                           \\<Gamma>)", "by (meson Un_iff eval.simps(1) imageI)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc i) \\<and>\n     eval\n      (list_conj\n        (map fm.Atom (map (swap_atom (Suc i) var) L) @\n         map (swap_fm (Suc i) var) F))\n      (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "assume h : \"length xs = Suc (Suc i)\"\"eval (list_conj (map fm.Atom (map (swap_atom (Suc i) var) L) @ map (swap_fm (Suc i) var) F)) (xs @ \\<Gamma>)\""], ["proof (state)\nthis:\n  length xs = Suc (Suc i)\n  eval\n   (list_conj\n     (map fm.Atom (map (swap_atom (Suc i) var) L) @\n      map (swap_fm (Suc i) var) F))\n   (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h3 : \"var < length (swap_list (Suc i) var xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (swap_list (Suc i) var xs @ \\<Gamma>)", "using h heurange"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  eval\n   (list_conj\n     (map fm.Atom (map (swap_atom (Suc i) var) L) @\n      map (swap_fm (Suc i) var) F))\n   (xs @ \\<Gamma>)\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. var < length (swap_list (Suc i) var xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  var < length (swap_list (Suc i) var xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h1: \"swap_list (Suc i) var (swap_list (Suc i) var xs @ \\<Gamma>) = xs @ \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_list (Suc i) var (swap_list (Suc i) var xs @ \\<Gamma>) =\n    xs @ \\<Gamma>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>)\n    [var := (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>) ! Suc i,\n     Suc i := (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>) ! var] =\n    xs @ \\<Gamma>", "using h(1) heurange"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  var \\<le> Suc i\n\ngoal (1 subgoal):\n 1. (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>)\n    [var := (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>) ! Suc i,\n     Suc i := (xs[var := xs ! Suc i, Suc i := xs ! var] @ \\<Gamma>) ! var] =\n    xs @ \\<Gamma>", "by (smt (z3) le_imp_less_Suc length_list_update lessI list_update_append list_update_id list_update_overwrite list_update_swap nth_append nth_list_update_eq)"], ["proof (state)\nthis:\n  swap_list (Suc i) var (swap_list (Suc i) var xs @ \\<Gamma>) =\n  xs @ \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "have h2 : \"Suc i < length (swap_list (Suc i) var xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < length (swap_list (Suc i) var xs @ \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  length xs = Suc (Suc i)\n  eval\n   (list_conj\n     (map fm.Atom (map (swap_atom (Suc i) var) L) @\n      map (swap_fm (Suc i) var) F))\n   (xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. Suc i < length (swap_list (Suc i) var xs @ \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  Suc i < length (swap_list (Suc i) var xs @ \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>length xs = Suc (Suc i);\n        eval\n         (list_conj\n           (map fm.Atom (map (swap_atom (Suc i) var) L) @\n            map (swap_fm (Suc i) var) F))\n         (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            length xs = Suc (Suc i) \\<and>\n                            eval (list_conj (map fm.Atom L @ F))\n                             (xs @ \\<Gamma>)", "show \"\\<exists>xs. length xs = Suc (Suc i) \\<and> eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       length xs = Suc (Suc i) \\<and>\n       eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)", "apply(rule exI[where x=\"swap_list (Suc i) var xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap_list (Suc i) var xs) = Suc (Suc i) \\<and>\n    eval (list_conj (map fm.Atom L @ F))\n     (swap_list (Suc i) var xs @ \\<Gamma>)", "apply(auto simp add:eval_list_conj simp del:swap_list.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (swap_list (Suc i) var xs) = Suc (Suc i)\n 2. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval x (swap_list (Suc i) var xs @ \\<Gamma>)\n 3. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval f (swap_list (Suc i) var xs @ \\<Gamma>)", "apply(simp add: h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval x (swap_list (Suc i) var xs @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval f (swap_list (Suc i) var xs @ \\<Gamma>)", "unfolding swap_fm[OF h2 h3] swap_atom[OF h2 h3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x)\n        (swap_list (Suc i) var (swap_list (Suc i) var xs @ \\<Gamma>))\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var f)\n        (swap_list (Suc i) var (swap_list (Suc i) var xs @ \\<Gamma>))", "unfolding h1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (xs @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var f) (xs @ \\<Gamma>)", "using h(2)"], ["proof (prove)\nusing this:\n  eval\n   (list_conj\n     (map fm.Atom (map (swap_atom (Suc i) var) L) @\n      map (swap_fm (Suc i) var) F))\n   (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (xs @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var f) (xs @ \\<Gamma>)", "unfolding eval_list_conj"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set (map fm.Atom (map (swap_atom (Suc i) var) L) @\n                      map (swap_fm (Suc i) var) F).\n     eval f (xs @ \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set L \\<Longrightarrow>\n       aEval (swap_atom (Suc i) var x) (xs @ \\<Gamma>)\n 2. \\<And>f.\n       f \\<in> set F \\<Longrightarrow>\n       eval (swap_fm (Suc i) var f) (xs @ \\<Gamma>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set L;\n        \\<forall>f\\<in>(\\<lambda>x. fm.Atom (swap_atom (Suc i) var x)) `\n                       set L \\<union>\n                       swap_fm (Suc i) var ` set F.\n           eval f (xs @ \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> aEval (swap_atom (Suc i) var x) (xs @ \\<Gamma>)", "apply (meson Un_iff eval.simps(1) imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>xs.\n     length xs = Suc (Suc i) \\<and>\n     eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc (Suc i) \\<and>\n      eval\n       (list_disj\n         (map (\\<lambda>(x, y). superPicker amountPred i x y)\n           (dnf (push_forall\n                  (nnf (unpower 0\n                         (groupQuantifiers\n                           (clearQuantifiers\n                             (step (Suc i) (map (swap_atom (Suc i) var) L)\n                               (map (swap_fm (Suc i) var) F))))))))))\n       (xs @ \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (list_conj (map fm.Atom L @ F)) (xs @ \\<Gamma>)) =\n  (\\<exists>xs.\n      length xs = Suc i + 1 \\<and>\n      eval (superPicker amount (Suc i) L F) (xs @ \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brownHueristic_less_than: \"brownsHeuristic n L F = var \\<Longrightarrow> var\\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brownsHeuristic n L F = var \\<Longrightarrow> var \\<le> n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case sorted_list_of_fset\n           ((\\<lambda>x.\n                case foldl\n                      (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                          let deg =\n                                MPoly_Type.degree\n                                 (case l of Less p \\<Rightarrow> p\n                                  | Eq p \\<Rightarrow> p\n                                  | Leq p \\<Rightarrow> p\n                                  | Neq p \\<Rightarrow> p)\n                                 x\n                          in (max maxdeg deg, totaldeg + deg,\n                              appearancecount + (if 0 < deg then 1 else 0)))\n                      (0, 0, 0) L of\n                (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n            fset_of_list [0..<n]) of\n     [] \\<Rightarrow> n\n     | Quad (xa, xba, xc, xb) # xd \\<Rightarrow> if n < xb then n else xb) =\n    var \\<Longrightarrow>\n    var \\<le> n", "apply(cases \"sorted_list_of_fset\n           ((\\<lambda>x. case foldl\n                        (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                            let deg = MPoly_Type.degree (case l of Less p \\<Rightarrow> p | Eq p \\<Rightarrow> p | Leq p \\<Rightarrow> p | Neq p \\<Rightarrow> p) x\n                            in (max maxdeg deg, totaldeg + deg, appearancecount + (if 0 < deg then 1 else 0)))\n                        (0, 0, 0) L of\n                  (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n            fset_of_list [0..<n])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(case sorted_list_of_fset\n                    ((\\<lambda>x.\n                         case foldl\n                               (\\<lambda>(maxdeg, totaldeg, appearancecount)\n                                   l. let deg =\n      MPoly_Type.degree\n       (case l of Less p \\<Rightarrow> p | Eq p \\<Rightarrow> p\n        | Leq p \\<Rightarrow> p | Neq p \\<Rightarrow> p)\n       x\nin (max maxdeg deg, totaldeg + deg,\n    appearancecount + (if 0 < deg then 1 else 0)))\n                               (0, 0, 0) L of\n                         (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n                     fset_of_list [0..<n]) of\n              [] \\<Rightarrow> n\n              | Quad (xa, xba, xc, xb) # xd \\<Rightarrow>\n                  if n < xb then n else xb) =\n             var;\n     sorted_list_of_fset\n      ((\\<lambda>x.\n           case foldl\n                 (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                     let deg =\n                           MPoly_Type.degree\n                            (case l of Less p \\<Rightarrow> p\n                             | Eq p \\<Rightarrow> p | Leq p \\<Rightarrow> p\n                             | Neq p \\<Rightarrow> p)\n                            x\n                     in (max maxdeg deg, totaldeg + deg,\n                         appearancecount + (if 0 < deg then 1 else 0)))\n                 (0, 0, 0) L of\n           (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n       fset_of_list [0..<n]) =\n     []\\<rbrakk>\n    \\<Longrightarrow> var \\<le> n\n 2. \\<And>a list.\n       \\<lbrakk>(case sorted_list_of_fset\n                       ((\\<lambda>x.\n                            case foldl\n                                  (\\<lambda>(maxdeg, totaldeg,\nappearancecount) l.\nlet deg =\n      MPoly_Type.degree\n       (case l of Less p \\<Rightarrow> p | Eq p \\<Rightarrow> p\n        | Leq p \\<Rightarrow> p | Neq p \\<Rightarrow> p)\n       x\nin (max maxdeg deg, totaldeg + deg,\n    appearancecount + (if 0 < deg then 1 else 0)))\n                                  (0, 0, 0) L of\n                            (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n                        fset_of_list [0..<n]) of\n                 [] \\<Rightarrow> n\n                 | Quad (xa, xba, xc, xb) # xd \\<Rightarrow>\n                     if n < xb then n else xb) =\n                var;\n        sorted_list_of_fset\n         ((\\<lambda>x.\n              case foldl\n                    (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                        let deg =\n                              MPoly_Type.degree\n                               (case l of Less p \\<Rightarrow> p\n                                | Eq p \\<Rightarrow> p\n                                | Leq p \\<Rightarrow> p\n                                | Neq p \\<Rightarrow> p)\n                               x\n                        in (max maxdeg deg, totaldeg + deg,\n                            appearancecount + (if 0 < deg then 1 else 0)))\n                    (0, 0, 0) L of\n              (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n          fset_of_list [0..<n]) =\n        a # list\\<rbrakk>\n       \\<Longrightarrow> var \\<le> n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>sorted_list_of_fset\n                 ((\\<lambda>x.\n                      case foldl\n                            (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                                let deg =\nMPoly_Type.degree\n (case l of Less p \\<Rightarrow> p | Eq p \\<Rightarrow> p\n  | Leq p \\<Rightarrow> p | Neq p \\<Rightarrow> p)\n x\n                                in (max maxdeg deg, totaldeg + deg,\n                                    appearancecount +\n                                    (if 0 < deg then 1 else 0)))\n                            (0, 0, 0) L of\n                      (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n                  fset_of_list [0..<n]) =\n                a # list;\n        var =\n        (case a of\n         Quad (xa, xba, xc, xb) \\<Rightarrow>\n           if n < xb then n else xb)\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          Quad (xa, xba, xc, xb) \\<Rightarrow>\n                            if n < xb then n else xb)\n                         \\<le> n", "subgoal for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_fset\n              ((\\<lambda>x.\n                   case foldl\n                         (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                             let deg =\n                                   MPoly_Type.degree\n                                    (case l of Less p \\<Rightarrow> p\n                                     | Eq p \\<Rightarrow> p\n                                     | Leq p \\<Rightarrow> p\n                                     | Neq p \\<Rightarrow> p)\n                                    x\n                             in (max maxdeg deg, totaldeg + deg,\n                                 appearancecount +\n                                 (if 0 < deg then 1 else 0)))\n                         (0, 0, 0) L of\n                   (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n               fset_of_list [0..<n]) =\n             a # list_;\n     var =\n     (case a of\n      Quad (xa, xba, xc, xb) \\<Rightarrow>\n        if n < xb then n else xb)\\<rbrakk>\n    \\<Longrightarrow> (case a of\n                       Quad (xa, xba, xc, xb) \\<Rightarrow>\n                         if n < xb then n else xb)\n                      \\<le> n", "apply(cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sorted_list_of_fset\n                 ((\\<lambda>x.\n                      case foldl\n                            (\\<lambda>(maxdeg, totaldeg, appearancecount) l.\n                                let deg =\nMPoly_Type.degree\n (case l of Less p \\<Rightarrow> p | Eq p \\<Rightarrow> p\n  | Leq p \\<Rightarrow> p | Neq p \\<Rightarrow> p)\n x\n                                in (max maxdeg deg, totaldeg + deg,\n                                    appearancecount +\n                                    (if 0 < deg then 1 else 0)))\n                            (0, 0, 0) L of\n                      (a, b, c) \\<Rightarrow> Quad (a, b, c, x)) |`|\n                  fset_of_list [0..<n]) =\n                a # list_;\n        var =\n        (case a of\n         Quad (xa, xba, xc, xb) \\<Rightarrow> if n < xb then n else xb);\n        a = Quad x\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          Quad (xa, xba, xc, xb) \\<Rightarrow>\n                            if n < xb then n else xb)\n                         \\<le> n", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}