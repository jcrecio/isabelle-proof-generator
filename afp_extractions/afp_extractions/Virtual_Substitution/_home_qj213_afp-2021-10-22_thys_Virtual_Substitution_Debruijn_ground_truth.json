{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/Debruijn.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma inc_above_dec_above: \"x < b \\<or> b + i \\<le> x \\<Longrightarrow> inc_above b i (dec_above b i x) = x\"", "lemma dec_above_inc_above: \"dec_above b i (inc_above b i x) = x\"", "lemma inc_above_dec_above_iff: \"inc_above b i (dec_above b i x) = x \\<longleftrightarrow> x < b \\<or> b + i \\<le> x\"", "lemma inj_on_dec_above: \"inj_on (dec_above b i) {x. x < b \\<or> b + i \\<le> x}\"", "lemma finite_inc_above_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (inc_above b i x) \\<noteq> c}\"", "lemma finite_dec_above_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (dec_above b i x) \\<noteq> c}\"", "lemma higherPowers_lowerPowers: \"higherPowers n i (lowerPowers n i x) = x\"", "lemma inj_lowerPowers: \"inj (lowerPowers b i)\"", "lemma lowerPowers_higherPowers:\n  \"(\\<And>j. n \\<le> j \\<Longrightarrow> j < n + i \\<Longrightarrow> lookup x j = 0) \\<Longrightarrow> lowerPowers n i (higherPowers n i x) = x\"", "lemma inj_on_higherPowers: \"inj_on (higherPowers n i) {x. \\<forall>j. n \\<le> j \\<and> j < n + i \\<longrightarrow> lookup x j = 0}\"", "lemma higherPowers_eq: \"lookup (higherPowers b i p) x = lookup p (inc_above b i x)\"", "lemma lowerPowers_eq: \"lookup (lowerPowers b i p) x = (if b \\<le> x \\<and> x < b + i then 0 else lookup p (dec_above b i x))\"", "lemma keys_higherPowers: \"keys (higherPowers b i m) = dec_above b i ` (keys m \\<inter> {x. x \\<notin> {b..<b+i}})\"", "lemma map_of_map_key_inverse_fun_eq:\n  \"map_of (map (\\<lambda>(k, y). (f k, y)) xs) x = map_of xs (g x)\"\n  if \"\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x\" \"f (g x) = x\"\n  for f::\"'a \\<Rightarrow> 'b\"", "lemma map_of_filter_key_in: \"P x \\<Longrightarrow> map_of (filter (\\<lambda>(k, v). P k) xs) x = map_of xs x\"", "lemma map_of_eq_NoneI: \"x\\<notin>fst`set xs \\<Longrightarrow> map_of xs x = None\"", "lemma compute_higherPowers\\<^sub>f[code]: \"higherPowers\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (if k < b then k else k - i, v)) (filter (\\<lambda>(k, v). k \\<notin> {b..<b+i}) xs))\"", "lemma compute_lowerPowers\\<^sub>f[code]: \"lowerPowers\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (if k < b then k else k + i, v)) xs)\"", "lemma compute_higherPowers[code]: \"higherPowers n i (Pm_fmap xs) = Pm_fmap (higherPowers\\<^sub>f n i xs)\"", "lemma compute_lowerPowers[code]: \"lowerPowers n i (Pm_fmap xs) = Pm_fmap (lowerPowers\\<^sub>f n i xs)\"", "lemma finite_nonzero_coeff: \"finite {x. MPoly_Type.coeff mpoly x \\<noteq> 0}\"", "lemma higherPowers_zero[simp]: \"higherPowers b i 0 = 0\"", "lemma keys_lowerPoly\\<^sub>0: \"keys (lowerPoly\\<^sub>0 b i mp) = higherPowers b i ` (keys mp \\<inter> {x. \\<forall>j\\<in>{b..<b+i}. lookup x j = 0})\"", "lemma keys_lowerPowers: \"keys (lowerPowers b i m) = inc_above b i ` (keys m)\"", "lemma keys_higherPoly\\<^sub>0: \"keys (higherPoly\\<^sub>0 b i mp) = lowerPowers b i ` (keys mp)\"", "lemma inc_above_id[simp]: \"n < m \\<Longrightarrow> inc_above m i n = n\"", "lemma inc_above_Suc[simp]: \"n \\<ge> m \\<Longrightarrow> inc_above m i n = n + i\"", "lemma compute_lowerPoly\\<^sub>0[code]: \"lowerPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (lowerPoly\\<^sub>f n i m)\"", "lemma compute_higherPoly\\<^sub>0[code]: \"higherPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (higherPoly\\<^sub>f n i m)\"", "lemma compute_lowerPoly\\<^sub>f[code]: \"lowerPoly\\<^sub>f n i (fmap_of_list xs) =\n  (fmap_of_list (map (\\<lambda>(mon, c). (higherPowers n i mon, c))\n    (filter (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n+i}. lookup mon j = 0) xs)))\"", "lemma compute_higherPoly\\<^sub>f[code]: \"higherPoly\\<^sub>f n i (fmap_of_list xs) =\n  fmap_of_list (filter (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n+i}. lookup mon j = 0)\n    (map (\\<lambda>(mon, c). (lowerPowers n i mon, c)) xs))\"", "lemma coeff_lowerPoly: \"MPoly_Type.coeff (lowerPoly b i mp) x = MPoly_Type.coeff mp (lowerPowers b i x)\"", "lemma coeff_liftPoly: \"MPoly_Type.coeff (liftPoly b i mp) x = (if (\\<exists>j\\<in>{b..<b+i}. lookup x j > 0)\n    then 0\n    else MPoly_Type.coeff mp (higherPowers b i x))\"", "lemma monomials_lowerPoly: \"monomials (lowerPoly b i mp) = higherPowers b i ` (monomials mp \\<inter> {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}) \"", "lemma monomials_liftPoly: \"monomials (liftPoly b i mp) = lowerPowers b i ` (monomials mp) \"", "lemma lookup_not_in_vars_eq_zero: \"x \\<in> monomials p \\<Longrightarrow> i \\<notin> vars p \\<Longrightarrow> lookup x i = 0\"", "lemma nth_dec_above:\n  assumes \"length xs = i\" \"length ys = j\" \"k \\<notin> {i..<i+j}\"\n  shows \"nth_default 0 (xs @ zs) (dec_above i j k) = (nth_default 0 (xs @ ys @ zs)) k\"", "lemma insertion_lowerPoly:\n  assumes i_notin: \"vars p \\<inter> {i..<i+j} = {}\"\n    and lprfx: \"length prfx = i\"\n    and lxs: \"length xs = j\"\n  shows \"insertion (nth_default 0 (prfx@L)) (lowerPoly i j p) = insertion (nth_default 0 (prfx@xs@L)) p\" (is \"?lhs = ?rhs\")", "lemma insertion_lowerPoly1:\n  assumes i_notin: \"i \\<notin> vars p\"\n    and lprfx: \"length prfx = i\"\n  shows \"insertion (nth_default 0 (prfx@x#L)) p = insertion (nth_default 0 (prfx@L)) (lowerPoly i 1 p)\"", "lemma insertion_lowerPoly01:\n  assumes i_notin: \"0 \\<notin> vars p\"\n  shows \"insertion (nth_default 0 (x#L)) p = insertion (nth_default 0 L) (lowerPoly 0 1 p)\"", "lemma aEval_lowerAtom : \"(freeIn 0 (Atom A)) \\<Longrightarrow> (aEval A (x#L) = aEval (lowerAtom 0 1 A) L)\"", "lemma eval_lowerFm_helper :\n  assumes \"freeIn i F\"\n  assumes \"length init = i\"\n  shows \"eval (lowerFm i 1 F) (init @xs) = eval F (init@[x]@xs)\"", "lemma eval_lowerFm :\n  assumes h : \"freeIn 0 F\"\n  shows \" \\<forall>xs. (eval (lowerFm 0 1 F) xs = eval (ExQ F) xs)\"", "lemma higherPoly\\<^sub>0_add : \"higherPoly\\<^sub>0 x y (p + q) = higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q\"", "lemma liftPoly_add: \"liftPoly w z (a + b) = (liftPoly w z a) + (liftPoly w z b)\"", "lemma vars_lift_add : \"vars(liftPoly a b (p+q)) \\<subseteq> vars(liftPoly a b (p))\\<union> vars(liftPoly a b (q))\"", "lemma mapping_of_lift_add : \"mapping_of (liftPoly x y (a + b)) = mapping_of (liftPoly x y a) + mapping_of (liftPoly x y b)\"", "lemma coeff_lift_add : \"MPoly_Type.coeff (liftPoly x y (a + b)) m = MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\"", "lemma lift_add : \"insertion (f::nat\\<Rightarrow>real)  (liftPoly 0 z (a + b)) = insertion f (liftPoly 0 z a + liftPoly 0 z b)\"", "lemma lower_power_zero : \"lowerPowers a b 0 = 0\"", "lemma lift_vars_monom : \"vars (liftPoly i j ((MPoly_Type.monom m a)::real mpoly)) = (\\<lambda>x. if x\\<ge>i then x+j else x) ` vars(MPoly_Type.monom m a)\"", "lemma lift_clear_vars : \"vars (liftPoly i j (p::real mpoly)) \\<inter> {i..<i + j} = {}\"", "lemma lift0: \"(liftPoly i j 0) = 0\"", "lemma lower0: \"(lowerPoly i j 0) = 0\"", "lemma lower_lift_monom : \"insertion f (MPoly_Type.monom m a :: real mpoly) = insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom  m a)))\"", "lemma lower_lift : \"insertion f (p::real mpoly) = insertion f (lowerPoly i j (liftPoly i j p))\"", "lemma lift_insertion : \" \\<forall>init.\n       length init = (i::nat) \\<longrightarrow>\n       (\\<forall>I xs.\n           (insertion (nth_default 0 (init @ xs)) (p::real mpoly)) = (insertion ((nth_default 0) (init @ I @ xs)) (liftPoly i (length I) p)))\"", "lemma eval_liftFm_helper :\n  assumes \"length init = i\"\n  assumes \"length I = amount\"\n  shows \"eval F (init @xs) = eval (liftFm i amount F) (init@I@xs)\"", "lemma eval_liftFm :\n  assumes \"length I = amount\"\n  assumes \"length L \\<ge> d\"\n  shows \"eval F L = eval (liftFm d amount F) (insert_into L d I)\"", "lemma not_in_lift : \"var\\<notin>vars(p::real mpoly) \\<Longrightarrow> var+z\\<notin>vars(liftPoly 0 z p)\"", "lemma lift_const : \"insertion f (liftPoly 0 z (Const (C::real))) = insertion f (Const C :: real mpoly)\"", "lemma liftPoly_sub: \"liftPoly 0 z (a - b) = (liftPoly 0 z a) - (liftPoly 0 z b)\"", "lemma lift_sub : \"insertion (f::nat\\<Rightarrow>real) (liftPoly 0 z (a - b)) = insertion f (liftPoly 0 z a - liftPoly 0 z b)\"", "lemma lift_minus : \n  assumes \"insertion (f::nat \\<Rightarrow> real) (liftPoly 0 z (c - Const (C::real))) = 0\"\n  shows \"insertion f (liftPoly 0 z c) = C\"", "lemma lift00 : \"liftPoly 0 0 (a::real mpoly) = a\""], "translations": [["", "lemma inc_above_dec_above: \"x < b \\<or> b + i \\<le> x \\<Longrightarrow> inc_above b i (dec_above b i x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < b \\<or> b + i \\<le> x \\<Longrightarrow>\n    inc_above b i (dec_above b i x) = x", "by (auto simp: inc_above_def dec_above_def)"], ["", "lemma dec_above_inc_above: \"dec_above b i (inc_above b i x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_above b i (inc_above b i x) = x", "by (auto simp: inc_above_def dec_above_def)"], ["", "lemma inc_above_dec_above_iff: \"inc_above b i (dec_above b i x) = x \\<longleftrightarrow> x < b \\<or> b + i \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inc_above b i (dec_above b i x) = x) = (x < b \\<or> b + i \\<le> x)", "by (auto simp: inc_above_def dec_above_def)"], ["", "lemma inj_on_dec_above: \"inj_on (dec_above b i) {x. x < b \\<or> b + i \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (dec_above b i) {x. x < b \\<or> b + i \\<le> x}", "by (rule inj_on_inverseI[where g = \"inc_above b i\"]) (auto simp: inc_above_dec_above)"], ["", "lemma finite_inc_above_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (inc_above b i x) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "fix b and f::\"nat\\<Rightarrow>'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "assume f: \"finite {x. f x \\<noteq> c}\""], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "moreover"], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "have \"finite {x. f (x + i) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "have \"{x. f (x + i) \\<noteq> c} = (+) i -` {x. f x \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f (x + i) \\<noteq> c} = (+) i -` {x. f x \\<noteq> c}", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  {x. f (x + i) \\<noteq> c} = (+) i -` {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "also"], ["proof (state)\nthis:\n  {x. f (x + i) \\<noteq> c} = (+) i -` {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((+) i -` {x. f x \\<noteq> c})", "by (rule finite_vimageI) (use f in auto)"], ["proof (state)\nthis:\n  finite ((+) i -` {x. f x \\<noteq> c})\n\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "finally"], ["proof (chain)\npicking this:\n  finite {x. f (x + i) \\<noteq> c}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. f (x + i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f (x + i) \\<noteq> c}", "."], ["proof (state)\nthis:\n  finite {x. f (x + i) \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {x. f (x + i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "ultimately"], ["proof (chain)\npicking this:\n  finite {x. f x \\<noteq> c}\n  finite {x. f (x + i) \\<noteq> c}", "have \"finite ({x. f x \\<noteq> c} \\<union> {x. f (x + i) \\<noteq> c})\""], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> c}\n  finite {x. f (x + i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite ({x. f x \\<noteq> c} \\<union> {x. f (x + i) \\<noteq> c})", "by auto"], ["proof (state)\nthis:\n  finite ({x. f x \\<noteq> c} \\<union> {x. f (x + i) \\<noteq> c})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (inc_above b i x) \\<noteq> c}", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite ({x. f x \\<noteq> c} \\<union> {x. f (x + i) \\<noteq> c})", "show \"finite {x. f (inc_above b i x) \\<noteq> c}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite ({x. f x \\<noteq> c} \\<union> {x. f (x + i) \\<noteq> c})\n\ngoal (1 subgoal):\n 1. finite {x. f (inc_above b i x) \\<noteq> c}", "by (rule finite_subset) (auto simp: inc_above_def)"], ["proof (state)\nthis:\n  finite {x. f (inc_above b i x) \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_dec_above_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (dec_above b i x) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "fix b and f::\"nat\\<Rightarrow>'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "assume f: \"finite {x. f x \\<noteq> c}\""], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "moreover"], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "have \"finite {x. f (x - i) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "have \"{x. f (x - i) \\<noteq> c} \\<subseteq> {0..i} \\<union> ((\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f (x - i) \\<noteq> c}\n    \\<subseteq> {0..i} \\<union>\n                (\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..}", "by auto"], ["proof (state)\nthis:\n  {x. f (x - i) \\<noteq> c}\n  \\<subseteq> {0..i} \\<union>\n              (\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..}\n\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "also"], ["proof (state)\nthis:\n  {x. f (x - i) \\<noteq> c}\n  \\<subseteq> {0..i} \\<union>\n              (\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..}\n\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({0..i} \\<union>\n      (\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..})", "apply (rule finite_UnI[OF finite_atLeastAtMost])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..})", "by (rule finite_vimage_IntI) (use f in \\<open>auto simp: inj_on_def\\<close>)"], ["proof (state)\nthis:\n  finite\n   ({0..i} \\<union>\n    (\\<lambda>x. x - i) -` {x. f x \\<noteq> c} \\<inter> {i<..})\n\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {x. f (x - i) \\<noteq> c}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. f (x - i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f (x - i) \\<noteq> c}", "."], ["proof (state)\nthis:\n  finite {x. f (x - i) \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {x. f (x - i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "ultimately"], ["proof (chain)\npicking this:\n  finite {x. f x \\<noteq> c}\n  finite {x. f (x - i) \\<noteq> c}", "have \"finite ({x. f x \\<noteq> c} \\<union> {x. f (x - i) \\<noteq> c} \\<union> {b})\""], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> c}\n  finite {x. f (x - i) \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite\n     ({x. f x \\<noteq> c} \\<union> {x. f (x - i) \\<noteq> c} \\<union> {b})", "by auto"], ["proof (state)\nthis:\n  finite\n   ({x. f x \\<noteq> c} \\<union> {x. f (x - i) \\<noteq> c} \\<union> {b})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (dec_above b i x) \\<noteq> c}", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite\n   ({x. f x \\<noteq> c} \\<union> {x. f (x - i) \\<noteq> c} \\<union> {b})", "show \"finite {x. f (dec_above b i x) \\<noteq> c}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite\n   ({x. f x \\<noteq> c} \\<union> {x. f (x - i) \\<noteq> c} \\<union> {b})\n\ngoal (1 subgoal):\n 1. finite {x. f (dec_above b i x) \\<noteq> c}", "by (rule finite_subset) (auto simp: dec_above_def)"], ["proof (state)\nthis:\n  finite {x. f (dec_above b i x) \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition lowerPowers::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a::zero)\"\n  is \"\\<lambda>b i p x. if x \\<in> {b..<b+i} then 0 else p (dec_above b i x)::'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if x \\<in> {nat1..<nat1 + nat2} then 0::'a\n             else fun (dec_above nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if x \\<in> {nat1..<nat1 + nat2} then 0::'a\n             else fun (dec_above nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "fix b i::nat and p::\"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if x \\<in> {nat1..<nat1 + nat2} then 0::'a\n             else fun (dec_above nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "assume \"finite {x. p x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if x \\<in> {nat1..<nat1 + nat2} then 0::'a\n             else fun (dec_above nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "then"], ["proof (chain)\npicking this:\n  finite {x. p x \\<noteq> (0::'a)}", "have \"finite {x. p (dec_above b i x) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {x. p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. p (dec_above b i x) \\<noteq> (0::'a)}", "by (rule finite_dec_above_ne)"], ["proof (state)\nthis:\n  finite {x. p (dec_above b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if x \\<in> {nat1..<nat1 + nat2} then 0::'a\n             else fun (dec_above nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite {x. p (dec_above b i x) \\<noteq> (0::'a)}", "show \"finite {x. (if x \\<in> {b..<b+i} then 0 else p (dec_above b i x)) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite {x. p (dec_above b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (if x \\<in> {b..<b + i} then 0::'a\n          else p (dec_above b i x)) \\<noteq>\n         (0::'a)}", "by (rule finite_subset) auto"], ["proof (state)\nthis:\n  finite\n   {x. (if x \\<in> {b..<b + i} then 0::'a else p (dec_above b i x)) \\<noteq>\n       (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition higherPowers::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a::zero)\"\n  is \"\\<lambda>b i p x. p (inc_above b i x)::'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (inc_above nat1 nat2 x) \\<noteq> (0::'a)}", "by (simp_all add: finite_inc_above_ne)"], ["", "lemma higherPowers_lowerPowers: \"higherPowers n i (lowerPowers n i x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers n i (lowerPowers n i x) = x", "by transfer (force simp: dec_above_def inc_above_def antisym_conv2)"], ["", "lemma inj_lowerPowers: \"inj (lowerPowers b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (lowerPowers b i)", "using higherPowers_lowerPowers"], ["proof (prove)\nusing this:\n  higherPowers ?n ?i (lowerPowers ?n ?i ?x) = ?x\n\ngoal (1 subgoal):\n 1. inj (lowerPowers b i)", "by (rule inj_on_inverseI)"], ["", "lemma lowerPowers_higherPowers:\n  \"(\\<And>j. n \\<le> j \\<Longrightarrow> j < n + i \\<Longrightarrow> lookup x j = 0) \\<Longrightarrow> lowerPowers n i (higherPowers n i x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>n \\<le> j; j < n + i\\<rbrakk>\n        \\<Longrightarrow> lookup x j = (0::'a)) \\<Longrightarrow>\n    lowerPowers n i (higherPowers n i x) = x", "by (transfer fixing: n i) (force simp: inc_above_dec_above)"], ["", "lemma inj_on_higherPowers: \"inj_on (higherPowers n i) {x. \\<forall>j. n \\<le> j \\<and> j < n + i \\<longrightarrow> lookup x j = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (higherPowers n i)\n     {x. \\<forall>j.\n            n \\<le> j \\<and> j < n + i \\<longrightarrow>\n            lookup x j = (0::'a)}", "using lowerPowers_higherPowers"], ["proof (prove)\nusing this:\n  (\\<And>j.\n      \\<lbrakk>?n \\<le> j; j < ?n + ?i\\<rbrakk>\n      \\<Longrightarrow> lookup ?x j = (0::?'a)) \\<Longrightarrow>\n  lowerPowers ?n ?i (higherPowers ?n ?i ?x) = ?x\n\ngoal (1 subgoal):\n 1. inj_on (higherPowers n i)\n     {x. \\<forall>j.\n            n \\<le> j \\<and> j < n + i \\<longrightarrow>\n            lookup x j = (0::'a)}", "by (rule inj_on_inverseI) auto"], ["", "lemma higherPowers_eq: \"lookup (higherPowers b i p) x = lookup p (inc_above b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (higherPowers b i p) x = lookup p (inc_above b i x)", "by (simp_all add: higherPowers.rep_eq)"], ["", "lemma lowerPowers_eq: \"lookup (lowerPowers b i p) x = (if b \\<le> x \\<and> x < b + i then 0 else lookup p (dec_above b i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lowerPowers b i p) x =\n    (if b \\<le> x \\<and> x < b + i then 0::'a\n     else lookup p (dec_above b i x))", "by (auto simp add: lowerPowers.rep_eq)"], ["", "lemma keys_higherPowers: \"keys (higherPowers b i m) = dec_above b i ` (keys m \\<inter> {x. x \\<notin> {b..<b+i}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (higherPowers b i m) =\n    dec_above b i ` (keys m \\<inter> {x. x \\<notin> {b..<b + i}})", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (higherPowers b i m) \\<Longrightarrow>\n       x \\<in> dec_above b i ` (keys m \\<inter> {x. x \\<notin> {b..<b + i}})\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys m; xa \\<notin> {b..<b + i}\\<rbrakk>\n       \\<Longrightarrow> dec_above b i xa \\<in> keys (higherPowers b i m)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (higherPowers b i m) \\<Longrightarrow>\n    x \\<in> dec_above b i ` (keys m \\<inter> {x. x \\<notin> {b..<b + i}})", "apply (rule image_eqI[where x=\"inc_above b i x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> keys (higherPowers b i m) \\<Longrightarrow>\n    x = dec_above b i (inc_above b i x)\n 2. x \\<in> keys (higherPowers b i m) \\<Longrightarrow>\n    inc_above b i x \\<in> keys m \\<inter> {x. x \\<notin> {b..<b + i}}", "apply (auto simp: dec_above_inc_above in_keys_iff higherPowers.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup m (inc_above b i x) \\<noteq> (0::'a);\n     b \\<le> inc_above b i x; inc_above b i x < b + i\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis add_less_cancel_right inc_above_def leD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys m; xa \\<notin> {b..<b + i}\\<rbrakk>\n       \\<Longrightarrow> dec_above b i xa \\<in> keys (higherPowers b i m)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ \\<in> keys m; xa_ \\<notin> {b..<b + i}\\<rbrakk>\n    \\<Longrightarrow> dec_above b i xa_ \\<in> keys (higherPowers b i m)", "by (auto simp: inc_above_dec_above in_keys_iff higherPowers.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context includes fmap.lifting begin"], ["", "lift_definition lowerPowers\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat, 'a) fmap \\<Rightarrow> (nat, 'a::zero) fmap\"\n  is \"\\<lambda>b i p x. if x \\<in> {b..<b+i} then None else p (dec_above b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "fix b i::nat and p::\"nat \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "assume \"finite (dom p)\""], ["proof (state)\nthis:\n  finite (dom p)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "then"], ["proof (chain)\npicking this:\n  finite (dom p)", "have \"finite {x. p x \\<noteq> None}\""], ["proof (prove)\nusing this:\n  finite (dom p)\n\ngoal (1 subgoal):\n 1. finite {x. p x \\<noteq> None}", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  finite {x. p x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "have \"dom (\\<lambda>x. p (dec_above b i x)) = {x. p (dec_above b i x) \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. p (dec_above b i x)) =\n    {x. p (dec_above b i x) \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  dom (\\<lambda>x. p (dec_above b i x)) =\n  {x. p (dec_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>x. p (dec_above b i x)) =\n  {x. p (dec_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. p (dec_above b i x) \\<noteq> None}", "by (rule finite_dec_above_ne) fact"], ["proof (state)\nthis:\n  finite {x. p (dec_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "finally"], ["proof (chain)\npicking this:\n  finite (dom (\\<lambda>x. p (dec_above b i x)))", "have \"finite (dom (\\<lambda>x. p (dec_above b i x)))\""], ["proof (prove)\nusing this:\n  finite (dom (\\<lambda>x. p (dec_above b i x)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>x. p (dec_above b i x)))", "."], ["proof (state)\nthis:\n  finite (dom (\\<lambda>x. p (dec_above b i x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>x.\n                 if x \\<in> {nat1..<nat1 + nat2} then None\n                 else fun (dec_above nat1 nat2 x)))", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom (\\<lambda>x. p (dec_above b i x)))", "show \"finite (dom (\\<lambda>x. if x \\<in> {b..<b+i} then None else p (dec_above b i x)))\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom (\\<lambda>x. p (dec_above b i x)))\n\ngoal (1 subgoal):\n 1. finite\n     (dom (\\<lambda>x.\n              if x \\<in> {b..<b + i} then None else p (dec_above b i x)))", "by (rule finite_subset) (auto split: if_splits)"], ["proof (state)\nthis:\n  finite\n   (dom (\\<lambda>x.\n            if x \\<in> {b..<b + i} then None else p (dec_above b i x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition higherPowers\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat, 'a) fmap \\<Rightarrow> (nat, 'a) fmap\"\n  is \"\\<lambda>b i f x. f (inc_above b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "fix b i::nat and f::\"nat \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "assume \"finite (dom f)\""], ["proof (state)\nthis:\n  finite (dom f)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "then"], ["proof (chain)\npicking this:\n  finite (dom f)", "have \"finite {i. f i \\<noteq> None}\""], ["proof (prove)\nusing this:\n  finite (dom f)\n\ngoal (1 subgoal):\n 1. finite {i. f i \\<noteq> None}", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  finite {i. f i \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "have \"dom (\\<lambda>x. f (inc_above b i x)) = {x. f (inc_above b i x) \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. f (inc_above b i x)) =\n    {x. f (inc_above b i x) \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  dom (\\<lambda>x. f (inc_above b i x)) =\n  {x. f (inc_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>x. f (inc_above b i x)) =\n  {x. f (inc_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f (inc_above b i x) \\<noteq> None}", "by (rule finite_inc_above_ne) fact"], ["proof (state)\nthis:\n  finite {x. f (inc_above b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (inc_above nat1 nat2 x)))", "finally"], ["proof (chain)\npicking this:\n  finite (dom (\\<lambda>x. f (inc_above b i x)))", "show \"finite (dom (\\<lambda>x. f (inc_above b i x)))\""], ["proof (prove)\nusing this:\n  finite (dom (\\<lambda>x. f (inc_above b i x)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>x. f (inc_above b i x)))", "."], ["proof (state)\nthis:\n  finite (dom (\\<lambda>x. f (inc_above b i x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_map_key_inverse_fun_eq:\n  \"map_of (map (\\<lambda>(k, y). (f k, y)) xs) x = map_of xs (g x)\"\n  if \"\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x\" \"f (g x) = x\"\n  for f::\"'a \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, y). (f k, y)) xs) x = map_of xs (g x)", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, y). (f k, y)) xs) x = map_of xs (g x)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set [] \\<Longrightarrow> g (f (fst x)) = fst x;\n     f (g x) = x\\<rbrakk>\n    \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) []) x =\n                      map_of [] (g x)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> set [] \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set [] \\<Longrightarrow> g (f (fst x)) = fst x;\n     f (g x) = x\\<rbrakk>\n    \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) []) x =\n                      map_of [] (g x)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set [] \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set [] \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>a. case a of (k, a) \\<Rightarrow> (f k, a)) [])\n     x =\n    map_of [] (g x)", "by simp"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>a. case a of (k, a) \\<Rightarrow> (f k, a)) []) x =\n  map_of [] (g x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x;\n   f (g x) = x\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>a.\n                              case a of (k, a) \\<Rightarrow> (f k, a))\n                       xs)\n                     x =\n                    map_of xs (g x)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x;\n   f (g x) = x\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>a.\n                              case a of (k, a) \\<Rightarrow> (f k, a))\n                       xs)\n                     x =\n                    map_of xs (g x)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x", "have IH: \"map_of (map (\\<lambda>a. (f (fst a), snd a)) xs) x = map_of xs (g x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x;\n   f (g x) = x\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>a.\n                              case a of (k, a) \\<Rightarrow> (f k, a))\n                       xs)\n                     x =\n                    map_of xs (g x)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>a. (f (fst a), snd a)) xs) x = map_of xs (g x)", "by (auto simp: split_beta')"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>a. (f (fst a), snd a)) xs) x = map_of xs (g x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "have inv_into: \"g (f (fst a)) = fst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (f (fst a)) = fst a", "by (rule Cons) simp"], ["proof (state)\nthis:\n  g (f (fst a)) = fst a\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            g (f (fst x)) = fst x;\n                 f (g x) = x\\<rbrakk>\n                \\<Longrightarrow> map_of\n                                   (map (\\<lambda>(k, y). (f k, y)) xs) x =\n                                  map_of xs (g x);\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst x)) = fst x;\n        f (g x) = x\\<rbrakk>\n       \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (f k, y)) (a # xs))\n                          x =\n                         map_of (a # xs) (g x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a. case a of (k, a) \\<Rightarrow> (f k, a)) (a # xs))\n     x =\n    map_of (a # xs) (g x)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> g (f (fst x)) = fst x;\n   f (g x) = x\\<rbrakk>\n  \\<Longrightarrow> map_of\n                     (map (\\<lambda>a.\n                              case a of (k, a) \\<Rightarrow> (f k, a))\n                       xs)\n                     x =\n                    map_of xs (g x)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> g (f (fst ?x)) = fst ?x\n  f (g x) = x\n\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>a. case a of (k, a) \\<Rightarrow> (f k, a)) (a # xs))\n     x =\n    map_of (a # xs) (g x)", "by (auto simp add: split_beta' inv_into IH)"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>a. case a of (k, a) \\<Rightarrow> (f k, a)) (a # xs)) x =\n  map_of (a # xs) (g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_filter_key_in: \"P x \\<Longrightarrow> map_of (filter (\\<lambda>(k, v). P k) xs) x = map_of xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow>\n    map_of (filter (\\<lambda>(k, v). P k) xs) x = map_of xs x", "by (induction xs) (auto simp: )"], ["", "lemma map_of_eq_NoneI: \"x\\<notin>fst`set xs \\<Longrightarrow> map_of xs x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set xs \\<Longrightarrow> map_of xs x = None", "by (induction xs) (auto simp: )"], ["", "lemma compute_higherPowers\\<^sub>f[code]: \"higherPowers\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (if k < b then k else k - i, v)) (filter (\\<lambda>(k, v). k \\<notin> {b..<b+i}) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list\n     (map (\\<lambda>(k, v). (if k < b then k else k - i, v))\n       (filter (\\<lambda>(k, v). k \\<notin> {b..<b + i}) xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. higherPowers\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list\n     (map (\\<lambda>(k, v). (if k < b then k else k - i, v))\n       (filter (\\<lambda>(k, v). k \\<notin> {b..<b + i}) xs))", "have *: \"map_of (map (\\<lambda>(k, y). (if k < b then k else k - i, y)) (filter (\\<lambda>(k, v).  b \\<le> k \\<longrightarrow> \\<not> k < b + i) xs)) x =\n    map_of (filter (\\<lambda>(k, v).  b \\<le> k \\<longrightarrow> \\<not> k < b + i) xs) (if x < b then x else x + i)\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (map (\\<lambda>(k, y). (if k < b then k else k - i, y))\n       (filter\n         (\\<lambda>(k, v). b \\<le> k \\<longrightarrow> \\<not> k < b + i)\n         xs))\n     x =\n    map_of\n     (filter (\\<lambda>(k, v). b \\<le> k \\<longrightarrow> \\<not> k < b + i)\n       xs)\n     (if x < b then x else x + i)", "by (rule map_of_map_key_inverse_fun_eq[where g=\"\\<lambda>k. if k < b then k else k + i\"\n          and f = \"\\<lambda>k. if k < b then k else k - i\"]) auto"], ["proof (state)\nthis:\n  map_of\n   (map (\\<lambda>(k, y). (if k < b then k else k - i, y))\n     (filter (\\<lambda>(k, v). b \\<le> k \\<longrightarrow> \\<not> k < b + i)\n       xs))\n   ?x =\n  map_of\n   (filter (\\<lambda>(k, v). b \\<le> k \\<longrightarrow> \\<not> k < b + i)\n     xs)\n   (if ?x < b then ?x else ?x + i)\n\ngoal (1 subgoal):\n 1. higherPowers\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list\n     (map (\\<lambda>(k, v). (if k < b then k else k - i, v))\n       (filter (\\<lambda>(k, v). k \\<notin> {b..<b + i}) xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list\n     (map (\\<lambda>(k, v). (if k < b then k else k - i, v))\n       (filter (\\<lambda>(k, v). k \\<notin> {b..<b + i}) xs))", "by (auto\n        simp add: * higherPowers\\<^sub>f.rep_eq lowerPowers\\<^sub>f.rep_eq fmlookup_of_list fmlookup_default_def \n        inc_above_def\n        map_of_filter_key_in\n        split: option.splits\n        intro!: fmap_ext)"], ["proof (state)\nthis:\n  higherPowers\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list\n   (map (\\<lambda>(k, v). (if k < b then k else k - i, v))\n     (filter (\\<lambda>(k, v). k \\<notin> {b..<b + i}) xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_lowerPowers\\<^sub>f[code]: \"lowerPowers\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (if k < b then k else k + i, v)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPowers\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (if k < b then k else k + i, v)) xs)", "apply (auto \n      simp add: lowerPowers\\<^sub>f.rep_eq fmlookup_of_list fmlookup_default_def \n      dec_above_def\n      map_of_filter_key_in\n      split: option.splits\n      intro!: fmap_ext)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0 < i \\<Longrightarrow>\n    None =\n    map_of (map (\\<lambda>(k, y). (if k < b then k else k + i, y)) xs) b\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> b; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> map_of xs x =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 3. \\<And>x.\n       \\<lbrakk>x \\<le> b; i = 0\\<rbrakk>\n       \\<Longrightarrow> map_of xs x =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + 0, y))\n                            xs)\n                          x\n 4. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; x < b + i\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 5. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; \\<not> x < b + i\\<rbrakk>\n       \\<Longrightarrow> map_of xs (x - i) =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow>\n    None =\n    map_of (map (\\<lambda>(k, y). (if k < b then k else k + i, y)) xs) b", "by (rule map_of_eq_NoneI[symmetric]) (auto split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> b; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> map_of xs x =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> b; i = 0\\<rbrakk>\n       \\<Longrightarrow> map_of xs x =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + 0, y))\n                            xs)\n                          x\n 3. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; x < b + i\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 4. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; \\<not> x < b + i\\<rbrakk>\n       \\<Longrightarrow> map_of xs (x - i) =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> b; b \\<noteq> x_\\<rbrakk>\n    \\<Longrightarrow> map_of xs x_ =\n                      map_of\n                       (map (\\<lambda>(k, y).\n                                (if k < b then k else k + i, y))\n                         xs)\n                       x_", "by (subst map_of_map_key_inverse_fun_eq[where g=\"\\<lambda>k. if k < b then k else k - i\"]) auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> b; i = 0\\<rbrakk>\n       \\<Longrightarrow> map_of xs x =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + 0, y))\n                            xs)\n                          x\n 2. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; x < b + i\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 3. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; \\<not> x < b + i\\<rbrakk>\n       \\<Longrightarrow> map_of xs (x - i) =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> b; i = 0\\<rbrakk>\n    \\<Longrightarrow> map_of xs x_ =\n                      map_of\n                       (map (\\<lambda>(k, y).\n                                (if k < b then k else k + 0, y))\n                         xs)\n                       x_", "by (subst map_of_map_key_inverse_fun_eq[where g=\"\\<lambda>k. if k < b then k else k - i\"]) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; x < b + i\\<rbrakk>\n       \\<Longrightarrow> None =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x\n 2. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; \\<not> x < b + i\\<rbrakk>\n       \\<Longrightarrow> map_of xs (x - i) =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> x_ \\<le> b; x_ < b + i\\<rbrakk>\n    \\<Longrightarrow> None =\n                      map_of\n                       (map (\\<lambda>(k, y).\n                                (if k < b then k else k + i, y))\n                         xs)\n                       x_", "by (rule map_of_eq_NoneI[symmetric]) (auto split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> x \\<le> b; \\<not> x < b + i\\<rbrakk>\n       \\<Longrightarrow> map_of xs (x - i) =\n                         map_of\n                          (map (\\<lambda>(k, y).\n                                   (if k < b then k else k + i, y))\n                            xs)\n                          x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> x_ \\<le> b; \\<not> x_ < b + i\\<rbrakk>\n    \\<Longrightarrow> map_of xs (x_ - i) =\n                      map_of\n                       (map (\\<lambda>(k, y).\n                                (if k < b then k else k + i, y))\n                         xs)\n                       x_", "by (subst map_of_map_key_inverse_fun_eq[where g=\"\\<lambda>k. if k < b then k else k - i\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_higherPowers[code]: \"higherPowers n i (Pm_fmap xs) = Pm_fmap (higherPowers\\<^sub>f n i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers n i (Pm_fmap xs) = Pm_fmap (higherPowers\\<^sub>f n i xs)", "by (rule poly_mapping_eqI)\n    (auto simp: higherPowers\\<^sub>f.rep_eq higherPowers.rep_eq fmlookup_default_def dec_above_def\n      split: option.splits)"], ["", "lemma compute_lowerPowers[code]: \"lowerPowers n i (Pm_fmap xs) = Pm_fmap (lowerPowers\\<^sub>f n i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPowers n i (Pm_fmap xs) = Pm_fmap (lowerPowers\\<^sub>f n i xs)", "by (rule poly_mapping_eqI)\n    (auto simp: lowerPowers\\<^sub>f.rep_eq lowerPowers.rep_eq fmlookup_default_def dec_above_def\n      split: option.splits)"], ["", "lemma finite_nonzero_coeff: \"finite {x. MPoly_Type.coeff mpoly x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. MPoly_Type.coeff mpoly x \\<noteq> (0::'a)}", "by transfer auto"], ["", "lift_definition lowerPoly\\<^sub>0::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0'a::zero) \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0 'a)\" is\n  \"\\<lambda>b i (mp::(nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>'a) mon. mp (lowerPowers b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "assume \"finite {x. mp x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "have \"{x. mp (lowerPowers b i x) \\<noteq> 0} = (lowerPowers b i -` {x. mp x \\<noteq> 0})\"\n    (is \"?set = ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. mp (lowerPowers b i x) \\<noteq> (0::'a)} =\n    lowerPowers b i -` {x. mp x \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. mp (lowerPowers b i x) \\<noteq> (0::'a)} =\n  lowerPowers b i -` {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "also"], ["proof (state)\nthis:\n  {x. mp (lowerPowers b i x) \\<noteq> (0::'a)} =\n  lowerPowers b i -` {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "from finite_vimageI[OF \\<open>finite _\\<close> inj_lowerPowers]"], ["proof (chain)\npicking this:\n  finite (lowerPowers ?b1 ?i1 -` {x. mp x \\<noteq> (0::'a)})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite (lowerPowers ?b1 ?i1 -` {x. mp x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. finite (lowerPowers b i -` {x. mp x \\<noteq> (0::'a)})", "."], ["proof (state)\nthis:\n  finite (lowerPowers b i -` {x. mp x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (lowerPowers nat1 nat2 x) \\<noteq> (0::'a)}", "finally"], ["proof (chain)\npicking this:\n  finite {x. mp (lowerPowers b i x) \\<noteq> (0::'a)}", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite {x. mp (lowerPowers b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. mp (lowerPowers b i x) \\<noteq> (0::'a)}", "."], ["proof (state)\nthis:\n  finite {x. mp (lowerPowers b i x) \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma higherPowers_zero[simp]: \"higherPowers b i 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers b i 0 = 0", "by transfer auto"], ["", "lemma keys_lowerPoly\\<^sub>0: \"keys (lowerPoly\\<^sub>0 b i mp) = higherPowers b i ` (keys mp \\<inter> {x. \\<forall>j\\<in>{b..<b+i}. lookup x j = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lowerPoly\\<^sub>0 b i mp) =\n    higherPowers b i `\n    (keys mp \\<inter> {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})", "apply (auto )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (lowerPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n       x \\<in> higherPowers b i `\n               (keys mp \\<inter>\n                {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> keys mp;\n        \\<forall>j\\<in>{b..<b + i}. lookup xa j = 0\\<rbrakk>\n       \\<Longrightarrow> higherPowers b i xa\n                         \\<in> keys (lowerPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (lowerPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x \\<in> higherPowers b i `\n            (keys mp \\<inter>\n             {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})", "apply (rule image_eqI[where x=\"lowerPowers b i x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> keys (lowerPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x = higherPowers b i (lowerPowers b i x)\n 2. x \\<in> keys (lowerPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    lowerPowers b i x\n    \\<in> keys mp \\<inter> {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}", "apply (auto simp: higherPowers_lowerPowers in_keys_iff lowerPoly\\<^sub>0.rep_eq lowerPowers.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> keys mp;\n        \\<forall>j\\<in>{b..<b + i}. lookup xa j = 0\\<rbrakk>\n       \\<Longrightarrow> higherPowers b i xa\n                         \\<in> keys (lowerPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> keys mp;\n     \\<forall>j\\<in>{b..<b + i}. lookup x j = 0\\<rbrakk>\n    \\<Longrightarrow> higherPowers b i x\n                      \\<in> keys (lowerPoly\\<^sub>0 b i mp)", "apply (auto simp: in_keys_iff lowerPoly\\<^sub>0.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n     \\<forall>j\\<in>{b..<b + i}. lookup x j = 0;\n     lookup mp (lowerPowers b i (higherPowers b i x)) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst (asm) lowerPowers_higherPowers)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n        \\<forall>j\\<in>{b..<b + i}. lookup x j = 0; b \\<le> j;\n        j < b + i\\<rbrakk>\n       \\<Longrightarrow> lookup x j = 0\n 2. \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n     \\<forall>j\\<in>{b..<b + i}. lookup x j = 0;\n     lookup mp x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition higherPoly\\<^sub>0::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0'a::zero) \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0 'a)\" is\n  \"\\<lambda>b i (mp::(nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>'a) mon.\n    if (\\<exists>j\\<in>{b..<b+i}. lookup mon j > 0)\n    then 0\n    else mp (higherPowers b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "assume \"finite {x. mp x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "have \"{x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0 else mp (higherPowers b i x)) \\<noteq> 0} \\<subseteq>\n    insert 0 (higherPowers b i -` {x. mp x \\<noteq> 0} \\<inter> {x. \\<forall>j\\<in>{b..<b+i}. lookup x j = 0})\"\n    (is \"?set \\<subseteq> ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n         else mp (higherPowers b i x)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> insert 0\n                 (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n                  {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})", "by auto"], ["proof (state)\nthis:\n  {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n       else mp (higherPowers b i x)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> insert 0\n               (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n                {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "also"], ["proof (state)\nthis:\n  {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n       else mp (higherPowers b i x)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> insert 0\n               (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n                {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "from finite_vimage_IntI[OF \\<open>finite _\\<close> inj_on_higherPowers, of b i]"], ["proof (chain)\npicking this:\n  finite\n   (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n    {x. \\<forall>j.\n           b \\<le> j \\<and> j < b + i \\<longrightarrow> lookup x j = 0})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite\n   (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n    {x. \\<forall>j.\n           b \\<le> j \\<and> j < b + i \\<longrightarrow> lookup x j = 0})\n\ngoal (1 subgoal):\n 1. finite\n     (insert 0\n       (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n        {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}))", "by (auto simp: Ball_def)"], ["proof (state)\nthis:\n  finite\n   (insert 0\n     (higherPowers b i -` {x. mp x \\<noteq> (0::'a)} \\<inter>\n      {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}))\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite\n        {x. (if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup x j\n             then 0::'a else fun (higherPowers nat1 nat2 x)) \\<noteq>\n            (0::'a)}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite\n   {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n        else mp (higherPowers b i x)) \\<noteq>\n       (0::'a)}", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite\n   {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n        else mp (higherPowers b i x)) \\<noteq>\n       (0::'a)}\n\ngoal (1 subgoal):\n 1. finite\n     {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n          else mp (higherPowers b i x)) \\<noteq>\n         (0::'a)}", "."], ["proof (state)\nthis:\n  finite\n   {x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n        else mp (higherPowers b i x)) \\<noteq>\n       (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes fmap.lifting begin"], ["", "lift_definition lowerPoly\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a::zero)fmap \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a)fmap\" is\n  \"\\<lambda>b i (mp::((nat\\<Rightarrow>\\<^sub>0nat)\\<rightharpoonup>'a)) mon::(nat\\<Rightarrow>\\<^sub>0nat). mp (lowerPowers b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "proof -\\<comment> \\<open>TODO: this is exactly the same proof as the one for \\<open>lowerPoly\\<^sub>0\\<close>\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "assume \"finite (dom mp)\""], ["proof (state)\nthis:\n  finite (dom mp)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  finite (dom mp)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "have \"dom mp = {x. mp x \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom mp = {x. mp x \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  dom mp = {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "finally"], ["proof (chain)\npicking this:\n  finite {x. mp x \\<noteq> None}", "have \"finite {x. mp x \\<noteq> None}\""], ["proof (prove)\nusing this:\n  finite {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. finite {x. mp x \\<noteq> None}", "."], ["proof (state)\nthis:\n  finite {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "have \"(dom (\\<lambda>mon. mp (lowerPowers b i mon))) = {mon. mp (lowerPowers b i mon) \\<noteq> None}\"\n    (is \"?set = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>mon. mp (lowerPowers b i mon)) =\n    {mon. mp (lowerPowers b i mon) \\<noteq> None}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  dom (\\<lambda>mon. mp (lowerPowers b i mon)) =\n  {mon. mp (lowerPowers b i mon) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>mon. mp (lowerPowers b i mon)) =\n  {mon. mp (lowerPowers b i mon) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "have \"\\<dots> = lowerPowers b i -` {x. mp x \\<noteq> None}\" (is \"_ = ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mon. mp (lowerPowers b i mon) \\<noteq> None} =\n    lowerPowers b i -` {x. mp x \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  {mon. mp (lowerPowers b i mon) \\<noteq> None} =\n  lowerPowers b i -` {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  {mon. mp (lowerPowers b i mon) \\<noteq> None} =\n  lowerPowers b i -` {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "from finite_vimageI[OF \\<open>finite {x. mp x \\<noteq> None}\\<close> inj_lowerPowers]"], ["proof (chain)\npicking this:\n  finite (lowerPowers ?b1 ?i1 -` {x. mp x \\<noteq> None})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite (lowerPowers ?b1 ?i1 -` {x. mp x \\<noteq> None})\n\ngoal (1 subgoal):\n 1. finite (lowerPowers b i -` {x. mp x \\<noteq> None})", "."], ["proof (state)\nthis:\n  finite (lowerPowers b i -` {x. mp x \\<noteq> None})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (lowerPowers nat1 nat2 mon)))", "finally"], ["proof (chain)\npicking this:\n  finite (dom (\\<lambda>mon. mp (lowerPowers b i mon)))", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite (dom (\\<lambda>mon. mp (lowerPowers b i mon)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>mon. mp (lowerPowers b i mon)))", "."], ["proof (state)\nthis:\n  finite (dom (\\<lambda>mon. mp (lowerPowers b i mon)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition higherPoly\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a::zero)fmap \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a)fmap\" is\n  \"\\<lambda>b i (mp::((nat\\<Rightarrow>\\<^sub>0nat)\\<rightharpoonup>'a)) mon::(nat\\<Rightarrow>\\<^sub>0nat).\n    if (\\<exists>j\\<in>{b..<b+i}. lookup mon j > 0)\n    then None\n    else mp (higherPowers b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<rightharpoonup> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "assume \"finite (dom mp)\""], ["proof (state)\nthis:\n  finite (dom mp)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "have \"dom (\\<lambda>x. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None else mp (higherPowers b i x))) \\<subseteq>\n    insert 0 (higherPowers b i -` (dom mp) \\<inter> {x. \\<forall>j\\<in>{b..<b+i}. lookup x j = 0})\"\n    (is \"?set \\<subseteq> ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n            else mp (higherPowers b i x))\n    \\<subseteq> insert 0\n                 (higherPowers b i -` dom mp \\<inter>\n                  {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  dom (\\<lambda>x.\n          if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n          else mp (higherPowers b i x))\n  \\<subseteq> insert 0\n               (higherPowers b i -` dom mp \\<inter>\n                {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>x.\n          if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n          else mp (higherPowers b i x))\n  \\<subseteq> insert 0\n               (higherPowers b i -` dom mp \\<inter>\n                {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "from finite_vimage_IntI[OF \\<open>finite _\\<close> inj_on_higherPowers, of b i]"], ["proof (chain)\npicking this:\n  finite\n   (higherPowers b i -` dom mp \\<inter>\n    {x. \\<forall>j.\n           b \\<le> j \\<and> j < b + i \\<longrightarrow> lookup x j = 0})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite\n   (higherPowers b i -` dom mp \\<inter>\n    {x. \\<forall>j.\n           b \\<le> j \\<and> j < b + i \\<longrightarrow> lookup x j = 0})\n\ngoal (1 subgoal):\n 1. finite\n     (insert 0\n       (higherPowers b i -` dom mp \\<inter>\n        {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}))", "by (auto simp: Ball_def)"], ["proof (state)\nthis:\n  finite\n   (insert 0\n     (higherPowers b i -` dom mp \\<inter>\n      {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}))\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite\n        (dom (\\<lambda>mon.\n                 if \\<exists>j\\<in>{nat1..<nat1 + nat2}. 0 < lookup mon j\n                 then None else fun (higherPowers nat1 nat2 mon)))", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite\n   (dom (\\<lambda>x.\n            if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n            else mp (higherPowers b i x)))", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite\n   (dom (\\<lambda>x.\n            if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n            else mp (higherPowers b i x)))\n\ngoal (1 subgoal):\n 1. finite\n     (dom (\\<lambda>x.\n              if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n              else mp (higherPowers b i x)))", "."], ["proof (state)\nthis:\n  finite\n   (dom (\\<lambda>x.\n            if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then None\n            else mp (higherPowers b i x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_lowerPowers: \"keys (lowerPowers b i m) = inc_above b i ` (keys m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lowerPowers b i m) = inc_above b i ` keys m", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (lowerPowers b i m) \\<Longrightarrow>\n       x \\<in> inc_above b i ` keys m\n 2. \\<And>x xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       inc_above b i xa \\<in> keys (lowerPowers b i m)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (lowerPowers b i m) \\<Longrightarrow>\n    x \\<in> inc_above b i ` keys m", "apply (rule image_eqI[where x=\"dec_above b i x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> keys (lowerPowers b i m) \\<Longrightarrow>\n    x = inc_above b i (dec_above b i x)\n 2. x \\<in> keys (lowerPowers b i m) \\<Longrightarrow>\n    dec_above b i x \\<in> keys m", "apply (auto simp: inc_above_dec_above in_keys_iff lowerPowers.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (if b \\<le> x \\<and> x < b + i then 0::'a\n     else lookup m (dec_above b i x)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    x = inc_above b i (dec_above b i x)\n 2. \\<lbrakk>(if b \\<le> x \\<and> x < b + i then 0::'a\n              else lookup m (dec_above b i x)) \\<noteq>\n             (0::'a);\n     lookup m (dec_above b i x) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis inc_above_dec_above not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if b \\<le> x \\<and> x < b + i then 0::'a\n              else lookup m (dec_above b i x)) \\<noteq>\n             (0::'a);\n     lookup m (dec_above b i x) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by meson"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       inc_above b i xa \\<in> keys (lowerPowers b i m)", "by (metis higherPowers.rep_eq higherPowers_lowerPowers in_keys_iff)"], ["", "lemma keys_higherPoly\\<^sub>0: \"keys (higherPoly\\<^sub>0 b i mp) = lowerPowers b i ` (keys mp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (higherPoly\\<^sub>0 b i mp) = lowerPowers b i ` keys mp", "apply (auto )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (higherPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n       x \\<in> lowerPowers b i ` keys mp\n 2. \\<And>xa.\n       xa \\<in> keys mp \\<Longrightarrow>\n       lowerPowers b i xa \\<in> keys (higherPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (higherPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x \\<in> lowerPowers b i ` keys mp", "apply (rule image_eqI[where x=\"higherPowers b i x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> keys (higherPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x = lowerPowers b i (higherPowers b i x)\n 2. x \\<in> keys (higherPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    higherPowers b i x \\<in> keys mp", "apply (auto simp: lowerPowers_higherPowers in_keys_iff higherPoly\\<^sub>0.rep_eq higherPowers.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n     else lookup mp (higherPowers b i x)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    x = lowerPowers b i (higherPowers b i x)\n 2. \\<lbrakk>(if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n              else lookup mp (higherPowers b i x)) \\<noteq>\n             (0::'a);\n     lookup mp (higherPowers b i x) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis atLeastLessThan_iff lowerPowers_higherPowers neq0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n              else lookup mp (higherPowers b i x)) \\<noteq>\n             (0::'a);\n     lookup mp (higherPowers b i x) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by meson"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys mp \\<Longrightarrow>\n       lowerPowers b i xa \\<in> keys (higherPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys mp \\<Longrightarrow>\n    lowerPowers b i x \\<in> keys (higherPoly\\<^sub>0 b i mp)", "apply (auto simp: in_keys_iff higherPoly\\<^sub>0.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>lookup mp x \\<noteq> (0::'a); b \\<le> j; j < b + i\\<rbrakk>\n       \\<Longrightarrow> lookup (lowerPowers b i x) j = 0\n 2. \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n     \\<forall>j\\<in>{b..<b + i}. lookup (lowerPowers b i x) j = 0;\n     lookup mp (higherPowers b i (lowerPowers b i x)) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: lowerPowers_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n     \\<forall>j\\<in>{b..<b + i}. lookup (lowerPowers b i x) j = 0;\n     lookup mp (higherPowers b i (lowerPowers b i x)) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: higherPowers_lowerPowers)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma inc_above_id[simp]: \"n < m \\<Longrightarrow> inc_above m i n = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < m \\<Longrightarrow> inc_above m i n = n", "by (auto simp: inc_above_def)"], ["", "lemma inc_above_Suc[simp]: \"n \\<ge> m \\<Longrightarrow> inc_above m i n = n + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> inc_above m i n = n + i", "by (auto simp: inc_above_def)"], ["", "lemma compute_lowerPoly\\<^sub>0[code]: \"lowerPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (lowerPoly\\<^sub>f n i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (lowerPoly\\<^sub>f n i m)", "by (auto simp: lowerPoly\\<^sub>0.rep_eq fmlookup_default_def lowerPoly\\<^sub>f.rep_eq\n      split: option.splits\n      intro!: poly_mapping_eqI)"], ["", "lemma compute_higherPoly\\<^sub>0[code]: \"higherPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (higherPoly\\<^sub>f n i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (higherPoly\\<^sub>f n i m)", "by (auto simp: higherPoly\\<^sub>0.rep_eq fmlookup_default_def higherPoly\\<^sub>f.rep_eq\n      split: option.splits\n      intro!: poly_mapping_eqI)"], ["", "lemma compute_lowerPoly\\<^sub>f[code]: \"lowerPoly\\<^sub>f n i (fmap_of_list xs) =\n  (fmap_of_list (map (\\<lambda>(mon, c). (higherPowers n i mon, c))\n    (filter (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n+i}. lookup mon j = 0) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPoly\\<^sub>f n i (fmap_of_list xs) =\n    fmap_of_list\n     (map (\\<lambda>(mon, c). (higherPowers n i mon, c))\n       (filter\n         (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n         xs))", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list\n     (map (\\<lambda>(mon, c). (higherPowers n i mon, c))\n       (filter\n         (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n         xs)) =\n    lowerPoly\\<^sub>f n i (fmap_of_list xs)", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup\n        (fmap_of_list\n          (map (\\<lambda>(mon, c). (higherPowers n i mon, c))\n            (filter\n              (\\<lambda>(mon, v).\n                  \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n              xs)))\n        x =\n       fmlookup (lowerPoly\\<^sub>f n i (fmap_of_list xs)) x", "unfolding lowerPoly\\<^sub>f.rep_eq fmlookup_of_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of\n        (map (\\<lambda>(mon, y). (higherPowers n i mon, y))\n          (filter\n            (\\<lambda>(mon, v).\n                \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n            xs))\n        x =\n       map_of xs (lowerPowers n i x)", "apply (subst map_of_map_key_inverse_fun_eq[where g=\"lowerPowers n i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set (filter\n                      (\\<lambda>(mon, v).\n                          \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n                      xs) \\<Longrightarrow>\n       lowerPowers n i (higherPowers n i (fst xa)) = fst xa\n 2. \\<And>x. higherPowers n i (lowerPowers n i x) = x\n 3. \\<And>x.\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          xs)\n        (lowerPowers n i x) =\n       map_of xs (lowerPowers n i x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xa_\n    \\<in> set (filter\n                (\\<lambda>(mon, v).\n                    \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n                xs) \\<Longrightarrow>\n    lowerPowers n i (higherPowers n i (fst xa_)) = fst xa_", "by (auto simp add: lowerPowers_higherPowers)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. higherPowers n i (lowerPowers n i x) = x\n 2. \\<And>x.\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          xs)\n        (lowerPowers n i x) =\n       map_of xs (lowerPowers n i x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers n i (lowerPowers n i x_) = x_", "by (auto simp add: higherPowers_lowerPowers)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          xs)\n        (lowerPowers n i x) =\n       map_of xs (lowerPowers n i x)", "apply (auto simp: fmlookup_of_list lowerPoly\\<^sub>f.rep_eq map_of_eq_None_iff map_of_filter_key_in\n      fmdom'_fmap_of_list higherPowers.rep_eq lowerPowers.rep_eq dec_above_def\n      intro!: fmap_ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_higherPoly\\<^sub>f[code]: \"higherPoly\\<^sub>f n i (fmap_of_list xs) =\n  fmap_of_list (filter (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n+i}. lookup mon j = 0)\n    (map (\\<lambda>(mon, c). (lowerPowers n i mon, c)) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>f n i (fmap_of_list xs) =\n    fmap_of_list\n     (filter\n       (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n       (map (\\<lambda>(mon, c). (lowerPowers n i mon, c)) xs))", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list\n     (filter\n       (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n       (map (\\<lambda>(mon, c). (lowerPowers n i mon, c)) xs)) =\n    higherPoly\\<^sub>f n i (fmap_of_list xs)", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup\n        (fmap_of_list\n          (filter\n            (\\<lambda>(mon, v).\n                \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n            (map (\\<lambda>(mon, c). (lowerPowers n i mon, c)) xs)))\n        x =\n       fmlookup (higherPoly\\<^sub>f n i (fmap_of_list xs)) x", "unfolding higherPoly\\<^sub>f.rep_eq fmlookup_of_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs))\n        x =\n       (if \\<exists>j\\<in>{n..<n + i}. 0 < lookup x j then None\n        else map_of xs (higherPowers n i x))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x j.\n       \\<lbrakk>0 < lookup x j; n \\<le> j; j < n + i\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (filter\n                            (\\<lambda>(mon, v).\n                                \\<forall>j\\<in>{n..<n + i}.\n                                   lookup mon j = 0)\n                            (map (\\<lambda>(mon, y).\n                                     (lowerPowers n i mon, y))\n                              xs))\n                          x =\n                         None\n 2. \\<And>x.\n       \\<forall>j\\<in>{n..<n + i}. lookup x j = 0 \\<Longrightarrow>\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs))\n        x =\n       map_of xs (higherPowers n i x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < lookup x_ j_; n \\<le> j_; j_ < n + i\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>(mon, v).\n                             \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n                         (map (\\<lambda>(mon, y). (lowerPowers n i mon, y))\n                           xs))\n                       x_ =\n                      None", "by (rule map_of_eq_NoneI) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>j\\<in>{n..<n + i}. lookup x j = 0 \\<Longrightarrow>\n       map_of\n        (filter\n          (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n          (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs))\n        x =\n       map_of xs (higherPowers n i x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of\n     (filter\n       (\\<lambda>(mon, v). \\<forall>j\\<in>{n..<n + i}. lookup mon j = 0)\n       (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs))\n     x_ =\n    map_of xs (higherPowers n i x_)", "apply (subst map_of_filter_key_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0\n 2. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs) x_ =\n    map_of xs (higherPowers n i x_)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of (map (\\<lambda>(mon, y). (lowerPowers n i mon, y)) xs) x_ =\n    map_of xs (higherPowers n i x_)", "apply (subst map_of_map_key_inverse_fun_eq[where g=\"higherPowers n i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> higherPowers n i (lowerPowers n i (fst xa)) =\n                         fst xa\n 2. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    lowerPowers n i (higherPowers n i x_) = x_\n 3. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of xs (higherPowers n i x_) = map_of xs (higherPowers n i x_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0;\n     xa_ \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> higherPowers n i (lowerPowers n i (fst xa_)) = fst xa_", "by (auto simp add: higherPowers_lowerPowers)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    lowerPowers n i (higherPowers n i x_) = x_\n 2. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of xs (higherPowers n i x_) = map_of xs (higherPowers n i x_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    lowerPowers n i (higherPowers n i x_) = x_", "by (auto simp add: lowerPowers_higherPowers)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>{n..<n + i}. lookup x_ j = 0 \\<Longrightarrow>\n    map_of xs (higherPowers n i x_) = map_of xs (higherPowers n i x_)", "apply (auto simp: fmlookup_of_list lowerPoly\\<^sub>f.rep_eq map_of_eq_None_iff map_of_filter_key_in\n        fmdom'_fmap_of_list higherPowers.rep_eq lowerPowers.rep_eq dec_above_def\n        intro!: fmap_ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lift_definition lowerPoly::\"nat \\<Rightarrow> nat \\<Rightarrow> 'a::zero mpoly \\<Rightarrow> 'a mpoly\" is lowerPoly\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition liftPoly::\"nat \\<Rightarrow> nat \\<Rightarrow> 'a::zero mpoly \\<Rightarrow> 'a mpoly\" is higherPoly\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma coeff_lowerPoly: \"MPoly_Type.coeff (lowerPoly b i mp) x = MPoly_Type.coeff mp (lowerPowers b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (lowerPoly b i mp) x =\n    MPoly_Type.coeff mp (lowerPowers b i x)", "by (transfer') (simp add: lowerPoly\\<^sub>0.rep_eq lowerPowers.rep_eq)"], ["", "lemma coeff_liftPoly: \"MPoly_Type.coeff (liftPoly b i mp) x = (if (\\<exists>j\\<in>{b..<b+i}. lookup x j > 0)\n    then 0\n    else MPoly_Type.coeff mp (higherPowers b i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly b i mp) x =\n    (if \\<exists>j\\<in>{b..<b + i}. 0 < lookup x j then 0::'a\n     else MPoly_Type.coeff mp (higherPowers b i x))", "by (transfer') (simp add: higherPowers.rep_eq higherPoly\\<^sub>0.rep_eq )"], ["", "lemma monomials_lowerPoly: \"monomials (lowerPoly b i mp) = higherPowers b i ` (monomials mp \\<inter> {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0}) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (lowerPoly b i mp) =\n    higherPowers b i `\n    (monomials mp \\<inter> {x. \\<forall>j\\<in>{b..<b + i}. lookup x j = 0})", "by transfer' (simp add: keys_lowerPoly\\<^sub>0)"], ["", "lemma monomials_liftPoly: \"monomials (liftPoly b i mp) = lowerPowers b i ` (monomials mp) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (liftPoly b i mp) = lowerPowers b i ` monomials mp", "using keys_higherPoly\\<^sub>0"], ["proof (prove)\nusing this:\n  keys (higherPoly\\<^sub>0 ?b ?i ?mp) = lowerPowers ?b ?i ` keys ?mp\n\ngoal (1 subgoal):\n 1. monomials (liftPoly b i mp) = lowerPowers b i ` monomials mp", "by (simp add: keys_higherPoly\\<^sub>0 liftPoly.rep_eq monomials.rep_eq)"], ["", "value [code] \"lowerPoly 1 1 (1 * Var 0 + 2 * Var 2 ^ 2 + 3 * Var 3 ^ 4::int mpoly) = (Var 0 + 2 * Var 1^2 + 3 * Var 2^4::int mpoly)\""], ["", "value [code] \"lowerPoly 1 3 (1 * Var 0 + 2 * Var 4 ^ 2 + 3 * Var 5 ^ 4::int mpoly) = (Var 0 + 2 * Var 1^2 + 3 * Var 2^4::int mpoly)\""], ["", "value [code] \"liftPoly 1 3 (1 * Var 0 + 2 * Var 4 ^ 2 + 3 * Var 5 ^ 4::int mpoly) = (Var 0 + 2 * Var 7^2 + 3 * Var 8^4::int mpoly)\""], ["", "fun lowerAtom :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom \\<Rightarrow> atom\" where\n  \"lowerAtom d amount (Eq p) = Eq(lowerPoly d amount p)\"|\n  \"lowerAtom d amount (Less p) = Less(lowerPoly d amount p)\"|\n  \"lowerAtom d amount (Leq p) = Leq(lowerPoly d amount p)\"|\n  \"lowerAtom d amount (Neq p) = Neq(lowerPoly d amount p)\""], ["", "lemma lookup_not_in_vars_eq_zero: \"x \\<in> monomials p \\<Longrightarrow> i \\<notin> vars p \\<Longrightarrow> lookup x i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> monomials p; i \\<notin> vars p\\<rbrakk>\n    \\<Longrightarrow> lookup x i = 0", "by (meson degree_eq_iff varNotIn_degree)"], ["", "lemma nth_dec_above:\n  assumes \"length xs = i\" \"length ys = j\" \"k \\<notin> {i..<i+j}\"\n  shows \"nth_default 0 (xs @ zs) (dec_above i j k) = (nth_default 0 (xs @ ys @ zs)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (xs @ zs) (dec_above i j k) =\n    nth_default (0::'a) (xs @ ys @ zs) k", "using assms dec_above_def nth_append add.commute"], ["proof (prove)\nusing this:\n  length xs = i\n  length ys = j\n  k \\<notin> {i..<i + j}\n  dec_above ?b ?i ?x = (if ?x \\<le> ?b then ?x else ?x - ?i)\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (xs @ zs) (dec_above i j k) =\n    nth_default (0::'a) (xs @ ys @ zs) k", "by (smt add_diff_cancel_left add_le_cancel_left add_strict_increasing append_Nil2 atLeastLessThan_iff le_add_diff_inverse length_append length_greater_0_conv less_imp_le_nat not_less nth_default_append)"], ["", "lemma insertion_lowerPoly:\n  assumes i_notin: \"vars p \\<inter> {i..<i+j} = {}\"\n    and lprfx: \"length prfx = i\"\n    and lxs: \"length xs = j\"\n  shows \"insertion (nth_default 0 (prfx@L)) (lowerPoly i j p) = insertion (nth_default 0 (prfx@xs@L)) p\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "have *: \"monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} = monomials p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} =\n    monomials p", "using assms(1)"], ["proof (prove)\nusing this:\n  vars p \\<inter> {i..<i + j} = {}\n\ngoal (1 subgoal):\n 1. monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} =\n    monomials p", "by (auto intro: lookup_not_in_vars_eq_zero)"], ["proof (state)\nthis:\n  monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} =\n  monomials p\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "then"], ["proof (chain)\npicking this:\n  monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} =\n  monomials p", "have \"monomials p \\<subseteq> {x. \\<forall>k. i \\<le> k \\<and> k < i + j \\<longrightarrow> lookup x k = 0}\""], ["proof (prove)\nusing this:\n  monomials p \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0} =\n  monomials p\n\ngoal (1 subgoal):\n 1. monomials p\n    \\<subseteq> {x. \\<forall>k.\n                       i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                       lookup x k = 0}", "by force"], ["proof (state)\nthis:\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "have \"?lhs = (\\<Sum>m\\<in>monomials (lowerPoly i j p). MPoly_Type.coeff (lowerPoly i j p) m * (\\<Prod>k\\<in>keys m. (nth_default 0 (prfx @ L)) k ^ lookup m k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n       MPoly_Type.coeff (lowerPoly i j p) m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k))", "unfolding insertion_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n       MPoly_Type.coeff (lowerPoly i j p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (prfx @ L) k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n       MPoly_Type.coeff (lowerPoly i j p) m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k))", ".."], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n     MPoly_Type.coeff (lowerPoly i j p) m *\n     (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "also"], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n     MPoly_Type.coeff (lowerPoly i j p) m *\n     (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "have \"\\<dots> = (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m * (\\<Prod>k\\<in>keys m. (nth_default 0 (prfx @ xs @ L) k) ^ lookup m k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n       MPoly_Type.coeff (lowerPoly i j p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (prfx @ L) k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))", "proof (rule sum.reindex_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?l (monomials p)\n 2. monomials (lowerPoly i j p) = ?l ` monomials p\n 3. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (?l x) *\n       (\\<Prod>k\\<in>keys (?l x).\n          nth_default (0::'a) (prfx @ L) k ^ lookup (?l x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "note inj_on_higherPowers[of i j]"], ["proof (state)\nthis:\n  inj_on (higherPowers i j)\n   {x. \\<forall>ja.\n          i \\<le> ja \\<and> ja < i + j \\<longrightarrow>\n          lookup x ja = (0::?'a)}\n\ngoal (3 subgoals):\n 1. inj_on ?l (monomials p)\n 2. monomials (lowerPoly i j p) = ?l ` monomials p\n 3. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (?l x) *\n       (\\<Prod>k\\<in>keys (?l x).\n          nth_default (0::'a) (prfx @ L) k ^ lookup (?l x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "moreover"], ["proof (state)\nthis:\n  inj_on (higherPowers i j)\n   {x. \\<forall>ja.\n          i \\<le> ja \\<and> ja < i + j \\<longrightarrow>\n          lookup x ja = (0::?'a)}\n\ngoal (3 subgoals):\n 1. inj_on ?l (monomials p)\n 2. monomials (lowerPoly i j p) = ?l ` monomials p\n 3. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (?l x) *\n       (\\<Prod>k\\<in>keys (?l x).\n          nth_default (0::'a) (prfx @ L) k ^ lookup (?l x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "note \\<open>monomials p \\<subseteq> _\\<close>"], ["proof (state)\nthis:\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}\n\ngoal (3 subgoals):\n 1. inj_on ?l (monomials p)\n 2. monomials (lowerPoly i j p) = ?l ` monomials p\n 3. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (?l x) *\n       (\\<Prod>k\\<in>keys (?l x).\n          nth_default (0::'a) (prfx @ L) k ^ lookup (?l x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on (higherPowers i j)\n   {x. \\<forall>ja.\n          i \\<le> ja \\<and> ja < i + j \\<longrightarrow>\n          lookup x ja = (0::?'a)}\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}", "show \"inj_on (higherPowers i j) (monomials p)\""], ["proof (prove)\nusing this:\n  inj_on (higherPowers i j)\n   {x. \\<forall>ja.\n          i \\<le> ja \\<and> ja < i + j \\<longrightarrow>\n          lookup x ja = (0::?'a)}\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}\n\ngoal (1 subgoal):\n 1. inj_on (higherPowers i j) (monomials p)", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on (higherPowers i j) (monomials p)\n\ngoal (2 subgoals):\n 1. monomials (lowerPoly i j p) = higherPowers i j ` monomials p\n 2. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. monomials (lowerPoly i j p) = higherPowers i j ` monomials p\n 2. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "show \"monomials (lowerPoly i j p) = higherPowers i j ` monomials p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (lowerPoly i j p) = higherPowers i j ` monomials p", "unfolding monomials_lowerPoly *"], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers i j ` monomials p = higherPowers i j ` monomials p", ".."], ["proof (state)\nthis:\n  monomials (lowerPoly i j p) = higherPowers i j ` monomials p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "assume m: \"m \\<in> monomials p\""], ["proof (state)\nthis:\n  m \\<in> monomials p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "from m \\<open>monomials p \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> monomials p\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}", "have \"keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\""], ["proof (prove)\nusing this:\n  m \\<in> monomials p\n  monomials p\n  \\<subseteq> {x. \\<forall>k.\n                     i \\<le> k \\<and> k < i + j \\<longrightarrow>\n                     lookup x k = 0}\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}", "by auto"], ["proof (state)\nthis:\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "then"], ["proof (chain)\npicking this:\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}", "have \"lookup m k = 0\" if \"i \\<le> k\" \"k < i + j\" for k"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n\ngoal (1 subgoal):\n 1. lookup m k = 0", "using that"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n  i \\<le> k\n  k < i + j\n\ngoal (1 subgoal):\n 1. lookup m k = 0", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?k; ?k < i + j\\<rbrakk> \\<Longrightarrow> lookup m ?k = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> ?k; ?k < i + j\\<rbrakk> \\<Longrightarrow> lookup m ?k = 0", "have \"lowerPowers i j (higherPowers i j m) = m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> ?k; ?k < i + j\\<rbrakk> \\<Longrightarrow> lookup m ?k = 0\n\ngoal (1 subgoal):\n 1. lowerPowers i j (higherPowers i j m) = m", "by (rule lowerPowers_higherPowers)"], ["proof (state)\nthis:\n  lowerPowers i j (higherPowers i j m) = m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "then"], ["proof (chain)\npicking this:\n  lowerPowers i j (higherPowers i j m) = m", "have \"MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) = MPoly_Type.coeff p m\""], ["proof (prove)\nusing this:\n  lowerPowers i j (higherPowers i j m) = m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) =\n    MPoly_Type.coeff p m", "unfolding coeff_lowerPoly"], ["proof (prove)\nusing this:\n  lowerPowers i j (higherPowers i j m) = m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p (lowerPowers i j (higherPowers i j m)) =\n    MPoly_Type.coeff p m", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) =\n  MPoly_Type.coeff p m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) =\n  MPoly_Type.coeff p m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "have \"(\\<Prod>k\\<in>keys (higherPowers i j m). (nth_default 0 (prfx @ L)) k ^ lookup (higherPowers i j m) k) = \n      (\\<Prod>k\\<in>keys m. (nth_default 0 (prfx @ xs @ L)) k ^ lookup m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k\\<in>keys (higherPowers i j m).\n       nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n    (\\<Prod>k\\<in>keys m.\n       nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)", "proof (rule prod.reindex_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?l (keys m)\n 2. keys (higherPowers i j m) = ?l ` keys m\n 3. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (?l x) ^\n       lookup (higherPowers i j m) (?l x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "show \"keys (higherPowers i j m) = dec_above i j ` keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (higherPowers i j m) = dec_above i j ` keys m", "unfolding keys_higherPowers"], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_above i j ` (keys m \\<inter> {x. x \\<notin> {i..<i + j}}) =\n    dec_above i j ` keys m", "using \\<open>keys m \\<subseteq> _\\<close>"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n\ngoal (1 subgoal):\n 1. dec_above i j ` (keys m \\<inter> {x. x \\<notin> {i..<i + j}}) =\n    dec_above i j ` keys m", "by auto"], ["proof (state)\nthis:\n  keys (higherPowers i j m) = dec_above i j ` keys m\n\ngoal (2 subgoals):\n 1. inj_on (dec_above i j) (keys m)\n 2. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (dec_above i j) (keys m)\n 2. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "from inj_on_dec_above[of i j]"], ["proof (chain)\npicking this:\n  inj_on (dec_above i j) {x. x < i \\<or> i + j \\<le> x}", "show \"inj_on (dec_above i j) (keys m)\""], ["proof (prove)\nusing this:\n  inj_on (dec_above i j) {x. x < i \\<or> i + j \\<le> x}\n\ngoal (1 subgoal):\n 1. inj_on (dec_above i j) (keys m)", "by (rule inj_on_subset) (use \\<open>keys m \\<subseteq> _\\<close> in auto)"], ["proof (state)\nthis:\n  inj_on (dec_above i j) (keys m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "assume k: \"k \\<in> keys m\""], ["proof (state)\nthis:\n  k \\<in> keys m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "from k \\<open>keys m \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> keys m\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}", "have \"k \\<notin> {i..<i+j}\""], ["proof (prove)\nusing this:\n  k \\<in> keys m\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n\ngoal (1 subgoal):\n 1. k \\<notin> {i..<i + j}", "by auto"], ["proof (state)\nthis:\n  k \\<notin> {i..<i + j}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "from k \\<open>keys m \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> keys m\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}", "have \"inc_above i j (dec_above i j k) = k\""], ["proof (prove)\nusing this:\n  k \\<in> keys m\n  keys m \\<subseteq> {x. x \\<notin> {i..<i + j}}\n\ngoal (1 subgoal):\n 1. inc_above i j (dec_above i j k) = k", "by (subst inc_above_dec_above) auto"], ["proof (state)\nthis:\n  inc_above i j (dec_above i j k) = k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "then"], ["proof (chain)\npicking this:\n  inc_above i j (dec_above i j k) = k", "have \"lookup (higherPowers i j m) (dec_above i j k) = lookup m k\""], ["proof (prove)\nusing this:\n  inc_above i j (dec_above i j k) = k\n\ngoal (1 subgoal):\n 1. lookup (higherPowers i j m) (dec_above i j k) = lookup m k", "unfolding higherPowers.rep_eq"], ["proof (prove)\nusing this:\n  inc_above i j (dec_above i j k) = k\n\ngoal (1 subgoal):\n 1. lookup m (inc_above i j (dec_above i j k)) = lookup m k", "by simp"], ["proof (state)\nthis:\n  lookup (higherPowers i j m) (dec_above i j k) = lookup m k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "moreover"], ["proof (state)\nthis:\n  lookup (higherPowers i j m) (dec_above i j k) = lookup m k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "have \"nth_default 0 (prfx @ L) (dec_above i j k) = (nth_default 0 (prfx @ xs @ L)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (prfx @ L) (dec_above i j k) =\n    nth_default (0::'a) (prfx @ xs @ L) k", "apply (rule nth_dec_above)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length prfx = i\n 2. length xs = j\n 3. k \\<notin> {i..<i + j}", "using assms \\<open>k \\<notin> _\\<close>"], ["proof (prove)\nusing this:\n  vars p \\<inter> {i..<i + j} = {}\n  length prfx = i\n  length xs = j\n  k \\<notin> {i..<i + j}\n\ngoal (3 subgoals):\n 1. length prfx = i\n 2. length xs = j\n 3. k \\<notin> {i..<i + j}", "by auto"], ["proof (state)\nthis:\n  nth_default (0::'a) (prfx @ L) (dec_above i j k) =\n  nth_default (0::'a) (prfx @ xs @ L) k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys m \\<Longrightarrow>\n       nth_default (0::'a) (prfx @ L) (dec_above i j x) ^\n       lookup (higherPowers i j m) (dec_above i j x) =\n       nth_default (0::'a) (prfx @ xs @ L) x ^ lookup m x", "ultimately"], ["proof (chain)\npicking this:\n  lookup (higherPowers i j m) (dec_above i j k) = lookup m k\n  nth_default (0::'a) (prfx @ L) (dec_above i j k) =\n  nth_default (0::'a) (prfx @ xs @ L) k", "show \"((nth_default 0 (prfx @ L)) (dec_above i j k)) ^ lookup (higherPowers i j m) (dec_above i j k) = ((nth_default 0 (prfx @ xs @ L)) k) ^ lookup m k\""], ["proof (prove)\nusing this:\n  lookup (higherPowers i j m) (dec_above i j k) = lookup m k\n  nth_default (0::'a) (prfx @ L) (dec_above i j k) =\n  nth_default (0::'a) (prfx @ xs @ L) k\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (prfx @ L) (dec_above i j k) ^\n    lookup (higherPowers i j m) (dec_above i j k) =\n    nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k", "by simp"], ["proof (state)\nthis:\n  nth_default (0::'a) (prfx @ L) (dec_above i j k) ^\n  lookup (higherPowers i j m) (dec_above i j k) =\n  nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>k\\<in>keys (higherPowers i j m).\n     nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n  (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> monomials p \\<Longrightarrow>\n       MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j x) *\n       (\\<Prod>k\\<in>keys (higherPowers i j x).\n          nth_default (0::'a) (prfx @ L) k ^\n          lookup (higherPowers i j x) k) =\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys x.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup x k)", "ultimately"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) =\n  MPoly_Type.coeff p m\n  (\\<Prod>k\\<in>keys (higherPowers i j m).\n     nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n  (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)", "show \"MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) * (\\<Prod>k\\<in>keys (higherPowers i j m). (nth_default 0(prfx @ L)) k ^ lookup (higherPowers i j m) k) =\n          MPoly_Type.coeff p m * (\\<Prod>k\\<in>keys m. (nth_default 0 (prfx @ xs @ L)) k ^ lookup m k)\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) =\n  MPoly_Type.coeff p m\n  (\\<Prod>k\\<in>keys (higherPowers i j m).\n     nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n  (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) *\n    (\\<Prod>k\\<in>keys (higherPowers i j m).\n       nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n    MPoly_Type.coeff p m *\n    (\\<Prod>k\\<in>keys m.\n       nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (lowerPoly i j p) (higherPowers i j m) *\n  (\\<Prod>k\\<in>keys (higherPowers i j m).\n     nth_default (0::'a) (prfx @ L) k ^ lookup (higherPowers i j m) k) =\n  MPoly_Type.coeff p m *\n  (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n     MPoly_Type.coeff (lowerPoly i j p) m *\n     (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials p.\n     MPoly_Type.coeff p m *\n     (\\<Prod>k\\<in>keys m.\n        nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "finally"], ["proof (chain)\npicking this:\n  insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n  (\\<Sum>m\\<in>monomials p.\n     MPoly_Type.coeff p m *\n     (\\<Prod>k\\<in>keys m.\n        nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n  (\\<Sum>m\\<in>monomials p.\n     MPoly_Type.coeff p m *\n     (\\<Prod>k\\<in>keys m.\n        nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n    insertion (nth_default (0::'a) (prfx @ xs @ L)) p", "unfolding insertion_code"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n     MPoly_Type.coeff (lowerPoly i j p) m *\n     (\\<Prod>k\\<in>keys m. nth_default (0::'a) (prfx @ L) k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials p.\n     MPoly_Type.coeff p m *\n     (\\<Prod>k\\<in>keys m.\n        nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (lowerPoly i j p).\n       MPoly_Type.coeff (lowerPoly i j p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (prfx @ L) k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (prfx @ xs @ L) k ^ lookup m k))", "."], ["proof (state)\nthis:\n  insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i j p) =\n  insertion (nth_default (0::'a) (prfx @ xs @ L)) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_lowerPoly1:\n  assumes i_notin: \"i \\<notin> vars p\"\n    and lprfx: \"length prfx = i\"\n  shows \"insertion (nth_default 0 (prfx@x#L)) p = insertion (nth_default 0 (prfx@L)) (lowerPoly i 1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ x # L)) p =\n    insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i 1 p)", "using assms nth_default_def"], ["proof (prove)\nusing this:\n  i \\<notin> vars p\n  length prfx = i\n  nth_default ?dflt ?xs ?n = (if ?n < length ?xs then ?xs ! ?n else ?dflt)\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (prfx @ x # L)) p =\n    insertion (nth_default (0::'a) (prfx @ L)) (lowerPoly i 1 p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> vars p; length prfx = i;\n     \\<And>dflt xs n.\n        nth_default dflt xs n =\n        (if n < length xs then xs ! n else dflt)\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default (0::'a) (prfx @ x # L)) p =\n                      insertion (nth_default (0::'a) (prfx @ L))\n                       (lowerPoly i (Suc 0) p)", "by (subst insertion_lowerPoly[where xs=\"[x]\"]) auto"], ["", "lemma insertion_lowerPoly01:\n  assumes i_notin: \"0 \\<notin> vars p\"\n  shows \"insertion (nth_default 0 (x#L)) p = insertion (nth_default 0 L) (lowerPoly 0 1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (x # L)) p =\n    insertion (nth_default (0::'a) L) (lowerPoly 0 1 p)", "using insertion_lowerPoly1[OF assms, of Nil x L]"], ["proof (prove)\nusing this:\n  length [] = 0 \\<Longrightarrow>\n  insertion (nth_default (0::'a) ([] @ x # L)) p =\n  insertion (nth_default (0::'a) ([] @ L)) (lowerPoly 0 1 p)\n\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) (x # L)) p =\n    insertion (nth_default (0::'a) L) (lowerPoly 0 1 p)", "by simp"], ["", "lemma aEval_lowerAtom : \"(freeIn 0 (Atom A)) \\<Longrightarrow> (aEval A (x#L) = aEval (lowerAtom 0 1 A) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 (fm.Atom A) \\<Longrightarrow>\n    aEval A (x # L) = aEval (lowerAtom 0 1 A) L", "by (cases A) (simp_all add:insertion_lowerPoly01)"], ["", "fun map_fm_binders :: \"(atom \\<Rightarrow> nat \\<Rightarrow> atom) \\<Rightarrow> atom fm \\<Rightarrow> nat \\<Rightarrow> atom fm\" where\n  \"map_fm_binders f TrueF n = TrueF\"|\n  \"map_fm_binders f FalseF n = FalseF\"|\n  \"map_fm_binders f (Atom \\<phi>) n = Atom (f \\<phi> n)\"|\n  \"map_fm_binders f (And \\<phi> \\<psi>) n = And (map_fm_binders f \\<phi> n) (map_fm_binders f \\<psi> n)\"|\n  \"map_fm_binders f (Or \\<phi> \\<psi>) n = Or (map_fm_binders f \\<phi> n) (map_fm_binders f \\<psi> n)\"|\n  \"map_fm_binders f (ExQ \\<phi>) n = ExQ(map_fm_binders f \\<phi> (n+1))\"|\n  \"map_fm_binders f (AllQ \\<phi>) n = AllQ(map_fm_binders f \\<phi> (n+1))\"|\n  \"map_fm_binders f (AllN i \\<phi>) n = AllN i (map_fm_binders f \\<phi> (n+i))\"|\n  \"map_fm_binders f (ExN i \\<phi>) n = ExN i (map_fm_binders f \\<phi> (n+i))\"|\n  \"map_fm_binders f (Neg \\<phi>) n = Neg(map_fm_binders f \\<phi> n)\""], ["", "fun lowerFm :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom fm \\<Rightarrow> atom fm\" where\n  \"lowerFm d amount f = map_fm_binders (\\<lambda>a. \\<lambda>x. lowerAtom (d+x) amount a) f 0\""], ["", "fun delete_nth :: \"nat \\<Rightarrow> real list \\<Rightarrow> real list\" where\n  \"delete_nth n xs = take n xs @ drop n xs\""], ["", "lemma eval_lowerFm_helper :\n  assumes \"freeIn i F\"\n  assumes \"length init = i\"\n  shows \"eval (lowerFm i 1 F) (init @xs) = eval F (init@[x]@xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 F) (init @ xs) = eval F (init @ [x] @ xs)", "using assms"], ["proof (prove)\nusing this:\n  freeIn i F\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 F) (init @ xs) = eval F (init @ [x] @ xs)", "proof(induction F arbitrary : i init)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>i init.\n       \\<lbrakk>freeIn i TrueF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 TrueF) (init @ xs) =\n                         eval TrueF (init @ [x] @ xs)\n 2. \\<And>i init.\n       \\<lbrakk>freeIn i FalseF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 FalseF) (init @ xs) =\n                         eval FalseF (init @ [x] @ xs)\n 3. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 5. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 8. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 10. \\<And>x1 F i init.\n        \\<lbrakk>\\<And>i init.\n                    \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                    \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\neval F (init @ [x] @ xs);\n         freeIn i (AllN x1 F); length init = i\\<rbrakk>\n        \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                          eval (AllN x1 F) (init @ [x] @ xs)", "case TrueF"], ["proof (state)\nthis:\n  freeIn i TrueF\n  length init = i\n\ngoal (10 subgoals):\n 1. \\<And>i init.\n       \\<lbrakk>freeIn i TrueF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 TrueF) (init @ xs) =\n                         eval TrueF (init @ [x] @ xs)\n 2. \\<And>i init.\n       \\<lbrakk>freeIn i FalseF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 FalseF) (init @ xs) =\n                         eval FalseF (init @ [x] @ xs)\n 3. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 5. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 8. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 10. \\<And>x1 F i init.\n        \\<lbrakk>\\<And>i init.\n                    \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                    \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\neval F (init @ [x] @ xs);\n         freeIn i (AllN x1 F); length init = i\\<rbrakk>\n        \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                          eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  freeIn i TrueF\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  freeIn i TrueF\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 TrueF) (init @ xs) = eval TrueF (init @ [x] @ xs)", "by simp"], ["proof (state)\nthis:\n  eval (lowerFm i 1 TrueF) (init @ xs) = eval TrueF (init @ [x] @ xs)\n\ngoal (9 subgoals):\n 1. \\<And>i init.\n       \\<lbrakk>freeIn i FalseF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 FalseF) (init @ xs) =\n                         eval FalseF (init @ [x] @ xs)\n 2. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i init.\n       \\<lbrakk>freeIn i FalseF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 FalseF) (init @ xs) =\n                         eval FalseF (init @ [x] @ xs)\n 2. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case FalseF"], ["proof (state)\nthis:\n  freeIn i FalseF\n  length init = i\n\ngoal (9 subgoals):\n 1. \\<And>i init.\n       \\<lbrakk>freeIn i FalseF; length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 FalseF) (init @ xs) =\n                         eval FalseF (init @ [x] @ xs)\n 2. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  freeIn i FalseF\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  freeIn i FalseF\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 FalseF) (init @ xs) = eval FalseF (init @ [x] @ xs)", "by simp"], ["proof (state)\nthis:\n  eval (lowerFm i 1 FalseF) (init @ xs) = eval FalseF (init @ [x] @ xs)\n\ngoal (8 subgoals):\n 1. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (Atom A)"], ["proof (state)\nthis:\n  freeIn i (fm.Atom A)\n  length init = i\n\ngoal (8 subgoals):\n 1. \\<And>xa i init.\n       \\<lbrakk>freeIn i (fm.Atom xa); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom xa)) (init @ xs) =\n                         eval (fm.Atom xa) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  freeIn i (fm.Atom A)\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  freeIn i (fm.Atom A)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n    eval (fm.Atom A) (init @ [x] @ xs)", "apply(cases A)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>freeIn i (fm.Atom A); length init = i; A = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n                         eval (fm.Atom A) (init @ [x] @ xs)\n 2. \\<And>x2.\n       \\<lbrakk>freeIn i (fm.Atom A); length init = i; A = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n                         eval (fm.Atom A) (init @ [x] @ xs)\n 3. \\<And>x3.\n       \\<lbrakk>freeIn i (fm.Atom A); length init = i; A = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n                         eval (fm.Atom A) (init @ [x] @ xs)\n 4. \\<And>x4.\n       \\<lbrakk>freeIn i (fm.Atom A); length init = i; A = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n                         eval (fm.Atom A) (init @ [x] @ xs)", "by (simp_all add: insertion_lowerPoly1)"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (fm.Atom A)) (init @ xs) =\n  eval (fm.Atom A) (init @ [x] @ xs)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (And F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (And F1 F2)\n  length init = i\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (And F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n                         eval (And F1 F2) (init @ [x] @ xs)\n 2. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (And F1 F2)\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (And F1 F2)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n    eval (And F1 F2) (init @ [x] @ xs)", "by auto"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (And F1 F2)) (init @ xs) =\n  eval (And F1 F2) (init @ [x] @ xs)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (Or F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (Or F1 F2)\n  length init = i\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F1; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F1) (init @ xs) =\n                                     eval F1 (init @ [x] @ xs);\n        \\<And>i init.\n           \\<lbrakk>freeIn i F2; length init = i\\<rbrakk>\n           \\<Longrightarrow> eval (lowerFm i 1 F2) (init @ xs) =\n                             eval F2 (init @ [x] @ xs);\n        freeIn i (Or F1 F2); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n                         eval (Or F1 F2) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 4. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (Or F1 F2)\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>freeIn ?i F1; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F1) (?init @ xs) =\n                    eval F1 (?init @ [x] @ xs)\n  \\<lbrakk>freeIn ?i F2; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F2) (?init @ xs) =\n                    eval F2 (?init @ [x] @ xs)\n  freeIn i (Or F1 F2)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n    eval (Or F1 F2) (init @ [x] @ xs)", "by auto"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (Or F1 F2)) (init @ xs) =\n  eval (Or F1 F2) (init @ [x] @ xs)\n\ngoal (5 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (Neg F)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (Neg F)\n  length init = i\n\ngoal (5 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (Neg F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (Neg F)) (init @ xs) =\n                         eval (Neg F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 3. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 5. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (Neg F)\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (Neg F)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (Neg F)) (init @ xs) = eval (Neg F) (init @ [x] @ xs)", "by simp"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (Neg F)) (init @ xs) = eval (Neg F) (init @ [x] @ xs)\n\ngoal (4 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (ExQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (ExQ F)\n  length init = i\n\ngoal (4 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1)) = (map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) TrueF (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) FalseF (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (fm.Atom x)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (fm.Atom x)\n        y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + 1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2 (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (And F1 F2)\n                          (y + 1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + 1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2 (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (Or F1 F2)\n                          (y + 1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (Neg F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (Neg F) y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExQ F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (ExQ F) y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllQ F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (AllQ F) y\n 9. \\<And>x1 F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExN x1 F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (ExN x1 F) y\n 10. \\<And>x1 F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllN x1 F)\n         (y + 1) =\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (AllN x1 F)\n         y", "by(simp_all)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (?y + 1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F ?y\n\ngoal (4 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExQ F)) (init @ xs) =\n                         eval (ExQ F) (init @ [x] @ xs)\n 2. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 4. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (ExQ F)) (init @ xs) = eval (ExQ F) (init @ [x] @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F\n           (Suc 0))\n         (x # init @ xs)) =\n    (\\<exists>xa. eval F (xa # init @ x # xs))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eval\n        (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F\n          (Suc 0))\n        (xa # init @ xs) =\n       eval F (xa # init @ x # xs)", "subgoal for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F (Suc 0))\n     (xa # init @ xs) =\n    eval F (xa # init @ x # xs)", "using map[of 0] ExQ(1)[of \"Suc i\" \"xa#init\"] ExQ(2) ExQ(3)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (0 + 1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F 0\n  \\<lbrakk>freeIn (Suc i) F; length (xa # init) = Suc i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm (Suc i) 1 F) ((xa # init) @ xs) =\n                    eval F ((xa # init) @ [x] @ xs)\n  freeIn i (ExQ F)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval\n     (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F (Suc 0))\n     (xa # init @ xs) =\n    eval F (xa # init @ x # xs)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (ExQ F)) (init @ xs) = eval (ExQ F) (init @ [x] @ xs)\n\ngoal (3 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (AllQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (AllQ F)\n  length init = i\n\ngoal (3 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1)) = (map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) TrueF (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) FalseF (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (fm.Atom x)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (fm.Atom x)\n        y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + 1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2 (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (And F1 F2)\n                          (y + 1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + 1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2 (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (Or F1 F2)\n                          (y + 1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (Neg F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (Neg F) y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExQ F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (ExQ F) y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllQ F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (AllQ F) y\n 9. \\<And>x1 F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExN x1 F)\n        (y + 1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (ExN x1 F) y\n 10. \\<And>x1 F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + 1) =\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllN x1 F)\n         (y + 1) =\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) (AllN x1 F)\n         y", "by(simp_all)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (?y + 1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F ?y\n\ngoal (3 subgoals):\n 1. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllQ F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n                         eval (AllQ F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 3. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (AllQ F)) (init @ xs) =\n    eval (AllQ F) (init @ [x] @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F\n           (Suc 0))\n         (x # init @ xs)) =\n    (\\<forall>xa. eval F (xa # init @ x # xs))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eval\n        (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F\n          (Suc 0))\n        (xa # init @ xs) =\n       eval F (xa # init @ x # xs)", "subgoal for xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F (Suc 0))\n     (xa # init @ xs) =\n    eval F (xa # init @ x # xs)", "using map[of 0] AllQ(1)[of \"Suc i\" \"xa#init\"] AllQ(2) AllQ(3)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (0 + 1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + 1 + x) 1 a) F 0\n  \\<lbrakk>freeIn (Suc i) F; length (xa # init) = Suc i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm (Suc i) 1 F) ((xa # init) @ xs) =\n                    eval F ((xa # init) @ [x] @ xs)\n  freeIn i (AllQ F)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval\n     (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F (Suc 0))\n     (xa # init @ xs) =\n    eval F (xa # init @ x # xs)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (AllQ F)) (init @ xs) = eval (AllQ F) (init @ [x] @ xs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (ExN x1 F)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (ExN x1 F)\n  length init = i\n\ngoal (2 subgoals):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1)) = (map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) TrueF (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) FalseF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (fm.Atom x)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (fm.Atom x)\n        y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + x1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (And F1 F2)\n                          (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + x1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (Or F1 F2)\n                          (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (Neg F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (Neg F) y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (ExQ F) y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (AllQ F) y\n 9. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExN x1a F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (ExN x1a F)\n        y\n 10. \\<And>x1a F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F\n             (y + x1) =\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllN x1a F)\n         (y + x1) =\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n         (AllN x1a F) y", "apply(simp_all add:add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 2. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 4. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "by (metis add.assoc)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (?y + x1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F ?y\n\ngoal (2 subgoals):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (ExN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n                         eval (ExN x1 F) (init @ [x] @ xs)\n 2. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n    eval (ExN x1 F) (init @ [x] @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l.\n        length l = x1 \\<and>\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n         (l @ init @ xs)) =\n    (\\<exists>l. length l = x1 \\<and> eval F (l @ init @ x # xs))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<and>\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n         (l @ init @ xs)) =\n       (length l = x1 \\<and> eval F (l @ init @ x # xs))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<and>\n     eval (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n      (l @ init @ xs)) =\n    (length l = x1 \\<and> eval F (l @ init @ x # xs))", "using map[of 0] ExN(1)[of \"i+x1\" \"l@init\"] ExN(2) ExN(3)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (0 + x1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F 0\n  \\<lbrakk>freeIn (i + x1) F; length (l @ init) = i + x1\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm (i + x1) 1 F) ((l @ init) @ xs) =\n                    eval F ((l @ init) @ [x] @ xs)\n  freeIn i (ExN x1 F)\n  length init = i\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<and>\n     eval (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n      (l @ init @ xs)) =\n    (length l = x1 \\<and> eval F (l @ init @ x # xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (ExN x1 F)) (init @ xs) =\n  eval (ExN x1 F) (init @ [x] @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "case (AllN x1 F)"], ["proof (state)\nthis:\n  \\<lbrakk>freeIn ?i F; length ?init = ?i\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm ?i 1 F) (?init @ xs) =\n                    eval F (?init @ [x] @ xs)\n  freeIn i (AllN x1 F)\n  length init = i\n\ngoal (1 subgoal):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1)) = (map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) TrueF (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) FalseF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (fm.Atom x)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (fm.Atom x)\n        y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + x1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (And F1 F2)\n                          (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F1\n                    (y + x1) =\n                   map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                    F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x) 1 a) (Or F1 F2)\n                          (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (Neg F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (Neg F) y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (ExQ F) y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (AllQ F) y\n 9. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (ExN x1a F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) (ExN x1a F)\n        y\n 10. \\<And>x1a F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F\n             (y + x1) =\n            map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) (AllN x1a F)\n         (y + x1) =\n        map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a)\n         (AllN x1a F) y", "apply(simp_all add:add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 2. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 4. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (Suc y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "apply (metis add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a)\n            F y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + i) (Suc 0) a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. lowerAtom (x + (i + x1)) (Suc 0) a) F\n        (x1a + y)", "by (metis add.assoc)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (?y + x1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F ?y\n\ngoal (1 subgoal):\n 1. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   \\<lbrakk>freeIn i F; length init = i\\<rbrakk>\n                   \\<Longrightarrow> eval (lowerFm i 1 F) (init @ xs) =\n                                     eval F (init @ [x] @ xs);\n        freeIn i (AllN x1 F); length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n                         eval (AllN x1 F) (init @ [x] @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n    eval (AllN x1 F) (init @ [x] @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n         (l @ init @ xs)) =\n    (\\<forall>l. length l = x1 \\<longrightarrow> eval F (l @ init @ x # xs))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<longrightarrow>\n        eval\n         (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n         (l @ init @ xs)) =\n       (length l = x1 \\<longrightarrow> eval F (l @ init @ x # xs))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow>\n     eval (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n      (l @ init @ xs)) =\n    (length l = x1 \\<longrightarrow> eval F (l @ init @ x # xs))", "using map[of 0] AllN(1)[of \"i+x1\" \"l@init\"] AllN(2) AllN(3)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x) 1 a) F (0 + x1) =\n  map_fm_binders (\\<lambda>a x. lowerAtom (i + x1 + x) 1 a) F 0\n  \\<lbrakk>freeIn (i + x1) F; length (l @ init) = i + x1\\<rbrakk>\n  \\<Longrightarrow> eval (lowerFm (i + x1) 1 F) ((l @ init) @ xs) =\n                    eval F ((l @ init) @ [x] @ xs)\n  freeIn i (AllN x1 F)\n  length init = i\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow>\n     eval (map_fm_binders (\\<lambda>a x. lowerAtom (i + x) (Suc 0) a) F x1)\n      (l @ init @ xs)) =\n    (length l = x1 \\<longrightarrow> eval F (l @ init @ x # xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (lowerFm i 1 (AllN x1 F)) (init @ xs) =\n  eval (AllN x1 F) (init @ [x] @ xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_lowerFm :\n  assumes h : \"freeIn 0 F\"\n  shows \" \\<forall>xs. (eval (lowerFm 0 1 F) xs = eval (ExQ F) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (lowerFm 0 1 F) xs = eval (ExQ F) xs", "using eval_lowerFm_helper[OF h]"], ["proof (prove)\nusing this:\n  length ?init = 0 \\<Longrightarrow>\n  eval (lowerFm 0 1 F) (?init @ ?xs) = eval F (?init @ [?x] @ ?xs)\n\ngoal (1 subgoal):\n 1. \\<forall>xs. eval (lowerFm 0 1 F) xs = eval (ExQ F) xs", "by simp"], ["", "fun liftAtom :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom \\<Rightarrow> atom\" where\n  \"liftAtom d amount (Eq p) = Eq(liftPoly d amount p)\"|\n  \"liftAtom d amount (Less p) = Less(liftPoly d amount p)\"|\n  \"liftAtom d amount (Leq p) = Leq(liftPoly d amount p)\"|\n  \"liftAtom d amount (Neq p) = Neq(liftPoly d amount p)\""], ["", "fun liftFm :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom fm \\<Rightarrow> atom fm\" where\n  \"liftFm d amount f = map_fm_binders (\\<lambda>a. \\<lambda>x. liftAtom (d+x) amount a) f 0\""], ["", "fun insert_into :: \"real list \\<Rightarrow> nat \\<Rightarrow> real list \\<Rightarrow> real list\" where\n  \"insert_into xs n l = take n xs @ l @ drop n xs\""], ["", "lemma higherPoly\\<^sub>0_add : \"higherPoly\\<^sub>0 x y (p + q) = higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 x y (p + q) =\n    higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q", "using poly_mapping_eq_iff[where a = \"higherPoly\\<^sub>0 x y (p + q)\", where b = \"higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q\"]\n    plus_poly_mapping.rep_eq[where x = \"higherPoly\\<^sub>0 x y (p + q)\", where xa = \"higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q\"]"], ["proof (prove)\nusing this:\n  (higherPoly\\<^sub>0 x y (p + q) =\n   higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q) =\n  (lookup (higherPoly\\<^sub>0 x y (p + q)) =\n   lookup (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q))\n  lookup\n   (higherPoly\\<^sub>0 x y (p + q) +\n    (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q)) =\n  (\\<lambda>k.\n      lookup (higherPoly\\<^sub>0 x y (p + q)) k +\n      lookup (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q) k)\n\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 x y (p + q) =\n    higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup\n              (higherPoly\\<^sub>0 x y (p + q) +\n               (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q)) =\n             (\\<lambda>k.\n                 lookup (higherPoly\\<^sub>0 x y (p + q)) k +\n                 lookup\n                  (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q) k);\n     higherPoly\\<^sub>0 x y (p + q) \\<noteq>\n     higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q;\n     lookup (higherPoly\\<^sub>0 x y (p + q)) \\<noteq>\n     lookup (higherPoly\\<^sub>0 x y p + higherPoly\\<^sub>0 x y q)\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: higherPoly\\<^sub>0.rep_eq lookup_add poly_mapping_eqI)"], ["", "lemma liftPoly_add: \"liftPoly w z (a + b) = (liftPoly w z a) + (liftPoly w z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly w z (a + b) = liftPoly w z a + liftPoly w z b", "unfolding liftPoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 w\n     z (a + b) =\n    map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 w\n     z a +\n    map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 w\n     z b", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "have h1: \"mapping_of (a + b) = mapping_of a + mapping_of b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of (a + b) = mapping_of a + mapping_of b", "by (simp add: plus_mpoly.rep_eq)"], ["proof (state)\nthis:\n  mapping_of (a + b) = mapping_of a + mapping_of b\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "have h2: \"MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) = \n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) + MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "have h0a: \"higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) = (higherPoly\\<^sub>0 w z (mapping_of a)) + (higherPoly\\<^sub>0 w z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) =\n    higherPoly\\<^sub>0 w z (mapping_of a) +\n    higherPoly\\<^sub>0 w z (mapping_of b)", "using higherPoly\\<^sub>0_add[of w z _ _ ]"], ["proof (prove)\nusing this:\n  higherPoly\\<^sub>0 w z (?p + ?q) =\n  higherPoly\\<^sub>0 w z ?p + higherPoly\\<^sub>0 w z ?q\n\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) =\n    higherPoly\\<^sub>0 w z (mapping_of a) +\n    higherPoly\\<^sub>0 w z (mapping_of b)", "by auto"], ["proof (state)\nthis:\n  higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) =\n  higherPoly\\<^sub>0 w z (mapping_of a) +\n  higherPoly\\<^sub>0 w z (mapping_of b)\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "then"], ["proof (chain)\npicking this:\n  higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) =\n  higherPoly\\<^sub>0 w z (mapping_of a) +\n  higherPoly\\<^sub>0 w z (mapping_of b)", "show ?thesis"], ["proof (prove)\nusing this:\n  higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b) =\n  higherPoly\\<^sub>0 w z (mapping_of a) +\n  higherPoly\\<^sub>0 w z (mapping_of b)\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "by (simp add: plus_mpoly.abs_eq)"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "show \"MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "using h1 h2"], ["proof (prove)\nusing this:\n  mapping_of (a + b) = mapping_of a + mapping_of b\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a + mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n    MPoly (higherPoly\\<^sub>0 w z (mapping_of b))", "by auto"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of (a + b))) =\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of a)) +\n  MPoly (higherPoly\\<^sub>0 w z (mapping_of b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_lift_add : \"vars(liftPoly a b (p+q)) \\<subseteq> vars(liftPoly a b (p))\\<union> vars(liftPoly a b (q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly a b (p + q))\n    \\<subseteq> vars (liftPoly a b p) \\<union> vars (liftPoly a b q)", "using liftPoly_add[of a b p q]"], ["proof (prove)\nusing this:\n  liftPoly a b (p + q) = liftPoly a b p + liftPoly a b q\n\ngoal (1 subgoal):\n 1. vars (liftPoly a b (p + q))\n    \\<subseteq> vars (liftPoly a b p) \\<union> vars (liftPoly a b q)", "using vars_add[of \"liftPoly a b p\" \"liftPoly a b q\"]"], ["proof (prove)\nusing this:\n  liftPoly a b (p + q) = liftPoly a b p + liftPoly a b q\n  vars (liftPoly a b p + liftPoly a b q)\n  \\<subseteq> vars (liftPoly a b p) \\<union> vars (liftPoly a b q)\n\ngoal (1 subgoal):\n 1. vars (liftPoly a b (p + q))\n    \\<subseteq> vars (liftPoly a b p) \\<union> vars (liftPoly a b q)", "by auto"], ["", "lemma mapping_of_lift_add : \"mapping_of (liftPoly x y (a + b)) = mapping_of (liftPoly x y a) + mapping_of (liftPoly x y b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of (liftPoly x y (a + b)) =\n    mapping_of (liftPoly x y a) + mapping_of (liftPoly x y b)", "unfolding liftPoly.rep_eq plus_mpoly.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 x y (mapping_of a + mapping_of b) =\n    higherPoly\\<^sub>0 x y (mapping_of a) +\n    higherPoly\\<^sub>0 x y (mapping_of b)", "using higherPoly\\<^sub>0_add"], ["proof (prove)\nusing this:\n  higherPoly\\<^sub>0 ?x ?y (?p + ?q) =\n  higherPoly\\<^sub>0 ?x ?y ?p + higherPoly\\<^sub>0 ?x ?y ?q\n\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 x y (mapping_of a + mapping_of b) =\n    higherPoly\\<^sub>0 x y (mapping_of a) +\n    higherPoly\\<^sub>0 x y (mapping_of b)", "."], ["", "lemma coeff_lift_add : \"MPoly_Type.coeff (liftPoly x y (a + b)) m = MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "have \"MPoly_Type.coeff (liftPoly x y (a + b)) m = MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m", "apply( simp add : mapping_of_lift_add coeff_def  )"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (mapping_of (liftPoly x y a) + mapping_of (liftPoly x y b)) m =\n    lookup (mapping_of (liftPoly x y a + liftPoly x y b)) m", "using lookup_add"], ["proof (prove)\nusing this:\n  lookup (?f + ?g) ?k = lookup ?f ?k + lookup ?g ?k\n\ngoal (1 subgoal):\n 1. lookup (mapping_of (liftPoly x y a) + mapping_of (liftPoly x y b)) m =\n    lookup (mapping_of (liftPoly x y a + liftPoly x y b)) m", "by (simp add: plus_mpoly.rep_eq)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (liftPoly x y (a + b)) m =\n  MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (liftPoly x y (a + b)) m =\n  MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "have \"... = MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "using MPolyExtension.coeff_add[of \"liftPoly x y a\" \"liftPoly x y b\" m]"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m =\n  MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "."], ["proof (state)\nthis:\n  MPoly_Type.coeff (liftPoly x y a + liftPoly x y b) m =\n  MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (liftPoly x y (a + b)) m =\n  MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (liftPoly x y (a + b)) m =\n  MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (liftPoly x y (a + b)) m =\n    MPoly_Type.coeff (liftPoly x y a) m +\n    MPoly_Type.coeff (liftPoly x y b) m", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (liftPoly x y (a + b)) m =\n  MPoly_Type.coeff (liftPoly x y a) m + MPoly_Type.coeff (liftPoly x y b) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_add : \"insertion (f::nat\\<Rightarrow>real)  (liftPoly 0 z (a + b)) = insertion f (liftPoly 0 z a + liftPoly 0 z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (a + b)) =\n    insertion f (liftPoly 0 z a + liftPoly 0 z b)", "using liftPoly_add[of 0 z a b]"], ["proof (prove)\nusing this:\n  liftPoly 0 z (a + b) = liftPoly 0 z a + liftPoly 0 z b\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (a + b)) =\n    insertion f (liftPoly 0 z a + liftPoly 0 z b)", "by simp"], ["", "lemma lower_power_zero : \"lowerPowers a b 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPowers a b 0 = 0", "unfolding lowerPowers_def dec_above_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun (\\<lambda>x. x)\n     (map_fun (\\<lambda>x. x) (map_fun lookup Abs_poly_mapping))\n     (\\<lambda>b i p x.\n         if x \\<in> {b..<b + i} then 0::'a\n         else p (if x \\<le> b then x else x - i))\n     a b 0 =\n    0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly_mapping\n     (\\<lambda>x.\n         if a \\<le> x \\<and> x < a + b then 0::'a\n         else lookup 0 (if x \\<le> a then x else x - b)) =\n    0", "unfolding Poly_Mapping.lookup_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly_mapping\n     (\\<lambda>x. if a \\<le> x \\<and> x < a + b then 0::'a else (0::'a)) =\n    0", "by auto"], ["", "lemma lift_vars_monom : \"vars (liftPoly i j ((MPoly_Type.monom m a)::real mpoly)) = (\\<lambda>x. if x\\<ge>i then x+j else x) ` vars(MPoly_Type.monom m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "proof(cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "then"], ["proof (chain)\npicking this:\n  a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "by (smt MPolyExtension.monom_zero add.left_neutral add_diff_cancel_right' image_empty liftPoly_add vars_monom_single_cases)"], ["proof (state)\nthis:\n  vars (liftPoly i j (MPoly_Type.monom m a)) =\n  (\\<lambda>x. if i \\<le> x then x + j else x) ` vars (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "have h1: \"vars (liftPoly i j (MPoly_Type.monom m a)) = keys (lowerPowers i j m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i j (MPoly_Type.monom m a)) = keys (lowerPowers i j m)", "unfolding liftPoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0\n       i j (MPoly_Type.monom m a)) =\n    keys (lowerPowers i j m)", "unfolding keys_lowerPowers keys_higherPoly\\<^sub>0 vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (keys `\n      keys\n       (mapping_of\n         (map_fun id (map_fun id (map_fun mapping_of MPoly))\n           higherPoly\\<^sub>0 i j (MPoly_Type.monom m a)))) =\n    inc_above i j ` keys m", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys\n                          (mapping_of\n                            (MPoly\n                              (higherPoly\\<^sub>0 i j (monomial a m))));\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inc_above i j ` keys m\n 2. \\<And>xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       \\<exists>x\\<in>keys\n                       (mapping_of\n                         (MPoly (higherPoly\\<^sub>0 i j (monomial a m)))).\n          inc_above i j xa \\<in> keys x", "apply (smt imageE keys_higherPoly\\<^sub>0 keys_lowerPowers lookup_eq_zero_in_keys_contradict lookup_single_not_eq mapping_of_inverse monomials.abs_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       \\<exists>x\\<in>keys\n                       (mapping_of\n                         (MPoly (higherPoly\\<^sub>0 i j (monomial a m)))).\n          inc_above i j xa \\<in> keys x", "by (metis False higherPowers.rep_eq higherPowers_lowerPowers image_eqI in_keys_iff keys_higherPoly\\<^sub>0 lookup_single_eq mapping_of_inverse monomials.abs_eq)"], ["proof (state)\nthis:\n  vars (liftPoly i j (MPoly_Type.monom m a)) = keys (lowerPowers i j m)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i j (MPoly_Type.monom m a)) =\n    (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a)", "unfolding h1  vars_monom_keys[OF False]\n      keys_lowerPowers inc_above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x < i then x else x + j) ` keys m =\n    (\\<lambda>x. if i \\<le> x then x + j else x) ` keys m", "by auto"], ["proof (state)\nthis:\n  vars (liftPoly i j (MPoly_Type.monom m a)) =\n  (\\<lambda>x. if i \\<le> x then x + j else x) ` vars (MPoly_Type.monom m a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_clear_vars : \"vars (liftPoly i j (p::real mpoly)) \\<inter> {i..<i + j} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i j p) \\<inter> {i..<i + j} = {}", "proof(induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       vars (liftPoly i j (MPoly_Type.monom m a)) \\<inter> {i..<i + j} = {}\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (liftPoly i j p1) \\<inter> {i..<i + j} = {};\n        vars (liftPoly i j p2) \\<inter> {i..<i + j} = {};\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> vars (liftPoly i j (p1 + p2)) \\<inter>\n                         {i..<i + j} =\n                         {}", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       vars (liftPoly i j (MPoly_Type.monom m a)) \\<inter> {i..<i + j} = {}\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (liftPoly i j p1) \\<inter> {i..<i + j} = {};\n        vars (liftPoly i j p2) \\<inter> {i..<i + j} = {};\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> vars (liftPoly i j (p1 + p2)) \\<inter>\n                         {i..<i + j} =\n                         {}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i j (MPoly_Type.monom m a)) \\<inter> {i..<i + j} = {}", "unfolding lift_vars_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if i \\<le> x then x + j else x) `\n    vars (MPoly_Type.monom m a) \\<inter>\n    {i..<i + j} =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars (liftPoly i j (MPoly_Type.monom m a)) \\<inter> {i..<i + j} = {}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (liftPoly i j p1) \\<inter> {i..<i + j} = {};\n        vars (liftPoly i j p2) \\<inter> {i..<i + j} = {};\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> vars (liftPoly i j (p1 + p2)) \\<inter>\n                         {i..<i + j} =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (liftPoly i j p1) \\<inter> {i..<i + j} = {};\n        vars (liftPoly i j p2) \\<inter> {i..<i + j} = {};\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> vars (liftPoly i j (p1 + p2)) \\<inter>\n                         {i..<i + j} =\n                         {}", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  vars (liftPoly i j p1) \\<inter> {i..<i + j} = {}\n  vars (liftPoly i j p2) \\<inter> {i..<i + j} = {}\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>vars (liftPoly i j p1) \\<inter> {i..<i + j} = {};\n        vars (liftPoly i j p2) \\<inter> {i..<i + j} = {};\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> vars (liftPoly i j (p1 + p2)) \\<inter>\n                         {i..<i + j} =\n                         {}", "then"], ["proof (chain)\npicking this:\n  vars (liftPoly i j p1) \\<inter> {i..<i + j} = {}\n  vars (liftPoly i j p2) \\<inter> {i..<i + j} = {}\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  vars (liftPoly i j p1) \\<inter> {i..<i + j} = {}\n  vars (liftPoly i j p2) \\<inter> {i..<i + j} = {}\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vars (liftPoly i j (p1 + p2)) \\<inter> {i..<i + j} = {}", "using vars_lift_add[of i j p1 p2]"], ["proof (prove)\nusing this:\n  vars (liftPoly i j p1) \\<inter> {i..<i + j} = {}\n  vars (liftPoly i j p2) \\<inter> {i..<i + j} = {}\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  vars (liftPoly i j (p1 + p2))\n  \\<subseteq> vars (liftPoly i j p1) \\<union> vars (liftPoly i j p2)\n\ngoal (1 subgoal):\n 1. vars (liftPoly i j (p1 + p2)) \\<inter> {i..<i + j} = {}", "by blast"], ["proof (state)\nthis:\n  vars (liftPoly i j (p1 + p2)) \\<inter> {i..<i + j} = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift0: \"(liftPoly i j 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly i j 0 = 0", "by (simp add: coeff_liftPoly mpoly_eq_iff)"], ["", "lemma lower0: \"(lowerPoly i j 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lowerPoly i j 0 = 0", "by (simp add: coeff_all_0 coeff_lowerPoly)"], ["", "lemma lower_lift_monom : \"insertion f (MPoly_Type.monom m a :: real mpoly) = insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom  m a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "unfolding True lift0 monom_zero lower0"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f 0 = insertion f 0", ".."], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom m a) =\n  insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "have h1 :  \"higherPowers i j ` ({lowerPowers i j m} \\<inter> {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}) = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers i j `\n    ({lowerPowers i j m} \\<inter>\n     {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}) =\n    {m}", "apply (simp add: lowerPowers.rep_eq higherPowers.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers i j (lowerPowers i j m) = m", "using higherPowers_lowerPowers"], ["proof (prove)\nusing this:\n  higherPowers ?n ?i (lowerPowers ?n ?i ?x) = ?x\n\ngoal (1 subgoal):\n 1. higherPowers i j (lowerPowers i j m) = m", "."], ["proof (state)\nthis:\n  higherPowers i j `\n  ({lowerPowers i j m} \\<inter>\n   {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}) =\n  {m}\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "have higher_lower : \"higherPowers i j (lowerPowers i j m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPowers i j (lowerPowers i j m) = m", "using higherPowers_lowerPowers"], ["proof (prove)\nusing this:\n  higherPowers ?n ?i (lowerPowers ?n ?i ?x) = ?x\n\ngoal (1 subgoal):\n 1. higherPowers i j (lowerPowers i j m) = m", "by blast"], ["proof (state)\nthis:\n  higherPowers i j (lowerPowers i j m) = m\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "using False"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m a) =\n    insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))", "unfolding insertion_code monomials_monom"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>(if a = 0 then {} else {m}).\n       MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n    (\\<Sum>ma\\<in>monomials\n                   (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    a * (\\<Prod>k\\<in>keys m. f k ^ lookup m k) =\n    (\\<Sum>ma\\<in>monomials\n                   (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "unfolding monomials_lowerPoly monomials_liftPoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    a * (\\<Prod>k\\<in>keys m. f k ^ lookup m k) =\n    (\\<Sum>ma\\<in>higherPowers i j `\n                  (lowerPowers i j `\n                   monomials (MPoly_Type.monom m a) \\<inter>\n                   {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    a * (\\<Prod>k\\<in>keys m. f k ^ lookup m k) =\n    (\\<Sum>ma\\<in>higherPowers i j `\n                  ({lowerPowers i j m} \\<inter>\n                   {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "unfolding More_MPoly_Type.coeff_monom  h1"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    a * (\\<Prod>k\\<in>keys m. f k ^ lookup m k) =\n    (\\<Sum>ma\\<in>{m}.\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0;\n     a \\<noteq>\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n      m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>keys m. f a = 0 \\<and> 0 < lookup m a", "unfolding coeff_lowerPoly coeff_liftPoly higherPowers_lowerPowers coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0;\n     a \\<noteq>\n     (if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j m) ja\n      then 0 else a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>keys m. f a = 0 \\<and> 0 < lookup m a", "apply(cases \"\\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j m) ja\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0;\n     a \\<noteq>\n     (if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j m) ja\n      then 0 else a);\n     \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j m) ja\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>keys m. f a = 0 \\<and> 0 < lookup m a\n 2. \\<lbrakk>a \\<noteq> 0;\n     a \\<noteq>\n     (if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j m) ja\n      then 0 else a);\n     \\<not> (\\<exists>ja\\<in>{i..<i + j}.\n                0 < lookup (lowerPowers i j m) ja)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>keys m. f a = 0 \\<and> 0 < lookup m a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       \\<lbrakk>a \\<noteq> 0; 0 < lookup (lowerPowers i j m) ja; i \\<le> ja;\n        ja < i + j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>keys m.\n                            f a = 0 \\<and> 0 < lookup m a", "by (simp add: lowerPowers_eq)"], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom m a) =\n  insertion f (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_lift : \"insertion f (p::real mpoly) = insertion f (lowerPoly i j (liftPoly i j p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = insertion f (lowerPoly i j (liftPoly i j p))", "unfolding insertion_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m * (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p)).\n       MPoly_Type.coeff (lowerPoly i j (liftPoly i j p)) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "proof(induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n          MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n          (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n       (\\<Sum>ma\\<in>monomials\n                      (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n          MPoly_Type.coeff\n           (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n          (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n          MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n          (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n       (\\<Sum>ma\\<in>monomials\n                      (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n          MPoly_Type.coeff\n           (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n          (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n       MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n    (\\<Sum>ma\\<in>monomials\n                   (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "using lower_lift_monom"], ["proof (prove)\nusing this:\n  insertion ?f (MPoly_Type.monom ?m ?a) =\n  insertion ?f (lowerPoly ?i ?j (liftPoly ?i ?j (MPoly_Type.monom ?m ?a)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n       MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n    (\\<Sum>ma\\<in>monomials\n                   (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n       MPoly_Type.coeff\n        (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "unfolding insertion_code monomials_lowerPoly monomials_liftPoly coeff_lowerPoly coeff_liftPoly"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>monomials (MPoly_Type.monom ?m ?a).\n     MPoly_Type.coeff (MPoly_Type.monom ?m ?a) m *\n     (\\<Prod>k\\<in>keys m. ?f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>higherPowers ?i ?j `\n               (lowerPowers ?i ?j `\n                monomials (MPoly_Type.monom ?m ?a) \\<inter>\n                {x. \\<forall>j\\<in>{?i..<?i + ?j}. lookup x j = 0}).\n     (if \\<exists>j\\<in>{?i..<?i + ?j}. 0 < lookup (lowerPowers ?i ?j m) j\n      then 0\n      else MPoly_Type.coeff (MPoly_Type.monom ?m ?a)\n            (higherPowers ?i ?j (lowerPowers ?i ?j m))) *\n     (\\<Prod>k\\<in>keys m. ?f k ^ lookup m k))\n\ngoal (1 subgoal):\n 1. (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n       MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n    (\\<Sum>ma\\<in>higherPowers i j `\n                  (lowerPowers i j `\n                   monomials (MPoly_Type.monom m a) \\<inter>\n                   {x. \\<forall>j\\<in>{i..<i + j}. lookup x j = 0}).\n       (if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j ma) ja\n        then 0\n        else MPoly_Type.coeff (MPoly_Type.monom m a)\n              (higherPowers i j (lowerPowers i j ma))) *\n       (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ma\\<in>monomials (MPoly_Type.monom m a).\n     MPoly_Type.coeff (MPoly_Type.monom m a) ma *\n     (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k)) =\n  (\\<Sum>ma\\<in>monomials\n                 (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a))).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j (MPoly_Type.monom m a)))\n      ma *\n     (\\<Prod>k\\<in>keys ma. f k ^ lookup ma k))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>monomials p1.\n     MPoly_Type.coeff p1 m * (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n  (\\<Sum>m\\<in>monomials p2.\n     MPoly_Type.coeff p2 m * (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "have h1 : \"monomials p1 \\<inter> monomials p2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials p1 \\<inter> monomials p2 = {}", "using sum"], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>monomials p1.\n     MPoly_Type.coeff p1 m * (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n  (\\<Sum>m\\<in>monomials p2.\n     MPoly_Type.coeff p2 m * (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomials p1 \\<inter> monomials p2 = {}", "by (metis Int_insert_right_if0 inf_bot_right monomials_monom)"], ["proof (state)\nthis:\n  monomials p1 \\<inter> monomials p2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "have h4 : \"monomials (lowerPoly i j (liftPoly i j (p1 + p2))) = monomials (lowerPoly i j (liftPoly i j (p1))) \\<union> monomials (lowerPoly i j (liftPoly i j (p2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (lowerPoly i j (liftPoly i j (p1 + p2))) =\n    monomials (lowerPoly i j (liftPoly i j p1)) \\<union>\n    monomials (lowerPoly i j (liftPoly i j p2))", "using monomials_lowerPoly monomials_liftPoly monomials_add_disjoint[OF h1]"], ["proof (prove)\nusing this:\n  monomials (lowerPoly ?b ?i ?mp) =\n  higherPowers ?b ?i `\n  (monomials ?mp \\<inter>\n   {x. \\<forall>j\\<in>{?b..<?b + ?i}. lookup x j = 0})\n  monomials (liftPoly ?b ?i ?mp) = lowerPowers ?b ?i ` monomials ?mp\n  monomials (p1 + p2) = monomials p1 \\<union> monomials p2\n\ngoal (1 subgoal):\n 1. monomials (lowerPoly i j (liftPoly i j (p1 + p2))) =\n    monomials (lowerPoly i j (liftPoly i j p1)) \\<union>\n    monomials (lowerPoly i j (liftPoly i j p2))", "by (simp add: monomials_liftPoly monomials_lowerPoly Int_Un_distrib2 image_Un)"], ["proof (state)\nthis:\n  monomials (lowerPoly i j (liftPoly i j (p1 + p2))) =\n  monomials (lowerPoly i j (liftPoly i j p1)) \\<union>\n  monomials (lowerPoly i j (liftPoly i j p2))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "have h5 : \"MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) = MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1))) + MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) =\n    MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) +\n    MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2))", "unfolding coeff_lowerPoly coeff_liftPoly MPolyExtension.coeff_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j x) ja\n        then 0\n        else MPoly_Type.coeff p1 (higherPowers i j (lowerPowers i j x)) +\n             MPoly_Type.coeff p2 (higherPowers i j (lowerPowers i j x))) =\n    (\\<lambda>x.\n        if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j x) ja\n        then 0\n        else MPoly_Type.coeff p1 (higherPowers i j (lowerPowers i j x))) +\n    (\\<lambda>x.\n        if \\<exists>ja\\<in>{i..<i + j}. 0 < lookup (lowerPowers i j x) ja\n        then 0\n        else MPoly_Type.coeff p2 (higherPowers i j (lowerPowers i j x)))", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) =\n  MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) +\n  MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>(\\<Sum>m\\<in>monomials p1.\n                   MPoly_Type.coeff p1 m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)).\n                   MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) m *\n                   (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        (\\<Sum>m\\<in>monomials p2.\n           MPoly_Type.coeff p2 m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n        (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p2)).\n           MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)) m *\n           (\\<Prod>k\\<in>keys m. f k ^ lookup m k));\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1;\n        a \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>m\\<in>monomials (p1 + p2).\n                            MPoly_Type.coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n                         (\\<Sum>m\\<in>monomials\n (lowerPoly i j (liftPoly i j (p1 + p2))).\n                            MPoly_Type.coeff\n                             (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n                            (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (p1 + p2).\n       MPoly_Type.coeff (p1 + p2) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j (p1 + p2))).\n       MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "unfolding MPolyExtension.coeff_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (p1 + p2).\n       (MPoly_Type.coeff p1 m + MPoly_Type.coeff p2 m) *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j (p1 + p2))).\n       MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "unfolding h4 h5"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials (p1 + p2).\n       (MPoly_Type.coeff p1 m + MPoly_Type.coeff p2 m) *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)) \\<union>\n                 monomials (lowerPoly i j (liftPoly i j p2)).\n       (MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) +\n        MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)))\n        m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "unfolding monomials_add_disjoint[OF h1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p1 \\<union> monomials p2.\n       (MPoly_Type.coeff p1 m + MPoly_Type.coeff p2 m) *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j p1)) \\<union>\n                 monomials (lowerPoly i j (liftPoly i j p2)).\n       (MPoly_Type.coeff (lowerPoly i j (liftPoly i j p1)) +\n        MPoly_Type.coeff (lowerPoly i j (liftPoly i j p2)))\n        m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "by (smt IntE coeff_eq_zero_iff disjoint_iff_not_equal finite_monomials h1 higherPowers_lowerPowers imageE monomials_liftPoly monomials_lowerPoly plus_fun_apply sum.IH(1) sum.IH(2) sum.cong sum.union_disjoint\n        )"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>monomials (p1 + p2).\n     MPoly_Type.coeff (p1 + p2) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n  (\\<Sum>m\\<in>monomials (lowerPoly i j (liftPoly i j (p1 + p2))).\n     MPoly_Type.coeff (lowerPoly i j (liftPoly i j (p1 + p2))) m *\n     (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_insertion : \" \\<forall>init.\n       length init = (i::nat) \\<longrightarrow>\n       (\\<forall>I xs.\n           (insertion (nth_default 0 (init @ xs)) (p::real mpoly)) = (insertion ((nth_default 0) (init @ I @ xs)) (liftPoly i (length I) p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>init.\n       length init = i \\<longrightarrow>\n       (\\<forall>I xs.\n           insertion (nth_default 0 (init @ xs)) p =\n           insertion (nth_default 0 (init @ I @ xs))\n            (liftPoly i (length I) p))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "fix init I xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "assume \"i = length (init::real list)\""], ["proof (state)\nthis:\n  i = length init\n\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "then"], ["proof (chain)\npicking this:\n  i = length init", "have i_len : \"length init = i\""], ["proof (prove)\nusing this:\n  i = length init\n\ngoal (1 subgoal):\n 1. length init = i", "by auto"], ["proof (state)\nthis:\n  length init = i\n\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "have h: \"higherPoly\\<^sub>0 i (length (I::real list)) (mapping_of p) \\<in> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 i (length I) (mapping_of p) \\<in> UNIV", "by simp"], ["proof (state)\nthis:\n  higherPoly\\<^sub>0 i (length I) (mapping_of p) \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "have h2 : \"vars (liftPoly i (length I) p) \\<inter> {i..<i + length I} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (liftPoly i (length I) p) \\<inter> {i..<i + length I} = {}", "using lift_clear_vars"], ["proof (prove)\nusing this:\n  vars (liftPoly ?i ?j ?p) \\<inter> {?i..<?i + ?j} = {}\n\ngoal (1 subgoal):\n 1. vars (liftPoly i (length I) p) \\<inter> {i..<i + length I} = {}", "by auto"], ["proof (state)\nthis:\n  vars (liftPoly i (length I) p) \\<inter> {i..<i + length I} = {}\n\ngoal (1 subgoal):\n 1. \\<And>init I xs.\n       i = length init \\<Longrightarrow>\n       insertion (nth_default 0 (init @ xs)) p =\n       insertion (nth_default 0 (init @ I @ xs))\n        (liftPoly (length init) (length I) p)", "show \"insertion ((nth_default 0) (init @ xs)) p = insertion ((nth_default 0) (init @ I @ xs)) (liftPoly (length init) (length I) p) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (init @ xs)) p =\n    insertion (nth_default 0 (init @ I @ xs))\n     (liftPoly (length init) (length I) p)", "using lower_lift insertion_lowerPoly[OF h2 i_len refl, of xs] i_len"], ["proof (prove)\nusing this:\n  insertion ?f ?p = insertion ?f (lowerPoly ?i ?j (liftPoly ?i ?j ?p))\n  insertion (nth_default 0 (init @ xs))\n   (lowerPoly i (length I) (liftPoly i (length I) p)) =\n  insertion (nth_default 0 (init @ I @ xs)) (liftPoly i (length I) p)\n  length init = i\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (init @ xs)) p =\n    insertion (nth_default 0 (init @ I @ xs))\n     (liftPoly (length init) (length I) p)", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (init @ xs)) p =\n  insertion (nth_default 0 (init @ I @ xs))\n   (liftPoly (length init) (length I) p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_liftFm_helper :\n  assumes \"length init = i\"\n  assumes \"length I = amount\"\n  shows \"eval F (init @xs) = eval (liftFm i amount F) (init@I@xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (init @ xs) = eval (liftFm i amount F) (init @ I @ xs)", "using assms(1)"], ["proof (prove)\nusing this:\n  length init = i\n\ngoal (1 subgoal):\n 1. eval F (init @ xs) = eval (liftFm i amount F) (init @ I @ xs)", "proof(induction F arbitrary: i init)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>x i init.\n       length init = i \\<Longrightarrow>\n       eval (fm.Atom x) (init @ xs) =\n       eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 5. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 8. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 10. \\<And>x1 F i init.\n        \\<lbrakk>\\<And>i init.\n                    length init = i \\<Longrightarrow>\n                    eval F (init @ xs) =\n                    eval (liftFm i amount F) (init @ I @ xs);\n         length init = i\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                          eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "case (Atom x)"], ["proof (state)\nthis:\n  length init = i\n\ngoal (10 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>x i init.\n       length init = i \\<Longrightarrow>\n       eval (fm.Atom x) (init @ xs) =\n       eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 5. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 8. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 10. \\<And>x1 F i init.\n        \\<lbrakk>\\<And>i init.\n                    length init = i \\<Longrightarrow>\n                    eval F (init @ xs) =\n                    eval (liftFm i amount F) (init @ I @ xs);\n         length init = i\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                          eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "then"], ["proof (chain)\npicking this:\n  length init = i", "show ?case"], ["proof (prove)\nusing this:\n  length init = i\n\ngoal (1 subgoal):\n 1. eval (fm.Atom x) (init @ xs) =\n    eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)", "apply(cases x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>length init = i; x = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (init @ xs) =\n                         eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n 2. \\<And>x2.\n       \\<lbrakk>length init = i; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (init @ xs) =\n                         eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n 3. \\<And>x3.\n       \\<lbrakk>length init = i; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (init @ xs) =\n                         eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n 4. \\<And>x4.\n       \\<lbrakk>length init = i; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) (init @ xs) =\n                         eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>length init = i; x = Less x1\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x1 < 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x1)\n                          < 0)\n 2. \\<And>x2.\n       \\<lbrakk>length init = i; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x2 = 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x2) =\n                          0)\n 3. \\<And>x3.\n       \\<lbrakk>length init = i; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x3\n                          \\<le> 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x3)\n                          \\<le> 0)\n 4. \\<And>x4.\n       \\<lbrakk>length init = i; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x4 = 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x4) =\n                          0)", "using lift_insertion assms Atom.prems"], ["proof (prove)\nusing this:\n  \\<forall>init.\n     length init = ?i \\<longrightarrow>\n     (\\<forall>I xs.\n         insertion (nth_default 0 (init @ xs)) ?p =\n         insertion (nth_default 0 (init @ I @ xs))\n          (liftPoly ?i (length I) ?p))\n  length init = i\n  length I = amount\n  length init = i\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>length init = i; x = Less x1\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x1 < 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x1)\n                          < 0)\n 2. \\<And>x2.\n       \\<lbrakk>length init = i; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x2 = 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x2) =\n                          0)\n 3. \\<And>x3.\n       \\<lbrakk>length init = i; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x3\n                          \\<le> 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x3)\n                          \\<le> 0)\n 4. \\<And>x4.\n       \\<lbrakk>length init = i; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> (insertion (nth_default 0 (init @ xs)) x4 = 0) =\n                         (insertion (nth_default 0 (init @ I @ xs))\n                           (liftPoly i amount x4) =\n                          0)", "by force+"], ["proof (state)\nthis:\n  eval (fm.Atom x) (init @ xs) =\n  eval (liftFm i amount (fm.Atom x)) (init @ I @ xs)\n\ngoal (9 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "case (ExQ F)"], ["proof (state)\nthis:\n  length ?init = ?i \\<Longrightarrow>\n  eval F (?init @ xs) = eval (liftFm ?i amount F) (?init @ I @ xs)\n  length init = i\n\ngoal (9 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. liftAtom (i + x) (amount) a) F (y + Suc 0)) = (map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) TrueF\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) FalseF\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (fm.Atom x)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n        (fm.Atom x) y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + Suc 0) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (And F1 F2) (y + Suc 0) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + Suc 0) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (Or F1 F2) (y + Suc 0) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (Neg F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (Neg F)\n        y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExQ F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (ExQ F)\n        y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllQ F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (AllQ F)\n        y\n 9. \\<And>x1 F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExN x1 F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n        (ExN x1 F) y\n 10. \\<And>x1 F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n             (y + Suc 0) =\n            map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllN x1 F)\n         (y + Suc 0) =\n        map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n         (AllN x1 F) y", "by(simp_all)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (?y + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F ?y\n\ngoal (9 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (init @ xs) =\n                         eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n 7. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 9. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExQ F) (init @ xs) =\n    eval (liftFm i amount (ExQ F)) (init @ I @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval F (x # init @ xs)) =\n    (\\<exists>x.\n        eval\n         (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n           (Suc 0))\n         (x # init @ I @ xs))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F (x # init @ xs) =\n       eval\n        (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n        (x # init @ I @ xs)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "using map[of 0]"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F 0\n\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "using ExQ(1)[of \"x#init\" \"i+1\"] ExQ(2)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F 0\n  length (x # init) = i + 1 \\<Longrightarrow>\n  eval F ((x # init) @ xs) =\n  eval (liftFm (i + 1) amount F) ((x # init) @ I @ xs)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExQ F) (init @ xs) = eval (liftFm i amount (ExQ F)) (init @ I @ xs)\n\ngoal (8 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "case (AllQ F)"], ["proof (state)\nthis:\n  length ?init = ?i \\<Longrightarrow>\n  eval F (?init @ xs) = eval (liftFm ?i amount F) (?init @ I @ xs)\n  length init = i\n\ngoal (8 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. liftAtom (i + x) (amount) a) F (y + Suc 0)) = (map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) TrueF\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) FalseF\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) FalseF y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (fm.Atom x)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n        (fm.Atom x) y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + Suc 0) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (And F1 F2) (y + Suc 0) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + Suc 0) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (Or F1 F2) (y + Suc 0) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (Neg F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (Neg F)\n        y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExQ F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (ExQ F)\n        y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllQ F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) (AllQ F)\n        y\n 9. \\<And>x1 F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + Suc 0) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExN x1 F)\n        (y + Suc 0) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n        (ExN x1 F) y\n 10. \\<And>x1 F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n             (y + Suc 0) =\n            map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllN x1 F)\n         (y + Suc 0) =\n        map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a)\n         (AllN x1 F) y", "by(simp_all)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (?y + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F ?y\n\ngoal (8 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (init @ xs) =\n                         eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 8. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllQ F) (init @ xs) =\n    eval (liftFm i amount (AllQ F)) (init @ I @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. eval F (x # init @ xs)) =\n    (\\<forall>x.\n        eval\n         (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n           (Suc 0))\n         (x # init @ I @ xs))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F (x # init @ xs) =\n       eval\n        (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n        (x # init @ I @ xs)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "using map[of 0]"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F 0\n\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "using AllQ(1)[of \"x#init\" \"i+1\"] AllQ(2)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + Suc 0) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + 1 + x) amount a) F 0\n  length (x # init) = i + 1 \\<Longrightarrow>\n  eval F ((x # init) @ xs) =\n  eval (liftFm (i + 1) amount F) ((x # init) @ I @ xs)\n  length init = i\n\ngoal (1 subgoal):\n 1. eval F (x # init @ xs) =\n    eval\n     (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (Suc 0))\n     (x # init @ I @ xs)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (AllQ F) (init @ xs) =\n  eval (liftFm i amount (AllQ F)) (init @ I @ xs)\n\ngoal (7 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "case (ExN x1 F)"], ["proof (state)\nthis:\n  length ?init = ?i \\<Longrightarrow>\n  eval F (?init @ xs) = eval (liftFm ?i amount F) (?init @ I @ xs)\n  length init = i\n\ngoal (7 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. liftAtom (i + x) (amount) a) F (y + x1)) = (map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) TrueF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) FalseF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) FalseF\n        y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (fm.Atom x)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (fm.Atom x) y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + x1) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (And F1 F2) (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + x1) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (Or F1 F2) (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (Neg F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) (Neg F)\n        y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) (ExQ F)\n        y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (AllQ F) y\n 9. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExN x1a F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (ExN x1a F) y\n 10. \\<And>x1a F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n             (y + x1) =\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n         (AllN x1a F) (y + x1) =\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n         (AllN x1a F) y", "apply(simp_all add: add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 2. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 4. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "by (metis add.assoc)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (?y + x1) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F ?y\n\ngoal (7 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (init @ xs) =\n                         eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n 7. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN x1 F) (init @ xs) =\n    eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = x1 \\<and> eval F (l @ init @ xs)) =\n    (\\<exists>l.\n        length l = x1 \\<and>\n        eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n         (l @ init @ I @ xs))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<and> eval F (l @ init @ xs)) =\n       (length l = x1 \\<and>\n        eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n         (l @ init @ I @ xs))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<and> eval F (l @ init @ xs)) =\n    (length l = x1 \\<and>\n     eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n      (l @ init @ I @ xs))", "using map[of 0] ExN(1)[of \"l@init\" \"i+x1\"] ExN(2)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + x1) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F 0\n  length (l @ init) = i + x1 \\<Longrightarrow>\n  eval F ((l @ init) @ xs) =\n  eval (liftFm (i + x1) amount F) ((l @ init) @ I @ xs)\n  length init = i\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<and> eval F (l @ init @ xs)) =\n    (length l = x1 \\<and>\n     eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n      (l @ init @ I @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExN x1 F) (init @ xs) =\n  eval (liftFm i amount (ExN x1 F)) (init @ I @ xs)\n\ngoal (6 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "case (AllN x1 F)"], ["proof (state)\nthis:\n  length ?init = ?i \\<Longrightarrow>\n  eval F (?init @ xs) = eval (liftFm ?i amount F) (?init @ I @ xs)\n  length init = i\n\ngoal (6 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "have map: \"\\<And>y. (map_fm_binders (\\<lambda>a x. liftAtom (i + x) (amount) a) F (y + x1)) = (map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F y", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) TrueF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) TrueF y\n 2. \\<And>y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) FalseF\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) FalseF\n        y\n 3. \\<And>x y.\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (fm.Atom x)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (fm.Atom x) y\n 4. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + x1) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (And F1 F2) (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n                          (And F1 F2) y\n 5. \\<And>F1 F2 y.\n       \\<lbrakk>\\<And>y.\n                   map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n                    F1 (y + x1) =\n                   map_fm_binders\n                    (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F1 y;\n        \\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F2\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F2\n            y\\<rbrakk>\n       \\<Longrightarrow> map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x) amount a)\n                          (Or F1 F2) (y + x1) =\n                         map_fm_binders\n                          (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n                          (Or F1 F2) y\n 6. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (Neg F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) (Neg F)\n        y\n 7. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) (ExQ F)\n        y\n 8. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (AllQ F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (AllQ F) y\n 9. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) (ExN x1a F)\n        (y + x1) =\n       map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n        (ExN x1a F) y\n 10. \\<And>x1a F y.\n        (\\<And>y.\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F\n             (y + x1) =\n            map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F\n             y) \\<Longrightarrow>\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a)\n         (AllN x1a F) (y + x1) =\n        map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a)\n         (AllN x1a F) y", "apply(simp_all add: add.commute add.left_commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 2. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 4. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (Suc (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (Suc y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 3. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)\n 2. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "apply (metis add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a F y.\n       (\\<And>y.\n           map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n            (y + x1) =\n           map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n            y) \\<Longrightarrow>\n       map_fm_binders (\\<lambda>a x. liftAtom (x + i) amount a) F\n        (x1a + (y + x1)) =\n       map_fm_binders (\\<lambda>a x. liftAtom (x + (i + x1)) amount a) F\n        (x1a + y)", "by (metis add.assoc)"], ["proof (state)\nthis:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (?y + x1) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F ?y\n\ngoal (6 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)\n 6. \\<And>x1 F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (init @ xs) =\n                         eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN x1 F) (init @ xs) =\n    eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l. length l = x1 \\<longrightarrow> eval F (l @ init @ xs)) =\n    (\\<forall>l.\n        length l = x1 \\<longrightarrow>\n        eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n         (l @ init @ I @ xs))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = x1 \\<longrightarrow> eval F (l @ init @ xs)) =\n       (length l = x1 \\<longrightarrow>\n        eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n         (l @ init @ I @ xs))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow> eval F (l @ init @ xs)) =\n    (length l = x1 \\<longrightarrow>\n     eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n      (l @ init @ I @ xs))", "using map[of 0] AllN(1)[of \"l@init\" \"i+x1\"] AllN(2)"], ["proof (prove)\nusing this:\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F (0 + x1) =\n  map_fm_binders (\\<lambda>a x. liftAtom (i + x1 + x) amount a) F 0\n  length (l @ init) = i + x1 \\<Longrightarrow>\n  eval F ((l @ init) @ xs) =\n  eval (liftFm (i + x1) amount F) ((l @ init) @ I @ xs)\n  length init = i\n\ngoal (1 subgoal):\n 1. (length l = x1 \\<longrightarrow> eval F (l @ init @ xs)) =\n    (length l = x1 \\<longrightarrow>\n     eval (map_fm_binders (\\<lambda>a x. liftAtom (i + x) amount a) F x1)\n      (l @ init @ I @ xs))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (AllN x1 F) (init @ xs) =\n  eval (liftFm i amount (AllN x1 F)) (init @ I @ xs)\n\ngoal (5 subgoals):\n 1. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval TrueF (init @ xs) = eval (liftFm i amount TrueF) (init @ I @ xs)\n 2. \\<And>i init.\n       length init = i \\<Longrightarrow>\n       eval FalseF (init @ xs) =\n       eval (liftFm i amount FalseF) (init @ I @ xs)\n 3. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (init @ xs) =\n                         eval (liftFm i amount (And F1 F2)) (init @ I @ xs)\n 4. \\<And>F1 F2 i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F1 (init @ xs) =\n                   eval (liftFm i amount F1) (init @ I @ xs);\n        \\<And>i init.\n           length init = i \\<Longrightarrow>\n           eval F2 (init @ xs) = eval (liftFm i amount F2) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (init @ xs) =\n                         eval (liftFm i amount (Or F1 F2)) (init @ I @ xs)\n 5. \\<And>F i init.\n       \\<lbrakk>\\<And>i init.\n                   length init = i \\<Longrightarrow>\n                   eval F (init @ xs) =\n                   eval (liftFm i amount F) (init @ I @ xs);\n        length init = i\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (init @ xs) =\n                         eval (liftFm i amount (Neg F)) (init @ I @ xs)", "qed auto"], ["", "lemma eval_liftFm :\n  assumes \"length I = amount\"\n  assumes \"length L \\<ge> d\"\n  shows \"eval F L = eval (liftFm d amount F) (insert_into L d I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "define init where \"init = take d L\""], ["proof (state)\nthis:\n  init = take d L\n\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "then"], ["proof (chain)\npicking this:\n  init = take d L", "have \"length init = d\""], ["proof (prove)\nusing this:\n  init = take d L\n\ngoal (1 subgoal):\n 1. length init = d", "using assms"], ["proof (prove)\nusing this:\n  init = take d L\n  length I = amount\n  d \\<le> length L\n\ngoal (1 subgoal):\n 1. length init = d", "by simp"], ["proof (state)\nthis:\n  length init = d\n\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "then"], ["proof (chain)\npicking this:\n  length init = d", "have \"(eval F (init @ (drop d L)) = eval (liftFm d amount F) (init @ I @ (drop d L)))\""], ["proof (prove)\nusing this:\n  length init = d\n\ngoal (1 subgoal):\n 1. eval F (init @ drop d L) =\n    eval (liftFm d amount F) (init @ I @ drop d L)", "using eval_liftFm_helper[of init d I amount  F \"(drop d L)\"] assms"], ["proof (prove)\nusing this:\n  length init = d\n  \\<lbrakk>length init = d; length I = amount\\<rbrakk>\n  \\<Longrightarrow> eval F (init @ drop d L) =\n                    eval (liftFm d amount F) (init @ I @ drop d L)\n  length I = amount\n  d \\<le> length L\n\ngoal (1 subgoal):\n 1. eval F (init @ drop d L) =\n    eval (liftFm d amount F) (init @ I @ drop d L)", "by auto"], ["proof (state)\nthis:\n  eval F (init @ drop d L) = eval (liftFm d amount F) (init @ I @ drop d L)\n\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "then"], ["proof (chain)\npicking this:\n  eval F (init @ drop d L) = eval (liftFm d amount F) (init @ I @ drop d L)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval F (init @ drop d L) = eval (liftFm d amount F) (init @ I @ drop d L)\n\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (insert_into L d I)", "unfolding insert_into.simps assms init_def"], ["proof (prove)\nusing this:\n  eval F (take d L @ drop d L) =\n  eval (liftFm d amount F) (take d L @ I @ drop d L)\n\ngoal (1 subgoal):\n 1. eval F L = eval (liftFm d amount F) (take d L @ I @ drop d L)", "by auto"], ["proof (state)\nthis:\n  eval F L = eval (liftFm d amount F) (insert_into L d I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_lift : \"var\\<notin>vars(p::real mpoly) \\<Longrightarrow> var+z\\<notin>vars(liftPoly 0 z p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars p \\<Longrightarrow>\n    var + z \\<notin> vars (liftPoly 0 z p)", "proof(induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       var \\<notin> vars (MPoly_Type.monom m a) \\<Longrightarrow>\n       var + z \\<notin> vars (liftPoly 0 z (MPoly_Type.monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>var \\<notin> vars p1 \\<Longrightarrow>\n                var + z \\<notin> vars (liftPoly 0 z p1);\n        var \\<notin> vars p2 \\<Longrightarrow>\n        var + z \\<notin> vars (liftPoly 0 z p2);\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        var \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "case (monom m a)"], ["proof (state)\nthis:\n  var \\<notin> vars (MPoly_Type.monom m a)\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       var \\<notin> vars (MPoly_Type.monom m a) \\<Longrightarrow>\n       var + z \\<notin> vars (liftPoly 0 z (MPoly_Type.monom m a))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>var \\<notin> vars p1 \\<Longrightarrow>\n                var + z \\<notin> vars (liftPoly 0 z p1);\n        var \\<notin> vars p2 \\<Longrightarrow>\n        var + z \\<notin> vars (liftPoly 0 z p2);\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        var \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars (MPoly_Type.monom m a)", "show ?case"], ["proof (prove)\nusing this:\n  var \\<notin> vars (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. var + z \\<notin> vars (liftPoly 0 z (MPoly_Type.monom m a))", "using lift_vars_monom[of 0 z m a]"], ["proof (prove)\nusing this:\n  var \\<notin> vars (MPoly_Type.monom m a)\n  vars (liftPoly 0 z (MPoly_Type.monom m a)) =\n  (\\<lambda>x. if 0 \\<le> x then x + z else x) ` vars (MPoly_Type.monom m a)\n\ngoal (1 subgoal):\n 1. var + z \\<notin> vars (liftPoly 0 z (MPoly_Type.monom m a))", "by auto"], ["proof (state)\nthis:\n  var + z \\<notin> vars (liftPoly 0 z (MPoly_Type.monom m a))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>var \\<notin> vars p1 \\<Longrightarrow>\n                var + z \\<notin> vars (liftPoly 0 z p1);\n        var \\<notin> vars p2 \\<Longrightarrow>\n        var + z \\<notin> vars (liftPoly 0 z p2);\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        var \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>var \\<notin> vars p1 \\<Longrightarrow>\n                var + z \\<notin> vars (liftPoly 0 z p1);\n        var \\<notin> vars p2 \\<Longrightarrow>\n        var + z \\<notin> vars (liftPoly 0 z p2);\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        var \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  var \\<notin> vars p1 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p1)\n  var \\<notin> vars p2 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p2)\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  var \\<notin> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>var \\<notin> vars p1 \\<Longrightarrow>\n                var + z \\<notin> vars (liftPoly 0 z p1);\n        var \\<notin> vars p2 \\<Longrightarrow>\n        var + z \\<notin> vars (liftPoly 0 z p2);\n        p2 = MPoly_Type.monom m a; m \\<notin> monomials p1; a \\<noteq> 0;\n        var \\<notin> vars (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "using sum"], ["proof (prove)\nusing this:\n  var \\<notin> vars p1 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p1)\n  var \\<notin> vars p2 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p2)\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  var \\<notin> vars (p1 + p2)\n\ngoal (1 subgoal):\n 1. var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "using vars_lift_add[of 0 z p1 p2]\n      vars_add[of p1 p2]"], ["proof (prove)\nusing this:\n  var \\<notin> vars p1 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p1)\n  var \\<notin> vars p2 \\<Longrightarrow>\n  var + z \\<notin> vars (liftPoly 0 z p2)\n  p2 = MPoly_Type.monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> 0\n  var \\<notin> vars (p1 + p2)\n  vars (liftPoly 0 z (p1 + p2))\n  \\<subseteq> vars (liftPoly 0 z p1) \\<union> vars (liftPoly 0 z p2)\n  vars (p1 + p2) \\<subseteq> vars p1 \\<union> vars p2\n\ngoal (1 subgoal):\n 1. var + z \\<notin> vars (liftPoly 0 z (p1 + p2))", "by (metis (no_types, lifting) Set.basic_monos(7) Un_iff monomials.rep_eq vars_add_monom)"], ["proof (state)\nthis:\n  var + z \\<notin> vars (liftPoly 0 z (p1 + p2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_const : \"insertion f (liftPoly 0 z (Const (C::real))) = insertion f (Const C :: real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (Const C)) = insertion f (Const C)", "apply(cases \"C=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. C = 0 \\<Longrightarrow>\n    insertion f (liftPoly 0 z (Const C)) = insertion f (Const C)\n 2. C \\<noteq> 0 \\<Longrightarrow>\n    insertion f (liftPoly 0 z (Const C)) = insertion f (Const C)", "unfolding insertion_code monomials_Const coeff_Const monomials_liftPoly"], ["proof (prove)\ngoal (2 subgoals):\n 1. C = 0 \\<Longrightarrow>\n    (\\<Sum>m\\<in>lowerPowers 0 z ` (if C = 0 then {} else {0}).\n       MPoly_Type.coeff (liftPoly 0 z (Const C)) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>(if C = 0 then {} else {0}).\n       (C when m = 0) * (\\<Prod>k\\<in>keys m. f k ^ lookup m k))\n 2. C \\<noteq> 0 \\<Longrightarrow>\n    (\\<Sum>m\\<in>lowerPowers 0 z ` (if C = 0 then {} else {0}).\n       MPoly_Type.coeff (liftPoly 0 z (Const C)) m *\n       (\\<Prod>k\\<in>keys m. f k ^ lookup m k)) =\n    (\\<Sum>m\\<in>(if C = 0 then {} else {0}).\n       (C when m = 0) * (\\<Prod>k\\<in>keys m. f k ^ lookup m k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.coeff (liftPoly 0 z (Const C)) (lowerPowers 0 z 0) *\n    (\\<Prod>k\\<in>keys (lowerPowers 0 z 0).\n       f k ^ lookup (lowerPowers 0 z 0) k) =\n    C", "unfolding lower_power_zero[of 0 z] lookup_zero power.power_0 comm_monoid_mult_class.prod.neutral_const coeff_liftPoly coeff_Const"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> 0 \\<Longrightarrow>\n    (if \\<exists>j\\<in>{0..<0 + z}. 0 < 0 then 0\n     else C when higherPowers 0 z 0 = 0) *\n    1 =\n    C", "unfolding higherPowers_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> 0 \\<Longrightarrow>\n    (if \\<exists>j\\<in>{0..<0 + z}. 0 < 0 then 0\n     else C when\n          map_fun id (map_fun id (map_fun lookup Abs_poly_mapping))\n           (\\<lambda>b i p x. p (inc_above b i x)) 0 z 0 =\n          0) *\n    1 =\n    C", "by auto"], ["", "lemma liftPoly_sub: \"liftPoly 0 z (a - b) = (liftPoly 0 z a) - (liftPoly 0 z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 z (a - b) = liftPoly 0 z a - liftPoly 0 z b", "unfolding liftPoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 0\n     z (a - b) =\n    map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 0\n     z a -\n    map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 0\n     z b", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "have h1: \"mapping_of (a - b) = mapping_of a - mapping_of b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of (a - b) = mapping_of a - mapping_of b", "by (simp add: minus_mpoly.rep_eq)"], ["proof (state)\nthis:\n  mapping_of (a - b) = mapping_of a - mapping_of b\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "have h2: \"MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) = \n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) - MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "have h0a: \"higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) = (higherPoly\\<^sub>0 0 z (mapping_of a)) - (higherPoly\\<^sub>0 0 z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n    higherPoly\\<^sub>0 0 z (mapping_of a) -\n    higherPoly\\<^sub>0 0 z (mapping_of b)", "using poly_mapping_eq_iff[where a = \"higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)\", where b = \"(higherPoly\\<^sub>0 0 z (mapping_of a)) - (higherPoly\\<^sub>0 0 z (mapping_of b))\"]\n        minus_poly_mapping.rep_eq[where x = \"higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)\", where xa = \"(higherPoly\\<^sub>0 0 z (mapping_of a)) - (higherPoly\\<^sub>0 0 z (mapping_of b))\"]"], ["proof (prove)\nusing this:\n  (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n   higherPoly\\<^sub>0 0 z (mapping_of a) -\n   higherPoly\\<^sub>0 0 z (mapping_of b)) =\n  (lookup (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n   lookup\n    (higherPoly\\<^sub>0 0 z (mapping_of a) -\n     higherPoly\\<^sub>0 0 z (mapping_of b)))\n  lookup\n   (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) -\n    (higherPoly\\<^sub>0 0 z (mapping_of a) -\n     higherPoly\\<^sub>0 0 z (mapping_of b))) =\n  (\\<lambda>k.\n      lookup (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) k -\n      lookup\n       (higherPoly\\<^sub>0 0 z (mapping_of a) -\n        higherPoly\\<^sub>0 0 z (mapping_of b))\n       k)\n\ngoal (1 subgoal):\n 1. higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n    higherPoly\\<^sub>0 0 z (mapping_of a) -\n    higherPoly\\<^sub>0 0 z (mapping_of b)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup\n              (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) -\n               (higherPoly\\<^sub>0 0 z (mapping_of a) -\n                higherPoly\\<^sub>0 0 z (mapping_of b))) =\n             (\\<lambda>k.\n                 lookup\n                  (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) k -\n                 lookup\n                  (higherPoly\\<^sub>0 0 z (mapping_of a) -\n                   higherPoly\\<^sub>0 0 z (mapping_of b))\n                  k);\n     higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) \\<noteq>\n     higherPoly\\<^sub>0 0 z (mapping_of a) -\n     higherPoly\\<^sub>0 0 z (mapping_of b);\n     lookup (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) \\<noteq>\n     lookup\n      (higherPoly\\<^sub>0 0 z (mapping_of a) -\n       higherPoly\\<^sub>0 0 z (mapping_of b))\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: higherPoly\\<^sub>0.rep_eq poly_mapping_eqI minus_poly_mapping.rep_eq)"], ["proof (state)\nthis:\n  higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n  higherPoly\\<^sub>0 0 z (mapping_of a) -\n  higherPoly\\<^sub>0 0 z (mapping_of b)\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "then"], ["proof (chain)\npicking this:\n  higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n  higherPoly\\<^sub>0 0 z (mapping_of a) -\n  higherPoly\\<^sub>0 0 z (mapping_of b)", "show ?thesis"], ["proof (prove)\nusing this:\n  higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b) =\n  higherPoly\\<^sub>0 0 z (mapping_of a) -\n  higherPoly\\<^sub>0 0 z (mapping_of b)\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "by (simp add: minus_mpoly.abs_eq)"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "show \"MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "using h1 h2"], ["proof (prove)\nusing this:\n  mapping_of (a - b) = mapping_of a - mapping_of b\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a - mapping_of b)) =\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\n\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n    MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))", "by auto"], ["proof (state)\nthis:\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of (a - b))) =\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of a)) -\n  MPoly (higherPoly\\<^sub>0 0 z (mapping_of b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_sub : \"insertion (f::nat\\<Rightarrow>real) (liftPoly 0 z (a - b)) = insertion f (liftPoly 0 z a - liftPoly 0 z b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (a - b)) =\n    insertion f (liftPoly 0 z a - liftPoly 0 z b)", "using liftPoly_sub[of \"z\" \"a\" \"b\"]"], ["proof (prove)\nusing this:\n  liftPoly 0 z (a - b) = liftPoly 0 z a - liftPoly 0 z b\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (a - b)) =\n    insertion f (liftPoly 0 z a - liftPoly 0 z b)", "by auto"], ["", "lemma lift_minus : \n  assumes \"insertion (f::nat \\<Rightarrow> real) (liftPoly 0 z (c - Const (C::real))) = 0\"\n  shows \"insertion f (liftPoly 0 z c) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "have \"insertion f (liftPoly 0 z (c - Const C)) = insertion f ((liftPoly 0 z c) - (liftPoly 0 z (Const C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z (c - Const C)) =\n    insertion f (liftPoly 0 z c - liftPoly 0 z (Const C))", "by (simp add: lift_sub)"], ["proof (state)\nthis:\n  insertion f (liftPoly 0 z (c - Const C)) =\n  insertion f (liftPoly 0 z c - liftPoly 0 z (Const C))\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "have \"... = insertion f (liftPoly 0 z c) - (insertion f (liftPoly 0 z (Const C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c - liftPoly 0 z (Const C)) =\n    insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C))", "using insertion_sub"], ["proof (prove)\nusing this:\n  insertion ?f (?A - ?B) = insertion ?f ?A - insertion ?f ?B\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c - liftPoly 0 z (Const C)) =\n    insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C))", "by auto"], ["proof (state)\nthis:\n  insertion f (liftPoly 0 z c - liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C))\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "also"], ["proof (state)\nthis:\n  insertion f (liftPoly 0 z c - liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C))\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "have \"... = insertion f (liftPoly 0 z c) - C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n    insertion f (liftPoly 0 z c) - C", "using lift_const[of f z C] insertion_const"], ["proof (prove)\nusing this:\n  insertion f (liftPoly 0 z (Const C)) = insertion f (Const C)\n  insertion ?f (Const ?c) = ?c\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n    insertion f (liftPoly 0 z c) - C", "by auto"], ["proof (state)\nthis:\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - C\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "then"], ["proof (chain)\npicking this:\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - C", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - C\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "using \\<open>insertion f (liftPoly 0 z (c - Const C)) = insertion f (liftPoly 0 z c - liftPoly 0 z (Const C))\\<close> assms calculation"], ["proof (prove)\nusing this:\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - C\n  insertion f (liftPoly 0 z (c - Const C)) =\n  insertion f (liftPoly 0 z c - liftPoly 0 z (Const C))\n  insertion f (liftPoly 0 z (c - Const C)) = 0\n  insertion f (liftPoly 0 z c - liftPoly 0 z (Const C)) =\n  insertion f (liftPoly 0 z c) - insertion f (liftPoly 0 z (Const C))\n\ngoal (1 subgoal):\n 1. insertion f (liftPoly 0 z c) = C", "by auto"], ["proof (state)\nthis:\n  insertion f (liftPoly 0 z c) = C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lift00 : \"liftPoly 0 0 (a::real mpoly) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 0 a = a", "unfolding liftPoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun id (map_fun mapping_of MPoly)) higherPoly\\<^sub>0 0\n     0 a =\n    a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (higherPoly\\<^sub>0 0 0 (mapping_of a)) = a", "unfolding higherPoly\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly\n     (map_fun id (map_fun id (map_fun lookup Abs_poly_mapping))\n       (\\<lambda>b i mp mon.\n           if \\<exists>j\\<in>{b..<b + i}. 0 < lookup mon j then 0\n           else mp (higherPowers b i mon))\n       0 0 (mapping_of a)) =\n    a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>mon. lookup (mapping_of a) (higherPowers 0 0 mon))) =\n    a", "unfolding higherPowers_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly\n     (Abs_poly_mapping\n       (\\<lambda>mon.\n           lookup (mapping_of a)\n            (map_fun id (map_fun id (map_fun lookup Abs_poly_mapping))\n              (\\<lambda>b i p x. p (inc_above b i x)) 0 0 mon))) =\n    a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly (mapping_of a) = a", "by (simp add: mapping_of_inverse)"], ["", "end"]]}