{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/NegInfinity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma freeIn_allzero : \"freeIn var (allZero p var)\"", "lemma allzero_eval :\n  assumes lLength : \"var < length L\"\n  shows\"(\\<exists>x. \\<forall>y<x. aEval (Eq p) (list_update L var y) ) = (\\<forall>x. eval (allZero p var) (list_update L var x))\"", "lemma freeIn_altNegInf : \"freeIn var (alternateNegInfinity p var)\"", "theorem freeIn_substNegInfinity : \"freeIn var (substNegInfinity var A)\""], "translations": [["", "lemma freeIn_allzero : \"freeIn var (allZero p var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (allZero p var)", "by (simp add: not_in_isovarspar freeIn_list_conj)"], ["", "lemma allzero_eval :\n  assumes lLength : \"var < length L\"\n  shows\"(\\<exists>x. \\<forall>y<x. aEval (Eq p) (list_update L var y) ) = (\\<forall>x. eval (allZero p var) (list_update L var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "define n where \"n = MPoly_Type.degree p var\""], ["proof (state)\nthis:\n  n = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "define k where \"k i x =((insertion (nth_default 0(list_update L var x)) (isolate_variable_sparse p var i)))\" for i x"], ["proof (state)\nthis:\n  k ?i ?x =\n  insertion (nth_default 0 (L[var := ?x]))\n   (isolate_variable_sparse p var ?i)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "{"], ["proof (state)\nthis:\n  k ?i ?x =\n  insertion (nth_default 0 (L[var := ?x]))\n   (isolate_variable_sparse p var ?i)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"(eval (allZero p var) (list_update L var x)) =\n        (\\<forall>i\\<in>{0..<(MPoly_Type.degree p var)+1}. aEval (Eq(isolate_variable_sparse p var i)) (list_update L var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (L[var := x]) =\n    (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n        aEval (Eq (isolate_variable_sparse p var i)) (L[var := x]))", "by (simp add: eval_list_conj atLeast0_lessThan_Suc)"], ["proof (state)\nthis:\n  eval (allZero p var) (L[var := x]) =\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      aEval (Eq (isolate_variable_sparse p var i)) (L[var := x]))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  eval (allZero p var) (L[var := x]) =\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      aEval (Eq (isolate_variable_sparse p var i)) (L[var := x]))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<forall>i\\<in>{0..<(MPoly_Type.degree p var)+1}. (insertion (nth_default 0(list_update L var x)) (isolate_variable_sparse p var i))=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n        aEval (Eq (isolate_variable_sparse p var i)) (L[var := x])) =\n    (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) =\n        0)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      aEval (Eq (isolate_variable_sparse p var i)) (L[var := x])) =\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      aEval (Eq (isolate_variable_sparse p var i)) (L[var := x])) =\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<forall>i\\<le>(MPoly_Type.degree p var). (insertion (nth_default 0(list_update L var x)) (isolate_variable_sparse p var i))=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) =\n        0) =\n    (\\<forall>i\\<le>MPoly_Type.degree p var.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) =\n        0)", "by fastforce"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0) =\n  (\\<forall>i\\<le>MPoly_Type.degree p var.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{0..<MPoly_Type.degree p var + 1}.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0) =\n  (\\<forall>i\\<le>MPoly_Type.degree p var.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<forall>y. (\\<Sum>i\\<le>(MPoly_Type.degree p var). ((insertion (nth_default 0(list_update L var x)) (isolate_variable_sparse p var i)) * y ^ i))=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<le>MPoly_Type.degree p var.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) =\n        0) =\n    (\\<forall>y.\n        (\\<Sum>i\\<le>MPoly_Type.degree p var.\n            insertion (nth_default 0 (L[var := x]))\n             (isolate_variable_sparse p var i) *\n            y ^ i) =\n        0)", "using polyfun_eq_const[where n=\"MPoly_Type.degree p var\", where k=\"0\", where c=\"\\<lambda>i. (insertion (nth_default 0(list_update L var x)) (isolate_variable_sparse p var i))\"]"], ["proof (prove)\nusing this:\n  (\\<forall>z.\n      (\\<Sum>i\\<le>MPoly_Type.degree p var.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) *\n          z ^ i) =\n      0) =\n  (insertion (nth_default 0 (L[var := x]))\n    (isolate_variable_sparse p var 0) =\n   0 \\<and>\n   (\\<forall>k.\n       k \\<noteq> 0 \\<and> k \\<le> MPoly_Type.degree p var \\<longrightarrow>\n       insertion (nth_default 0 (L[var := x]))\n        (isolate_variable_sparse p var k) =\n       0))\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<le>MPoly_Type.degree p var.\n        insertion (nth_default 0 (L[var := x]))\n         (isolate_variable_sparse p var i) =\n        0) =\n    (\\<forall>y.\n        (\\<Sum>i\\<le>MPoly_Type.degree p var.\n            insertion (nth_default 0 (L[var := x]))\n             (isolate_variable_sparse p var i) *\n            y ^ i) =\n        0)", "by (metis (no_types, lifting) le_add2 le_add_same_cancel2)"], ["proof (state)\nthis:\n  (\\<forall>i\\<le>MPoly_Type.degree p var.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0) =\n  (\\<forall>y.\n      (\\<Sum>i\\<le>MPoly_Type.degree p var.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) *\n          y ^ i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<forall>i\\<le>MPoly_Type.degree p var.\n      insertion (nth_default 0 (L[var := x]))\n       (isolate_variable_sparse p var i) =\n      0) =\n  (\\<forall>y.\n      (\\<Sum>i\\<le>MPoly_Type.degree p var.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) *\n          y ^ i) =\n      0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y.\n        (\\<Sum>i\\<le>MPoly_Type.degree p var.\n            insertion (nth_default 0 (L[var := x]))\n             (isolate_variable_sparse p var i) *\n            y ^ i) =\n        0) =\n    (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "using k_def n_def"], ["proof (prove)\nusing this:\n  k ?i ?x =\n  insertion (nth_default 0 (L[var := ?x]))\n   (isolate_variable_sparse p var ?i)\n  n = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. (\\<forall>y.\n        (\\<Sum>i\\<le>MPoly_Type.degree p var.\n            insertion (nth_default 0 (L[var := x]))\n             (isolate_variable_sparse p var i) *\n            y ^ i) =\n        0) =\n    (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>y.\n      (\\<Sum>i\\<le>MPoly_Type.degree p var.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) *\n          y ^ i) =\n      0) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "finally"], ["proof (chain)\npicking this:\n  eval (allZero p var) (L[var := x]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "have  \"(eval (allZero p var) (list_update L var x)) = (\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0)\""], ["proof (prove)\nusing this:\n  eval (allZero p var) (L[var := x]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (L[var := x]) =\n    (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "by simp"], ["proof (state)\nthis:\n  eval (allZero p var) (L[var := x]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "}"], ["proof (state)\nthis:\n  eval (allZero p var) (L[var := ?x2]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i ?x2 * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  eval (allZero p var) (L[var := ?x2]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i ?x2 * y ^ i) = 0)", "have h1 : \"(\\<forall>x. (eval (allZero p var) (list_update L var x))) = (\\<forall>x.(\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0))\""], ["proof (prove)\nusing this:\n  eval (allZero p var) (L[var := ?x2]) =\n  (\\<forall>y. (\\<Sum>i\\<le>n. k i ?x2 * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. eval (allZero p var) (L[var := x])) =\n    (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x. eval (allZero p var) (L[var := x])) =\n  (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"(\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0) = (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>(MPoly_Type.degree p var). (insertion (nth_default 0 (list_update L var x))(isolate_variable_sparse p var i))* x^i)= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n    (\\<exists>y.\n        \\<forall>x<y.\n           (\\<Sum>i\\<le>MPoly_Type.degree p var.\n               insertion (nth_default 0 (L[var := x]))\n                (isolate_variable_sparse p var i) *\n               x ^ i) =\n           0)", "using k_def n_def"], ["proof (prove)\nusing this:\n  k ?i ?x =\n  insertion (nth_default 0 (L[var := ?x]))\n   (isolate_variable_sparse p var ?i)\n  n = MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n    (\\<exists>y.\n        \\<forall>x<y.\n           (\\<Sum>i\\<le>MPoly_Type.degree p var.\n               insertion (nth_default 0 (L[var := x]))\n                (isolate_variable_sparse p var i) *\n               x ^ i) =\n           0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<exists>y.\n      \\<forall>x<y.\n         (\\<Sum>i\\<le>MPoly_Type.degree p var.\n             insertion (nth_default 0 (L[var := x]))\n              (isolate_variable_sparse p var i) *\n             x ^ i) =\n         0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<exists>y.\n      \\<forall>x<y.\n         (\\<Sum>i\\<le>MPoly_Type.degree p var.\n             insertion (nth_default 0 (L[var := x]))\n              (isolate_variable_sparse p var i) *\n             x ^ i) =\n         0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<exists>y. \\<forall>x<y. insertion (nth_default 0 (list_update L var x)) (\\<Sum>i\\<le>(MPoly_Type.degree p var). (isolate_variable_sparse p var i)* Var var^i)= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        \\<forall>x<y.\n           (\\<Sum>i\\<le>MPoly_Type.degree p var.\n               insertion (nth_default 0 (L[var := x]))\n                (isolate_variable_sparse p var i) *\n               x ^ i) =\n           0) =\n    (\\<exists>y.\n        \\<forall>x<y.\n           insertion (nth_default 0 (L[var := x]))\n            (\\<Sum>i\\<le>MPoly_Type.degree p var.\n                isolate_variable_sparse p var i * Var var ^ i) =\n           0)", "by(simp add: insertion_sum' insertion_mult insertion_pow insertion_var lLength)"], ["proof (state)\nthis:\n  (\\<exists>y.\n      \\<forall>x<y.\n         (\\<Sum>i\\<le>MPoly_Type.degree p var.\n             insertion (nth_default 0 (L[var := x]))\n              (isolate_variable_sparse p var i) *\n             x ^ i) =\n         0) =\n  (\\<exists>y.\n      \\<forall>x<y.\n         insertion (nth_default 0 (L[var := x]))\n          (\\<Sum>i\\<le>MPoly_Type.degree p var.\n              isolate_variable_sparse p var i * Var var ^ i) =\n         0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<exists>y.\n      \\<forall>x<y.\n         (\\<Sum>i\\<le>MPoly_Type.degree p var.\n             insertion (nth_default 0 (L[var := x]))\n              (isolate_variable_sparse p var i) *\n             x ^ i) =\n         0) =\n  (\\<exists>y.\n      \\<forall>x<y.\n         insertion (nth_default 0 (L[var := x]))\n          (\\<Sum>i\\<le>MPoly_Type.degree p var.\n              isolate_variable_sparse p var i * Var var ^ i) =\n         0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<exists>y. \\<forall>x<y. insertion (nth_default 0 (list_update L var x)) p = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        \\<forall>x<y.\n           insertion (nth_default 0 (L[var := x]))\n            (\\<Sum>i\\<le>MPoly_Type.degree p var.\n                isolate_variable_sparse p var i * Var var ^ i) =\n           0) =\n    (\\<exists>y.\n        \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0)", "using sum_over_zero"], ["proof (prove)\nusing this:\n  ?mp =\n  (\\<Sum>i\\<le>MPoly_Type.degree ?mp ?x.\n      isolate_variable_sparse ?mp ?x i * Var ?x ^ i)\n\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        \\<forall>x<y.\n           insertion (nth_default 0 (L[var := x]))\n            (\\<Sum>i\\<le>MPoly_Type.degree p var.\n                isolate_variable_sparse p var i * Var var ^ i) =\n           0) =\n    (\\<exists>y.\n        \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>y.\n      \\<forall>x<y.\n         insertion (nth_default 0 (L[var := x]))\n          (\\<Sum>i\\<le>MPoly_Type.degree p var.\n              isolate_variable_sparse p var i * Var var ^ i) =\n         0) =\n  (\\<exists>y. \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "also"], ["proof (state)\nthis:\n  (\\<exists>y.\n      \\<forall>x<y.\n         insertion (nth_default 0 (L[var := x]))\n          (\\<Sum>i\\<le>MPoly_Type.degree p var.\n              isolate_variable_sparse p var i * Var var ^ i) =\n         0) =\n  (\\<exists>y. \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have \"... = (\\<exists>y. \\<forall>x<y. aEval (Eq p) (list_update L var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0) =\n    (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x]))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>y.\n      \\<forall>x<y. insertion (nth_default 0 (L[var := x])) p = 0) =\n  (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x]))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x]))", "have h2 : \"(\\<exists>y. \\<forall>x<y. aEval (Eq p) (list_update L var x)) = (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0)\""], ["proof (prove)\nusing this:\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x]))\n\ngoal (1 subgoal):\n 1. (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x])) =\n    (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x])) =\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have k_all : \"\\<forall>x y i. k i x = k i y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y i. k i x = k i y", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y i.\n       insertion (nth_default 0 (L[var := x]))\n        (isolate_variable_sparse p var i) =\n       insertion (nth_default 0 (L[var := y]))\n        (isolate_variable_sparse p var i)", "by (simp add: insertion_isovarspars_free)"], ["proof (state)\nthis:\n  \\<forall>x y i. k i x = k i y\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have h3a : \"(\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0) \\<Longrightarrow> (\\<forall>x.(\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "assume h : \"(\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0)\""], ["proof (state)\nthis:\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "{"], ["proof (state)\nthis:\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "fix z y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "assume h : \"(\\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0)\""], ["proof (state)\nthis:\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "have \"\\<forall>x<y.\\<forall>i\\<le>n. k i x = k i z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<y. \\<forall>i\\<le>n. k i x = k i z", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<y.\n       \\<forall>i\\<le>n.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) =\n          insertion (nth_default 0 (L[var := z]))\n           (isolate_variable_sparse p var i)", "using insertion_isovarspars_free"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (?L[?var := ?x]))\n   (isolate_variable_sparse ?p ?var ?i) =\n  insertion (nth_default 0 (?L[?var := ?y]))\n   (isolate_variable_sparse ?p ?var ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>x<y.\n       \\<forall>i\\<le>n.\n          insertion (nth_default 0 (L[var := x]))\n           (isolate_variable_sparse p var i) =\n          insertion (nth_default 0 (L[var := z]))\n           (isolate_variable_sparse p var i)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x = k i z\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x = k i z", "have * : \"\\<forall>x<y.\\<forall>i\\<le>n. k i x * x ^ i = k i z * x^i\""], ["proof (prove)\nusing this:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x = k i z\n\ngoal (1 subgoal):\n 1. \\<forall>x<y. \\<forall>i\\<le>n. k i x * x ^ i = k i z * x ^ i", "by auto"], ["proof (state)\nthis:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x * x ^ i = k i z * x ^ i\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x * x ^ i = k i z * x ^ i", "have \"\\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)\""], ["proof (prove)\nusing this:\n  \\<forall>x<y. \\<forall>i\\<le>n. k i x * x ^ i = k i z * x ^ i\n\ngoal (1 subgoal):\n 1. \\<forall>x<y.\n       (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)", "by (metis (no_types, lifting) k_all sum.cong)"], ["proof (state)\nthis:\n  \\<forall>x<y.\n     (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x<y.\n     (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)", "have \"\\<forall>x<y. (\\<Sum>i\\<le>n. (k i z)* x^i)= 0\""], ["proof (prove)\nusing this:\n  \\<forall>x<y.\n     (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)\n\ngoal (1 subgoal):\n 1. \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "using h"], ["proof (prove)\nusing this:\n  \\<forall>x<y.\n     (\\<Sum>i\\<le>n. k i x * x ^ i) = (\\<Sum>i\\<le>n. k i z * x ^ i)\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "have \"\\<not>(finite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0})\""], ["proof (prove)\nusing this:\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}", "using infinite_Iio[where a=\"y\"]  Inf_many_def[where P=\"\\<lambda>x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\"]"], ["proof (prove)\nusing this:\n  \\<forall>x<y. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n  infinite {..<y}\n  (\\<exists>\\<^sub>\\<infinity>x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0) =\n  infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}\n\ngoal (1 subgoal):\n 1. infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}", "by (smt INFM_iff_infinite frequently_mono lessThan_def)"], ["proof (state)\nthis:\n  infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}", "have \"\\<forall>i\\<le>n. k i z = 0\""], ["proof (prove)\nusing this:\n  infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. k i z = 0", "using  polyfun_rootbound[where n=\"n\",  where c = \"\\<lambda>i. k i z\" ]"], ["proof (prove)\nusing this:\n  infinite {x. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0}\n  \\<exists>ka\\<le>n. k ka z \\<noteq> 0 \\<Longrightarrow>\n  finite {za. (\\<Sum>i\\<le>n. k i z * za ^ i) = 0} \\<and>\n  card {za. (\\<Sum>i\\<le>n. k i z * za ^ i) = 0} \\<le> n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. k i z = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. k i z = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "}"], ["proof (state)\nthis:\n  \\<forall>x<?y2. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>i\\<le>n. k i ?z2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x<?y2. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>i\\<le>n. k i ?z2 = 0", "have \"\\<forall>x.\\<forall>i\\<le>n. k i x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x<?y2. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>i\\<le>n. k i ?z2 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0", "using h"], ["proof (prove)\nusing this:\n  \\<forall>x<?y2. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>i\\<le>n. k i ?z2 = 0\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0", "by (meson gt_ex)"], ["proof (state)\nthis:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n    \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y.\n     \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have h3b : \"(\\<forall>x.(\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0)) \\<Longrightarrow> (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "assume h : \"(\\<forall>x.(\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0))\""], ["proof (state)\nthis:\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "{"], ["proof (state)\nthis:\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "fix z y x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "have \"(\\<Sum>i\\<le>n. (k i z)* x^i)= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "using h k_all"], ["proof (prove)\nusing this:\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n  \\<forall>x y i. k i x = k i y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>n. k i z * x ^ i) = 0", "have \"\\<forall>i\\<le>n. k i z = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. k i z = 0", "using polyfun_eq_const[where k=\"0\", where c = \"\\<lambda>i. k i z\", where n=\"n\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n. k i z * x ^ i) = 0\n  (\\<forall>za. (\\<Sum>i\\<le>n. k i z * za ^ i) = 0) =\n  (k 0 z = 0 \\<and>\n   (\\<forall>ka.\n       ka \\<noteq> 0 \\<and> ka \\<le> n \\<longrightarrow> k ka z = 0))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. k i z = 0", "by (metis h)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. k i z = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "}"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. k i ?z2 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. k i ?z2 = 0", "have \"\\<forall>x.\\<forall>i\\<le>n. k i x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. k i ?z2 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0", "by (meson gt_ex)"], ["proof (state)\nthis:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n    \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x i. i \\<le> n \\<longrightarrow> k i x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0", "by simp"], ["proof (state)\nthis:\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "have h3 : \"(\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. (k i x)* x^i)= 0) = (\\<forall>x.(\\<forall>y. (\\<Sum>i\\<le>n. (k i x) * y ^ i)=0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n    (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "using h3a h3b"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0 \\<Longrightarrow>\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0\n  \\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0 \\<Longrightarrow>\n  \\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n    (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  (\\<forall>x. eval (allZero p var) (L[var := x])) =\n  (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n  (\\<exists>y. \\<forall>x<y. aEval (Eq p) (L[var := x])) =\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0)\n  (\\<exists>y. \\<forall>x<y. (\\<Sum>i\\<le>n. k i x * x ^ i) = 0) =\n  (\\<forall>x y. (\\<Sum>i\\<le>n. k i x * y ^ i) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n    (\\<forall>x. eval (allZero p var) (L[var := x]))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. \\<forall>y<x. aEval (Eq p) (L[var := y])) =\n  (\\<forall>x. eval (allZero p var) (L[var := x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_altNegInf : \"freeIn var (alternateNegInfinity p var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "have h1 : \"\\<forall>i. var \\<notin> (vars (if (i::nat) mod 2 = 0 then (Const(1)::real mpoly) else (Const(-1)::real mpoly)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       var \\<notin> vars (if i mod 2 = 0 then Const 1 else Const (- 1))", "using var_not_in_Const[where var = \"var\", where x=\"1\"] var_not_in_Const[where var = \"var\", where x=\"-1\"]"], ["proof (prove)\nusing this:\n  var \\<notin> vars (Const 1)\n  var \\<notin> vars (Const (- 1))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       var \\<notin> vars (if i mod 2 = 0 then Const 1 else Const (- 1))", "by simp"], ["proof (state)\nthis:\n  \\<forall>i.\n     var \\<notin> vars (if i mod 2 = 0 then Const 1 else Const (- 1))\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "define g where \"g = (\\<lambda>F.\\<lambda>i.\n    let a_n = isolate_variable_sparse p var i in\n    let exp = (if i mod 2 = 0 then Const(1) else Const(-1)) in\n      or (Atom(Less (exp * a_n)))\n        (and (Atom (Eq a_n)) F)\n    )\""], ["proof (state)\nthis:\n  g =\n  (\\<lambda>F i.\n      let a_n = isolate_variable_sparse p var i;\n          exp = if i mod 2 = 0 then Const 1 else Const (- 1)\n      in or (fm.Atom (Less (exp * a_n))) (and (fm.Atom (Eq a_n)) F))\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "have h3 : \"\\<forall>i. \\<forall>F. (freeIn var F \\<longrightarrow> freeIn var (g F i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i F. freeIn var F \\<longrightarrow> freeIn var (g F i)", "using g_def h1"], ["proof (prove)\nusing this:\n  g =\n  (\\<lambda>F i.\n      let a_n = isolate_variable_sparse p var i;\n          exp = if i mod 2 = 0 then Const 1 else Const (- 1)\n      in or (fm.Atom (Less (exp * a_n))) (and (fm.Atom (Eq a_n)) F))\n  \\<forall>i.\n     var \\<notin> vars (if i mod 2 = 0 then Const 1 else Const (- 1))\n\ngoal (1 subgoal):\n 1. \\<forall>i F. freeIn var F \\<longrightarrow> freeIn var (g F i)", "by (smt PolyAtoms.and_def not_in_isovarspar PolyAtoms.or_def freeIn.simps(1) freeIn.simps(2) freeIn.simps(7) freeIn.simps(8) not_in_mult)"], ["proof (state)\nthis:\n  \\<forall>i F. freeIn var F \\<longrightarrow> freeIn var (g F i)\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "define L where \"L = ([0..<((MPoly_Type.degree p var)+1)])\""], ["proof (state)\nthis:\n  L = [0..<MPoly_Type.degree p var + 1]\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "have \"\\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl (g::atom fm \\<Rightarrow> nat \\<Rightarrow> atom fm) F (L::nat list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F [])\n 2. \\<And>a L.\n       \\<forall>F.\n          freeIn var F \\<longrightarrow>\n          freeIn var (foldl g F L) \\<Longrightarrow>\n       \\<forall>F.\n          freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F [])\n 2. \\<And>a L.\n       \\<forall>F.\n          freeIn var F \\<longrightarrow>\n          freeIn var (foldl g F L) \\<Longrightarrow>\n       \\<forall>F.\n          freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F [])", "by simp"], ["proof (state)\nthis:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F [])\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>F.\n          freeIn var F \\<longrightarrow>\n          freeIn var (foldl g F L) \\<Longrightarrow>\n       \\<forall>F.\n          freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>F.\n          freeIn var F \\<longrightarrow>\n          freeIn var (foldl g F L) \\<Longrightarrow>\n       \\<forall>F.\n          freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "case (Cons a L)"], ["proof (state)\nthis:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<forall>F.\n          freeIn var F \\<longrightarrow>\n          freeIn var (foldl g F L) \\<Longrightarrow>\n       \\<forall>F.\n          freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "then"], ["proof (chain)\npicking this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n\ngoal (1 subgoal):\n 1. \\<forall>F.\n       freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "using h3"], ["proof (prove)\nusing this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n  \\<forall>i F. freeIn var F \\<longrightarrow> freeIn var (g F i)\n\ngoal (1 subgoal):\n 1. \\<forall>F.\n       freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))", "by simp"], ["proof (state)\nthis:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F (a # L))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "then"], ["proof (chain)\npicking this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)", "have \"freeIn var (foldl g FalseF L)\""], ["proof (prove)\nusing this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n\ngoal (1 subgoal):\n 1. freeIn var (foldl g FalseF L)", "using freeIn.simps(6)"], ["proof (prove)\nusing this:\n  \\<forall>F. freeIn var F \\<longrightarrow> freeIn var (foldl g F L)\n  freeIn ?var FalseF = True\n\ngoal (1 subgoal):\n 1. freeIn var (foldl g FalseF L)", "by blast"], ["proof (state)\nthis:\n  freeIn var (foldl g FalseF L)\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "then"], ["proof (chain)\npicking this:\n  freeIn var (foldl g FalseF L)", "show ?thesis"], ["proof (prove)\nusing this:\n  freeIn var (foldl g FalseF L)\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "using g_def L_def"], ["proof (prove)\nusing this:\n  freeIn var (foldl g FalseF L)\n  g =\n  (\\<lambda>F i.\n      let a_n = isolate_variable_sparse p var i;\n          exp = if i mod 2 = 0 then Const 1 else Const (- 1)\n      in or (fm.Atom (Less (exp * a_n))) (and (fm.Atom (Eq a_n)) F))\n  L = [0..<MPoly_Type.degree p var + 1]\n\ngoal (1 subgoal):\n 1. freeIn var (alternateNegInfinity p var)", "by simp"], ["proof (state)\nthis:\n  freeIn var (alternateNegInfinity p var)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem freeIn_substNegInfinity : \"freeIn var (substNegInfinity var A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substNegInfinity var A)", "apply(cases A)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow> freeIn var (substNegInfinity var A)", "using freeIn_altNegInf freeIn_allzero"], ["proof (prove)\nusing this:\n  freeIn ?var (alternateNegInfinity ?p ?var)\n  freeIn ?var (allZero ?p ?var)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       A = Less x1 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 2. \\<And>x2.\n       A = Eq x2 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 3. \\<And>x3.\n       A = Leq x3 \\<Longrightarrow> freeIn var (substNegInfinity var A)\n 4. \\<And>x4.\n       A = Neq x4 \\<Longrightarrow> freeIn var (substNegInfinity var A)", "by simp_all"], ["", "end"]]}