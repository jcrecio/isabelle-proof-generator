{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/MPolyExtension.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma coeff_code[code]: \"coeff = coeff_code\"", "lemma coeff_transfer[transfer_rule]:\\<comment> \\<open>TODO: coeff should be defined via\nlifting, this gives us the illusion\\<close>\n  \"rel_fun cr_mpoly (=) lookup coeff\"", "lemmas coeff_add = coeff_add[symmetric]", "lemma plus_monom_zero[simp]: \"p + MPoly_Type.monom m 0 = p\"", "lemma mpoly_induct [case_names monom sum]:\\<comment> \\<open>TODO: overwrites @{thm\nmpoly_induct}\\<close>\n  assumes monom:\"\\<And>m a. P (MPoly_Type.monom m a)\"\n    and sum:\"(\\<And>p1 p2 m a. P p1 \\<Longrightarrow> P p2 \\<Longrightarrow> p2 = (MPoly_Type.monom m a) \\<Longrightarrow> m \\<notin> monomials p1\n\\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> P (p1+p2))\"\n  shows \"P p\"", "lemma Sum_any_lookup_times_eq:\n  \"(\\<Sum>k. ((lookup (x::'a\\<Rightarrow>\\<^sub>0('b::comm_semiring_1)) (k::'a)) * ((f:: 'a\\<Rightarrow>('b::comm_semiring_1)) k))) = (\\<Sum>k\\<in>keys\nx. (lookup x (k::'a)) * (f k))\"", "lemma Prod_any_power_lookup_eq:\n  \"(\\<Prod>k::'a. f k ^ lookup (x::'a\\<Rightarrow>\\<^sub>0nat) k) = (\\<Prod>k\\<in>keys x. f k ^ lookup x k)\"", "lemma insertion_monom: \"insertion i (monom m a) = a * (\\<Prod>k\\<in>keys m. i k ^\nlookup m k)\"", "lemma monomials_monom[simp]: \"monomials (monom m a) = (if a = 0 then {}\nelse {m})\"", "lemma finite_monomials[simp]: \"finite (monomials m)\"", "lemma monomials_add_disjoint:\n  \"monomials (a + b) = monomials a \\<union> monomials b\" if \"monomials a \\<inter>\nmonomials b = {}\"", "lemma coeff_monom[simp]: \"coeff (monom m a) m = a\"", "lemma coeff_not_in_monomials[simp]: \"coeff m x = 0\" if \"x \\<notin> monomials m\"", "lemma insertion_code[code]: \"insertion i mp =\n   (\\<Sum>m\\<in>monomials mp. (coeff mp m) * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))\"", "lemma Poly_Mapping_update_code[code]: \"Poly_Mapping.update a b (Pm_fmap\nfm) = Pm_fmap (fmupd a b fm)\"", "lemma monom_zero [simp] : \"monom m 0 = 0\"", "lemma remove_key_code[code]: \"remove_key v (Pm_fmap fm) = Pm_fmap\n(fmdrop v fm)\"", "lemma extract_var_code[code]:\n  \"extract_var p v =\n     (\\<Sum>m\\<in>monomials p. monom (remove_key v m) (monom (Poly_Mapping.single\nv (lookup m v)) (coeff p m)))\"", "lemma vars_code[code]: \"vars p = \\<Union> (keys ` monomials p)\"", "lemma insertionNegative : \"insertion f p = - insertion f (-p)\""], "translations": [["", "lemma coeff_code[code]: \"coeff = coeff_code\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff = coeff_code", "unfolding coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. lookup (mapping_of p)) = coeff_code", "apply(transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup = lookup", "by auto"], ["", "lemma coeff_transfer[transfer_rule]:\\<comment> \\<open>TODO: coeff should be defined via\nlifting, this gives us the illusion\\<close>\n  \"rel_fun cr_mpoly (=) lookup coeff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_mpoly (=) lookup coeff", "using coeff_code.transfer[folded\n      coeff_code]"], ["proof (prove)\nusing this:\n  rel_fun cr_mpoly (=) lookup coeff\n\ngoal (1 subgoal):\n 1. rel_fun cr_mpoly (=) lookup coeff", "."], ["", "lemmas coeff_add = coeff_add[symmetric]"], ["", "lemma plus_monom_zero[simp]: \"p + MPoly_Type.monom m 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + monom m (0::'a) = p", "by transfer auto"], ["", "lift_definition monomials::\"'a::zero mpoly \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat) set\" is\n  \"Poly_Mapping.keys::((nat\\<Rightarrow>\\<^sub>0nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> _ set\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma mpoly_induct [case_names monom sum]:\\<comment> \\<open>TODO: overwrites @{thm\nmpoly_induct}\\<close>\n  assumes monom:\"\\<And>m a. P (MPoly_Type.monom m a)\"\n    and sum:\"(\\<And>p1 p2 m a. P p1 \\<Longrightarrow> P p2 \\<Longrightarrow> p2 = (MPoly_Type.monom m a) \\<Longrightarrow> m \\<notin> monomials p1\n\\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> P (p1+p2))\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using assms"], ["proof (prove)\nusing this:\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> monomials ?p1.0; ?a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)\n\ngoal (1 subgoal):\n 1. P p", "proof (induction p rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>m a. P (monom m a);\n        \\<And>p1 p2 m a.\n           \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n            a \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> P (monom m a)\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>\\<lbrakk>\\<And>m a. P (monom m a);\n                 \\<And>p1 p2 m a.\n                    \\<lbrakk>P p1; P p2; p2 = monom m a;\n                     m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n                    \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n                \\<Longrightarrow> P p1;\n        \\<lbrakk>\\<And>m a. P (monom m a);\n         \\<And>p1 p2 m a.\n            \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n             a \\<noteq> (0::'a)\\<rbrakk>\n            \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n        \\<Longrightarrow> P p2;\n        p2 = monom m a; m \\<notin> keys (mapping_of p1);\n        \\<And>m a. P (monom m a);\n        \\<And>p1 p2 m a.\n           \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n            a \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> P (p1 + p2)", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p1\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> monomials ?p1.0; ?a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>m a. P (monom m a);\n        \\<And>p1 p2 m a.\n           \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n            a \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> P (monom m a)\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>\\<lbrakk>\\<And>m a. P (monom m a);\n                 \\<And>p1 p2 m a.\n                    \\<lbrakk>P p1; P p2; p2 = monom m a;\n                     m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n                    \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n                \\<Longrightarrow> P p1;\n        \\<lbrakk>\\<And>m a. P (monom m a);\n         \\<And>p1 p2 m a.\n            \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n             a \\<noteq> (0::'a)\\<rbrakk>\n            \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n        \\<Longrightarrow> P p2;\n        p2 = monom m a; m \\<notin> keys (mapping_of p1);\n        \\<And>m a. P (monom m a);\n        \\<And>p1 p2 m a.\n           \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n            a \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> P (p1 + p2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p1\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> monomials ?p1.0; ?a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p1\n  \\<lbrakk>\\<And>m a. P (monom m a);\n   \\<And>p1 p2 m a.\n      \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n       a \\<noteq> (0::'a)\\<rbrakk>\n      \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n  \\<Longrightarrow> P p2\n  p2 = monom m a\n  m \\<notin> keys (mapping_of p1)\n  P (monom ?m ?a)\n  \\<lbrakk>P ?p1.0; P ?p2.0; ?p2.0 = monom ?m ?a;\n   ?m \\<notin> monomials ?p1.0; ?a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> P (?p1.0 + ?p2.0)\n\ngoal (1 subgoal):\n 1. P (p1 + p2)", "by (cases \"a = 0\") (auto simp: monomials.rep_eq)"], ["proof (state)\nthis:\n  P (p1 + p2)\n\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<And>m a. P (monom m a);\n        \\<And>p1 p2 m a.\n           \\<lbrakk>P p1; P p2; p2 = monom m a; m \\<notin> monomials p1;\n            a \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> P (p1 + p2)\\<rbrakk>\n       \\<Longrightarrow> P (monom m a)", "qed simp"], ["", "value \"monomials ((Var 0 + Const (3::int) * Var 1)^2)\""], ["", "lemma Sum_any_lookup_times_eq:\n  \"(\\<Sum>k. ((lookup (x::'a\\<Rightarrow>\\<^sub>0('b::comm_semiring_1)) (k::'a)) * ((f:: 'a\\<Rightarrow>('b::comm_semiring_1)) k))) = (\\<Sum>k\\<in>keys\nx. (lookup x (k::'a)) * (f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k. lookup x k * f k) = (\\<Sum>k\\<in>keys x. lookup x k * f k)", "by (subst Sum_any.conditionalize) (auto simp: in_keys_iff intro!:\n      Sum_any.cong)"], ["", "lemma Prod_any_power_lookup_eq:\n  \"(\\<Prod>k::'a. f k ^ lookup (x::'a\\<Rightarrow>\\<^sub>0nat) k) = (\\<Prod>k\\<in>keys x. f k ^ lookup x k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k. f k ^ lookup x k) = (\\<Prod>k\\<in>keys x. f k ^ lookup x k)", "by (subst Prod_any.conditionalize) (auto simp: in_keys_iff intro!:\n      Prod_any.cong)"], ["", "lemma insertion_monom: \"insertion i (monom m a) = a * (\\<Prod>k\\<in>keys m. i k ^\nlookup m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion i (monom m a) = a * (\\<Prod>k\\<in>keys m. i k ^ lookup m k)", "by transfer (auto simp: insertion_aux_def insertion_fun_def\n      Sum_any_lookup_times_eq Prod_any_power_lookup_eq)"], ["", "lemma monomials_monom[simp]: \"monomials (monom m a) = (if a = 0 then {}\nelse {m})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (monom m a) = (if a = (0::'a) then {} else {m})", "by transfer auto"], ["", "lemma finite_monomials[simp]: \"finite (monomials m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (monomials m)", "by transfer auto"], ["", "lemma monomials_add_disjoint:\n  \"monomials (a + b) = monomials a \\<union> monomials b\" if \"monomials a \\<inter>\nmonomials b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (a + b) = monomials a \\<union> monomials b", "using that"], ["proof (prove)\nusing this:\n  monomials a \\<inter> monomials b = {}\n\ngoal (1 subgoal):\n 1. monomials (a + b) = monomials a \\<union> monomials b", "by transfer (auto simp add: keys_plus_eqI)"], ["", "lemma coeff_monom[simp]: \"coeff (monom m a) m = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom m a) m = a", "by transfer simp"], ["", "lemma coeff_not_in_monomials[simp]: \"coeff m x = 0\" if \"x \\<notin> monomials m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff m x = (0::'a)", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> monomials m\n\ngoal (1 subgoal):\n 1. coeff m x = (0::'a)", "by transfer (simp add: in_keys_iff)"], ["", "code_thms insertion"], ["", "lemma insertion_code[code]: \"insertion i mp =\n   (\\<Sum>m\\<in>monomials mp. (coeff mp m) * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion i mp =\n    (\\<Sum>m\\<in>monomials mp.\n       coeff mp m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "proof (induction mp rule: mpoly_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion i (monom m a) =\n       (\\<Sum>ma\\<in>monomials (monom m a).\n          coeff (monom m a) ma * (\\<Prod>k\\<in>keys ma. i k ^ lookup ma k))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "case (monom m a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       insertion i (monom m a) =\n       (\\<Sum>ma\\<in>monomials (monom m a).\n          coeff (monom m a) ma * (\\<Prod>k\\<in>keys ma. i k ^ lookup ma k))\n 2. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion i (monom m a) =\n    (\\<Sum>ma\\<in>monomials (monom m a).\n       coeff (monom m a) ma * (\\<Prod>k\\<in>keys ma. i k ^ lookup ma k))", "by (simp add: insertion_monom)"], ["proof (state)\nthis:\n  insertion i (monom m a) =\n  (\\<Sum>ma\\<in>monomials (monom m a).\n     coeff (monom m a) ma * (\\<Prod>k\\<in>keys ma. i k ^ lookup ma k))\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "case (sum p1 p2 m a)"], ["proof (state)\nthis:\n  insertion i p1 =\n  (\\<Sum>m\\<in>monomials p1.\n     coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))\n  insertion i p2 =\n  (\\<Sum>m\\<in>monomials p2.\n     coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))\n  p2 = monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "have monomials_add: \"monomials (p1 + p2) = insert m (monomials p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (p1 + p2) = insert m (monomials p1)", "using sum.hyps"], ["proof (prove)\nusing this:\n  p2 = monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monomials (p1 + p2) = insert m (monomials p1)", "by (auto simp: monomials_add_disjoint)"], ["proof (state)\nthis:\n  monomials (p1 + p2) = insert m (monomials p1)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "have *: \"coeff (monom m a) x = 0\" if \"x \\<in> monomials p1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (monom m a) x = (0::'a)", "using sum.hyps that"], ["proof (prove)\nusing this:\n  p2 = monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n  x \\<in> monomials p1\n\ngoal (1 subgoal):\n 1. coeff (monom m a) x = (0::'a)", "by (subst coeff_not_in_monomials) auto"], ["proof (state)\nthis:\n  ?x \\<in> monomials p1 \\<Longrightarrow> coeff (monom m a) ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2 m a.\n       \\<lbrakk>insertion i p1 =\n                (\\<Sum>m\\<in>monomials p1.\n                   coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        insertion i p2 =\n        (\\<Sum>m\\<in>monomials p2.\n           coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k));\n        p2 = monom m a; m \\<notin> monomials p1; a \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> insertion i (p1 + p2) =\n                         (\\<Sum>m\\<in>monomials (p1 + p2).\n                            coeff (p1 + p2) m *\n                            (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion i (p1 + p2) =\n    (\\<Sum>m\\<in>monomials (p1 + p2).\n       coeff (p1 + p2) m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "unfolding insertion_add monomials_add sum.IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p1.\n       coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k)) +\n    (\\<Sum>m\\<in>monomials p2.\n       coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k)) =\n    (\\<Sum>m\\<in>insert m (monomials p1).\n       coeff (p1 + p2) m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "using sum.hyps"], ["proof (prove)\nusing this:\n  p2 = monom m a\n  m \\<notin> monomials p1\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p1.\n       coeff p1 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k)) +\n    (\\<Sum>m\\<in>monomials p2.\n       coeff p2 m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k)) =\n    (\\<Sum>m\\<in>insert m (monomials p1).\n       coeff (p1 + p2) m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))", "by (auto simp: coeff_add * algebra_simps)"], ["proof (state)\nthis:\n  insertion i (p1 + p2) =\n  (\\<Sum>m\\<in>monomials (p1 + p2).\n     coeff (p1 + p2) m * (\\<Prod>k\\<in>keys m. i k ^ lookup m k))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* insertion f p\n  takes in a mapping from natural numbers to the type of the polynomial and substitutes in\n  the constant (f var) for each var variable in polynomial p\n*)"], ["", "code_thms insertion"], ["", "value \"insertion (nth [1, 2.3]) ((Var 0 + Const (3::int) * Var 1)^2)\""], ["", "(* isolate_variable_sparse p var degree\n    returns the coefficient of the term a*var^degree in polynomial p\n *)"], ["", "lift_definition isolate_variable_sparse::\"'a::comm_monoid_add mpoly \\<Rightarrow>\nnat \\<Rightarrow> nat \\<Rightarrow> 'a mpoly\" is\n  \"\\<lambda>(mp::'a mpoly) x d. sum\n     (\\<lambda>m. monomial (coeff mp m) (Poly_Mapping.update x 0 m))\n     {m \\<in> monomials mp. lookup m x = d}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Poly_Mapping_update_code[code]: \"Poly_Mapping.update a b (Pm_fmap\nfm) = Pm_fmap (fmupd a b fm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.update a b (Pm_fmap fm) = Pm_fmap (fmupd a b fm)", "by (auto intro!: poly_mapping_eqI simp: update.rep_eq\n      fmlookup_default_def)"], ["", "lemma monom_zero [simp] : \"monom m 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom m (0::'a) = 0", "by (simp add: coeff_all_0)"], ["", "lemma remove_key_code[code]: \"remove_key v (Pm_fmap fm) = Pm_fmap\n(fmdrop v fm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_key v (Pm_fmap fm) = Pm_fmap (fmdrop v fm)", "by (auto simp: remove_key_lookup fmlookup_default_def intro!:\n      poly_mapping_eqI)"], ["", "lemma extract_var_code[code]:\n  \"extract_var p v =\n     (\\<Sum>m\\<in>monomials p. monom (remove_key v m) (monom (Poly_Mapping.single\nv (lookup m v)) (coeff p m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_var p v =\n    (\\<Sum>m\\<in>monomials p.\n       monom (remove_key v m) (monom (monomial (lookup m v) v) (coeff p m)))", "apply (rule extract_var_finite_set[where S=\"monomials p\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {m'. coeff p m' \\<noteq> (0::'a)} \\<subseteq> monomials p\n 2. finite (monomials p)", "using coeff_not_in_monomials"], ["proof (prove)\nusing this:\n  ?x \\<notin> monomials ?m \\<Longrightarrow> coeff ?m ?x = (0::?'a)\n\ngoal (2 subgoals):\n 1. {m'. coeff p m' \\<noteq> (0::'a)} \\<subseteq> monomials p\n 2. finite (monomials p)", "by auto"], ["", "value \"extract_var ((Var 0 + Const (3::real) * Var 1)^2) 0\""], ["", "(* degree p var\n  takes in polynomial p and a variable var and finds the degree of that variable in the polynomial\n  missing code theorems? still manages to evaluate\n*)"], ["", "code_thms degree"], ["", "value \"degree ((Var 0 + Const (3::real) * Var 1)^2) 0\""], ["", "(* this function gives a set of all the variables in the polynomial\n*)"], ["", "lemma vars_code[code]: \"vars p = \\<Union> (keys ` monomials p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = \\<Union> (keys ` monomials p)", "unfolding monomials.rep_eq vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of p)) =\n    \\<Union> (keys ` keys (mapping_of p))", ".."], ["", "value \"vars ((Var 0 + Const (3::real) * Var 1)^2)\""], ["", "(* return true if the polynomial contains no variables\n*)"], ["", "fun is_constant :: \"'a::zero mpoly \\<Rightarrow> bool\" where\n  \"is_constant p = Set.is_empty (vars p)\""], ["", "value \"is_constant (Const (0::int))\""], ["", "(*\n  if the polynomial is constant, returns the real value associated with the polynomial,\n  otherwise returns none\n*)"], ["", "fun get_if_const :: \"real mpoly \\<Rightarrow> real option\" where\n  \"get_if_const p = (if is_constant p then Some (coeff p 0) else None)\""], ["", "term \"coeff p 0\""], ["", "lemma insertionNegative : \"insertion f p = - insertion f (-p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p = - insertion f (- p)", "by (metis (no_types, hide_lams) add_eq_0_iff cancel_comm_monoid_add_class.diff_cancel insertion_add insertion_zero uminus_add_conv_diff)"], ["", "definition derivative :: \"nat \\<Rightarrow> real mpoly \\<Rightarrow> real mpoly\" where\n  \"derivative x p = (\\<Sum>i\\<in>{0..degree p x-1}. isolate_variable_sparse p x (i+1) * (Var x)^i * (Const (i+1)))\""], ["", "text \"get\\\\_coeffs $x$ $p$\n  gets the tuple of coefficients $a$ $b$ $c$ of the term $a*x^2+b*x+c$ in polynomial $p$\""], ["", "fun get_coeffs :: \"nat \\<Rightarrow> real mpoly \\<Rightarrow> real mpoly * real mpoly * real mpoly\" where\n  \"get_coeffs var x = (\n  isolate_variable_sparse x var 2,\n  isolate_variable_sparse x var 1,\n  isolate_variable_sparse x var 0)\n\""], ["", "end"]]}