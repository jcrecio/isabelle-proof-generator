{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/InfinitesimalsUni.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma convert_convertDerivative : \n  assumes \"convert_poly var p (xs'@x#xs) = Some(a,b,c)\"\n  assumes \"length xs' = var\"\n  shows \"eval (convertDerivative var p) (xs'@x#xs) = evalUni (convertDerivativeUni (a,b,c)) x\"", "lemma convert_linearSubstitutionUni: \n  assumes \"convert_atom var a (xs'@x#xs) = Some(a')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"aEval (linear_substitution var (-c) b a) (xs'@x#xs) = evalUni (linearSubstitutionUni B C a') x\"", "lemma convert_linear_subst_fm :\n  assumes \"convert_atom var a (xs'@x#xs) = Some a'\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"aEval (linear_substitution (var + 0) (liftPoly 0 0 (-c)) (liftPoly 0 0 b) a) (xs'@x#xs) =\n     evalUni (linearSubstitutionUni B C a') x\"", "lemma evalUni_if : \"evalUni (if cond then TrueFUni else FalseFUni) x = cond\"", "lemma degree_less_sum' : \"MPoly_Type.degree (p::real mpoly) var = n \\<Longrightarrow> MPoly_Type.degree (q::real mpoly) var = m \\<Longrightarrow> n < m \\<Longrightarrow> MPoly_Type.degree (p + q) var = m\"", "lemma convert_substInfinitesimalLinear_less : \n  assumes \"convert_poly var p (xs'@x#xs) = Some(p')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"\neval (liftmap\n    (\\<lambda>x. \\<lambda>A. Atom(linear_substitution (var+x) (liftPoly 0 x (-c)) (liftPoly 0 x b) A)) \n    (convertDerivative var p)\n    0) (xs'@x#xs) =\nevalUni (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\"", "lemma convert_substInfinitesimalLinear: \n  assumes \"convert_atom var a (xs'@x#xs) = Some(a')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"eval (substInfinitesimalLinear var (-c) b a) (xs'@x#xs) = evalUni (substInfinitesimalLinearUni B C a') x\"", "lemma either_or:\n  fixes r :: \"real\"\n  assumes a: \"(\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (EqUni (a, b, c)) x) \\<or> (aEvalUni (LessUni (a, b, c)) x))\"\n  shows \"(\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (EqUni (a, b, c)) x)) \\<or> \n  (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (LessUni (a, b, c)) x))\"", "lemma infinitesimal_linear'_helper :\n  assumes at_is: \"At = LessUni p \\<or> At = EqUni p\"\n  assumes \"B \\<noteq> 0\"\n  shows \"((\\<exists>y'::real>-C/B. \\<forall>x::real \\<in>{-C/B<..y'}. aEvalUni At x)\n      = evalUni (substInfinitesimalLinearUni B C At) x)\"", "lemma infinitesimal_linear' :\n  assumes \"B \\<noteq> 0\"\n  shows \"(\\<exists>y'::real>-C/B. \\<forall>x::real \\<in>{-C/B<..y'}. aEvalUni At x)\n      = evalUni (substInfinitesimalLinearUni B C At) x\"", "lemma weird :\n  fixes D::\"real\"\n  assumes dneq: \"D \\<noteq> (0::real)\"\n  shows \n    \"((a'::real) * (((A::real) + (B::real) * sqrt (C::real)) / (D::real))\\<^sup>2 + (b'::real) * (A + B * sqrt C) / D + c' < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + (c'::real) = 0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' = 0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\"", "lemma convert_substInfinitesimalQuadratic_less :\n  assumes \"convert_poly var p (xs'@x#xs) = Some p'\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) a = A\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) d = D\"\n  assumes \"D \\<noteq> 0\"\n  assumes \"0 \\<le> C\"\n  assumes \"var\\<notin>(vars a)\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"var\\<notin>(vars d)\"\n  assumes \"length xs' = var\"\n  shows \"eval (quadratic_sub_fm var a b c d (convertDerivative var p)) (xs'@x#xs) = evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\"", "lemma convert_substInfinitesimalQuadratic: \n  assumes \"convert_atom var At (xs'@ x#xs) = Some(At')\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) a = A\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) c = C\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) d = D\"\n  assumes \"D \\<noteq> 0\"\n  assumes \"0 \\<le> C\"\n  assumes \"var\\<notin>(vars a)\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"var\\<notin>(vars d)\"\n  assumes \"length xs' = var\"\n  shows \"eval (substInfinitesimalQuadratic var a b c d At) (xs'@ x#xs) = evalUni (substInfinitesimalQuadraticUni A B C D At') x\"", "lemma infinitesimal_quad_helper:\n  fixes A B C D:: \"real\"\n  assumes at_is: \"At = LessUni p \\<or> At = EqUni p\"\n  assumes \"D\\<noteq>0\"\n  assumes \"C\\<ge>0\"\n  shows \"(\\<exists>y'::real>((A+B * sqrt(C))/(D)). \\<forall>x::real \\<in>{((A+B * sqrt(C))/(D))<..y'}. aEvalUni At x)\n      = (evalUni (substInfinitesimalQuadraticUni A B C D At) x)\"", "lemma infinitesimal_quad:\n  fixes A B C D:: \"real\"\n  assumes \"D\\<noteq>0\"\n  assumes \"C\\<ge>0\"\n  shows \"(\\<exists>y'::real>((A+B * sqrt(C))/(D)). \\<forall>x::real \\<in>{((A+B * sqrt(C))/(D))<..y'}. aEvalUni At x)\n      = (evalUni (substInfinitesimalQuadraticUni A B C D At) x)\""], "translations": [["", "lemma convert_convertDerivative : \n  assumes \"convert_poly var p (xs'@x#xs) = Some(a,b,c)\"\n  assumes \"length xs' = var\"\n  shows \"eval (convertDerivative var p) (xs'@x#xs) = evalUni (convertDerivativeUni (a,b,c)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "apply (simp add: isovar_greater_degree eval_or eval_and insertion_mult insertion_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 0;\n     a = 0 \\<and>\n     b = 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p < 0) =\n                      (c < 0)", "using sum_over_zero[of p var]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 0;\n     a = 0 \\<and>\n     b = 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) p < 0) =\n                      (c < 0)", "by auto"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have nonzero: \"MPoly_Type.degree p var \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have h1 : \"MPoly_Type.degree p var < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using True"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have h2 : \"get_coeffs var p = (isolate_variable_sparse p var 2, isolate_variable_sparse p var 1, isolate_variable_sparse p var 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_coeffs var p =\n    (isolate_variable_sparse p var 2, isolate_variable_sparse p var 1,\n     isolate_variable_sparse p var 0)", "by auto"], ["proof (state)\nthis:\n  get_coeffs var p =\n  (isolate_variable_sparse p var 2, isolate_variable_sparse p var 1,\n   isolate_variable_sparse p var 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have h : \"insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c", "using poly_to_univar[OF h1 h2 _ _ _ assms(2), of  a x xs b c x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a =\n           insertion (nth_default 0 (xs' @ x # xs))\n            (isolate_variable_sparse p var 2);\n   b =\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 1);\n   c =\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 0)\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p =\n                    a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>a =\n           insertion (nth_default 0 (xs' @ x # xs))\n            (isolate_variable_sparse p var 2);\n   b =\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 1);\n   c =\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 0)\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p =\n                    a * x\\<^sup>2 + b * x + c\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a =\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2);\n              b =\n              insertion (nth_default 0 (xs' @ x # xs))\n               (isolate_variable_sparse p var 1);\n              c =\n              insertion (nth_default 0 (xs' @ x # xs))\n               (isolate_variable_sparse p var 0)\\<rbrakk>\n             \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p =\n                               a * x\\<^sup>2 + b * x + c;\n     convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c\n 2. \\<lbrakk>\\<lbrakk>a =\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2);\n              b =\n              insertion (nth_default 0 (xs' @ x # xs))\n               (isolate_variable_sparse p var 1);\n              c =\n              insertion (nth_default 0 (xs' @ x # xs))\n               (isolate_variable_sparse p var 0)\\<rbrakk>\n             \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p =\n                               a * x\\<^sup>2 + b * x + c;\n     convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             a * x\\<^sup>2 + b * x + c;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) =\n     a \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) =\n     b \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> a = 0 \\<or> x = 0", "using isovar_greater_degree[of p var]"], ["proof (prove)\nusing this:\n  \\<forall>i>MPoly_Type.degree p var. isolate_variable_sparse p var i = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             a * x\\<^sup>2 + b * x + c;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) =\n     a \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) =\n     b \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> a = 0 \\<or> x = 0", "unfolding True"], ["proof (prove)\nusing this:\n  \\<forall>i>1. isolate_variable_sparse p var i = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             a * x\\<^sup>2 + b * x + c;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) =\n     a \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) =\n     b \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     1 < 3\\<rbrakk>\n    \\<Longrightarrow> a = 0 \\<or> x = 0", "by simp"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = b * x + c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have h3: \"MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "using degree_mult[of \"isolate_variable_sparse p var (Suc 0)\" \"Const 1\" var]"], ["proof (prove)\nusing this:\n  \\<lbrakk>isolate_variable_sparse p var (Suc 0) \\<noteq> 0;\n   Const 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree\n                     (isolate_variable_sparse p var (Suc 0) * Const 1) var =\n                    MPoly_Type.degree\n                     (isolate_variable_sparse p var (Suc 0)) var +\n                    MPoly_Type.degree (Const 1) var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "using degree_isovarspar mult_one_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>isolate_variable_sparse p var (Suc 0) \\<noteq> 0;\n   Const 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree\n                     (isolate_variable_sparse p var (Suc 0) * Const 1) var =\n                    MPoly_Type.degree\n                     (isolate_variable_sparse p var (Suc 0)) var +\n                    MPoly_Type.degree (Const 1) var\n  MPoly_Type.degree (isolate_variable_sparse ?p ?x ?i) ?x = 0\n  ?P * Const 1 = ?P\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "by presburger"], ["proof (state)\nthis:\n  MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "using assms True"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "unfolding convertDerivative.simps[of _ p] convertDerivative.simps[of _ \"(derivative var p)\"]"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. eval\n     (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n      else Or (fm.Atom (Less p))\n            (And (fm.Atom (Eq p))\n              (if MPoly_Type.degree (derivative var p) var = 0\n               then fm.Atom (Less (derivative var p))\n               else Or (fm.Atom (Less (derivative var p)))\n                     (And (fm.Atom (Eq (derivative var p)))\n                       (convertDerivative var\n                         (derivative var (derivative var p)))))))\n     (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "apply (simp add: derivative_def isovar_greater_degree eval_or eval_and insertion_add insertion_mult insertion_const HOL.arg_cong[OF sum_over_zero[of p var], of \"insertion (nth_default var (xs'@x#xs))\"] insertion_var_zero del:convertDerivative.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var (Suc 0)) =\n             b \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 0) =\n             c;\n     length xs' = var; MPoly_Type.degree p var = Suc 0\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree\n                        (isolate_variable_sparse p var (Suc 0) * Const 1)\n                        var =\n                       0 \\<longrightarrow>\n                       (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<or>\n                        insertion (nth_default 0 (xs' @ x # xs)) p =\n                        0 \\<and>\n                        b < 0) =\n                       (b * x + c < 0 \\<or>\n                        b * x + c = 0 \\<and> b < 0)) \\<and>\n                      (0 < MPoly_Type.degree\n                            (isolate_variable_sparse p var (Suc 0) *\n                             Const 1)\n                            var \\<longrightarrow>\n                       (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<or>\n                        insertion (nth_default 0 (xs' @ x # xs)) p =\n                        0 \\<and>\n                        (b < 0 \\<or>\n                         b = 0 \\<and>\n                         eval\n                          (convertDerivative var\n                            (\\<Sum>i = 0..MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1) var -\n    Suc 0.\n                                isolate_variable_sparse\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var (Suc i) *\n                                Var var ^ i *\n                                Const (1 + real i)))\n                          (xs' @ x # xs))) =\n                       (b * x + c < 0 \\<or> b * x + c = 0 \\<and> b < 0))", "unfolding h     h3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var (Suc 0)) =\n             b \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 0) =\n             c;\n     length xs' = var; MPoly_Type.degree p var = Suc 0\\<rbrakk>\n    \\<Longrightarrow> (0 = 0 \\<longrightarrow>\n                       (b * x + c < 0 \\<or> b * x + c = 0 \\<and> b < 0) =\n                       (b * x + c < 0 \\<or>\n                        b * x + c = 0 \\<and> b < 0)) \\<and>\n                      (0 < 0 \\<longrightarrow>\n                       (b * x + c < 0 \\<or>\n                        b * x + c = 0 \\<and>\n                        (b < 0 \\<or>\n                         b = 0 \\<and>\n                         eval\n                          (convertDerivative var\n                            (\\<Sum>i = 0..0 - Suc 0.\n                                isolate_variable_sparse\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var (Suc i) *\n                                Var var ^ i *\n                                Const (1 + real i)))\n                          (xs' @ x # xs))) =\n                       (b * x + c < 0 \\<or> b * x + c = 0 \\<and> b < 0))", "by(simp del:convertDerivative.simps)"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have deg2 :  \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by (metis One_nat_def assms(1) convert_poly.simps le_SucE less_Suc0 less_Suc_eq_le nonzero numeral_2_eq_2 numeral_3_eq_3 option.distinct(1))"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 2", "have first : \"isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0", "by (metis MPoly_Type.degree_zero isolate_variable_sparse_degree_eq_zero_iff nat.distinct(1) numeral_2_eq_2)"], ["proof (state)\nthis:\n  isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have second : \"(isolate_variable_sparse p var (Suc (Suc 0)) * Var var)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var (Suc (Suc 0)) * Var var \\<noteq> 0", "by (metis MPoly_Type.degree_zero One_nat_def ExecutiblePolyProps.degree_one Zero_not_Suc first mult_eq_0_iff)"], ["proof (state)\nthis:\n  isolate_variable_sparse p var (Suc (Suc 0)) * Var var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have other : \"Const (2::real)\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const 2 \\<noteq> 0", "by (simp add: nonzero_const_is_nonzero)"], ["proof (state)\nthis:\n  Const 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have thing: \"(Var var::real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var var \\<noteq> 0", "using second"], ["proof (prove)\nusing this:\n  isolate_variable_sparse p var (Suc (Suc 0)) * Var var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Var var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Var var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have degree: \"MPoly_Type.degree\n                  (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                   isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n                  var -\n                 Suc 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var -\n    Suc 0 =\n    0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var\n    \\<le> Suc 0", "apply(rule Nat.eq_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var =\n    Suc 0", "apply(rule degree_less_sum'[of _ _ 0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0\n 2. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    Suc 0\n 3. 0 < Suc 0", "apply (simp add: degree_isovarspar mult_one_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    Suc 0\n 2. 0 < Suc 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    Suc 0", "unfolding degree_mult[OF second other, of var] degree_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var) var +\n    0 =\n    Suc 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var) var =\n    Suc 0", "unfolding degree_mult[OF first thing] degree_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc (Suc 0))) var +\n    1 =\n    Suc 0", "using degree_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree (isolate_variable_sparse ?p ?x ?i) ?x = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc (Suc 0))) var +\n    1 =\n    Suc 0", "by force"], ["proof (state)\nthis:\n  MPoly_Type.degree\n   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n    isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n   var -\n  Suc 0 =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have insertion: \"insertion (nth_default 0 (xs'@x#xs)) (\\<Sum>(i::nat)\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = a * x^2 + b * x + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "using False"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "by blast"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have deg2 :  \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by (metis One_nat_def assms(1) convert_poly.simps le_SucE less_Suc0 less_Suc_eq_le nonzero numeral_2_eq_2 numeral_3_eq_3 option.distinct(1))"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 2", "have degless3 : \"MPoly_Type.degree p var < 3\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "have thing : \"var<length(xs'@x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "have h : \"(\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p", "using deg2"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p", "by (metis sum_over_zero)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "have three: \"(3::nat) = Suc(Suc(Suc(0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 = Suc (Suc (Suc 0))", "by auto"], ["proof (state)\nthis:\n  3 = Suc (Suc (Suc 0))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "have \"(\\<Sum>i = 0..<3. insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var i) * x ^ i) =\n          (insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) * x ^ 0) + \n          (insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (1::nat)) * x ^ (1::nat)) + \n          (insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (2::nat)) * x ^ (2::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<3.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2", "unfolding Set_Interval.comm_monoid_add_class.sum.atLeast0_lessThan_Suc three"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var i) *\n        x ^ i) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x ^ Suc 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    x ^ Suc (Suc 0) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var i) *\n        x ^ i) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x ^ Suc 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    x ^ Suc (Suc 0) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2", "have \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (MPoly_Type.degree p var)) * x ^ MPoly_Type.degree p var + (x * insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 1) + (insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) + (\\<Sum>n = 0..<0. insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var n) * x ^ n))) = insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) + x * insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 1) + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (MPoly_Type.degree p var)) * x ^ MPoly_Type.degree p var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n    x ^ MPoly_Type.degree p var +\n    (x *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 1) +\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var 0) +\n      (\\<Sum>n = 0..<0.\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse p var n) *\n          x ^ n))) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    x *\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n    x ^ MPoly_Type.degree p var", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var +\n  (x *\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 1) +\n   (insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    (\\<Sum>n = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var n) *\n        x ^ n))) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) +\n  x *\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var i) *\n        x ^ i) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x ^ Suc 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    x ^ Suc (Suc 0) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var +\n  (x *\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 1) +\n   (insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    (\\<Sum>n = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var n) *\n        x ^ n))) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) +\n  x *\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var", "show \"(\\<Sum>n = 0..<0. insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var n) * x ^ n) + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) * x ^ 0 + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc 0)) * x ^ Suc 0 + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc (Suc 0))) * x ^ Suc (Suc 0) = insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) * x ^ 0 + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 1) * x ^ 1 + insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 2) * x\\<^sup>2\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var +\n  (x *\n   insertion (nth_default 0 (xs' @ x # xs))\n    (isolate_variable_sparse p var 1) +\n   (insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    (\\<Sum>n = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var n) *\n        x ^ n))) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) +\n  x *\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (MPoly_Type.degree p var)) *\n  x ^ MPoly_Type.degree p var\n\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<0.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var n) *\n        x ^ n) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x ^ Suc 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    x ^ Suc (Suc 0) =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2", "by (metis (no_types) One_nat_def Suc_1 add.commute deg2 mult.commute mult.left_neutral power_0 power_one_right)"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..<0.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var n) *\n      x ^ n) +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) *\n  x ^ 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) *\n  x ^ Suc 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc (Suc 0))) *\n  x ^ Suc (Suc 0) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) *\n  x ^ 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) *\n  x ^ 1 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) *\n  x\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) *\n  x ^ 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) *\n  x ^ 1 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) *\n  x\\<^sup>2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) *\n  x ^ 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) *\n  x ^ 1 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) *\n  x\\<^sup>2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "have \"... =  a * x\\<^sup>2 + b * x + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) *\n    x ^ 0 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x ^ 1 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2 =\n    a * x\\<^sup>2 + b * x + c", "unfolding Power.power_class.power.power_0 Power.monoid_mult_class.power_one_right Groups.monoid_mult_class.mult_1_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2 =\n    a * x\\<^sup>2 + b * x + c", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2 =\n    a * x\\<^sup>2 + b * x + c", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2 =\n    a * x\\<^sup>2 + b * x + c", "using degless3"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some (a, b, c)\n  length xs' = var\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    x\\<^sup>2 =\n    a * x\\<^sup>2 + b * x + c", "by simp"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) *\n  x ^ 0 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) *\n  x ^ 1 +\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) *\n  x\\<^sup>2 =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  a * x\\<^sup>2 + b * x + c", "have h2  :\"(\\<Sum>i = 0..<3. insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var i) * x ^ i) =  a * x\\<^sup>2 + b * x + c \""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<3.\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    a * x\\<^sup>2 + b * x + c", "."], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "using sum_over_degree_insertion[OF thing deg2, of x]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<2 + 1.\n      insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<3.\n        insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "using h h2"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<3.\n        insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "using assms(2)"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) = p\n  (\\<Sum>i = 0..<3.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i) =\n  a * x\\<^sup>2 + b * x + c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<3.\n        insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n         (isolate_variable_sparse p var i) *\n        x ^ i) =\n    insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n    a * x\\<^sup>2 + b * x + c", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (\\<Sum>i\\<le>2. isolate_variable_sparse p var i * Var var ^ i) =\n  a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have insertionb: \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc 0)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b\n 2. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b", "by simp_all"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have insertiona : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc (Suc 0))) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) =\n    a", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) =\n    a", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc (Suc 0))) =\n                      a\n 2. \\<lbrakk>convert_poly var p (xs' @ x # xs) = Some (a, b, c);\n     length xs' = var; \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc (Suc 0))) =\n                      a", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 2) =\n             a \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var (Suc 0)) =\n             b \\<and>\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 0) =\n             c;\n     length xs' = var; MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc (Suc 0))) =\n                      a", "by (simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc (Suc 0))) =\n  a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have x :  \"insertion (nth_default 0 (xs' @ x # xs)) (Var var) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (Var var) = x", "using insertion_var[of var \"(xs' @ x # xs)\" x]"], ["proof (prove)\nusing this:\n  var < length (xs' @ x # xs) \\<Longrightarrow>\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x])) (Var var) = x\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (Var var) = x", "using assms(2)"], ["proof (prove)\nusing this:\n  var < length (xs' @ x # xs) \\<Longrightarrow>\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x])) (Var var) = x\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (Var var) = x", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) (Var var) = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have zero1 : \"insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var (Suc 0)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) =\n    0", "by (simp add: degree_isovarspar isovar_greater_degree)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n     (Suc 0)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have zero2 : \"insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0))) var 0) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0) =\n    a", "using degree0isovarspar degree_isovarspar insertiona"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  MPoly_Type.degree (isolate_variable_sparse ?p ?x ?i) ?x = 0\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc (Suc 0))) =\n  a\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0) =\n    a", "by presburger"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n     var 0) =\n  a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have zero3 : \"insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse (Var var) var (Suc 0)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (Var var) var (Suc 0)) =\n    1", "using isolate_var_one"], ["proof (prove)\nusing this:\n  isolate_variable_sparse (Var ?x) ?x 1 = 1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (Var var) var (Suc 0)) =\n    1", "using MPoly_Type.insertion_one"], ["proof (prove)\nusing this:\n  isolate_variable_sparse (Var ?x) ?x 1 = 1\n  insertion ?f 1 = (1::?'a)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (Var var) var (Suc 0)) =\n    1", "by fastforce"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (Var var) var (Suc 0)) =\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have zero4 : \"insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var (Suc 0)) =\n    0", "by (simp add: degree_isovarspar isovar_greater_degree)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n     var (Suc 0)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have insertion_deriv : \"insertion (nth_default 0 (xs'@x#xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0)) = 2*a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0)) =\n    2 * a", "unfolding isovarspar_sum isolate_variable_sparse_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((\\<Sum>i\\<le>Suc 0.\n          isolate_variable_sparse (isolate_variable_sparse p var (Suc 0))\n           var i *\n          isolate_variable_sparse (Const 1) var (Suc 0 - i)) +\n      (\\<Sum>i\\<le>Suc 0.\n          (\\<Sum>ia\\<le>i.\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc (Suc 0))) var ia *\n              isolate_variable_sparse (Var var) var (i - ia)) *\n          isolate_variable_sparse (Const 2) var (Suc 0 - i))) =\n    2 * a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0 *\n      isolate_variable_sparse (Const 1) var (Suc 0) +\n      isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0) *\n      isolate_variable_sparse (Const 1) var 0 +\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0 *\n       isolate_variable_sparse (Var var) var 0 *\n       isolate_variable_sparse (Const 2) var (Suc 0) +\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var 0 *\n        isolate_variable_sparse (Var var) var (Suc 0) +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0) *\n        isolate_variable_sparse (Var var) var 0) *\n       isolate_variable_sparse (Const 2) var 0)) =\n    2 * a", "unfolding const_lookup_suc const_lookup_zero Rings.mult_zero_class.mult_zero_right\n        Groups.group_add_class.add.group_left_neutral"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0) *\n      Const 1 +\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0 *\n       isolate_variable_sparse (Var var) var (Suc 0) +\n       isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0) *\n       isolate_variable_sparse (Var var) var 0) *\n      Const 2) =\n    2 * a", "unfolding insertion_add insertion_mult insertion_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) *\n    1 +\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var (Suc 0)) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0)) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var 0)) *\n    2 =\n    2 * a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) +\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var (Suc 0)) *\n     2 +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0)) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var 0) *\n     2) =\n    2 * a", "unfolding zero1 zero2 zero3 zero4"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 +\n    (a * 1 * 2 +\n     0 *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var 0) *\n     2) =\n    2 * a", "by simp"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0)) =\n  2 * a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "have deg2 : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degree_convert_eq[OF assms(1)] False nonzero"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                      evalUni (convertDerivativeUni (a, b, c)) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "unfolding convertDerivative.simps[of _ p] convertDerivative.simps[of _ \"(derivative var p)\"] convertDerivative.simps[of _ \"(derivative var (derivative var p))\"]"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  convert_poly var p (xs' @ x # xs) = Some (a, b, c)\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval\n     (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n      else Or (fm.Atom (Less p))\n            (And (fm.Atom (Eq p))\n              (if MPoly_Type.degree (derivative var p) var = 0\n               then fm.Atom (Less (derivative var p))\n               else Or (fm.Atom (Less (derivative var p)))\n                     (And (fm.Atom (Eq (derivative var p)))\n                       (if MPoly_Type.degree\n                            (derivative var (derivative var p)) var =\n                           0\n                        then fm.Atom\n                              (Less (derivative var (derivative var p)))\n                        else Or (fm.Atom\n                                  (Less\n                                    (derivative var (derivative var p))))\n                              (And (fm.Atom\n                                     (Eq\n (derivative var (derivative var p))))\n                                (convertDerivative var\n                                  (derivative var\n                                    (derivative var\n(derivative var p))))))))))\n     (xs' @ x # xs) =\n    evalUni (convertDerivativeUni (a, b, c)) x", "apply (simp add: x insertionb insertiona insertion_deriv insertion degree derivative_def isovar_greater_degree eval_or eval_and insertion_add insertion_mult insertion_const HOL.arg_cong[OF sum_over_zero[of p var], of \"insertion (nth_default 0 (xs'@x#xs))\"] insertion_var_zero del:convertDerivative.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = 2;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) =\n     a \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0) =\n     c;\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (MPoly_Type.degree\n                        (isolate_variable_sparse\n                          (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                           isolate_variable_sparse p var (Suc (Suc 0)) *\n                           Var var *\n                           Const 2)\n                          var (Suc 0) *\n                         Const 1)\n                        var =\n                       0 \\<longrightarrow>\n                       (MPoly_Type.degree\n                         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                          isolate_variable_sparse p var (Suc (Suc 0)) *\n                          Var var *\n                          Const 2)\n                         var =\n                        0 \\<longrightarrow>\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         b + a * x * 2 < 0) =\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (2 * a * x + b < 0 \\<or>\n                          2 * a * x + b = 0 \\<and> a < 0))) \\<and>\n                       (0 < MPoly_Type.degree\n                             (isolate_variable_sparse p var (Suc 0) *\n                              Const 1 +\n                              isolate_variable_sparse p var (Suc (Suc 0)) *\n                              Var var *\n                              Const 2)\n                             var \\<longrightarrow>\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (b + a * x * 2 < 0 \\<or>\n                          b + a * x * 2 = 0 \\<and> a < 0)) =\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (2 * a * x + b < 0 \\<or>\n                          2 * a * x + b = 0 \\<and> a < 0)))) \\<and>\n                      (0 < MPoly_Type.degree\n                            (isolate_variable_sparse\n                              (isolate_variable_sparse p var (Suc 0) *\n                               Const 1 +\n                               isolate_variable_sparse p var (Suc (Suc 0)) *\n                               Var var *\n                               Const 2)\n                              var (Suc 0) *\n                             Const 1)\n                            var \\<longrightarrow>\n                       (MPoly_Type.degree\n                         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                          isolate_variable_sparse p var (Suc (Suc 0)) *\n                          Var var *\n                          Const 2)\n                         var =\n                        0 \\<longrightarrow>\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         b + a * x * 2 < 0) =\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (2 * a * x + b < 0 \\<or>\n                          2 * a * x + b = 0 \\<and> a < 0))) \\<and>\n                       (0 < MPoly_Type.degree\n                             (isolate_variable_sparse p var (Suc 0) *\n                              Const 1 +\n                              isolate_variable_sparse p var (Suc (Suc 0)) *\n                              Var var *\n                              Const 2)\n                             var \\<longrightarrow>\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (b + a * x * 2 < 0 \\<or>\n                          b + a * x * 2 = 0 \\<and>\n                          (a < 0 \\<or>\n                           a = 0 \\<and>\n                           eval\n                            (convertDerivative var\n                              (\\<Sum>i = 0..MPoly_Type.degree\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1)\n       var -\n      Suc 0.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse\n                                     (isolate_variable_sparse p var\n (Suc 0) *\nConst 1 +\nisolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n                                     var (Suc 0) *\n                                    Const 1)\n                                   var (Suc i) *\n                                  Var var ^ i *\n                                  Const (1 + real i)))\n                            (xs' @ x # xs)))) =\n                        (a * x\\<^sup>2 + b * x + c < 0 \\<or>\n                         a * x\\<^sup>2 + b * x + c = 0 \\<and>\n                         (2 * a * x + b < 0 \\<or>\n                          2 * a * x + b = 0 \\<and> a < 0))))", "by (smt (z3) One_nat_def degree_isovarspar distrib_right insertion_deriv isolate_variable_sparse_ne_zeroD mult_one_right neq0_conv not_one_le_zero zero1)"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni (a, b, c)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni (a, b, c)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun linearSubstitutionUni :: \"real \\<Rightarrow> real \\<Rightarrow> atomUni \\<Rightarrow> atomUni fmUni\" where\n  \"linearSubstitutionUni b c a = (if aEvalUni a (-c/b) then TrueFUni else FalseFUni)\""], ["", "lemma convert_linearSubstitutionUni: \n  assumes \"convert_atom var a (xs'@x#xs) = Some(a')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"aEval (linear_substitution var (-c) b a) (xs'@x#xs) = evalUni (linearSubstitutionUni B C a') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "have \"aEval a (xs'@(-C/B)#xs) = evalUni (linearSubstitutionUni B C a') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "using assms(1)"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "proof(cases \"a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  a = Less p", "have \"MPoly_Type.degree p var < 3\""], ["proof (prove)\nusing this:\n  a = Less p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using assms(1)"], ["proof (prove)\nusing this:\n  a = Less p\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Less p; convert_atom var a (xs' @ x # xs) = Some a';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>a = Less p; convert_atom var a (xs' @ x # xs) = Some a';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "using Less assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  a = Less p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Less p;\n     LessUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p\n                       < 0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       \\<not> insertion\n                               (nth_default 0 (xs' @ - (C / B) # xs)) p\n                              < 0)", "using poly_to_univar"], ["proof (prove)\nusing this:\n  \\<lbrakk>MPoly_Type.degree ?p ?var < 3; get_coeffs ?var ?p = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) ?p =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Less p;\n     LessUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p\n                       < 0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       \\<not> insertion\n                               (nth_default 0 (xs' @ - (C / B) # xs)) p\n                              < 0)", "by force"], ["proof (state)\nthis:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "have \"MPoly_Type.degree p var < 3\""], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using assms(1)"], ["proof (prove)\nusing this:\n  a = Eq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p; convert_atom var a (xs' @ x # xs) = Some a';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>a = Eq p; convert_atom var a (xs' @ x # xs) = Some a';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "using Eq assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  a = Eq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Eq p;\n     EqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p =\n                       0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs))\n                        p \\<noteq>\n                       0)", "using poly_to_univar"], ["proof (prove)\nusing this:\n  \\<lbrakk>MPoly_Type.degree ?p ?var < 3; get_coeffs ?var ?p = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) ?p =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Eq p;\n     EqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p =\n                       0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs))\n                        p \\<noteq>\n                       0)", "by force"], ["proof (state)\nthis:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  a = Leq p", "have \"MPoly_Type.degree p var < 3\""], ["proof (prove)\nusing this:\n  a = Leq p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using assms(1)"], ["proof (prove)\nusing this:\n  a = Leq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Leq p; convert_atom var a (xs' @ x # xs) = Some a';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>a = Leq p; convert_atom var a (xs' @ x # xs) = Some a';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "using Leq assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  a = Leq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Leq p;\n     LeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p\n                       \\<le> 0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       \\<not> insertion\n                               (nth_default 0 (xs' @ - (C / B) # xs)) p\n                              \\<le> 0)", "using poly_to_univar"], ["proof (prove)\nusing this:\n  \\<lbrakk>MPoly_Type.degree ?p ?var < 3; get_coeffs ?var ?p = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) ?p =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Leq p;\n     LeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p\n                       \\<le> 0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       \\<not> insertion\n                               (nth_default 0 (xs' @ - (C / B) # xs)) p\n                              \\<le> 0)", "by force"], ["proof (state)\nthis:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  a = Neq p", "have \"MPoly_Type.degree p var < 3\""], ["proof (prove)\nusing this:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using assms(1)"], ["proof (prove)\nusing this:\n  a = Neq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Neq p; convert_atom var a (xs' @ x # xs) = Some a';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>a = Neq p; convert_atom var a (xs' @ x # xs) = Some a';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> aEval a (xs' @ - C / B # xs) =\n                         evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "using Neq assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  a = Neq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Neq p;\n     NeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs))\n                        p \\<noteq>\n                       0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p =\n                       0)", "using poly_to_univar"], ["proof (prove)\nusing this:\n  \\<lbrakk>MPoly_Type.degree ?p ?var < 3; get_coeffs ?var ?p = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) ?p =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var < 3; a = Neq p;\n     NeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0)) =\n     a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs))\n                        p \\<noteq>\n                       0) \\<and>\n                      (\\<not> aEvalUni a' (- (C / B)) \\<longrightarrow>\n                       insertion (nth_default 0 (xs' @ - (C / B) # xs)) p =\n                       0)", "by force"], ["proof (state)\nthis:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x", "have subst : \"aEval a ((xs'@x#xs)[var := - C / B]) = evalUni (linearSubstitutionUni B C a') x\""], ["proof (prove)\nusing this:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. aEval a ((xs' @ x # xs)[var := - C / B]) =\n    evalUni (linearSubstitutionUni B C a') x", "using assms"], ["proof (prove)\nusing this:\n  aEval a (xs' @ - C / B # xs) = evalUni (linearSubstitutionUni B C a') x\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a ((xs' @ x # xs)[var := - C / B]) =\n    evalUni (linearSubstitutionUni B C a') x", "by auto"], ["proof (state)\nthis:\n  aEval a ((xs' @ x # xs)[var := - C / B]) =\n  evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "have hlength : \"var< length (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "have inB : \"insertion (nth_default 0 ((xs'@x#xs)[var := - C / B])) b = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) b = B", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) b = B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n     length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n     B = insertion (nth_default 0 (xs' @ x # xs)) b;\n     C = insertion (nth_default 0 (xs' @ x # xs)) c;\n     var = length xs'\\<rbrakk>\n    \\<Longrightarrow> insertion\n                       (nth_default 0\n                         (xs' @\n                          - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                             insertion (nth_default 0 (xs' @ x # xs)) b) #\n                          xs))\n                       b =\n                      insertion (nth_default 0 (xs' @ x # xs)) b", "apply(cases a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Less x1;\n        (if MPoly_Type.degree x1 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = LessUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 2. \\<And>x2 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Eq x2;\n        (if MPoly_Type.degree x2 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = EqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 3. \\<And>x3 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Leq x3;\n        (if MPoly_Type.degree x3 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = LeqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b\n 4. \\<And>x4 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Neq x4;\n        (if MPoly_Type.degree x4 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = NeqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          b =\n                         insertion (nth_default 0 (xs' @ x # xs)) b", "by (simp add: insertion_lowerPoly1)+"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) b = B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "have inC : \"insertion (nth_default 0 ((xs'@x#xs)[var := - C / B])) (-c) = -C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) (- c) = - C", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) (- c) = - C", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n     length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n     B = insertion (nth_default 0 (xs' @ x # xs)) b;\n     C = insertion (nth_default 0 (xs' @ x # xs)) c;\n     var = length xs'\\<rbrakk>\n    \\<Longrightarrow> insertion\n                       (nth_default 0\n                         (xs' @\n                          - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                             insertion (nth_default 0 (xs' @ x # xs)) b) #\n                          xs))\n                       (- c) =\n                      - insertion (nth_default 0 (xs' @ x # xs)) c", "apply(cases a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom (length xs') a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Less x1;\n        (if MPoly_Type.degree x1 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x1\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = LessUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 2. \\<And>x2 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Eq x2;\n        (if MPoly_Type.degree x2 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x2\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = EqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 3. \\<And>x3 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Leq x3;\n        (if MPoly_Type.degree x3 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x3\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = LeqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c\n 4. \\<And>x4 aa aaa ba.\n       \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n        length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n        B = insertion (nth_default 0 (xs' @ x # xs)) b;\n        C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n        a = Neq x4;\n        (if MPoly_Type.degree x4 (length xs') < 3\n         then let (A, B, C) = get_coeffs (length xs') x4\n              in Some\n                  (insertion (nth_default 0 (xs' @ x # xs)) A,\n                   insertion (nth_default 0 (xs' @ x # xs)) B,\n                   insertion (nth_default 0 (xs' @ x # xs)) C)\n         else None) =\n        Some (aa, aaa, ba);\n        a' = NeqUni (aa, aaa, ba)\\<rbrakk>\n       \\<Longrightarrow> insertion\n                          (nth_default 0\n                            (xs' @\n                             - (insertion (nth_default 0 (xs' @ x # xs)) c /\n                                insertion (nth_default 0 (xs' @ x # xs))\n                                 b) #\n                             xs))\n                          (- c) =\n                         - insertion (nth_default 0 (xs' @ x # xs)) c", "by (simp add: insertion_lowerPoly1 insertion_neg)+"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := - C / B])) (- c) = - C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "have freenegc : \"var\\<notin>vars(-c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (- c)", "using assms not_in_neg"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (- c)", "by auto"], ["proof (state)\nthis:\n  var \\<notin> vars (- c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var\\<rbrakk>\n    \\<Longrightarrow> aEval (linear_substitution var (- c) b a)\n                       (xs' @ x # xs) =\n                      evalUni (linearSubstitutionUni B C a') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "using linear[OF hlength assms(4)  freenegc assms(5) inC inB, of a ] subst"], ["proof (prove)\nusing this:\n  aEval a ((xs' @ x # xs)[var := - C / B]) =\n  aEval (linear_substitution var (- c) b a) ((xs' @ x # xs)[var := ?v])\n  aEval a ((xs' @ x # xs)[var := - C / B]) =\n  evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "using  var_not_in_eval3[OF var_not_in_linear[OF freenegc assms(5)] assms(7)]"], ["proof (prove)\nusing this:\n  aEval a ((xs' @ x # xs)[var := - C / B]) =\n  aEval (linear_substitution var (- c) b a) ((xs' @ x # xs)[var := ?v])\n  aEval a ((xs' @ x # xs)[var := - C / B]) =\n  evalUni (linearSubstitutionUni B C a') x\n  (\\<exists>x.\n      eval (fm.Atom (linear_substitution var (- c) b ?A1)) (xs' @ x # ?L)) =\n  (\\<forall>x.\n      eval (fm.Atom (linear_substitution var (- c) b ?A1)) (xs' @ x # ?L))\n\ngoal (1 subgoal):\n 1. aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "by (metis assms(7) list_update_length)"], ["proof (state)\nthis:\n  aEval (linear_substitution var (- c) b a) (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni B C a') x\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  substInfinitesimalLinear var b c A\n  substitutes -c/b+epsilon for variable var in atom A\n  assumes b is nonzero\n  defined in page 615\n*)"], ["", "fun substInfinitesimalLinearUni :: \"real \\<Rightarrow> real \\<Rightarrow> atomUni \\<Rightarrow> atomUni fmUni\" where\n  \"substInfinitesimalLinearUni b c (EqUni p) = allZero' p\"|\n  \"substInfinitesimalLinearUni b c (LessUni p) = \n  map_atomUni (linearSubstitutionUni b c) (convertDerivativeUni p)\"|\n  \"substInfinitesimalLinearUni b c (LeqUni p) = \nOrUni\n  (allZero' p)\n  (map_atomUni (linearSubstitutionUni b c) (convertDerivativeUni p))\"|\n  \"substInfinitesimalLinearUni b c (NeqUni p) = negUni (allZero' p)\""], ["", "lemma convert_linear_subst_fm :\n  assumes \"convert_atom var a (xs'@x#xs) = Some a'\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"aEval (linear_substitution (var + 0) (liftPoly 0 0 (-c)) (liftPoly 0 0 b) a) (xs'@x#xs) =\n     evalUni (linearSubstitutionUni B C a') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "have lb : \"insertion (nth_default 0 (xs'@x#xs)) (liftPoly 0 0 b) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 b) = B", "unfolding lift00"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) b = B", "using assms(2)"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) b = B", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 b) = B\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "have lc : \"insertion (nth_default 0 (xs'@x#xs)) (liftPoly 0 0 c) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 c) = C", "unfolding lift00"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) c = C", "using assms(3) insertion_neg"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion ?f (- ?p) = - insertion ?f ?p\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) c = C", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 c) = C\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "have nb : \"var \\<notin> vars (liftPoly 0 0 b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (liftPoly 0 0 b)", "using not_in_lift[OF assms(5), of 0]"], ["proof (prove)\nusing this:\n  var + 0 \\<notin> vars (liftPoly 0 0 b)\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (liftPoly 0 0 b)", "by auto"], ["proof (state)\nthis:\n  var \\<notin> vars (liftPoly 0 0 b)\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "have nc : \"var \\<notin> vars (liftPoly 0 0 c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (liftPoly 0 0 c)", "using not_in_lift[OF assms(6)] not_in_neg"], ["proof (prove)\nusing this:\n  var + ?z \\<notin> vars (liftPoly 0 ?z c)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (liftPoly 0 0 c)", "using assms(6) lift00"], ["proof (prove)\nusing this:\n  var + ?z \\<notin> vars (liftPoly 0 ?z c)\n  (?var \\<notin> vars ?p) = (?var \\<notin> vars (- ?p))\n  var \\<notin> vars c\n  liftPoly 0 0 ?a = ?a\n\ngoal (1 subgoal):\n 1. var \\<notin> vars (liftPoly 0 0 c)", "by auto"], ["proof (state)\nthis:\n  var \\<notin> vars (liftPoly 0 0 c)\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "then"], ["proof (chain)\npicking this:\n  var \\<notin> vars (liftPoly 0 0 c)", "show ?thesis"], ["proof (prove)\nusing this:\n  var \\<notin> vars (liftPoly 0 0 c)\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "using assms"], ["proof (prove)\nusing this:\n  var \\<notin> vars (liftPoly 0 0 c)\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "using lb lc convert_linearSubstitutionUni[OF assms(1)  lb lc assms(4) nb nc]"], ["proof (prove)\nusing this:\n  var \\<notin> vars (liftPoly 0 0 c)\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 b) = B\n  insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 c) = C\n  length xs' = var \\<Longrightarrow>\n  aEval (linear_substitution var (- liftPoly 0 0 c) (liftPoly 0 0 b) a)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni B C a') x\n\ngoal (1 subgoal):\n 1. aEval\n     (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n     (xs' @ x # xs) =\n    evalUni (linearSubstitutionUni B C a') x", "by (simp add: lift00)"], ["proof (state)\nthis:\n  aEval\n   (linear_substitution (var + 0) (liftPoly 0 0 (- c)) (liftPoly 0 0 b) a)\n   (xs' @ x # xs) =\n  evalUni (linearSubstitutionUni B C a') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma evalUni_if : \"evalUni (if cond then TrueFUni else FalseFUni) x = cond\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (if cond then TrueFUni else FalseFUni) x = cond", "by(cases cond)(auto)"], ["", "lemma degree_less_sum' : \"MPoly_Type.degree (p::real mpoly) var = n \\<Longrightarrow> MPoly_Type.degree (q::real mpoly) var = m \\<Longrightarrow> n < m \\<Longrightarrow> MPoly_Type.degree (p + q) var = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = n; MPoly_Type.degree q var = m;\n     n < m\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree (p + q) var = m", "using degree_less_sum[of q var m p n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>MPoly_Type.degree q var = m; MPoly_Type.degree p var = n;\n   n < m\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (q + p) var = m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var = n; MPoly_Type.degree q var = m;\n     n < m\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree (p + q) var = m", "by (simp add: add.commute)"], ["", "lemma convert_substInfinitesimalLinear_less : \n  assumes \"convert_poly var p (xs'@x#xs) = Some(p')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"\neval (liftmap\n    (\\<lambda>x. \\<lambda>A. Atom(linear_substitution (var+x) (liftPoly 0 x (-c)) (liftPoly 0 x b) A)) \n    (convertDerivative var p)\n    0) (xs'@x#xs) =\nevalUni (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "proof(cases p')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "case (fields a' b' c')"], ["proof (state)\nthis:\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have h : \"convert_poly var p (xs'@x#xs) = Some (a', b', c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_poly var p (xs' @ x # xs) = Some (a', b', c')", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. convert_poly var p (xs' @ x # xs) = Some (a', b', c')", "by auto"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some (a', b', c')\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have h2 : \"\\<exists>F'. convert_fm var (convertDerivative var p) xs = Some F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F'. convert_fm var (convertDerivative var p) xs = Some F'", "unfolding convertDerivative.simps[of _ p] convertDerivative.simps[of _ \"derivative var p\"] convertDerivative.simps[of _ \"derivative var (derivative var p)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F'.\n       convert_fm var\n        (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n         else Or (fm.Atom (Less p))\n               (And (fm.Atom (Eq p))\n                 (if MPoly_Type.degree (derivative var p) var = 0\n                  then fm.Atom (Less (derivative var p))\n                  else Or (fm.Atom (Less (derivative var p)))\n                        (And (fm.Atom (Eq (derivative var p)))\n                          (if MPoly_Type.degree\n                               (derivative var (derivative var p)) var =\n                              0\n                           then fm.Atom\n                                 (Less (derivative var (derivative var p)))\n                           else Or (fm.Atom\n                                     (Less\n (derivative var (derivative var p))))\n                                 (And (fm.Atom\n  (Eq (derivative var (derivative var p))))\n                                   (convertDerivative var\n                                     (derivative var\n (derivative var (derivative var p))))))))))\n        xs =\n       Some F'", "apply( auto simp del: convertDerivative.simps)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 14 subgoals...", "using degree_convert_eq h"], ["proof (prove)\nusing this:\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n  convert_poly var p (xs' @ x # xs) = Some (a', b', c')\n\ngoal (14 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 14 subgoals...", "apply blast"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 13 subgoals...", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (13 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 13 subgoals...", "apply blast"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 12 subgoals...", "apply (metis Suc_eq_plus1 degree_derivative gr_implies_not0 less_trans_Suc nat_neq_iff)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      \\<not> MPoly_Type.degree (derivative var p) var < 3;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 11 subgoals...", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (11 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      \\<not> MPoly_Type.degree (derivative var p) var < 3;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 11 subgoals...", "apply blast"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   xs of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 xs)\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 xs)\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 xs)\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 xs)\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 xs) (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion (nth_default 0 xs)\n (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 xs) (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis One_nat_def Suc_eq_plus1 degree_derivative less_2_cases less_Suc_eq nat_neq_iff numeral_3_eq_3 one_add_one)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (8 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using degree_derivative"], ["proof (prove)\nusing this:\n  0 < MPoly_Type.degree ?p ?x \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree (derivative ?x ?p) ?x + 1\n\ngoal (7 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply force"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (6 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis degree_derivative eq_numeral_Suc less_add_one less_trans_Suc not_less_eq numeral_2_eq_2 pred_numeral_simps(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using degree_derivative"], ["proof (prove)\nusing this:\n  0 < MPoly_Type.degree ?p ?x \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree (derivative ?x ?p) ?x + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by (meson assms(1) degree_convert_eq)"], ["proof (state)\nthis:\n  \\<exists>F'. convert_fm var (convertDerivative var p) xs = Some F'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have c'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0) =\n                      c'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0) =\n                      c'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have b'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc 0)) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'", "have b'_insertion2 : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 1) = b'\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) =\n    b'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have a'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 2) = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2) =\n                      a'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2) =\n                      a'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have liftb : \"liftPoly 0 0 b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 0 b = b", "using lift00"], ["proof (prove)\nusing this:\n  liftPoly 0 0 ?a = ?a\n\ngoal (1 subgoal):\n 1. liftPoly 0 0 b = b", "by auto"], ["proof (state)\nthis:\n  liftPoly 0 0 b = b\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have liftc : \"liftPoly 0 0 c = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 0 c = c", "using lift00"], ["proof (prove)\nusing this:\n  liftPoly 0 0 ?a = ?a\n\ngoal (1 subgoal):\n 1. liftPoly 0 0 c = c", "by auto"], ["proof (state)\nthis:\n  liftPoly 0 0 c = c\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have b'_insertion' : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var 0) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) =\n                      b'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n     var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) =\n                      b'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) b \\<noteq> 0;\n     length xs' \\<notin> vars b; length xs' \\<notin> vars c;\n     p' =\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 2),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') (Suc 0)),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     MPoly_Type.degree p (length xs') < 3;\n     B = insertion (nth_default 0 (xs' @ x # xs)) b;\n     C = insertion (nth_default 0 (xs' @ x # xs)) c; var = length xs';\n     a' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 0)\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p (length xs') (Suc 0))\n                         (length xs') 0) =\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0))", "by (simp add: degree0isovarspar degree_isovarspar)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var 0) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have insertion_into_1 : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse (Const 1) var 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (Const 1) var 0) =\n    1", "by (simp add: const_lookup_zero insertion_const)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (Const 1) var 0) =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "have twominusone : \"((2-1)::nat) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 1 = 1", "by auto"], ["proof (state)\nthis:\n  2 - 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       p' = (a, ba, ca) \\<Longrightarrow>\n       eval\n        (liftmap\n          (\\<lambda>x A.\n              fm.Atom\n               (linear_substitution (var + x) (liftPoly 0 x (- c))\n                 (liftPoly 0 x b) A))\n          (convertDerivative var p) 0)\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p'))\n        x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "have simp: \"(convertDerivative var p)=Atom(Less p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convertDerivative var p = fm.Atom (Less p)", "using True"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. convertDerivative var p = fm.Atom (Less p)", "by auto"], ["proof (state)\nthis:\n  convertDerivative var p = fm.Atom (Less p)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "have azero : \"a'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = 0", "by (metis MPoly_Type.insertion_zero True a'_insertion isolate_variable_sparse_ne_zeroD nat.simps(3) not_less numeral_2_eq_2 zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "have bzero : \"b'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = 0", "using True b'_insertion isovar_greater_degree"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n  \\<forall>i>MPoly_Type.degree ?p ?var.\n     isolate_variable_sparse ?p ?var i = 0\n\ngoal (1 subgoal):\n 1. b' = 0", "by fastforce"], ["proof (state)\nthis:\n  b' = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "unfolding fields substInfinitesimalLinearUni.simps\n        convertDerivativeUni.simps linearSubstitutionUni.simps map_atomUni.simps evalUni.simps evalUni_if aEvalUni.simps\n        Rings.mult_zero_class.mult_zero_left Rings.mult_zero_class.mult_zero_right Groups.add_0 azero bzero\n        substInfinitesimalLinear.simps convertDerivative.simps[of _ p] True simp liftmap.simps \n        linear_substitution.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (if 0 = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0)\n     (xs' @ x # xs) =\n    (c' < 0 \\<or> c' = 0 \\<and> (0 < 0 \\<or> 0 = 0 \\<and> 0 < 0))", "apply (auto simp add:True)"], ["proof (prove)\ngoal (2 subgoals):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)\n    < 0 \\<Longrightarrow>\n    c' < 0\n 2. c' < 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)\n    < 0", "unfolding c'_insertion"], ["proof (prove)\ngoal (2 subgoals):\n 1. c' < 0 \\<Longrightarrow> c' < 0\n 2. c' < 0 \\<Longrightarrow> c' < 0", "by auto"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have degnot0 : \"MPoly_Type.degree p var \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 1", "have simp : \"convertDerivative var p = Or (fm.Atom (Less p)) (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. convertDerivative var p =\n    Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))", "by (metis One_nat_def Suc_eq_plus1 add_right_imp_eq convertDerivative.simps degnot0 degree_derivative zero_less_one)"], ["proof (state)\nthis:\n  convertDerivative var p =\n  Or (fm.Atom (Less p))\n   (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have azero : \"a'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = 0", "by (metis MPoly_Type.insertion_zero One_nat_def True a'_insertion isovar_greater_degree lessI numeral_2_eq_2)"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have degderiv : \"MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "using degree_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (?p * ?q) ?v =\n                    MPoly_Type.degree ?p ?v + MPoly_Type.degree ?q ?v\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "by (simp add: degree_isovarspar mult_one_right)"], ["proof (state)\nthis:\n  MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var = 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x\n 2. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "unfolding fields substInfinitesimalLinearUni.simps\n          convertDerivativeUni.simps linearSubstitutionUni.simps map_atomUni.simps evalUni.simps evalUni_if aEvalUni.simps\n          Rings.mult_zero_class.mult_zero_left Rings.mult_zero_class.mult_zero_right Groups.add_0 azero\n          substInfinitesimalLinear.simps True simp liftmap.simps \n          linear_substitution.simps eval_Or eval_And liftb liftc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (fm.Atom\n        (let d = MPoly_Type.degree p (var + 0);\n             P = \\<Sum>i = 0..<d + 1.\n                    isolate_variable_sparse p (var + 0) i *\n                    liftPoly 0 0 (- c) ^ i *\n                    b ^ (d - i)\n         in Less (P * b ^ (d mod 2))))\n      (xs' @ x # xs) \\<or>\n     eval\n      (fm.Atom\n        (let d = MPoly_Type.degree p (var + 0)\n         in Eq (\\<Sum>i = 0..<d + 1.\n                   isolate_variable_sparse p (var + 0) i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i))))\n      (xs' @ x # xs) \\<and>\n     eval\n      (fm.Atom\n        (let d = MPoly_Type.degree (derivative var p) (var + 0);\n             P = \\<Sum>i = 0..<d + 1.\n                    isolate_variable_sparse (derivative var p) (var + 0) i *\n                    liftPoly 0 0 (- c) ^ i *\n                    b ^ (d - i)\n         in Less (P * b ^ (d mod 2))))\n      (xs' @ x # xs)) =\n    (b' * (- C / B) + c' < 0 \\<or>\n     b' * (- C / B) + c' = 0 \\<and> (b' < 0 \\<or> b' = 0 \\<and> 0 < 0))", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>aEval\n              (let d = MPoly_Type.degree p var\n               in Less\n                   (((\\<Sum>i = 0..<d.\n                         isolate_variable_sparse p var i *\n                         liftPoly 0 0 (- c) ^ i *\n                         b ^ (d - i)) +\n                     isolate_variable_sparse p var d *\n                     liftPoly 0 0 (- c) ^ d) *\n                    b ^ (d mod 2)))\n              (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>aEval\n              (let d = MPoly_Type.degree p var\n               in Less\n                   (((\\<Sum>i = 0..<d.\n                         isolate_variable_sparse p var i *\n                         liftPoly 0 0 (- c) ^ i *\n                         b ^ (d - i)) +\n                     isolate_variable_sparse p var d *\n                     liftPoly 0 0 (- c) ^ d) *\n                    b ^ (d mod 2)))\n              (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>aEval\n              (let d = MPoly_Type.degree p var\n               in Eq ((\\<Sum>i = 0..<d.\n                          isolate_variable_sparse p var i *\n                          liftPoly 0 0 (- c) ^ i *\n                          b ^ (d - i)) +\n                      isolate_variable_sparse p var d *\n                      liftPoly 0 0 (- c) ^ d))\n              (xs' @ x # xs);\n     aEval\n      (let d = MPoly_Type.degree (derivative var p) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse (derivative var p) var i *\n                 liftPoly 0 0 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse (derivative var p) var d *\n             liftPoly 0 0 (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 4. \\<lbrakk>aEval\n              (let d = MPoly_Type.degree p var\n               in Eq ((\\<Sum>i = 0..<d.\n                          isolate_variable_sparse p var i *\n                          liftPoly 0 0 (- c) ^ i *\n                          b ^ (d - i)) +\n                      isolate_variable_sparse p var d *\n                      liftPoly 0 0 (- c) ^ d))\n              (xs' @ x # xs);\n     aEval\n      (let d = MPoly_Type.degree (derivative var p) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse (derivative var p) var i *\n                 liftPoly 0 0 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse (derivative var p) var d *\n             liftPoly 0 0 (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 5. \\<lbrakk>c' < b' * C / B;\n     \\<not> aEval\n             (let d = MPoly_Type.degree p var\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i *\n                        liftPoly 0 0 (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d *\n                    liftPoly 0 0 (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree p var\n                        in Eq ((\\<Sum>i = 0..<d.\n                                   isolate_variable_sparse p var i *\n                                   liftPoly 0 0 (- c) ^ i *\n                                   b ^ (d - i)) +\n                               isolate_variable_sparse p var d *\n                               liftPoly 0 0 (- c) ^ d))\n                       (xs' @ x # xs)\n 6. \\<lbrakk>c' < b' * C / B;\n     \\<not> aEval\n             (let d = MPoly_Type.degree p var\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i *\n                        liftPoly 0 0 (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d *\n                    liftPoly 0 0 (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree (derivative var p) var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse (derivative var p)\n                                   var i *\n                                  liftPoly 0 0 (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse (derivative var p) var\n                               d *\n                              liftPoly 0 0 (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 7. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> aEval\n             (let d = MPoly_Type.degree p var\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i *\n                        liftPoly 0 0 (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d *\n                    liftPoly 0 0 (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree p var\n                        in Eq ((\\<Sum>i = 0..<d.\n                                   isolate_variable_sparse p var i *\n                                   liftPoly 0 0 (- c) ^ i *\n                                   b ^ (d - i)) +\n                               isolate_variable_sparse p var d *\n                               liftPoly 0 0 (- c) ^ d))\n                       (xs' @ x # xs)\n 8. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> aEval\n             (let d = MPoly_Type.degree p var\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i *\n                        liftPoly 0 0 (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d *\n                    liftPoly 0 0 (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree (derivative var p) var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse (derivative var p)\n                                   var i *\n                                  liftPoly 0 0 (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse (derivative var p) var\n                               d *\n                              liftPoly 0 0 (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "unfolding derivative_def True insertion_sub insertion_mult c'_insertion b'_insertion assms lift00"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>aEval\n              (let d = 1\n               in Less\n                   (((\\<Sum>i = 0..<d.\n                         isolate_variable_sparse p var i * (- c) ^ i *\n                         b ^ (d - i)) +\n                     isolate_variable_sparse p var d * (- c) ^ d) *\n                    b ^ (d mod 2)))\n              (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>aEval\n              (let d = 1\n               in Less\n                   (((\\<Sum>i = 0..<d.\n                         isolate_variable_sparse p var i * (- c) ^ i *\n                         b ^ (d - i)) +\n                     isolate_variable_sparse p var d * (- c) ^ d) *\n                    b ^ (d mod 2)))\n              (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>aEval\n              (let d = 1\n               in Eq ((\\<Sum>i = 0..<d.\n                          isolate_variable_sparse p var i * (- c) ^ i *\n                          b ^ (d - i)) +\n                      isolate_variable_sparse p var d * (- c) ^ d))\n              (xs' @ x # xs);\n     aEval\n      (let d = MPoly_Type.degree\n                (\\<Sum>i = 0..1 - 1.\n                    isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                    Const (real (i + 1)))\n                var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (\\<Sum>i = 0..1 - 1.\n                      isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                      Const (real (i + 1)))\n                  var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (\\<Sum>i = 0..1 - 1.\n                  isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                  Const (real (i + 1)))\n              var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 4. \\<lbrakk>aEval\n              (let d = 1\n               in Eq ((\\<Sum>i = 0..<d.\n                          isolate_variable_sparse p var i * (- c) ^ i *\n                          b ^ (d - i)) +\n                      isolate_variable_sparse p var d * (- c) ^ d))\n              (xs' @ x # xs);\n     aEval\n      (let d = MPoly_Type.degree\n                (\\<Sum>i = 0..1 - 1.\n                    isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                    Const (real (i + 1)))\n                var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (\\<Sum>i = 0..1 - 1.\n                      isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                      Const (real (i + 1)))\n                  var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (\\<Sum>i = 0..1 - 1.\n                  isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                  Const (real (i + 1)))\n              var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 5. \\<lbrakk>c' < b' * C / B;\n     \\<not> aEval\n             (let d = 1\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i * (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d * (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = 1\n                        in Eq ((\\<Sum>i = 0..<d.\n                                   isolate_variable_sparse p var i *\n                                   (- c) ^ i *\n                                   b ^ (d - i)) +\n                               isolate_variable_sparse p var d * (- c) ^ d))\n                       (xs' @ x # xs)\n 6. \\<lbrakk>c' < b' * C / B;\n     \\<not> aEval\n             (let d = 1\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i * (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d * (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (\\<Sum>i = 0..1 - 1.\n                                     isolate_variable_sparse p var (i + 1) *\n                                     Var var ^ i *\n                                     Const (real (i + 1)))\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (\\<Sum>i = 0..1 - 1.\n isolate_variable_sparse p var (i + 1) * Var var ^ i * Const (real (i + 1)))\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (\\<Sum>i = 0..1 - 1.\n                                   isolate_variable_sparse p var (i + 1) *\n                                   Var var ^ i *\n                                   Const (real (i + 1)))\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 7. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> aEval\n             (let d = 1\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i * (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d * (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = 1\n                        in Eq ((\\<Sum>i = 0..<d.\n                                   isolate_variable_sparse p var i *\n                                   (- c) ^ i *\n                                   b ^ (d - i)) +\n                               isolate_variable_sparse p var d * (- c) ^ d))\n                       (xs' @ x # xs)\n 8. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> aEval\n             (let d = 1\n              in Less\n                  (((\\<Sum>i = 0..<d.\n                        isolate_variable_sparse p var i * (- c) ^ i *\n                        b ^ (d - i)) +\n                    isolate_variable_sparse p var d * (- c) ^ d) *\n                   b ^ (d mod 2)))\n             (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (\\<Sum>i = 0..1 - 1.\n                                     isolate_variable_sparse p var (i + 1) *\n                                     Var var ^ i *\n                                     Const (real (i + 1)))\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (\\<Sum>i = 0..1 - 1.\n isolate_variable_sparse p var (i + 1) * Var var ^ i * Const (real (i + 1)))\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (\\<Sum>i = 0..1 - 1.\n                                   isolate_variable_sparse p var (i + 1) *\n                                   Var var ^ i *\n                                   Const (real (i + 1)))\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs))\n              ((isolate_variable_sparse p var 0 * b -\n                isolate_variable_sparse p var (Suc 0) * c) *\n               b)\n             < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs))\n              ((isolate_variable_sparse p var 0 * b -\n                isolate_variable_sparse p var (Suc 0) * c) *\n               b)\n             < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) =\n             0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 4. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) =\n             0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 5. \\<lbrakk>c' < b' * C / B;\n     \\<not> insertion (nth_default 0 (xs' @ x # xs))\n             ((isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) *\n              b)\n            < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0 * b -\n                        isolate_variable_sparse p var (Suc 0) * c) =\n                      0\n 6. \\<lbrakk>c' < b' * C / B;\n     \\<not> insertion (nth_default 0 (xs' @ x # xs))\n             ((isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) *\n              b)\n            < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 7. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> insertion (nth_default 0 (xs' @ x # xs))\n             ((isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) *\n              b)\n            < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0 * b -\n                        isolate_variable_sparse p var (Suc 0) * c) =\n                      0\n 8. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> insertion (nth_default 0 (xs' @ x # xs))\n             ((isolate_variable_sparse p var 0 * b -\n               isolate_variable_sparse p var (Suc 0) * c) *\n              b)\n            < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "unfolding insertion_sub insertion_mult c'_insertion b'_insertion assms lift00"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>(c' * B - b' * C) * B < 0; \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>(c' * B - b' * C) * B < 0; \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 4. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 5. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 6. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 7. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 8. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "apply (smt diff_divide_eq_iff divide_less_0_iff mult_less_0_iff)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(c' * B - b' * C) * B < 0; \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 3. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 4. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 5. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 6. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 7. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "apply (smt mult_imp_less_div_pos neg_less_divide_eq zero_le_mult_iff)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 4. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 6. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "using assms(4) mult.commute nonzero_mult_div_cancel_left"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n  ?a * ?b = ?b * ?a\n  ?a \\<noteq> (0::?'a) \\<Longrightarrow> ?a * ?b div ?a = ?b\n\ngoal (6 subgoals):\n 1. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> c' = b' * C / B\n 2. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 4. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 6. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "apply smt"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = MPoly_Type.degree\n                (isolate_variable_sparse p var (Suc 0) * Const 1) var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 4. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = MPoly_Type.degree\n                                 (isolate_variable_sparse p var (Suc 0) *\n                                  Const 1)\n                                 var\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "unfolding degderiv"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B - b' * C = 0;\n     aEval\n      (let d = 0\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse\n                  (isolate_variable_sparse p var (Suc 0) * Const 1) var i *\n                 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse\n              (isolate_variable_sparse p var (Suc 0) * Const 1) var d *\n             (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs);\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = 0\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)\n 4. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B - b' * C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> aEval\n                       (let d = 0\n                        in Less\n                            (((\\<Sum>i = 0..<d.\n                                  isolate_variable_sparse\n                                   (isolate_variable_sparse p var (Suc 0) *\n                                    Const 1)\n                                   var i *\n                                  (- c) ^ i *\n                                  b ^ (d - i)) +\n                              isolate_variable_sparse\n                               (isolate_variable_sparse p var (Suc 0) *\n                                Const 1)\n                               var d *\n                              (- c) ^ d) *\n                             b ^ (d mod 2)))\n                       (xs' @ x # xs)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse\n        (isolate_variable_sparse p var (Suc 0) * Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B = b' * C\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0) * Const 1)\n                         var 0)\n                      < 0\n 4. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0) * Const 1)\n                         var 0)\n                      < 0", "unfolding isolate_variable_sparse_mult"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i\\<le>0.\n          isolate_variable_sparse (isolate_variable_sparse p var (Suc 0))\n           var i *\n          isolate_variable_sparse (Const 1) var (0 - i))\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B = b' * C\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (\\<Sum>i\\<le>0.\n                           isolate_variable_sparse\n                            (isolate_variable_sparse p var (Suc 0)) var i *\n                           isolate_variable_sparse (Const 1) var (0 - i))\n                      < 0\n 4. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (\\<Sum>i\\<le>0.\n                           isolate_variable_sparse\n                            (isolate_variable_sparse p var (Suc 0)) var i *\n                           isolate_variable_sparse (Const 1) var (0 - i))\n                      < 0", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0 *\n       isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B = b' * C\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0 *\n                        isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 4. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0 *\n                        isolate_variable_sparse (Const 1) var 0)\n                      < 0", "unfolding insertion_mult"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B = b' * C\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 4. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 5. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> c' * B = b' * C\n 2. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 3. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 4. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 5. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0", "apply (smt assms(4) diff_divide_eq_iff divide_less_0_iff mult_less_0_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 2. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 3. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 4. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 2. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 3. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 4. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0", "using assms(4)"], ["proof (prove)\nusing this:\n  B \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>c' = 0; b' < 0; B = 0\\<rbrakk> \\<Longrightarrow> C = 0\n 2. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 3. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 4. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0\n 2. \\<lbrakk>c' * B = b' * C;\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Const 1) var 0)\n     < 0;\n     \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) *\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse (Const 1) var 0)\n                      < 0", "unfolding b'_insertion' insertion_into_1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>c' = b' * C / B; b' < 0;\n     \\<not> ((if B = 0 then 0 else b' * C) - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> b' * 1 < 0\n 2. \\<lbrakk>c' * B = b' * C; b' * 1 < 0; \\<not> c' < b' * C / B\\<rbrakk>\n    \\<Longrightarrow> b' < 0\n 3. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> b' * 1 < 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c' < b' * C / B; \\<not> (c' * B - b' * C) * B < 0\\<rbrakk>\n    \\<Longrightarrow> b' < 0", "by (smt assms(4) less_divide_eq mult_pos_neg2 no_zero_divisors zero_less_mult_pos)"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have degreetwo : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degnot0"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by (metis One_nat_def degree_convert_eq h less_2_cases less_Suc_eq numeral_2_eq_2 numeral_3_eq_3)"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have two : \"(2::nat) = Suc(Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have sum : \"(\\<Sum>i = 0..<2. isolate_variable_sparse p var i * (- c) ^ i * b ^ (2 - i)) =\n                  isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (2 - 0) + isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (2 - 1) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<2.\n        isolate_variable_sparse p var i * (- c) ^ i * b ^ (2 - i)) =\n    isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (2 - 0) +\n    isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (2 - 1)", "unfolding Set_Interval.comm_monoid_add_class.sum.atLeast0_lessThan_Suc two"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<0.\n        isolate_variable_sparse p var i * (- c) ^ i *\n        b ^ (Suc (Suc 0) - i)) +\n    isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (Suc (Suc 0) - 0) +\n    isolate_variable_sparse p var (Suc 0) * (- c) ^ Suc 0 *\n    b ^ (Suc (Suc 0) - Suc 0) =\n    isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (Suc (Suc 0) - 0) +\n    isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (Suc (Suc 0) - 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<2.\n      isolate_variable_sparse p var i * (- c) ^ i * b ^ (2 - i)) =\n  isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (2 - 0) +\n  isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (2 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have a : \"isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0", "by (metis degnot0 degree_isovarspar degreetwo isolate_variable_sparse_degree_eq_zero_iff numeral_2_eq_2)"], ["proof (state)\nthis:\n  isolate_variable_sparse p var (Suc (Suc 0)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have b : \"((Var var * Const 2) :: real mpoly) \\<noteq> (0::real mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var var * Const 2 \\<noteq> 0", "by (metis MPoly_Type.degree_zero ExecutiblePolyProps.degree_one mult_eq_0_iff nonzero_const_is_nonzero zero_neq_numeral zero_neq_one)"], ["proof (state)\nthis:\n  Var var * Const 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have degreedeg1 : \"MPoly_Type.degree\n               (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n               var  = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var =\n    1", "apply(rule degree_less_sum'[where n =\"0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0\n 2. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1\n 3. 0 < 1", "apply (simp add: degree_isovarspar mult_one_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1\n 2. 0 < 1", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1\n 2. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1", "using degree_mult[OF a b, of var]"], ["proof (prove)\nusing this:\n  MPoly_Type.degree\n   (isolate_variable_sparse p var (Suc (Suc 0)) * (Var var * Const 2)) var =\n  MPoly_Type.degree (isolate_variable_sparse p var (Suc (Suc 0))) var +\n  MPoly_Type.degree (Var var * Const 2) var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1", "by (metis (no_types, hide_lams) ExecutiblePolyProps.degree_one add.left_neutral b degree_const degree_isovarspar degree_mult mult.commute mult_zero_class.mult_zero_right)"], ["proof (state)\nthis:\n  MPoly_Type.degree\n   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n    isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n   var =\n  1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have simp : \"(convertDerivative var p) = Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p))\n       (Or (fm.Atom (Less (derivative var p)))\n         (And (fm.Atom (Eq (derivative var p))) (fm.Atom (Less (derivative var (derivative var p)))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convertDerivative var p =\n    Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p))\n       (Or (fm.Atom (Less (derivative var p)))\n         (And (fm.Atom (Eq (derivative var p)))\n           (fm.Atom (Less (derivative var (derivative var p)))))))", "using degreetwo"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. convertDerivative var p =\n    Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p))\n       (Or (fm.Atom (Less (derivative var p)))\n         (And (fm.Atom (Eq (derivative var p)))\n           (fm.Atom (Less (derivative var (derivative var p)))))))", "by (metis One_nat_def Suc_1 Suc_eq_plus1 add_diff_cancel_right' convertDerivative.simps degree_derivative neq0_conv zero_less_Suc)"], ["proof (state)\nthis:\n  convertDerivative var p =\n  Or (fm.Atom (Less p))\n   (And (fm.Atom (Eq p))\n     (Or (fm.Atom (Less (derivative var p)))\n       (And (fm.Atom (Eq (derivative var p)))\n         (fm.Atom (Less (derivative var (derivative var p)))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have a : \"insertion (nth_default 0 (xs'@x#xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var 0) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var 0) =\n    b'", "unfolding isovarspar_sum isolate_variable_sparse_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((\\<Sum>i\\<le>0.\n          isolate_variable_sparse (isolate_variable_sparse p var (Suc 0))\n           var i *\n          isolate_variable_sparse (Const 1) var (0 - i)) +\n      (\\<Sum>i\\<le>0.\n          (\\<Sum>ia\\<le>i.\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc (Suc 0))) var ia *\n              isolate_variable_sparse (Var var) var (i - ia)) *\n          isolate_variable_sparse (Const 2) var (0 - i))) =\n    b'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0 *\n      isolate_variable_sparse (Const 1) var 0 +\n      isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0 *\n      isolate_variable_sparse (Var var) var 0 *\n      isolate_variable_sparse (Const 2) var 0) =\n    b'", "unfolding const_lookup_suc const_lookup_zero Rings.mult_zero_class.mult_zero_right\n          Groups.group_add_class.add.group_left_neutral"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0 *\n      Const 1 +\n      isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0 *\n      isolate_variable_sparse (Var var) var 0 *\n      Const 2) =\n    b'", "by (simp add: b'_insertion' isolate_var_0 mult_one_right)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var 0) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have b : \"insertion (nth_default 0 (xs'@x#xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0)) = 2 * a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0)) =\n    2 * a'", "unfolding isovarspar_sum isolate_variable_sparse_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     ((\\<Sum>i\\<le>Suc 0.\n          isolate_variable_sparse (isolate_variable_sparse p var (Suc 0))\n           var i *\n          isolate_variable_sparse (Const 1) var (Suc 0 - i)) +\n      (\\<Sum>i\\<le>Suc 0.\n          (\\<Sum>ia\\<le>i.\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc (Suc 0))) var ia *\n              isolate_variable_sparse (Var var) var (i - ia)) *\n          isolate_variable_sparse (Const 2) var (Suc 0 - i))) =\n    2 * a'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0 *\n      isolate_variable_sparse (Const 1) var (Suc 0) +\n      isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0) *\n      isolate_variable_sparse (Const 1) var 0 +\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0 *\n       isolate_variable_sparse (Var var) var 0 *\n       isolate_variable_sparse (Const 2) var (Suc 0) +\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var 0 *\n        isolate_variable_sparse (Var var) var (Suc 0) +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0) *\n        isolate_variable_sparse (Var var) var 0) *\n       isolate_variable_sparse (Const 2) var 0)) =\n    2 * a'", "unfolding const_lookup_suc const_lookup_zero Rings.mult_zero_class.mult_zero_right\n          Groups.group_add_class.add.group_left_neutral"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0) *\n      Const 1 +\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0 *\n       isolate_variable_sparse (Var var) var (Suc 0) +\n       isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0) *\n       isolate_variable_sparse (Var var) var 0) *\n      Const 2) =\n    2 * a'", "unfolding insertion_add insertion_mult insertion_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) *\n    1 +\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var (Suc 0)) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0)) *\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse (Var var) var 0)) *\n    2 =\n    2 * a'", "by (metis MPoly_Type.insertion_one MPoly_Type.insertion_zero One_nat_def a'_insertion add.commute add.right_neutral degree0isovarspar degree_isovarspar isolate_var_one isovar_greater_degree mult.commute mult.right_neutral mult_zero_class.mult_zero_right numeral_2_eq_2 zero_less_one)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0)) =\n  2 * a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have simp_insertion_blob : \"insertion (nth_default 0 (xs'@x#xs))\n     (isolate_variable_sparse\n        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n         isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n        var 0 *\n       b -\n       isolate_variable_sparse\n        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n         isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n        var (Suc 0) *\n       c) = b' * B - 2 * a' * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var 0 *\n      b -\n      isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0) *\n      c) =\n    b' * B - 2 * a' * C", "unfolding insertion_sub insertion_mult assms a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b' * B - 2 * a' * C = b' * B - 2 * a' * C", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var 0 *\n    b -\n    isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0) *\n    c) =\n  b' * B - 2 * a' * C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have a : \"isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0) \\<noteq>\n    0", "by (metis MPoly_Type.degree_zero One_nat_def degreedeg1 isolate_variable_sparse_degree_eq_zero_iff zero_neq_one)"], ["proof (state)\nthis:\n  isolate_variable_sparse\n   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n    isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n   var (Suc 0) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have b' : \"(Const 1::real mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const 1 \\<noteq> 0", "by (simp add: nonzero_const_is_nonzero)"], ["proof (state)\nthis:\n  Const 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have degreeblob : \"MPoly_Type.degree\n               (isolate_variable_sparse\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n                 var (Suc 0) *\n                Const 1)\n               var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0) *\n      Const 1)\n     var =\n    0", "unfolding degree_mult[OF a b', of var]"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0))\n     var +\n    MPoly_Type.degree (Const 1) var =\n    0", "by (simp add: degree_isovarspar degree_eq_iff monomials_Const)"], ["proof (state)\nthis:\n  MPoly_Type.degree\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0) *\n    Const 1)\n   var =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have otherblob : \"insertion (nth_default 0 (xs'@x#xs))\n      (isolate_variable_sparse\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) * Const 1 +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var (Suc 0) *\n         Const 1)\n        var 0) = 2 * a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1)\n       var 0) =\n    2 * a'", "using b"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0)) =\n  2 * a'\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1)\n       var 0) =\n    2 * a'", "by (simp add: degree0isovarspar degree_isovarspar mult_one_right)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0) *\n      Const 1)\n     var 0) =\n  2 * a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"(c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) = ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2)/(B\\<^sup>2) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n    ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0)", "by (simp add: assms(4) divide_less_0_iff)"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "also"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"... = (((c' * B\\<^sup>2)/(B\\<^sup>2) - (b' * C * B)/(B\\<^sup>2) + (a' * C\\<^sup>2)/(B\\<^sup>2)) < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0) =\n    (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0)", "by (metis (no_types, lifting) add_divide_distrib diff_divide_distrib )"], ["proof (state)\nthis:\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0) =\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "also"], ["proof (state)\nthis:\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 < 0) =\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"... = (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "assume \"c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\""], ["proof (state)\nthis:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "then"], ["proof (chain)\npicking this:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0", "have ?thesis"], ["proof (prove)\nusing this:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "by (simp add: assms(4) power2_eq_square)"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "}"], ["proof (state)\nthis:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "moreover"], ["proof (state)\nthis:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "{"], ["proof (state)\nthis:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "assume \"\\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\""], ["proof (state)\nthis:\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "}"], ["proof (state)\nthis:\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "ultimately"], ["proof (chain)\npicking this:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n  \\<not> c' + a' * (C / B)\\<^sup>2 - b' * (C / B) < 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2\n     < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "by fastforce"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2\n   < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "finally"], ["proof (chain)\npicking this:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "have h1: \"(c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) = (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\""], ["proof (prove)\nusing this:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)", "."], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 < 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"(c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) = ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2)/(B\\<^sup>2) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n    ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0)", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "also"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"... = (((c' * B\\<^sup>2)/(B\\<^sup>2) - (b' * C * B)/(B\\<^sup>2) + (a' * C\\<^sup>2)/(B\\<^sup>2)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0) =\n    (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0)", "by (metis (no_types, lifting) add_divide_distrib diff_divide_distrib )"], ["proof (state)\nthis:\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0) =\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "also"], ["proof (state)\nthis:\n  ((c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2) / B\\<^sup>2 = 0) =\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have \"... = (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "assume \"c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0\""], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "then"], ["proof (chain)\npicking this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0", "have ?thesis"], ["proof (prove)\nusing this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "by (simp add: assms(4) power2_eq_square)"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "}"], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "moreover"], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "{"], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "assume \"c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0\""], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "then"], ["proof (chain)\npicking this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0", "have ?thesis"], ["proof (prove)\nusing this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "}"], ["proof (state)\nthis:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "ultimately"], ["proof (chain)\npicking this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) \\<noteq> 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n  c' + a' * (C * (C / (B * B))) - b' * (C / B) = 0 \\<Longrightarrow>\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n     a' * C\\<^sup>2 / B\\<^sup>2 =\n     0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "by fastforce"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 / B\\<^sup>2 - b' * C * B / B\\<^sup>2 +\n   a' * C\\<^sup>2 / B\\<^sup>2 =\n   0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "finally"], ["proof (chain)\npicking this:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "have h2 : \"(c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) = (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\""], ["proof (prove)\nusing this:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)", "."], ["proof (state)\nthis:\n  (c' * B\\<^sup>2 - b' * C * B + a' * C\\<^sup>2 = 0) =\n  (a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have h3 : \"((b' * B - 2 * a' * C) * B < 0) = (b' < 2 * a' * C / B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((b' * B - 2 * a' * C) * B < 0) = (b' < 2 * a' * C / B)", "by (smt assms(4) less_divide_eq zero_le_mult_iff)"], ["proof (state)\nthis:\n  ((b' * B - 2 * a' * C) * B < 0) = (b' < 2 * a' * C / B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "have h4 : \"(b' * B = 2 * a' * C) = (b' = 2 * a' * C / B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b' * B = 2 * a' * C) = (b' = 2 * a' * C / B)", "by (simp add: assms(4) nonzero_eq_divide_eq)"], ["proof (state)\nthis:\n  (b' * B = 2 * a' * C) = (b' = 2 * a' * C / B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree p var \\<noteq> 0;\n     MPoly_Type.degree p var \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> eval\n                       (liftmap\n                         (\\<lambda>x A.\n                             fm.Atom\n                              (linear_substitution (var + x)\n                                (liftPoly 0 x (- c)) (liftPoly 0 x b) A))\n                         (convertDerivative var p) 0)\n                       (xs' @ x # xs) =\n                      evalUni\n                       (map_atomUni (linearSubstitutionUni B C)\n                         (convertDerivativeUni p'))\n                       x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x (- c))\n              (liftPoly 0 x b) A))\n       (convertDerivative var p) 0)\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x", "unfolding fields substInfinitesimalLinearUni.simps\n          convertDerivativeUni.simps linearSubstitutionUni.simps map_atomUni.simps evalUni.simps evalUni_if aEvalUni.simps\n          Rings.mult_zero_class.mult_zero_left Rings.mult_zero_class.mult_zero_right Groups.add_0\n          substInfinitesimalLinear.simps degreetwo simp liftmap.simps \n          linear_substitution.simps eval_Or eval_And liftb liftc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval\n      (fm.Atom\n        (let d = MPoly_Type.degree p (var + 0);\n             P = \\<Sum>i = 0..<d + 1.\n                    isolate_variable_sparse p (var + 0) i *\n                    liftPoly 0 0 (- c) ^ i *\n                    b ^ (d - i)\n         in Less (P * b ^ (d mod 2))))\n      (xs' @ x # xs) \\<or>\n     eval\n      (fm.Atom\n        (let d = MPoly_Type.degree p (var + 0)\n         in Eq (\\<Sum>i = 0..<d + 1.\n                   isolate_variable_sparse p (var + 0) i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i))))\n      (xs' @ x # xs) \\<and>\n     (eval\n       (fm.Atom\n         (let d = MPoly_Type.degree (derivative var p) (var + 0);\n              P = \\<Sum>i = 0..<d + 1.\n                     isolate_variable_sparse (derivative var p) (var + 0)\n                      i *\n                     liftPoly 0 0 (- c) ^ i *\n                     b ^ (d - i)\n          in Less (P * b ^ (d mod 2))))\n       (xs' @ x # xs) \\<or>\n      eval\n       (fm.Atom\n         (let d = MPoly_Type.degree (derivative var p) (var + 0)\n          in Eq (\\<Sum>i = 0..<d + 1.\n                    isolate_variable_sparse (derivative var p) (var + 0) i *\n                    liftPoly 0 0 (- c) ^ i *\n                    b ^ (d - i))))\n       (xs' @ x # xs) \\<and>\n      eval\n       (fm.Atom\n         (let d = MPoly_Type.degree (derivative var (derivative var p))\n                   (var + 0);\n              P = \\<Sum>i = 0..<d + 1.\n                     isolate_variable_sparse\n                      (derivative var (derivative var p)) (var + 0) i *\n                     liftPoly 0 0 (- c) ^ i *\n                     b ^ (d - i)\n          in Less (P * b ^ (d mod 2))))\n       (xs' @ x # xs))) =\n    (a' * (- C / B)\\<^sup>2 + b' * (- C / B) + c' < 0 \\<or>\n     a' * (- C / B)\\<^sup>2 + b' * (- C / B) + c' = 0 \\<and>\n     (2 * a' * (- C / B) + b' < 0 \\<or>\n      2 * a' * (- C / B) + b' = 0 \\<and> 2 * a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (aEval\n      (let d = MPoly_Type.degree p var\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse p var d * liftPoly 0 0 (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs) \\<or>\n     aEval\n      (let d = MPoly_Type.degree p var\n       in Eq ((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse p var d * liftPoly 0 0 (- c) ^ d))\n      (xs' @ x # xs) \\<and>\n     (aEval\n       (let d = MPoly_Type.degree (derivative var p) var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse (derivative var p) var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse (derivative var p) var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = MPoly_Type.degree (derivative var p) var\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse (derivative var p) var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse (derivative var p) var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree (derivative var (derivative var p)) var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (derivative var (derivative var p)) var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse (derivative var (derivative var p))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding derivative_def degreetwo insertion_sub insertion_mult c'_insertion b'_insertion assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. (aEval\n      (let d = 2\n       in Less\n           (((\\<Sum>i = 0..<d.\n                 isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n                 b ^ (d - i)) +\n             isolate_variable_sparse p var d * liftPoly 0 0 (- c) ^ d) *\n            b ^ (d mod 2)))\n      (xs' @ x # xs) \\<or>\n     aEval\n      (let d = 2\n       in Eq ((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse p var d * liftPoly 0 0 (- c) ^ d))\n      (xs' @ x # xs) \\<and>\n     (aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..2 - 1.\n                     isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                     Const (real (i + 1)))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..2 - 1.\n                       isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                       Const (real (i + 1)))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..2 - 1.\n                   isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                   Const (real (i + 1)))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..2 - 1.\n                     isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                     Const (real (i + 1)))\n                 var\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse\n                    (\\<Sum>i = 0..2 - 1.\n                        isolate_variable_sparse p var (i + 1) *\n                        Var var ^ i *\n                        Const (real (i + 1)))\n                    var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse\n                (\\<Sum>i = 0..2 - 1.\n                    isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                    Const (real (i + 1)))\n                var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..MPoly_Type.degree\n                                (\\<Sum>i = 0..2 - 1.\n                                    isolate_variable_sparse p var (i + 1) *\n                                    Var var ^ i *\n                                    Const (real (i + 1)))\n                                var -\n                               1.\n                     isolate_variable_sparse\n                      (\\<Sum>i = 0..2 - 1.\n                          isolate_variable_sparse p var (i + 1) *\n                          Var var ^ i *\n                          Const (real (i + 1)))\n                      var (i + 1) *\n                     Var var ^ i *\n                     Const (real (i + 1)))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..MPoly_Type.degree\n                                  (\\<Sum>i = 0..2 - 1.\nisolate_variable_sparse p var (i + 1) * Var var ^ i * Const (real (i + 1)))\n                                  var -\n                                 1.\n                       isolate_variable_sparse\n                        (\\<Sum>i = 0..2 - 1.\n                            isolate_variable_sparse p var (i + 1) *\n                            Var var ^ i *\n                            Const (real (i + 1)))\n                        var (i + 1) *\n                       Var var ^ i *\n                       Const (real (i + 1)))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..MPoly_Type.degree\n                              (\\<Sum>i = 0..2 - 1.\n                                  isolate_variable_sparse p var (i + 1) *\n                                  Var var ^ i *\n                                  Const (real (i + 1)))\n                              var -\n                             1.\n                   isolate_variable_sparse\n                    (\\<Sum>i = 0..2 - 1.\n                        isolate_variable_sparse p var (i + 1) *\n                        Var var ^ i *\n                        Const (real (i + 1)))\n                    var (i + 1) *\n                   Var var ^ i *\n                   Const (real (i + 1)))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      ((\\<Sum>i = 0..<2.\n           isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n           b ^ (2 - i)) +\n       isolate_variable_sparse p var 2 * (liftPoly 0 0 (- c))\\<^sup>2)\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      ((\\<Sum>i = 0..<2.\n           isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n           b ^ (2 - i)) +\n       isolate_variable_sparse p var 2 * (liftPoly 0 0 (- c))\\<^sup>2) =\n     0 \\<and>\n     (aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                    isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                    Const 2)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                Const 2)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse\n                (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                 isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                 Const 2)\n                var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..MPoly_Type.degree\n                                (isolate_variable_sparse p var (Suc 0) *\n                                 Const 1 +\n                                 isolate_variable_sparse p var\n                                  (Suc (Suc 0)) *\n                                 Var var *\n                                 Const 2)\n                                var -\n                               Suc 0.\n                     isolate_variable_sparse\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var (Suc i) *\n                     Var var ^ i *\n                     Const (1 + real i))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..MPoly_Type.degree\n                                  (isolate_variable_sparse p var (Suc 0) *\n                                   Const 1 +\n                                   isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   Var var *\n                                   Const 2)\n                                  var -\n                                 Suc 0.\n                       isolate_variable_sparse\n                        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                         isolate_variable_sparse p var (Suc (Suc 0)) *\n                         Var var *\n                         Const 2)\n                        var (Suc i) *\n                       Var var ^ i *\n                       Const (1 + real i))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..MPoly_Type.degree\n                              (isolate_variable_sparse p var (Suc 0) *\n                               Const 1 +\n                               isolate_variable_sparse p var (Suc (Suc 0)) *\n                               Var var *\n                               Const 2)\n                              var -\n                             Suc 0.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var (Suc i) *\n                   Var var ^ i *\n                   Const (1 + real i))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding sum insertion_add insertion_mult insertion_pow insertion_neg assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2) *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                    isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                    Const 2)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                Const 2)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse\n                (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                 isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                 Const 2)\n                var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..MPoly_Type.degree\n                                (isolate_variable_sparse p var (Suc 0) *\n                                 Const 1 +\n                                 isolate_variable_sparse p var\n                                  (Suc (Suc 0)) *\n                                 Var var *\n                                 Const 2)\n                                var -\n                               Suc 0.\n                     isolate_variable_sparse\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var (Suc i) *\n                     Var var ^ i *\n                     Const (1 + real i))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..MPoly_Type.degree\n                                  (isolate_variable_sparse p var (Suc 0) *\n                                   Const 1 +\n                                   isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   Var var *\n                                   Const 2)\n                                  var -\n                                 Suc 0.\n                       isolate_variable_sparse\n                        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                         isolate_variable_sparse p var (Suc (Suc 0)) *\n                         Var var *\n                         Const 2)\n                        var (Suc i) *\n                       Var var ^ i *\n                       Const (1 + real i))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..MPoly_Type.degree\n                              (isolate_variable_sparse p var (Suc 0) *\n                               Const 1 +\n                               isolate_variable_sparse p var (Suc (Suc 0)) *\n                               Var var *\n                               Const 2)\n                              var -\n                             Suc 0.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var (Suc i) *\n                   Var var ^ i *\n                   Const (1 + real i))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding b'_insertion2 c'_insertion a'_insertion"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                    isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                    Const 2)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                Const 2)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse\n                (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                 isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                 Const 2)\n                var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..MPoly_Type.degree\n                                (isolate_variable_sparse p var (Suc 0) *\n                                 Const 1 +\n                                 isolate_variable_sparse p var\n                                  (Suc (Suc 0)) *\n                                 Var var *\n                                 Const 2)\n                                var -\n                               Suc 0.\n                     isolate_variable_sparse\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var (Suc i) *\n                     Var var ^ i *\n                     Const (1 + real i))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..MPoly_Type.degree\n                                  (isolate_variable_sparse p var (Suc 0) *\n                                   Const 1 +\n                                   isolate_variable_sparse p var\n                                    (Suc (Suc 0)) *\n                                   Var var *\n                                   Const 2)\n                                  var -\n                                 Suc 0.\n                       isolate_variable_sparse\n                        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                         isolate_variable_sparse p var (Suc (Suc 0)) *\n                         Var var *\n                         Const 2)\n                        var (Suc i) *\n                       Var var ^ i *\n                       Const (1 + real i))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..MPoly_Type.degree\n                              (isolate_variable_sparse p var (Suc 0) *\n                               Const 1 +\n                               isolate_variable_sparse p var (Suc (Suc 0)) *\n                               Var var *\n                               Const 2)\n                              var -\n                             Suc 0.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var (Suc i) *\n                   Var var ^ i *\n                   Const (1 + real i))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding Power.power_class.power.power_0  Groups.monoid_mult_class.mult_1_right\n          Groups.cancel_comm_monoid_add_class.diff_zero Power.monoid_mult_class.power_one_right\n          twominusone degreedeg1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (aEval\n       (let d = 1\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                    isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                    Const 2)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                Const 2)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs) \\<or>\n      aEval\n       (let d = 1\n        in Eq ((\\<Sum>i = 0..<d.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var i *\n                   liftPoly 0 0 (- c) ^ i *\n                   b ^ (d - i)) +\n               isolate_variable_sparse\n                (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                 isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                 Const 2)\n                var d *\n               liftPoly 0 0 (- c) ^ d))\n       (xs' @ x # xs) \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (\\<Sum>i = 0..1 - Suc 0.\n                     isolate_variable_sparse\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var (Suc i) *\n                     Var var ^ i *\n                     Const (1 + real i))\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (\\<Sum>i = 0..1 - Suc 0.\n                       isolate_variable_sparse\n                        (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                         isolate_variable_sparse p var (Suc (Suc 0)) *\n                         Var var *\n                         Const 2)\n                        var (Suc i) *\n                       Var var ^ i *\n                       Const (1 + real i))\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (\\<Sum>i = 0..1 - Suc 0.\n                   isolate_variable_sparse\n                    (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                     isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                     Const 2)\n                    var (Suc i) *\n                   Var var ^ i *\n                   Const (1 + real i))\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       ((isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) * Const 1 +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var 0 *\n         b +\n         isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) * Const 1 +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var (Suc 0) *\n         liftPoly 0 0 (- c)) *\n        b)\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) =\n      0 \\<and>\n      aEval\n       (let d = MPoly_Type.degree\n                 (isolate_variable_sparse\n                   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                    isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                    Const 2)\n                   var (Suc 0) *\n                  Const 1)\n                 var\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse\n                     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                      isolate_variable_sparse p var (Suc (Suc 0)) *\n                      Var var *\n                      Const 2)\n                     var (Suc 0) *\n                    Const 1)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var (Suc 0) *\n                Const 1)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding insertion_mult assms simp_insertion_blob degreeblob"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) =\n      0 \\<and>\n      aEval\n       (let d = 0\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse\n                     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                      isolate_variable_sparse p var (Suc (Suc 0)) *\n                      Var var *\n                      Const 2)\n                     var (Suc 0) *\n                    Const 1)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var (Suc 0) *\n                Const 1)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding insertion_mult insertion_sub assms otherblob"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) =\n      0 \\<and>\n      aEval\n       (let d = 0\n        in Less\n            (((\\<Sum>i = 0..<d.\n                  isolate_variable_sparse\n                   (isolate_variable_sparse\n                     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                      isolate_variable_sparse p var (Suc (Suc 0)) *\n                      Var var *\n                      Const 2)\n                     var (Suc 0) *\n                    Const 1)\n                   var i *\n                  liftPoly 0 0 (- c) ^ i *\n                  b ^ (d - i)) +\n              isolate_variable_sparse\n               (isolate_variable_sparse\n                 (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                  isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n                  Const 2)\n                 var (Suc 0) *\n                Const 1)\n               var d *\n              liftPoly 0 0 (- c) ^ d) *\n             b ^ (d mod 2)))\n       (xs' @ x # xs))) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) =\n      0 \\<and>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse\n           (isolate_variable_sparse p var (Suc 0) * Const 1 +\n            isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n           var (Suc 0) *\n          Const 1)\n         var 0)\n      < 0)) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding otherblob h1 h2 h3 h4"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs)) (liftPoly 0 0 (- c)))\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (\\<Sum>i = 0..<2.\n          isolate_variable_sparse p var i * liftPoly 0 0 (- c) ^ i *\n          b ^ (2 - i)) +\n     a' *\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (liftPoly 0 0 (- c)))\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        liftPoly 0 0 (- c)) =\n      0 \\<and>\n      2 * a' < 0)) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding lift00 insertion_neg assms insertion_isovarspars_free insertion_sum insertion_mult insertion_sub degree0isovarspar degree_isovarspar mult_one_right insertion_sum_var insertion_pow insertion_neg sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (2 - 0) +\n       isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (2 - 1)) +\n     a' * (- C)\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0 * (- c) ^ 0 * b ^ (2 - 0) +\n       isolate_variable_sparse p var 1 * (- c) ^ 1 * b ^ (2 - 1)) +\n     a' * (- C)\\<^sup>2 =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        - c) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0 *\n        b +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        - c) =\n      0 \\<and>\n      2 * a' < 0)) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "unfolding assms b'_insertion c'_insertion a'_insertion insertion_neg insertion_mult insertion_add insertion_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * (- C) ^ 0 * B ^ (2 - 0) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 1) *\n     (- C) ^ 1 *\n     B ^ (2 - 1) +\n     a' * (- C)\\<^sup>2\n     < 0 \\<or>\n     c' * (- C) ^ 0 * B ^ (2 - 0) +\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 1) *\n     (- C) ^ 1 *\n     B ^ (2 - 1) +\n     a' * (- C)\\<^sup>2 =\n     0 \\<and>\n     ((insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var 0) *\n       B +\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var (Suc 0)) *\n       - C) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0) *\n      B +\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0)) *\n      - C =\n      0 \\<and>\n      2 * a' < 0)) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c' * B\\<^sup>2 -\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) *\n     C *\n     B +\n     a' * C\\<^sup>2\n     < 0 \\<or>\n     c' * B\\<^sup>2 -\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)) *\n     C *\n     B +\n     a' * C\\<^sup>2 =\n     0 \\<and>\n     ((insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var 0) *\n       B -\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc 0) +\n           isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n          var (Suc 0)) *\n       C) *\n      B\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var 0) *\n      B =\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0)) *\n      C \\<and>\n      a' < 0)) =\n    (a' * (C / B)\\<^sup>2 - b' * C / B + c' < 0 \\<or>\n     a' * (C / B)\\<^sup>2 - b' * C / B + c' = 0 \\<and>\n     (b' < 2 * a' * C / B \\<or> b' = 2 * a' * C / B \\<and> a' < 0))", "by (smt assms(2) assms(3) b'_insertion h1 h2 h3 h4 insertion_mult insertion_sub mult_one_right simp_insertion_blob)"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_substInfinitesimalLinear: \n  assumes \"convert_atom var a (xs'@x#xs) = Some(a')\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"B \\<noteq> 0\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"length xs' = var\"\n  shows \"eval (substInfinitesimalLinear var (-c) b a) (xs'@x#xs) = evalUni (substInfinitesimalLinearUni B C a') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have \"\\<exists>p'. convert_poly var p (xs'@x#xs) = Some p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "using Less assms(1)"], ["proof (prove)\nusing this:\n  a = Less p\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Less p; convert_atom var a (xs' @ x # xs) = Some a';\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         convert_poly var p (xs' @ x # xs) = Some p'\n 2. \\<lbrakk>a = Less p; convert_atom var a (xs' @ x # xs) = Some a';\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         convert_poly var p (xs' @ x # xs) = Some p'", "by auto"], ["proof (state)\nthis:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "then"], ["proof (chain)\npicking this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "obtain p' where p'_def : \"convert_poly var p (xs'@x#xs) = Some p'\""], ["proof (prove)\nusing this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        convert_poly var p (xs' @ x # xs) = Some p' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have A'_simp :  \"a' = LessUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = LessUni p'", "using assms Less"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Less p\n\ngoal (1 subgoal):\n 1. a' = LessUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Less p\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. a' = LessUni p'", "by auto"], ["proof (state)\nthis:\n  a' = LessUni p'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have h1 : \"eval (convertDerivative var p) (xs'@x#xs) = evalUni (convertDerivativeUni p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni p') x", "using convert_convertDerivative"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some (?a, ?b, ?c);\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (convertDerivative ?var ?p) (?xs' @ ?x # ?xs) =\n                    evalUni (convertDerivativeUni (?a, ?b, ?c)) ?x\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni p') x", "apply ( cases p')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>var p xs' x xs a b c.\n                   \\<lbrakk>convert_poly var p (xs' @ x # xs) =\n                            Some (a, b, c);\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (convertDerivative var p)\n(xs' @ x # xs) =\n                                     evalUni\n(convertDerivativeUni (a, b, c)) x;\n        p' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                         evalUni (convertDerivativeUni p') x", "using A'_simp Less assms"], ["proof (prove)\nusing this:\n  a' = LessUni p'\n  a = Less p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>var p xs' x xs a b c.\n                   \\<lbrakk>convert_poly var p (xs' @ x # xs) =\n                            Some (a, b, c);\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (convertDerivative var p)\n(xs' @ x # xs) =\n                                     evalUni\n(convertDerivativeUni (a, b, c)) x;\n        p' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                         evalUni (convertDerivativeUni p') x", "by auto"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni p') x\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "unfolding A'_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni p')) x", "using convert_substInfinitesimalLinear_less[OF p'_def assms(2-7)]"], ["proof (prove)\nusing this:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni p')) x", "unfolding Less"], ["proof (prove)\nusing this:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b (Less p)) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni p')) x", "by auto"], ["proof (state)\nthis:\n  eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni B C a') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "define p' where \"p' = (case convert_poly var p (xs'@x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have A'_simp :  \"a' = EqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = EqUni p'", "using assms Eq"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Eq p\n\ngoal (1 subgoal):\n 1. a' = EqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Eq p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. a' = EqUni p'", "by auto"], ["proof (state)\nthis:\n  a' = EqUni p'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "unfolding Eq A'_simp substInfinitesimalLinear.simps substInfinitesimalLinearUni.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using convert_allZero A'_simp Eq assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n  a' = EqUni p'\n  a = Eq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "by auto"], ["proof (state)\nthis:\n  eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni B C a') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have \"\\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "using assms(1)"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "unfolding Leq"], ["proof (prove)\nusing this:\n  convert_atom var (Leq p) (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = LeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = LeqUni (a, aa, b); MPoly_Type.degree p var < 3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = LeqUni (a, aa, b); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "then"], ["proof (chain)\npicking this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "obtain p' where p'_def : \"convert_poly var p (xs' @ x # xs) = Some p'\""], ["proof (prove)\nusing this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        convert_poly var p (xs' @ x # xs) = Some p' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have A'_simp :  \"a' = LeqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = LeqUni p'", "using assms Leq"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Leq p\n\ngoal (1 subgoal):\n 1. a' = LeqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Leq p\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. a' = LeqUni p'", "by auto"], ["proof (state)\nthis:\n  a' = LeqUni p'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have h1 : \"eval (convertDerivative var p) (xs'@x#xs) = evalUni (convertDerivativeUni p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni p') x", "using convert_convertDerivative"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some (?a, ?b, ?c);\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (convertDerivative ?var ?p) (?xs' @ ?x # ?xs) =\n                    evalUni (convertDerivativeUni (?a, ?b, ?c)) ?x\n\ngoal (1 subgoal):\n 1. eval (convertDerivative var p) (xs' @ x # xs) =\n    evalUni (convertDerivativeUni p') x", "apply(cases p')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>var p xs' x xs a b c.\n                   \\<lbrakk>convert_poly var p (xs' @ x # xs) =\n                            Some (a, b, c);\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (convertDerivative var p)\n(xs' @ x # xs) =\n                                     evalUni\n(convertDerivativeUni (a, b, c)) x;\n        p' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                         evalUni (convertDerivativeUni p') x", "using A'_simp Leq assms"], ["proof (prove)\nusing this:\n  a' = LeqUni p'\n  a = Leq p\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>var p xs' x xs a b c.\n                   \\<lbrakk>convert_poly var p (xs' @ x # xs) =\n                            Some (a, b, c);\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (convertDerivative var p)\n(xs' @ x # xs) =\n                                     evalUni\n(convertDerivativeUni (a, b, c)) x;\n        p' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> eval (convertDerivative var p) (xs' @ x # xs) =\n                         evalUni (convertDerivativeUni p') x", "by auto"], ["proof (state)\nthis:\n  eval (convertDerivative var p) (xs' @ x # xs) =\n  evalUni (convertDerivativeUni p') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "unfolding A'_simp Leq substInfinitesimalLinear.simps eval_Or substInfinitesimalLinearUni.simps evalUni.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval (allZero p var) (xs' @ x # xs) \\<or>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x (- c))\n               (liftPoly 0 x b) A))\n        (convertDerivative var p) 0)\n      (xs' @ x # xs)) =\n    (evalUni (allZero' p') x \\<or>\n     evalUni\n      (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x)", "using convert_substInfinitesimalLinear_less[OF p'_def assms(2-7)]\n      convert_allZero[OF p'_def assms(7)]"], ["proof (prove)\nusing this:\n  eval\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x (- c))\n            (liftPoly 0 x b) A))\n     (convertDerivative var p) 0)\n   (xs' @ x # xs) =\n  evalUni\n   (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (1 subgoal):\n 1. (eval (allZero p var) (xs' @ x # xs) \\<or>\n     eval\n      (liftmap\n        (\\<lambda>x A.\n            fm.Atom\n             (linear_substitution (var + x) (liftPoly 0 x (- c))\n               (liftPoly 0 x b) A))\n        (convertDerivative var p) 0)\n      (xs' @ x # xs)) =\n    (evalUni (allZero' p') x \\<or>\n     evalUni\n      (map_atomUni (linearSubstitutionUni B C) (convertDerivativeUni p')) x)", "by simp"], ["proof (state)\nthis:\n  eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni B C a') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have \"\\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "using assms(1)"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "unfolding Neq"], ["proof (prove)\nusing this:\n  convert_atom var (Neq p) (xs' @ x # xs) = Some a'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = NeqUni (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = NeqUni (a, aa, b); MPoly_Type.degree p var < 3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<And>a aa b.\n       \\<lbrakk>(if MPoly_Type.degree p var < 3\n                 then let (A, B, C) = get_coeffs var p\n                      in Some\n                          (insertion (nth_default 0 (xs' @ x # xs)) A,\n                           insertion (nth_default 0 (xs' @ x # xs)) B,\n                           insertion (nth_default 0 (xs' @ x # xs)) C)\n                 else None) =\n                Some (a, aa, b);\n        a' = NeqUni (a, aa, b); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["proof (state)\nthis:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "then"], ["proof (chain)\npicking this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'", "obtain p' where p'_def : \"convert_poly var p (xs' @ x # xs) = Some p'\""], ["proof (prove)\nusing this:\n  \\<exists>p'. convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        convert_poly var p (xs' @ x # xs) = Some p' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "have A'_simp :  \"a' = NeqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = NeqUni p'", "using assms Neq"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Neq p\n\ngoal (1 subgoal):\n 1. a' = NeqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var a (xs' @ x # xs) = Some a'\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  B \\<noteq> 0\n  var \\<notin> vars b\n  var \\<notin> vars c\n  length xs' = var\n  a = Neq p\n  convert_poly var p (xs' @ x # xs) = Some p'\n\ngoal (1 subgoal):\n 1. a' = NeqUni p'", "by auto"], ["proof (state)\nthis:\n  a' = NeqUni p'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var a (xs' @ x # xs) = Some a';\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C; B \\<noteq> 0;\n        var \\<notin> vars b; var \\<notin> vars c; length xs' = var;\n        a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalLinear var (- c) b a)\n                          (xs' @ x # xs) =\n                         evalUni (substInfinitesimalLinearUni B C a') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n    evalUni (substInfinitesimalLinearUni B C a') x", "unfolding Neq A'_simp substInfinitesimalLinear.simps substInfinitesimalLinearUni.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (neg (allZero p var)) (xs' @ x # xs) =\n    evalUni (negUni (allZero' p')) x", "using convert_allZero[OF p'_def assms(7)]"], ["proof (prove)\nusing this:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (1 subgoal):\n 1. eval (neg (allZero p var)) (xs' @ x # xs) =\n    evalUni (negUni (allZero' p')) x", "by (metis A'_simp Neq assms(1) assms(7) convert_substNegInfinity eval.simps(6) eval_neg substNegInfinityUni.simps(4) substNegInfinity.simps(4))"], ["proof (state)\nthis:\n  eval (substInfinitesimalLinear var (- c) b a) (xs' @ x # xs) =\n  evalUni (substInfinitesimalLinearUni B C a') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma either_or:\n  fixes r :: \"real\"\n  assumes a: \"(\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (EqUni (a, b, c)) x) \\<or> (aEvalUni (LessUni (a, b, c)) x))\"\n  shows \"(\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (EqUni (a, b, c)) x)) \\<or> \n  (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (LessUni (a, b, c)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "proof  (cases \"a = 0 \\<and> b = 0 \\<and> c= 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<and> b = 0 \\<and> c = 0 \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)\n 2. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "case True"], ["proof (state)\nthis:\n  a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<and> b = 0 \\<and> c = 0 \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)\n 2. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "then"], ["proof (chain)\npicking this:\n  a = 0 \\<and> b = 0 \\<and> c = 0", "have \"(\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}.  (aEvalUni (EqUni (a, b, c)) x))\""], ["proof (prove)\nusing this:\n  a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x", "using assms"], ["proof (prove)\nusing this:\n  a = 0 \\<and> b = 0 \\<and> c = 0\n  \\<exists>y'>r.\n     \\<forall>x\\<in>{r<..y'}.\n        aEvalUni (EqUni (a, b, c)) x \\<or> aEvalUni (LessUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. \\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x\n\ngoal (2 subgoals):\n 1. a = 0 \\<and> b = 0 \\<and> c = 0 \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)\n 2. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>r.\n      \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n  (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "case False"], ["proof (state)\nthis:\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "then"], ["proof (chain)\npicking this:\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0)", "have noz: \"a\\<noteq>0 \\<or> b\\<noteq>0 \\<or> c\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "obtain y1' where y1prop: \"y1' > r \\<and> (\\<forall>x\\<in>{r<..y1'}. (aEvalUni (EqUni (a, b, c)) x) \\<or> (aEvalUni (LessUni (a, b, c)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y1'.\n        r < y1' \\<and>\n        (\\<forall>x\\<in>{r<..y1'}.\n            aEvalUni (EqUni (a, b, c)) x \\<or>\n            aEvalUni (LessUni (a, b, c)) x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  \\<exists>y'>r.\n     \\<forall>x\\<in>{r<..y'}.\n        aEvalUni (EqUni (a, b, c)) x \\<or> aEvalUni (LessUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. (\\<And>y1'.\n        r < y1' \\<and>\n        (\\<forall>x\\<in>{r<..y1'}.\n            aEvalUni (EqUni (a, b, c)) x \\<or>\n            aEvalUni (LessUni (a, b, c)) x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r < y1' \\<and>\n  (\\<forall>x\\<in>{r<..y1'}.\n      aEvalUni (EqUni (a, b, c)) x \\<or> aEvalUni (LessUni (a, b, c)) x)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "obtain y2' where y2prop: \"y2' > r \\<and> (\\<forall>x\\<in>{r<..y2'}. a * x\\<^sup>2 + b * x + c \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y2'.\n        r < y2' \\<and>\n        (\\<forall>x\\<in>{r<..y2'}.\n            a * x\\<^sup>2 + b * x + c \\<noteq> 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using noz nonzcoeffs[of a b c]"], ["proof (prove)\nusing this:\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0\n  a \\<noteq> 0 \\<or> b \\<noteq> 0 \\<or> c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>y'>?r.\n     \\<forall>x\\<in>{?r<..y'}. a * x\\<^sup>2 + b * x + c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y2'.\n        r < y2' \\<and>\n        (\\<forall>x\\<in>{r<..y2'}.\n            a * x\\<^sup>2 + b * x + c \\<noteq> 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r < y2' \\<and>\n  (\\<forall>x\\<in>{r<..y2'}. a * x\\<^sup>2 + b * x + c \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "let ?y = \"min y1' y2'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "have ygt: \"?y > r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < min y1' y2'", "using y1prop y2prop"], ["proof (prove)\nusing this:\n  r < y1' \\<and>\n  (\\<forall>x\\<in>{r<..y1'}.\n      aEvalUni (EqUni (a, b, c)) x \\<or> aEvalUni (LessUni (a, b, c)) x)\n  r < y2' \\<and>\n  (\\<forall>x\\<in>{r<..y2'}. a * x\\<^sup>2 + b * x + c \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. r < min y1' y2'", "by auto"], ["proof (state)\nthis:\n  r < min y1' y2'\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "have \"\\<forall>x\\<in>{r<..?y}. (aEvalUni (LessUni (a, b, c)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x", "using y1prop y2prop greaterThanAtMost_iff"], ["proof (prove)\nusing this:\n  r < y1' \\<and>\n  (\\<forall>x\\<in>{r<..y1'}.\n      aEvalUni (EqUni (a, b, c)) x \\<or> aEvalUni (LessUni (a, b, c)) x)\n  r < y2' \\<and>\n  (\\<forall>x\\<in>{r<..y2'}. a * x\\<^sup>2 + b * x + c \\<noteq> 0)\n  (?i \\<in> {?l<..?u}) = (?l < ?i \\<and> ?i \\<le> ?u)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<and> b = 0 \\<and> c = 0) \\<Longrightarrow>\n    (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "using ygt"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{r<..min y1' y2'}. aEvalUni (LessUni (a, b, c)) x\n  r < min y1' y2'\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>r.\n        \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n    (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>r.\n      \\<forall>x\\<in>{r<..y'}. aEvalUni (EqUni (a, b, c)) x) \\<or>\n  (\\<exists>y'>r. \\<forall>x\\<in>{r<..y'}. aEvalUni (LessUni (a, b, c)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinitesimal_linear'_helper :\n  assumes at_is: \"At = LessUni p \\<or> At = EqUni p\"\n  assumes \"B \\<noteq> 0\"\n  shows \"((\\<exists>y'::real>-C/B. \\<forall>x::real \\<in>{-C/B<..y'}. aEvalUni At x)\n      = evalUni (substInfinitesimalLinearUni B C At) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof (cases \"At = LessUni p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "case True"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "have LessUni: \"At = LessUni p\""], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. At = LessUni p", "by auto"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  p = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "unfolding LessUni fields"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni (a, b, c))) x", "using one_root_a_lt0[where r=\"C/B\", where a= \"a\", where b=\"b\",where c= \"c\"]"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n  \\<lbrakk>a < 0; b = 2 * a * (C / B);\n   a * (C / B)\\<^sup>2 - 2 * a * (C / B) * (C / B) + c = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>- (C / B).\n                       \\<forall>x\\<in>{- (C / B)<..y'}.\n                          a * x\\<^sup>2 + 2 * a * (C / B) * x + c < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni (a, b, c))) x", "apply(auto)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>b = 2 * a * C / B; a < 0;\n     a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 4. \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n     a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 6. \\<lbrakk>b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<lbrakk>b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 8. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 9. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 10. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n      a * (C / B)\\<^sup>2 - b * C / B + c < 0\\<rbrakk>\n     \\<Longrightarrow> \\<exists>y'>- (C / B).\n                          \\<forall>x\\<in>{- (C / B)<..y'}.\n                             a * x\\<^sup>2 + b * x + c < 0\nA total of 11 subgoals...", "using continuity_lem_lt0_expanded[where a= \"a\", where b = \"2 * a * C / B \", where c = \"c\"]"], ["proof (prove)\nusing this:\n  a * ?r\\<^sup>2 + 2 * a * C / B * ?r + c < 0 \\<Longrightarrow>\n  \\<exists>y'>?r.\n     \\<forall>x\\<in>{?r<..y'}. a * x\\<^sup>2 + 2 * a * C / B * x + c < 0\n\ngoal (11 subgoals):\n 1. \\<lbrakk>b = 2 * a * C / B; a < 0;\n     a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 4. \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n     a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 6. \\<lbrakk>b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<lbrakk>b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 8. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n        - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 9. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 10. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n      a * (C / B)\\<^sup>2 - b * C / B + c < 0\\<rbrakk>\n     \\<Longrightarrow> \\<exists>y'>- (C / B).\n                          \\<forall>x\\<in>{- (C / B)<..y'}.\n                             a * x\\<^sup>2 + b * x + c < 0\nA total of 11 subgoals...", "apply (auto)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 4. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 8. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 9. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_gt0_expanded[where a = \"a\", where b = \"2 * a * C / B\",where c = \"c\", where r = \"- (C / B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?k;\n   0 < a * (- (C / B))\\<^sup>2 + 2 * a * C / B * - (C / B) + c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..?k}.\n                       0 < a * x\\<^sup>2 + 2 * a * C / B * x + c\n\ngoal (9 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 4. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 8. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 9. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 4. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 8. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 9. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (meson less_eq_real_def linorder_not_less)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 7. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 8. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using one_root_a_gt0[where r = \"C/B\", where a = \"a\", where b=\"b\", where c=\"c\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>b = 2 * a * (C / B); \\<not> a < 0;\n   a * (C / B)\\<^sup>2 - 2 * a * (C / B) * (C / B) + c = 0;\n   - (C / B) < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..?y'}.\n                       \\<not> a * x\\<^sup>2 + 2 * a * (C / B) * x + c < 0\n\ngoal (8 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c = 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 7. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 8. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_lt0_expanded[where a= \"a\", where b = \"2 * a * C / B\", where c= \"c\"]"], ["proof (prove)\nusing this:\n  a * ?r\\<^sup>2 + 2 * a * C / B * ?r + c < 0 \\<Longrightarrow>\n  \\<exists>y'>?r.\n     \\<forall>x\\<in>{?r<..y'}. a * x\\<^sup>2 + 2 * a * C / B * x + c < 0\n\ngoal (7 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_gt0_expanded[where a = \"a\", where b = \"2 * a * C / B\",where c = \"c\", where r = \"- (C / B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?k;\n   0 < a * (- (C / B))\\<^sup>2 + 2 * a * C / B * - (C / B) + c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..?k}.\n                       0 < a * x\\<^sup>2 + 2 * a * C / B * x + c\n\ngoal (7 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b = 2 * a * C / B; \\<not> a < 0;\n        a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c < 0;\n        - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + 2 * a * C * x / B + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + 2 * a * C * x / B + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 6. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 7. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (meson less_eq_real_def linorder_not_less)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using case_d1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b < 2 * ?a * ?r; ?a * ?r\\<^sup>2 - ?b * ?r + ?c = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>- ?r.\n                       \\<forall>x\\<in>{- ?r<..y'}.\n                          ?a * x\\<^sup>2 + ?b * x + ?c < 0\n\ngoal (6 subgoals):\n 1. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c = 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 2. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 4. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 5. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                 c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 6. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B +\n                                    c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n     \\<And>b a r c.\n        \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>y'>- r.\n                             \\<forall>x\\<in>{- r<..y'}.\n                                a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 4. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n     \\<And>b a r c.\n        \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>y'>- r.\n                             \\<forall>x\\<in>{- r<..y'}.\n                                a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_lt0_expanded[where a= \"a\", where b = \"b\", where c= \"c\"]"], ["proof (prove)\nusing this:\n  a * ?r\\<^sup>2 + b * ?r + c < 0 \\<Longrightarrow>\n  \\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. a * x\\<^sup>2 + b * x + c < 0\n\ngoal (5 subgoals):\n 1. \\<lbrakk>b < 2 * a * C / B; a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n     \\<And>b a r c.\n        \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>y'>- r.\n                             \\<forall>x\\<in>{- r<..y'}.\n                                a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 4. \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n     a * (C / B)\\<^sup>2 - b * C / B + c < 0;\n     \\<And>r.\n        a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n        \\<exists>y'>r.\n           \\<forall>x\\<in>{r<..y'}.\n              a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n     \\<And>k.\n        \\<lbrakk>- (C / B) < k;\n         0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                             0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n     \\<And>b a r c.\n        \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n        \\<Longrightarrow> \\<exists>y'>- r.\n                             \\<forall>x\\<in>{- r<..y'}.\n                                a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>- (C / B).\n                         \\<forall>x\\<in>{- (C / B)<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0\n 5. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_gt0_expanded[where a = \"a\", where b = \"b\",where c = \"c\", where r = \"- (C / B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?k;\n   0 < a * (- (C / B))\\<^sup>2 + b * - (C / B) + c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..?k}.\n                       0 < a * x\\<^sup>2 + b * x + c\n\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + b * x + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 3. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + b * x + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (meson less_eq_real_def linorder_not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + b * x + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using case_d4"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<noteq> 2 * ?a * ?r; \\<not> ?b < 2 * ?a * ?r;\n   ?a * ?r\\<^sup>2 - ?b * ?r + ?c = 0; - ?r < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- ?r<..?y'}.\n                       \\<not> ?a * x\\<^sup>2 + ?b * x + ?c < 0\n\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c = 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0\n 2. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + b * x + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}. 0 < a * x\\<^sup>2 + b * x + c;\n        \\<And>b a r c y'.\n           \\<lbrakk>b \\<noteq> 2 * a * r; \\<not> b < 2 * a * r;\n            a * r\\<^sup>2 - b * r + c = 0; - r < y'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- r<..y'}.\n                                \\<not> a * x\\<^sup>2 + b * x + c\n < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_lt0_expanded[where a= \"a\", where b = \"b\", where c= \"c\"]"], ["proof (prove)\nusing this:\n  a * ?r\\<^sup>2 + b * ?r + c < 0 \\<Longrightarrow>\n  \\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}. 0 < a * x\\<^sup>2 + b * x + c;\n        \\<And>b a r c y'.\n           \\<lbrakk>b \\<noteq> 2 * a * r; \\<not> b < 2 * a * r;\n            a * r\\<^sup>2 - b * r + c = 0; - r < y'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- r<..y'}.\n                                \\<not> a * x\\<^sup>2 + b * x + c\n < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}. 0 < a * x\\<^sup>2 + b * x + c;\n        \\<And>b a r c y'.\n           \\<lbrakk>b \\<noteq> 2 * a * r; \\<not> b < 2 * a * r;\n            a * r\\<^sup>2 - b * r + c = 0; - r < y'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- r<..y'}.\n                                \\<not> a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_gt0_expanded[where a = \"a\", where b = \"b\",where c = \"c\", where r = \"- (C / B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?k;\n   0 < a * (- (C / B))\\<^sup>2 + b * - (C / B) + c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..?k}.\n                       0 < a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}. 0 < a * x\\<^sup>2 + b * x + c;\n        \\<And>b a r c y'.\n           \\<lbrakk>b \\<noteq> 2 * a * r; \\<not> b < 2 * a * r;\n            a * r\\<^sup>2 - b * r + c = 0; - r < y'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- r<..y'}.\n                                \\<not> a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + b * x + c < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>b \\<noteq> 2 * a * C / B; \\<not> b < 2 * a * C / B;\n        a * (C / B)\\<^sup>2 - b * C / B + c \\<noteq> 0;\n        \\<not> a * (C / B)\\<^sup>2 - b * C / B + c < 0; - (C / B) < y';\n        \\<And>r.\n           a * r\\<^sup>2 + 2 * a * C * r / B + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}.\n                 a * x\\<^sup>2 + 2 * a * C * x / B + c < 0;\n        \\<And>k.\n           \\<lbrakk>- (C / B) < k;\n            0 < a * (C / B)\\<^sup>2 - 2 * a * C * C / (B * B) + c\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..k}.\n                                0 < a * x\\<^sup>2 + 2 * a * C * x / B + c;\n        \\<And>b a r c.\n           \\<lbrakk>b < 2 * a * r; a * r\\<^sup>2 - b * r + c = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y'>- r.\n                                \\<forall>x\\<in>{- r<..y'}.\n                                   a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>b a r c y'.\n           \\<lbrakk>b \\<noteq> 2 * a * r; \\<not> b < 2 * a * r;\n            a * r\\<^sup>2 - b * r + c = 0; - r < y'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x\\<in>{- r<..y'}.\n                                \\<not> a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>r.\n           a * r\\<^sup>2 + b * r + c < 0 \\<Longrightarrow>\n           \\<exists>y'>r.\n              \\<forall>x\\<in>{r<..y'}. a * x\\<^sup>2 + b * x + c < 0;\n        \\<And>k.\n           - (C / B) < k \\<Longrightarrow>\n           \\<exists>x\\<in>{- (C / B)<..k}.\n              0 < a * x\\<^sup>2 + b * x + c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{- (C / B)<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "by (meson less_eq_real_def linorder_not_le)"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "case False"], ["proof (state)\nthis:\n  At \\<noteq> LessUni p\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At \\<noteq> LessUni p", "have EqUni: \"At = EqUni p\""], ["proof (prove)\nusing this:\n  At \\<noteq> LessUni p\n\ngoal (1 subgoal):\n 1. At = EqUni p", "using at_is"], ["proof (prove)\nusing this:\n  At \\<noteq> LessUni p\n  At = LessUni p \\<or> At = EqUni p\n\ngoal (1 subgoal):\n 1. At = EqUni p", "by auto"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "apply(auto simp add:EqUni fields)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0\n 2. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 4. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "using continuity_lem_eq0[where r= \"-(C/B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?p;\n   \\<forall>x\\<in>{- (C / B)<..?p}.\n      ?a * x\\<^sup>2 + ?b * x + ?c = 0\\<rbrakk>\n  \\<Longrightarrow> ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n\ngoal (4 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0\n 2. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 4. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 3. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "using continuity_lem_eq0[where r= \"-(C/B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?p;\n   \\<forall>x\\<in>{- (C / B)<..?p}.\n      ?a * x\\<^sup>2 + ?b * x + ?c = 0\\<rbrakk>\n  \\<Longrightarrow> ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 3. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 2. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "using continuity_lem_eq0[where r= \"-(C/B)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>- (C / B) < ?p;\n   \\<forall>x\\<in>{- (C / B)<..?p}.\n      ?a * x\\<^sup>2 + ?b * x + ?c = 0\\<rbrakk>\n  \\<Longrightarrow> ?a = 0 \\<and> ?b = 0 \\<and> ?c = 0\n\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>- (C / B) < y';\n        \\<forall>x\\<in>{- (C / B)<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> c = 0\n 2. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "using linordered_field_no_ub"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. x < y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'. - (C / B) < y'", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* I assume substInfinitesimalLinearUni' was supposed to be substInfinitesimalLinearUni?*)"], ["", "lemma infinitesimal_linear' :\n  assumes \"B \\<noteq> 0\"\n  shows \"(\\<exists>y'::real>-C/B. \\<forall>x::real \\<in>{-C/B<..y'}. aEvalUni At x)\n      = evalUni (substInfinitesimalLinearUni B C At) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using infinitesimal_linear'_helper[of At p B C] assms"], ["proof (prove)\nusing this:\n  At = LessUni p\n  \\<lbrakk>At = LessUni p \\<or> At = EqUni p; B \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) ?x\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using infinitesimal_linear'_helper[of At p B C] assms"], ["proof (prove)\nusing this:\n  At = EqUni p\n  \\<lbrakk>At = LessUni p \\<or> At = EqUni p; B \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) ?x\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by (auto)"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have same: \"\\<forall>x. aEvalUni (LeqUni p) x = (aEvalUni (EqUni p) x) \\<or> (aEvalUni (LessUni p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n       aEvalUni (LessUni p) x", "apply (simp add: fields)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (a * x\\<^sup>2 + b * x + c \\<le> 0) =\n       (a * x\\<^sup>2 + b * x + c = 0) \\<or>\n       a * x\\<^sup>2 + b * x + c < 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x.\n     aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n     aEvalUni (LessUni p) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have \"\\<And>a b c.\n       At = LeqUni p \\<Longrightarrow>\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "assume atis: \"At = LeqUni p\""], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "assume p_is: \" p = (a, b, c)\""], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have s1: \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) = (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}.  (aEvalUni (EqUni p) x) \\<or> (aEvalUni (LessUni p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)", "using atis same aEvalUni.simps(2) aEvalUni.simps(3) fields less_eq_real_def"], ["proof (prove)\nusing this:\n  At = LeqUni p\n  \\<forall>x.\n     aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n     aEvalUni (LessUni p) x\n  aEvalUni (LessUni (?a, ?b, ?c)) ?x = (?a * ?x\\<^sup>2 + ?b * ?x + ?c < 0)\n  aEvalUni (LeqUni (?a, ?b, ?c)) ?x =\n  (?a * ?x\\<^sup>2 + ?b * ?x + ?c \\<le> 0)\n  p = (a__, b__, c__)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have s2: \"... = (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}.  (aEvalUni (EqUni p) x)) \\<or> (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. (aEvalUni (LessUni p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) \\<or>\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x)", "using either_or[where r = \"-C/B\"] p_is"], ["proof (prove)\nusing this:\n  \\<exists>y'>- C / B.\n     \\<forall>x\\<in>{- C / B<..y'}.\n        aEvalUni (EqUni (?a, ?b, ?c)) x \\<or>\n        aEvalUni (LessUni (?a, ?b, ?c)) x \\<Longrightarrow>\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni (?a, ?b, ?c)) x) \\<or>\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni (?a, ?b, ?c)) x)\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) \\<or>\n    (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) \\<or>\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have eq1: \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}.  (aEvalUni (EqUni p) x)) =  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) =\n    evalUni (substInfinitesimalLinearUni B C (EqUni p)) x", "using infinitesimal_linear'_helper[where At = \"EqUni p\", where p = \"p\", where B = \"B\", where C= \"C\"] \n          assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>EqUni p = LessUni p \\<or> EqUni p = EqUni p;\n   B \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}.\n                           aEvalUni (EqUni p) x) =\n                    evalUni (substInfinitesimalLinearUni B C (EqUni p)) ?x\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) =\n    evalUni (substInfinitesimalLinearUni B C (EqUni p)) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) =\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have eq2: \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. (aEvalUni (LessUni p) x)) = (evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni p)) x", "using infinitesimal_linear'_helper[where At = \"LessUni p\", where p = \"p\", where B = \"B\", where C= \"C\"] \n          assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>LessUni p = LessUni p \\<or> LessUni p = EqUni p;\n   B \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}.\n                           aEvalUni (LessUni p) x) =\n                    evalUni (substInfinitesimalLinearUni B C (LessUni p)) ?x\n  B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x) =\n    evalUni (substInfinitesimalLinearUni B C (LessUni p)) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x) =\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have z1: \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) = ((evalUni (substInfinitesimalLinearUni B C (EqUni p)) x) \\<or> (evalUni (substInfinitesimalLinearUni B C (LessUni p)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)", "using s1 s2 eq1 eq2"], ["proof (prove)\nusing this:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) \\<or>\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x)\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (EqUni p) x) =\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x\n  (\\<exists>y'>- C / B.\n      \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (LessUni p) x) =\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have z2: \"(evalUni (substInfinitesimalLinearUni B C (EqUni p)) x) \\<or> (evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) = evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n    evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have z3: \"(evalUni (substInfinitesimalLinearUni B C At) x) = evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni B C At) x =\n    evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x", "using LeqUni"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni B C At) x =\n    evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni B C At) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  evalUni (substInfinitesimalLinearUni B C At) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x", "have z4: \"(evalUni (substInfinitesimalLinearUni B C (EqUni p)) x) \\<or> (evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) = (evalUni (substInfinitesimalLinearUni B C At) x) \""], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalLinearUni B C At) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using z2 z3"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalLinearUni B C At) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n  evalUni (substInfinitesimalLinearUni B C At) x =\n  evalUni (substInfinitesimalLinearUni B C (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "let ?a = \"(evalUni (substInfinitesimalLinearUni B C (EqUni p)) x) \\<or> (evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "let ?b = \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "let ?c = \"(evalUni (substInfinitesimalLinearUni B C At) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have t1: \"?b = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)", "using z1"], ["proof (prove)\nusing this:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "have t2: \"?a = ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using z4"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalLinearUni B C (LessUni p)) x =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by (simp add: atis)"], ["proof (state)\nthis:\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n  evalUni (substInfinitesimalLinearUni B C At) x", "have \"?b = ?c\""], ["proof (prove)\nusing this:\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using t1 t2"], ["proof (prove)\nusing this:\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x)\n  (evalUni (substInfinitesimalLinearUni B C (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalLinearUni B C (LessUni p)) x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x", "show \"(\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) = evalUni (substInfinitesimalLinearUni B C At) x\""], ["proof (prove)\nusing this:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "using LeqUni fields"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>- C / B.\n                        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                    evalUni (substInfinitesimalLinearUni B C At) x\n  At = LeqUni p\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>- C / B.\n                             \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n                         evalUni (substInfinitesimalLinearUni B C At) x", "then"], ["proof (chain)\npicking this:\n  p = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalLinearUni B C At) x", "unfolding NeqUni fields"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (NeqUni (a, b, c)) x) =\n    evalUni (substInfinitesimalLinearUni B C (NeqUni (a, b, c))) x", "using nonzcoeffs"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n  ?a \\<noteq> 0 \\<or> ?b \\<noteq> 0 \\<or> ?c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>y'>?r.\n     \\<forall>x\\<in>{?r<..y'}. ?a * x\\<^sup>2 + ?b * x + ?c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>- C / B.\n        \\<forall>x\\<in>{- C / B<..y'}. aEvalUni (NeqUni (a, b, c)) x) =\n    evalUni (substInfinitesimalLinearUni B C (NeqUni (a, b, c))) x", "by (auto)"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>- C / B. \\<forall>x\\<in>{- C / B<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalLinearUni B C At) x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun quadraticSubUni :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> atomUni \\<Rightarrow> atomUni fmUni\" where\n  \"quadraticSubUni a b c d A = (if aEvalUni A ((a+b*sqrt(c))/d) then TrueFUni else FalseFUni)\""], ["", "fun substInfinitesimalQuadraticUni :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> atomUni \\<Rightarrow> atomUni fmUni\" where\n  \"substInfinitesimalQuadraticUni a b c d (EqUni p) = allZero' p\"|\n  \"substInfinitesimalQuadraticUni a b c d (LessUni p) = map_atomUni (quadraticSubUni a b c d) (convertDerivativeUni p)\"|\n  \"substInfinitesimalQuadraticUni a b c d (LeqUni p) = OrUni(map_atomUni (quadraticSubUni a b c d) (convertDerivativeUni p)) (allZero' p)\"|\n  \"substInfinitesimalQuadraticUni a b c d (NeqUni p) = negUni (allZero' p)\""], ["", "lemma weird :\n  fixes D::\"real\"\n  assumes dneq: \"D \\<noteq> (0::real)\"\n  shows \n    \"((a'::real) * (((A::real) + (B::real) * sqrt (C::real)) / (D::real))\\<^sup>2 + (b'::real) * (A + B * sqrt C) / D + c' < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + (c'::real) = 0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' = 0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "proof (cases \"(a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n    < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n 2. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "case True"], ["proof (state)\nthis:\n  a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0\n\ngoal (2 subgoals):\n 1. a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n    < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n 2. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' < 0\n\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "by auto"], ["proof (state)\nthis:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n   < 0 \\<or>\n   a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n   < 0 \\<or>\n   a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "case False"], ["proof (state)\nthis:\n  \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n         c'\n         < 0\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "have \"a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)", "by auto"], ["proof (state)\nthis:\n  a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)", "have \"a' * (A + B * sqrt C) * 2 / D =2 * a' * (A + B * sqrt C) / D \""], ["proof (prove)\nusing this:\n  a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)\n\ngoal (1 subgoal):\n 1. a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D", "using dneq"], ["proof (prove)\nusing this:\n  a' * (A + B * sqrt C) * 2 = 2 * a' * (A + B * sqrt C)\n  D \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D", "by simp"], ["proof (state)\nthis:\n  a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D", "have \"b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'\""], ["proof (prove)\nusing this:\n  a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D\n\ngoal (1 subgoal):\n 1. b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'", "using add.commute"], ["proof (prove)\nusing this:\n  a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'", "by simp"], ["proof (state)\nthis:\n  b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'", "have \"(b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or> b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)\n   = (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or> 2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0)\""], ["proof (prove)\nusing this:\n  b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'\n\ngoal (1 subgoal):\n 1. (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n     b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0) =\n    (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n     2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0)", "by (simp add: \\<open>b' + a' * (A + B * sqrt C) * 2 / D = 2 * a' * (A + B * sqrt C) / D + b'\\<close>)"], ["proof (state)\nthis:\n  (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n   b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0) =\n  (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n   2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0)\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n   b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0) =\n  (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n   2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0)", "have \"(a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' = 0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or> b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' = 0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or> 2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\""], ["proof (prove)\nusing this:\n  (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n   b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0) =\n  (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n   2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0)\n\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "by blast"], ["proof (state)\nthis:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n\ngoal (1 subgoal):\n 1. \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n           c'\n           < 0 \\<Longrightarrow>\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "then"], ["proof (chain)\npicking this:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "using False"], ["proof (prove)\nusing this:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n  \\<not> a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D +\n         c'\n         < 0\n\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n      b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "by simp"], ["proof (state)\nthis:\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n   < 0 \\<or>\n   a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (b' + a' * (A + B * sqrt C) * 2 / D < 0 \\<or>\n    b' + a' * (A + B * sqrt C) * 2 / D = 0 \\<and> 2 * a' < 0)) =\n  (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n   < 0 \\<or>\n   a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n   0 \\<and>\n   (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n    2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_substInfinitesimalQuadratic_less :\n  assumes \"convert_poly var p (xs'@x#xs) = Some p'\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) a = A\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) c = C\"\n  assumes \"insertion (nth_default 0 (xs'@x#xs)) d = D\"\n  assumes \"D \\<noteq> 0\"\n  assumes \"0 \\<le> C\"\n  assumes \"var\\<notin>(vars a)\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"var\\<notin>(vars d)\"\n  assumes \"length xs' = var\"\n  shows \"eval (quadratic_sub_fm var a b c d (convertDerivative var p)) (xs'@x#xs) = evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "proof(cases p')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "case (fields a' b' c')"], ["proof (state)\nthis:\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have h : \"convert_poly var p (xs'@x#xs) = Some (a', b', c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_poly var p (xs' @ x # xs) = Some (a', b', c')", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. convert_poly var p (xs' @ x # xs) = Some (a', b', c')", "by auto"], ["proof (state)\nthis:\n  convert_poly var p (xs' @ x # xs) = Some (a', b', c')\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have h2 : \"\\<exists>F'. convert_fm var (convertDerivative var p) (xs'@x#xs) = Some F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F'.\n       convert_fm var (convertDerivative var p) (xs' @ x # xs) = Some F'", "unfolding convertDerivative.simps[of _ p] convertDerivative.simps[of _ \"derivative var p\"] convertDerivative.simps[of _ \"derivative var (derivative var p)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F'.\n       convert_fm var\n        (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n         else Or (fm.Atom (Less p))\n               (And (fm.Atom (Eq p))\n                 (if MPoly_Type.degree (derivative var p) var = 0\n                  then fm.Atom (Less (derivative var p))\n                  else Or (fm.Atom (Less (derivative var p)))\n                        (And (fm.Atom (Eq (derivative var p)))\n                          (if MPoly_Type.degree\n                               (derivative var (derivative var p)) var =\n                              0\n                           then fm.Atom\n                                 (Less (derivative var (derivative var p)))\n                           else Or (fm.Atom\n                                     (Less\n (derivative var (derivative var p))))\n                                 (And (fm.Atom\n  (Eq (derivative var (derivative var p))))\n                                   (convertDerivative var\n                                     (derivative var\n (derivative var (derivative var p))))))))))\n        (xs' @ x # xs) =\n       Some F'", "apply (auto simp del: convertDerivative.simps)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 14 subgoals...", "using degree_convert_eq h"], ["proof (prove)\nusing this:\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n  convert_poly var p (xs' @ x # xs) = Some (a', b', c')\n\ngoal (14 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 14 subgoals...", "apply blast"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 13 subgoals...", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (13 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 13 subgoals...", "apply blast"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 12 subgoals...", "using degree_derivative"], ["proof (prove)\nusing this:\n  0 < MPoly_Type.degree ?p ?x \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree (derivative ?x ?p) ?x + 1\n\ngoal (12 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      MPoly_Type.degree (derivative var p) var < 3;\n      0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3\nA total of 12 subgoals...", "apply fastforce"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var = 0;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      \\<not> MPoly_Type.degree (derivative var p) var < 3;\n      MPoly_Type.degree p var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var = 0\nA total of 11 subgoals...", "apply (metis degree_convert_eq h   numeral_3_eq_3 )"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 10. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                      var\n                     < 3;\n      \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n     \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis (no_types, lifting) One_nat_def add.right_neutral add_Suc_right degree_derivative less_Suc_eq_0_disj less_Suc_eq_le neq0_conv numeral_3_eq_3)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3; 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F'.\n                         (case case case case case case convert_fm var\n                   (convertDerivative var\n                     (derivative var (derivative var (derivative var p))))\n                   (xs' @ x # xs) of\n             None \\<Rightarrow> None\n             | Some b \\<Rightarrow>\n                 Some\n                  (AndUni\n                    (AtomUni\n                      (EqUni\n                        (insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 2),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var\n                            (Suc 0)),\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse\n                            (derivative var (derivative var p)) var 0))))\n                    b) of\n        None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            Some\n             (OrUni\n               (AtomUni\n                 (LessUni\n                   (insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 2),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var (Suc 0)),\n                    insertion (nth_default 0 (xs' @ x # xs))\n                     (isolate_variable_sparse\n                       (derivative var (derivative var p)) var 0))))\n               b) of\n   None \\<Rightarrow> None\n   | Some b \\<Rightarrow>\n       Some\n        (AndUni\n          (AtomUni\n            (EqUni\n              (insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 2),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var (Suc 0)),\n               insertion (nth_default 0 (xs' @ x # xs))\n                (isolate_variable_sparse (derivative var p) var 0))))\n          b) of\n                                    None \\<Rightarrow> None\n                                    | Some b \\<Rightarrow>\n  Some\n   (OrUni\n     (AtomUni\n       (LessUni\n         (insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 2),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var (Suc 0)),\n          insertion (nth_default 0 (xs' @ x # xs))\n           (isolate_variable_sparse (derivative var p) var 0))))\n     b) of\n                               None \\<Rightarrow> None\n                               | Some b \\<Rightarrow>\n                                   Some\n                                    (AndUni\n(AtomUni\n  (EqUni\n    (insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 2),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0)),\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var 0))))\nb) of\n                          None \\<Rightarrow> None\n                          | Some b \\<Rightarrow>\n                              Some\n                               (OrUni\n                                 (AtomUni\n                                   (LessUni\n                                     (insertion\n (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var (Suc 0)),\ninsertion (nth_default 0 (xs' @ x # xs))\n (isolate_variable_sparse p var 0))))\n                                 b)) =\n                         Some F'\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 9. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis One_nat_def Suc_eq_plus1 degree_derivative less_2_cases less_Suc_eq nat_neq_iff numeral_3_eq_3 one_add_one)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 8. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using degree_derivative"], ["proof (prove)\nusing this:\n  0 < MPoly_Type.degree ?p ?x \\<Longrightarrow>\n  MPoly_Type.degree ?p ?x = MPoly_Type.degree (derivative ?x ?p) ?x + 1\n\ngoal (7 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 7. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (6 subgoals):\n 1. \\<lbrakk>MPoly_Type.degree (derivative var (derivative var p)) var < 3;\n     0 < MPoly_Type.degree (derivative var (derivative var p)) var;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 6. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 5. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 4. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis degree_derivative less_Suc_eq less_add_one not_less_eq numeral_3_eq_3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     MPoly_Type.degree (derivative var p) var < 3;\n     0 < MPoly_Type.degree (derivative var p) var\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 3. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (meson assms(1) degree_convert_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var = 0\n 2. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "apply (metis (no_types, hide_lams) Suc_1 Suc_eq_plus1 degree_derivative less_2_cases less_Suc_eq numeral_3_eq_3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "using assms(1) degree_convert_eq"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  convert_poly ?var ?p ?xs = Some ?a \\<Longrightarrow>\n  MPoly_Type.degree ?p ?var < 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> MPoly_Type.degree (derivative var (derivative var p))\n                     var\n                    < 3;\n     \\<not> MPoly_Type.degree (derivative var p) var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by blast"], ["proof (state)\nthis:\n  \\<exists>F'.\n     convert_fm var (convertDerivative var p) (xs' @ x # xs) = Some F'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have c'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 0) = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) =\n    c'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0) =\n                      c'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 0) =\n                      c'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'", "have c'_insertion'' : \"\\<And>x. insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 0) = c'\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0) =\n       c'", "using assms(12) not_in_isovarspar[of p var 0 \"isolate_variable_sparse p var 0\", OF HOL.refl]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n  length xs' = var\n  var \\<notin> vars (isolate_variable_sparse p var 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 0) =\n       c'", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have b'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var (Suc 0)) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) =\n    b'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var (Suc 0)) =\n                      b'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'", "have b'_insertion'' : \"\\<And>x. insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var (Suc 0)) = b'\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)) =\n       b'", "using assms(12) not_in_isovarspar[of p var \"Suc 0\" \"isolate_variable_sparse p var (Suc 0)\", OF HOL.refl]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n  length xs' = var\n  var \\<notin> vars (isolate_variable_sparse p var (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)) =\n       b'", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'", "have b'_insertion2 : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 1) = b'\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 1) =\n    b'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have a'_insertion : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse p var 2) = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2) =\n                      a'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p var 2) =\n                      a'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'", "have a'_insertion'' : \"\\<And>x. insertion (nth_default 0 (xs' @ x # xs)) (isolate_variable_sparse p var 2) = a'\""], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) =\n       a'", "using assms(12) not_in_isovarspar[of p var 2 \"isolate_variable_sparse p var 2\", OF HOL.refl]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n  length xs' = var\n  var \\<notin> vars (isolate_variable_sparse p var 2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var 2) =\n       a'", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have liftb : \"liftPoly 0 0 b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 0 b = b", "using lift00"], ["proof (prove)\nusing this:\n  liftPoly 0 0 ?a = ?a\n\ngoal (1 subgoal):\n 1. liftPoly 0 0 b = b", "by auto"], ["proof (state)\nthis:\n  liftPoly 0 0 b = b\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have liftc : \"liftPoly 0 0 c = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftPoly 0 0 c = c", "using lift00"], ["proof (prove)\nusing this:\n  liftPoly 0 0 ?a = ?a\n\ngoal (1 subgoal):\n 1. liftPoly 0 0 c = c", "by auto"], ["proof (state)\nthis:\n  liftPoly 0 0 c = c\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have b'_insertion' : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var 0) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "using assms fields"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "unfolding convert_poly.simps"], ["proof (prove)\nusing this:\n  (if MPoly_Type.degree p var < 3\n   then let (A, B, C) = get_coeffs var p\n        in Some\n            (insertion (nth_default 0 (xs' @ x # xs)) A,\n             insertion (nth_default 0 (xs' @ x # xs)) B,\n             insertion (nth_default 0 (xs' @ x # xs)) C)\n   else None) =\n  Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  p' = (a', b', c')\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       0) =\n    b'", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) =\n                      b'\n 2. \\<lbrakk>(if MPoly_Type.degree p var < 3\n              then let (A, B, C) = get_coeffs var p\n                   in Some\n                       (insertion (nth_default 0 (xs' @ x # xs)) A,\n                        insertion (nth_default 0 (xs' @ x # xs)) B,\n                        insertion (nth_default 0 (xs' @ x # xs)) C)\n              else None) =\n             Some p';\n     insertion (nth_default 0 (xs' @ x # xs)) a = A;\n     insertion (nth_default 0 (xs' @ x # xs)) b = B;\n     insertion (nth_default 0 (xs' @ x # xs)) c = C;\n     insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n     0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n     var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n     p' = (a', b', c'); \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p var (Suc 0)) var 0) =\n                      b'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) d \\<noteq> 0;\n     0 \\<le> insertion (nth_default 0 (xs' @ x # xs)) c;\n     length xs' \\<notin> vars a; length xs' \\<notin> vars b;\n     length xs' \\<notin> vars c; length xs' \\<notin> vars d;\n     p' =\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 2),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') (Suc 0)),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     MPoly_Type.degree p (length xs') < 3;\n     A = insertion (nth_default 0 (xs' @ x # xs)) a;\n     B = insertion (nth_default 0 (xs' @ x # xs)) b;\n     C = insertion (nth_default 0 (xs' @ x # xs)) c;\n     D = insertion (nth_default 0 (xs' @ x # xs)) d; var = length xs';\n     a' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 0)\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p (length xs') (Suc 0))\n                         (length xs') 0) =\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0))", "using degree0isovarspar degree_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  MPoly_Type.degree (isolate_variable_sparse ?p ?x ?i) ?x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) d \\<noteq> 0;\n     0 \\<le> insertion (nth_default 0 (xs' @ x # xs)) c;\n     length xs' \\<notin> vars a; length xs' \\<notin> vars b;\n     length xs' \\<notin> vars c; length xs' \\<notin> vars d;\n     p' =\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 2),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') (Suc 0)),\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') 0));\n     MPoly_Type.degree p (length xs') < 3;\n     A = insertion (nth_default 0 (xs' @ x # xs)) a;\n     B = insertion (nth_default 0 (xs' @ x # xs)) b;\n     C = insertion (nth_default 0 (xs' @ x # xs)) c;\n     D = insertion (nth_default 0 (xs' @ x # xs)) d; var = length xs';\n     a' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c' =\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p (length xs') 0)\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse\n                         (isolate_variable_sparse p (length xs') (Suc 0))\n                         (length xs') 0) =\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0))", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var 0) =\n  b'\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertion_into_1 : \"insertion (nth_default 0 (xs'@x#xs)) (isolate_variable_sparse (Const 1) var 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse (Const 1) var 0) =\n    1", "by (simp add: const_lookup_zero insertion_const)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse (Const 1) var 0) =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have twominusone : \"((2-1)::nat) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 1 = 1", "by auto"], ["proof (state)\nthis:\n  2 - 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have length0 : \"var < length (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinserta : \"\\<forall>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) a = A", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) a = A", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) a = A\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinserta' : \"\\<And>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) a = A", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) a = A", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := ?xa])) a = A\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertb : \"\\<forall>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) b = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) b = B", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) b = B", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) b = B\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertb' : \"\\<And>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) b = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) b = B", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) b = B", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := ?xa])) b = B\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertc : \"\\<forall>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) c = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) c = C", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) c = C", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) c = C\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertc' : \"\\<And>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) c = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) c = C", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) c = C", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := ?xa])) c = C\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertd : \"\\<forall>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) d = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) d = D", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) d = D", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  \\<forall>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) d = D\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have altinsertd' : \"\\<And>xa. insertion (nth_default 0 ((xs'@x#xs)[var := xa])) d = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) d = D", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>xa. insertion (nth_default 0 ((xs' @ x # xs)[var := xa])) d = D", "by (metis list_update_length not_contains_insertion)"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := ?xa])) d = D\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have freeInQuadraticSub : \"\\<forall>At. eval (quadratic_sub var a b c d At) ((xs'@x#xs)[var := sqrt C]) = eval (quadratic_sub var a b c d At) ((xs'@x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>At.\n       eval (quadratic_sub var a b c d At) ((xs' @ x # xs)[var := sqrt C]) =\n       eval (quadratic_sub var a b c d At) (xs' @ x # xs)", "by (metis assms(10) assms(11) assms(8) assms(9) free_in_quad list_update_id var_not_in_eval)"], ["proof (state)\nthis:\n  \\<forall>At.\n     eval (quadratic_sub var a b c d At) ((xs' @ x # xs)[var := sqrt C]) =\n     eval (quadratic_sub var a b c d At) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have quad : \"\\<And>At. (eval (quadratic_sub var a b c d At) (xs'@x#xs) =\n  aEval At ((xs'@x#xs)[var := (A + B * sqrt C) / D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>At.\n       eval (quadratic_sub var a b c d At) (xs' @ x # xs) =\n       aEval At ((xs' @ x # xs)[var := (A + B * sqrt C) / D])", "using quadratic_sub[OF length0 assms(6-7) assms(10) altinserta altinsertb altinsertc altinsertd, symmetric]"], ["proof (prove)\nusing this:\n  eval (quadratic_sub var a b c d ?A) ((xs' @ x # xs)[var := sqrt C]) =\n  aEval ?A ((xs' @ x # xs)[var := (A + B * sqrt C) / D])\n\ngoal (1 subgoal):\n 1. \\<And>At.\n       eval (quadratic_sub var a b c d At) (xs' @ x # xs) =\n       aEval At ((xs' @ x # xs)[var := (A + B * sqrt C) / D])", "using freeInQuadraticSub"], ["proof (prove)\nusing this:\n  eval (quadratic_sub var a b c d ?A) ((xs' @ x # xs)[var := sqrt C]) =\n  aEval ?A ((xs' @ x # xs)[var := (A + B * sqrt C) / D])\n  \\<forall>At.\n     eval (quadratic_sub var a b c d At) ((xs' @ x # xs)[var := sqrt C]) =\n     eval (quadratic_sub var a b c d At) (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>At.\n       eval (quadratic_sub var a b c d At) (xs' @ x # xs) =\n       aEval At ((xs' @ x # xs)[var := (A + B * sqrt C) / D])", "by auto"], ["proof (state)\nthis:\n  eval (quadratic_sub var a b c d ?At) (xs' @ x # xs) =\n  aEval ?At ((xs' @ x # xs)[var := (A + B * sqrt C) / D])\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       p' = (aa, ba, ca) \\<Longrightarrow>\n       eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n        (xs' @ x # xs) =\n       evalUni\n        (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 0", "have simp: \"(convertDerivative var p)=Atom(Less p)\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n\ngoal (1 subgoal):\n 1. convertDerivative var p = fm.Atom (Less p)", "by auto"], ["proof (state)\nthis:\n  convertDerivative var p = fm.Atom (Less p)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have azero : \"a'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = 0", "by (metis MPoly_Type.insertion_zero True a'_insertion isolate_variable_sparse_ne_zeroD nat.simps(3) not_less numeral_2_eq_2 zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have bzero : \"b'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = 0", "using True b'_insertion isovar_greater_degree"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n  \\<forall>i>MPoly_Type.degree ?p ?var.\n     isolate_variable_sparse ?p ?var i = 0\n\ngoal (1 subgoal):\n 1. b' = 0", "by fastforce"], ["proof (state)\nthis:\n  b' = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "define p1 where \"p1 = isolate_variable_sparse p var 0\""], ["proof (state)\nthis:\n  p1 = isolate_variable_sparse p var 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have degree_p1: \"MPoly_Type.degree p1 var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p1 var = 0", "unfolding p1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var 0) var = 0", "by (simp add: degree_isovarspar)"], ["proof (state)\nthis:\n  MPoly_Type.degree p1 var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "define p2 where \"p2 = isolate_variable_sparse p1 var 0 * Const 0 * Var var + isolate_variable_sparse p1 var 0 * Const 1\""], ["proof (state)\nthis:\n  p2 =\n  isolate_variable_sparse p1 var 0 * Const 0 * Var var +\n  isolate_variable_sparse p1 var 0 * Const 1\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "define A where \"A = isolate_variable_sparse p2 var 0\""], ["proof (state)\nthis:\n  A = isolate_variable_sparse p2 var 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "define B where \"B = isolate_variable_sparse p2 var (Suc 0)\""], ["proof (state)\nthis:\n  B = isolate_variable_sparse p2 var (Suc 0)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "unfolding substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps\n        fields\n        convertDerivativeUni.simps map_atomUni.simps quadraticSubUni.simps aEvalUni.simps evalUni.simps evalUni_if\n        Rings.mult_zero_class.mult_zero_left Groups.add_0 Rings.mult_zero_class.mult_zero_right\n        True simp azero bzero \n        quadratic_sub_fm.simps quadratic_sub_fm_helper.simps liftmap.simps lift00  \n        quad aEval.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub (var + 0) a b c d (Less p)) (xs' @ x # xs) =\n    (c' < 0 \\<or> c' = 0 \\<and> (0 < 0 \\<or> 0 = 0 \\<and> 0 < 0))", "apply (simp add:True c'_insertion p1_def[symmetric] degree_p1 p2_def[symmetric] A_def[symmetric] B_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs)) A < 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs)) (B\\<^sup>2 * c - A\\<^sup>2)\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs)) B \\<le> 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs)) A < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs)) (A\\<^sup>2 - B\\<^sup>2 * c)\n      < 0)) =\n    (c' < 0)", "unfolding A_def B_def p2_def p1_def  degree0isovarspar[OF True] isovarspar_sum mult_one_right mult_zero_right mult_zero_left const_lookup_zero const_lookup_suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs)) (Const 0 + p) < 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      ((0 + isolate_variable_sparse p var (Suc 0))\\<^sup>2 * c -\n       (Const 0 + p)\\<^sup>2)\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (0 + isolate_variable_sparse p var (Suc 0))\n     \\<le> 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs)) (Const 0 + p) < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       ((Const 0 + p)\\<^sup>2 -\n        (0 + isolate_variable_sparse p var (Suc 0))\\<^sup>2 * c)\n      < 0)) =\n    (c' < 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs)) (Const 0 + p) < 0 \\<and>\n     insertion (nth_default 0 (xs' @ x # xs))\n      ((isolate_variable_sparse p var (Suc 0))\\<^sup>2 * c -\n       (Const 0 + p)\\<^sup>2)\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0))\n     \\<le> 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs)) (Const 0 + p) < 0 \\<or>\n      insertion (nth_default 0 (xs' @ x # xs))\n       ((Const 0 + p)\\<^sup>2 -\n        (isolate_variable_sparse p var (Suc 0))\\<^sup>2 * c)\n      < 0)) =\n    (c' < 0)", "unfolding insertion_add insertion_sub insertion_mult insertion_pow insertion_const c'_insertion"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 + insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n     insertion (nth_default 0 (xs' @ x # xs)) c -\n     (0 + insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2\n     < 0 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0))\n     \\<le> 0 \\<and>\n     (0 + insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<or>\n      (0 + insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2 -\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n      insertion (nth_default 0 (xs' @ x # xs)) c\n      < 0)) =\n    (c' < 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n     insertion (nth_default 0 (xs' @ x # xs)) c\n     < (insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0))\n     \\<le> 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<or>\n      (insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2\n      < (insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n        insertion (nth_default 0 (xs' @ x # xs)) c)) =\n    (c' < 0)", "using \\<open>isolate_variable_sparse p var 0 = p\\<close> b'_insertion2 bzero c'_insertion"], ["proof (prove)\nusing this:\n  isolate_variable_sparse p var 0 = p\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 1) =\n  b'\n  b' = 0\n  insertion (nth_default 0 (xs' @ x # xs))\n   (isolate_variable_sparse p var 0) =\n  c'\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n     insertion (nth_default 0 (xs' @ x # xs)) c\n     < (insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2 \\<or>\n     insertion (nth_default 0 (xs' @ x # xs))\n      (isolate_variable_sparse p var (Suc 0))\n     \\<le> 0 \\<and>\n     (insertion (nth_default 0 (xs' @ x # xs)) p < 0 \\<or>\n      (insertion (nth_default 0 (xs' @ x # xs)) p)\\<^sup>2\n      < (insertion (nth_default 0 (xs' @ x # xs))\n          (isolate_variable_sparse p var (Suc 0)))\\<^sup>2 *\n        insertion (nth_default 0 (xs' @ x # xs)) c)) =\n    (c' < 0)", "by force"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have degreenonzero : \"MPoly_Type.degree p var \\<noteq>0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var = 1", "have simp : \"convertDerivative var p = Or (fm.Atom (Less p)) (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. convertDerivative var p =\n    Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))", "by (metis One_nat_def Suc_eq_plus1 add_right_imp_eq convertDerivative.simps degree_derivative degreenonzero less_numeral_extra(1))"], ["proof (state)\nthis:\n  convertDerivative var p =\n  Or (fm.Atom (Less p))\n   (And (fm.Atom (Eq p)) (fm.Atom (Less (derivative var p))))\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have azero : \"a'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = 0", "by (metis MPoly_Type.insertion_zero One_nat_def True a'_insertion isovar_greater_degree lessI numeral_2_eq_2)"], ["proof (state)\nthis:\n  a' = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have degderiv : \"MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "using degree_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.degree (?p * ?q) ?v =\n                    MPoly_Type.degree ?p ?v + MPoly_Type.degree ?q ?v\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0", "by (simp add: degree_isovarspar mult_one_right)"], ["proof (state)\nthis:\n  MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1) var =\n  0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have thing : \"var<length (xs'@((A + B * sqrt C) / D # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ (A + B * sqrt C) / D # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ (A + B * sqrt C) / D # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ (A + B * sqrt C) / D # xs)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertp : \"insertion (nth_default 0 (xs'@((A + B * sqrt C) / D # xs))) p = b' * (A + B * sqrt C) / D + c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    b' * (A + B * sqrt C) / D + c'", "using sum_over_degree_insertion[OF thing True, of \"(A + B * sqrt C) / D\", symmetric]"], ["proof (prove)\nusing this:\n  insertion\n   (nth_default 0\n     ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n   p =\n  (\\<Sum>i = 0..<1 + 1.\n      insertion\n       (nth_default 0\n         ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var i) *\n      ((A + B * sqrt C) / D) ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    b' * (A + B * sqrt C) / D + c'", "unfolding list_update_length  assms(12)[symmetric]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n  (\\<Sum>i = 0..<1 + 1.\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p (length xs') i) *\n      ((A + B * sqrt C) / D) ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    b' * (A + B * sqrt C) / D + c'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p (length xs') 0) +\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p (length xs') (Suc 0)) *\n    (A + B * sqrt C) /\n    D \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p (length xs') 0) +\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p (length xs') (Suc 0)) *\n    (A + B * sqrt C) /\n    D =\n    b' * (A + B * sqrt C) / D + c'", "unfolding assms(12)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D =\n    b' * (A + B * sqrt C) / D + c'", "unfolding c'_insertion'' b'_insertion''"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n    c' + b' * (A + B * sqrt C) / D \\<Longrightarrow>\n    c' + b' * (A + B * sqrt C) / D = b' * (A + B * sqrt C) / D + c'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n  b' * (A + B * sqrt C) / D + c'\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertb : \"insertion (nth_default 0 (xs'@(A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse p var (Suc 0) * Const 1) = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var (Suc 0) * Const 1) =\n    b'", "unfolding insertion_mult insertion_const b'_insertion''"], ["proof (prove)\ngoal (1 subgoal):\n 1. b' * 1 = b'", "by simp"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse p var (Suc 0) * Const 1) =\n  b'\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "unfolding substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps\n          fields\n          convertDerivativeUni.simps map_atomUni.simps quadraticSubUni.simps aEvalUni.simps evalUni.simps evalUni_if\n          Rings.mult_zero_class.mult_zero_left Groups.add_0 Rings.mult_zero_class.mult_zero_right\n          True simp azero \n          quadratic_sub_fm.simps quadratic_sub_fm_helper.simps liftmap.simps lift00  \n          quad aEval.simps eval.simps derivative_def Groups.monoid_add_class.add_0_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      (\\<Sum>i = 0..1 - 1.\n          isolate_variable_sparse p var (i + 1) * Var var ^ i *\n          Const (real (i + 1)))\n     < 0) =\n    (b' * ((A + B * sqrt C) / D) + c' < 0 \\<or>\n     b' * ((A + B * sqrt C) / D) + c' = 0 \\<and>\n     (b' < 0 \\<or> b' = 0 \\<and> 0 < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      (isolate_variable_sparse p var (Suc 0) * Const 1)\n     < 0) =\n    (b' * (A + B * sqrt C) / D + c' < 0 \\<or>\n     b' * (A + B * sqrt C) / D + c' = 0 \\<and> b' < 0)", "unfolding insertp insertb insertion_mult insertion_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      (isolate_variable_sparse p var (Suc 0)) *\n     1\n     < 0) =\n    (b' * (A + B * sqrt C) / D + c' < 0 \\<or>\n     b' * (A + B * sqrt C) / D + c' = 0 \\<and> b' < 0)", "using assms(12) b'_insertion'' insertp"], ["proof (prove)\nusing this:\n  length xs' = var\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var (Suc 0)) =\n  b'\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) p =\n  b' * (A + B * sqrt C) / D + c'\n\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      (isolate_variable_sparse p var (Suc 0)) *\n     1\n     < 0) =\n    (b' * (A + B * sqrt C) / D + c' < 0 \\<or>\n     b' * (A + B * sqrt C) / D + c' = 0 \\<and> b' < 0)", "by force"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have degree2 : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degreenonzero"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using h less_Suc_eq"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var \\<noteq> 0\n  convert_poly var p (xs' @ x # xs) = Some (a', b', c')\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by fastforce"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have simp : \"(convertDerivative var p) = Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p))\n       (Or (fm.Atom (Less (derivative var p)))\n         (And (fm.Atom (Eq (derivative var p))) (fm.Atom (Less (derivative var (derivative var p)))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convertDerivative var p =\n    Or (fm.Atom (Less p))\n     (And (fm.Atom (Eq p))\n       (Or (fm.Atom (Less (derivative var p)))\n         (And (fm.Atom (Eq (derivative var p)))\n           (fm.Atom (Less (derivative var (derivative var p)))))))", "by (metis One_nat_def Suc_eq_plus1 add_diff_cancel_right' convertDerivative.simps degree2 degree_derivative degreenonzero neq0_conv one_add_one)"], ["proof (state)\nthis:\n  convertDerivative var p =\n  Or (fm.Atom (Less p))\n   (And (fm.Atom (Eq p))\n     (Or (fm.Atom (Less (derivative var p)))\n       (And (fm.Atom (Eq (derivative var p)))\n         (fm.Atom (Less (derivative var (derivative var p)))))))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertionp : \"var < length (xs'@(A + B * sqrt C) / D # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ (A + B * sqrt C) / D # xs)", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ (A + B * sqrt C) / D # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ (A + B * sqrt C) / D # xs)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have three : \"3 = Suc(Suc(Suc(0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 = Suc (Suc (Suc 0))", "by auto"], ["proof (state)\nthis:\n  3 = Suc (Suc (Suc 0))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have two : \"2 = Suc(Suc(0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertionp : \"insertion (nth_default 0 ((xs'@x # xs)[var := (A + B * sqrt C) / D])) p = a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'", "using sum_over_degree_insertion[OF insertionp degree2, of \"(A + B * sqrt C) / D\", symmetric]"], ["proof (prove)\nusing this:\n  insertion\n   (nth_default 0\n     ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n   p =\n  (\\<Sum>i = 0..<2 + 1.\n      insertion\n       (nth_default 0\n         ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var i) *\n      ((A + B * sqrt C) / D) ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'", "unfolding  \n          a'_insertion[symmetric] b'_insertion[symmetric] c'_insertion[symmetric] \n          insertion_isovarspars_free[of _ _ \"(A + B * sqrt C) / D\" _ _ x]"], ["proof (prove)\nusing this:\n  insertion\n   (nth_default 0\n     ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n   p =\n  (\\<Sum>i = 0..<2 + 1.\n      insertion\n       (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n       (isolate_variable_sparse p var i) *\n      ((A + B * sqrt C) / D) ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 2) *\n    ((A + B * sqrt C) / D)\\<^sup>2 +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "unfolding two"], ["proof (prove)\nusing this:\n  insertion\n   (nth_default 0\n     ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n   p =\n  (\\<Sum>i = 0..<Suc (Suc 0) + 1.\n      insertion\n       (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n       (isolate_variable_sparse p var i) *\n      ((A + B * sqrt C) / D) ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    ((A + B * sqrt C) / D) ^ Suc (Suc 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion\n     (nth_default 0\n       ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    ((A + B * sqrt C) * (A + B * sqrt C)) /\n    (D * D) \\<Longrightarrow>\n    insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    ((A + B * sqrt C) * (A + B * sqrt C)) /\n    (D * D) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "using assms(12)"], ["proof (prove)\nusing this:\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion\n     (nth_default 0\n       ((xs' @ (A + B * sqrt C) / D # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 ((xs' @ (A + B * sqrt C) / D # xs)[var := x]))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    ((A + B * sqrt C) * (A + B * sqrt C)) /\n    (D * D) \\<Longrightarrow>\n    insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n     p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    ((A + B * sqrt C) * (A + B * sqrt C)) /\n    (D * D) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    (A + B * sqrt C) /\n    D +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0)", "by force"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n   p =\n  a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertion_simp : \"insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D])) = insertion (nth_default 0 ((xs' @ ((A + B * sqrt C) / D) # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion\n     (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D])) =\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion\n     (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D])) =\n    insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))", "by (metis list_update_length)"], ["proof (state)\nthis:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D])) =\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have degreeone : \"MPoly_Type.degree\n                  (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                   isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n                  var = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var =\n    1", "apply(rule degree_less_sum'[where n=0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. MPoly_Type.degree (isolate_variable_sparse p var (Suc 0) * Const 1)\n     var =\n    0\n 2. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1\n 3. 0 < 1", "apply (simp add: degree_isovarspar mult_one_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MPoly_Type.degree\n     (isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2) var =\n    1\n 2. 0 < 1", "apply (smt One_nat_def ExecutiblePolyProps.degree_one degree2 degree_const degree_isovarspar degree_mult degreenonzero isolate_variable_sparse_degree_eq_zero_iff mult.commute nonzero_const_is_nonzero numeral_2_eq_2 plus_1_eq_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.degree\n   (isolate_variable_sparse p var (Suc 0) * Const 1 +\n    isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n   var =\n  1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have zero1 : \" insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var (Suc 0)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) =\n    0", "by (simp add: degree_isovarspar isovar_greater_degree)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n     (Suc 0)) =\n  0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have zero2 : \"insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0))) var 0) = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0) =\n    a'", "using a'_insertion'' degree0isovarspar degree_isovarspar numeral_2_eq_2"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ ?x # xs))\n   (isolate_variable_sparse p var 2) =\n  a'\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  MPoly_Type.degree (isolate_variable_sparse ?p ?x ?i) ?x = 0\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var 0) =\n    a'", "by force"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n     var 0) =\n  a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have zero3 : \"insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (isolate_variable_sparse (Var var) var (Suc 0)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (Var var) var (Suc 0)) =\n    1", "using isolate_var_one"], ["proof (prove)\nusing this:\n  isolate_variable_sparse (Var ?x) ?x 1 = 1\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (Var var) var (Suc 0)) =\n    1", "by fastforce"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse (Var var) var (Suc 0)) =\n  1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have zero4 : \"insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n       var (Suc 0)) =\n    0", "by (simp add: degree_isovarspar isovar_greater_degree)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n     var (Suc 0)) =\n  0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have insertiona' : \" insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1) = 2 * a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse\n       (isolate_variable_sparse p var (Suc 0) * Const 1 +\n        isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n       var (Suc 0) *\n      Const 1) =\n    2 * a'", "unfolding isovarspar_sum isolate_variable_sparse_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (((\\<Sum>i\\<le>Suc 0.\n           isolate_variable_sparse (isolate_variable_sparse p var (Suc 0))\n            var i *\n           isolate_variable_sparse (Const 1) var (Suc 0 - i)) +\n       (\\<Sum>i\\<le>Suc 0.\n           (\\<Sum>ia\\<le>i.\n               isolate_variable_sparse\n                (isolate_variable_sparse p var (Suc (Suc 0))) var ia *\n               isolate_variable_sparse (Var var) var (i - ia)) *\n           isolate_variable_sparse (Const 2) var (Suc 0 - i))) *\n      Const 1) =\n    2 * a'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     ((isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        0 *\n       isolate_variable_sparse (Const 1) var (Suc 0) +\n       isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        (Suc 0) *\n       isolate_variable_sparse (Const 1) var 0 +\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var 0 *\n        isolate_variable_sparse (Var var) var 0 *\n        isolate_variable_sparse (Const 2) var (Suc 0) +\n        (isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc (Suc 0))) var 0 *\n         isolate_variable_sparse (Var var) var (Suc 0) +\n         isolate_variable_sparse\n          (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0) *\n         isolate_variable_sparse (Var var) var 0) *\n        isolate_variable_sparse (Const 2) var 0)) *\n      Const 1) =\n    2 * a'", "unfolding const_lookup_suc const_lookup_zero Rings.mult_zero_class.mult_zero_right\n          Groups.group_add_class.add.group_left_neutral"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     ((isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        (Suc 0) *\n       Const 1 +\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var 0 *\n        isolate_variable_sparse (Var var) var (Suc 0) +\n        isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0) *\n        isolate_variable_sparse (Var var) var 0) *\n       Const 2) *\n      Const 1) =\n    2 * a'", "unfolding insertion_add insertion_mult insertion_const b'_insertion'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n        (Suc 0)) *\n     1 +\n     (insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var 0) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse (Var var) var (Suc 0)) +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc (Suc 0))) var (Suc 0)) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse (Var var) var 0)) *\n     2) *\n    1 =\n    2 * a'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse (isolate_variable_sparse p var (Suc 0)) var\n       (Suc 0)) +\n    (insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var 0) *\n     insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (Var var) var (Suc 0)) *\n     2 +\n     insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (isolate_variable_sparse p var (Suc (Suc 0)))\n        var (Suc 0)) *\n     insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (Var var) var 0) *\n     2) =\n    2 * a'", "unfolding zero1 zero2 zero3 zero4"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 +\n    (a' * 1 * 2 +\n     0 *\n     insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n      (isolate_variable_sparse (Var var) var 0) *\n     2) =\n    2 * a'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse\n     (isolate_variable_sparse p var (Suc 0) * Const 1 +\n      isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n     var (Suc 0) *\n    Const 1) =\n  2 * a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have a' :  \"insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (isolate_variable_sparse p var (Suc (Suc 0))) = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) =\n    a'", "unfolding two[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n     (isolate_variable_sparse p var 2) =\n    a'", "unfolding a'_insertion''"], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = a'", "by auto"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n   (isolate_variable_sparse p var (Suc (Suc 0))) =\n  a'\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "have var: \"insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (Var var) = (A + B * sqrt C) / D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (Var var) =\n    (A + B * sqrt C) / D", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p (xs' @ x # xs) = Some p'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (Var var) =\n    (A + B * sqrt C) / D", "by (metis insertion_simp insertion_var length0)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs)) (Var var) =\n  (A + B * sqrt C) / D\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "unfolding substInfinitesimalQuadratic.simps substInfinitesimalQuadraticUni.simps\n          fields\n          convertDerivativeUni.simps map_atomUni.simps quadraticSubUni.simps aEvalUni.simps evalUni.simps evalUni_if\n          Rings.mult_zero_class.mult_zero_left Groups.add_0 Rings.mult_zero_class.mult_zero_right\n          degree2 simp\n          quadratic_sub_fm.simps quadratic_sub_fm_helper.simps liftmap.simps lift00   Groups.monoid_add_class.add_0_right\n          quad aEval.simps eval.simps derivative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     (insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (\\<Sum>i = 0..2 - 1.\n           isolate_variable_sparse p var (i + 1) * Var var ^ i *\n           Const (real (i + 1)))\n      < 0 \\<or>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (\\<Sum>i = 0..2 - 1.\n           isolate_variable_sparse p var (i + 1) * Var var ^ i *\n           Const (real (i + 1))) =\n      0 \\<and>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (\\<Sum>i = 0..MPoly_Type.degree\n                      (\\<Sum>i = 0..2 - 1.\n                          isolate_variable_sparse p var (i + 1) *\n                          Var var ^ i *\n                          Const (real (i + 1)))\n                      var -\n                     1.\n           isolate_variable_sparse\n            (\\<Sum>i = 0..2 - 1.\n                isolate_variable_sparse p var (i + 1) * Var var ^ i *\n                Const (real (i + 1)))\n            var (i + 1) *\n           Var var ^ i *\n           Const (real (i + 1)))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * ((A + B * sqrt C) / D) + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * ((A + B * sqrt C) / D) +\n     c' =\n     0 \\<and>\n     (2 * a' * ((A + B * sqrt C) / D) + b' < 0 \\<or>\n      2 * a' * ((A + B * sqrt C) / D) + b' = 0 \\<and> 2 * a' < 0))", "apply (simp add:insertion_sum insertion_add insertion_mult insertion_const insertion_var_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p\n     < 0 \\<or>\n     insertion (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n      p =\n     0 \\<and>\n     (insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (Var var) *\n      2\n      < 0 \\<or>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (\\<Sum>i = 0..MPoly_Type.degree\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var -\n                     Suc 0.\n           isolate_variable_sparse\n            (isolate_variable_sparse p var (Suc 0) * Const 1 +\n             isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n             Const 2)\n            var (Suc i) *\n           Var var ^ i *\n           Const (1 + real i))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding insertionp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (Var var) *\n      2\n      < 0 \\<or>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion\n       (nth_default 0 ((xs' @ x # xs)[var := (A + B * sqrt C) / D]))\n       (\\<Sum>i = 0..MPoly_Type.degree\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var -\n                     Suc 0.\n           isolate_variable_sparse\n            (isolate_variable_sparse p var (Suc 0) * Const 1 +\n             isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n             Const 2)\n            var (Suc i) *\n           Var var ^ i *\n           Const (1 + real i))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding insertion_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2\n      < 0 \\<or>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc 0)) +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (\\<Sum>i = 0..MPoly_Type.degree\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var -\n                     Suc 0.\n           isolate_variable_sparse\n            (isolate_variable_sparse p var (Suc 0) * Const 1 +\n             isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n             Const 2)\n            var (Suc i) *\n           Var var ^ i *\n           Const (1 + real i))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding b'_insertion'' a'_insertion''"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2\n      < 0 \\<or>\n      b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (\\<Sum>i = 0..MPoly_Type.degree\n                      (isolate_variable_sparse p var (Suc 0) * Const 1 +\n                       isolate_variable_sparse p var (Suc (Suc 0)) *\n                       Var var *\n                       Const 2)\n                      var -\n                     Suc 0.\n           isolate_variable_sparse\n            (isolate_variable_sparse p var (Suc 0) * Const 1 +\n             isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n             Const 2)\n            var (Suc i) *\n           Var var ^ i *\n           Const (1 + real i))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding \n          degreeone"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2\n      < 0 \\<or>\n      b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (\\<Sum>i = 0..1 - Suc 0.\n           isolate_variable_sparse\n            (isolate_variable_sparse p var (Suc 0) * Const 1 +\n             isolate_variable_sparse p var (Suc (Suc 0)) * Var var *\n             Const 2)\n            var (Suc i) *\n           Var var ^ i *\n           Const (1 + real i))\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2\n      < 0 \\<or>\n      b' +\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse p var (Suc (Suc 0))) *\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (Var var) *\n      2 =\n      0 \\<and>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1)\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding a' var"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * ((A + B * sqrt C) / D) * 2 < 0 \\<or>\n      b' + a' * ((A + B * sqrt C) / D) * 2 = 0 \\<and>\n      insertion (nth_default 0 (xs' @ (A + B * sqrt C) / D # xs))\n       (isolate_variable_sparse\n         (isolate_variable_sparse p var (Suc 0) * Const 1 +\n          isolate_variable_sparse p var (Suc (Suc 0)) * Var var * Const 2)\n         var (Suc 0) *\n        Const 1)\n      < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "unfolding insertiona'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * ((A + B * sqrt C) / D) * 2 < 0 \\<or>\n      b' + a' * ((A + B * sqrt C) / D) * 2 = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "using weird[OF assms(6)]"], ["proof (prove)\nusing this:\n  (?a' * ((?A + ?B * sqrt ?C) / D)\\<^sup>2 + ?b' * (?A + ?B * sqrt ?C) / D +\n   ?c'\n   < 0 \\<or>\n   ?a' * ((?A + ?B * sqrt ?C) / D)\\<^sup>2 + ?b' * (?A + ?B * sqrt ?C) / D +\n   ?c' =\n   0 \\<and>\n   (?b' + ?a' * (?A + ?B * sqrt ?C) * 2 / D < 0 \\<or>\n    ?b' + ?a' * (?A + ?B * sqrt ?C) * 2 / D = 0 \\<and> 2 * ?a' < 0)) =\n  (?a' * ((?A + ?B * sqrt ?C) / D)\\<^sup>2 + ?b' * (?A + ?B * sqrt ?C) / D +\n   ?c'\n   < 0 \\<or>\n   ?a' * ((?A + ?B * sqrt ?C) / D)\\<^sup>2 + ?b' * (?A + ?B * sqrt ?C) / D +\n   ?c' =\n   0 \\<and>\n   (2 * ?a' * (?A + ?B * sqrt ?C) / D + ?b' < 0 \\<or>\n    2 * ?a' * (?A + ?B * sqrt ?C) / D + ?b' = 0 \\<and> ?a' < 0))\n\ngoal (1 subgoal):\n 1. (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (b' + a' * ((A + B * sqrt C) / D) * 2 < 0 \\<or>\n      b' + a' * ((A + B * sqrt C) / D) * 2 = 0 \\<and> 2 * a' < 0)) =\n    (a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c'\n     < 0 \\<or>\n     a' * ((A + B * sqrt C) / D)\\<^sup>2 + b' * (A + B * sqrt C) / D + c' =\n     0 \\<and>\n     (2 * a' * (A + B * sqrt C) / D + b' < 0 \\<or>\n      2 * a' * (A + B * sqrt C) / D + b' = 0 \\<and> a' < 0))", "by auto"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_substInfinitesimalQuadratic: \n  assumes \"convert_atom var At (xs'@ x#xs) = Some(At')\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) a = A\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) b = B\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) c = C\"\n  assumes \"insertion (nth_default 0 (xs'@ x#xs)) d = D\"\n  assumes \"D \\<noteq> 0\"\n  assumes \"0 \\<le> C\"\n  assumes \"var\\<notin>(vars a)\"\n  assumes \"var\\<notin>(vars b)\"\n  assumes \"var\\<notin>(vars c)\"\n  assumes \"var\\<notin>(vars d)\"\n  assumes \"length xs' = var\"\n  shows \"eval (substInfinitesimalQuadratic var a b c d At) (xs'@ x#xs) = evalUni (substInfinitesimalQuadraticUni A B C D At') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "using assms"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "define p' where \"p' = (case convert_poly var p (xs'@ x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have At'_simp :  \"At' = LessUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At' = LessUni p'", "using assms Less"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Less p\n\ngoal (1 subgoal):\n 1. At' = LessUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Less p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. At' = LessUni p'", "by auto"], ["proof (state)\nthis:\n  At' = LessUni p'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 4. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "using convert_substInfinitesimalQuadratic_less[OF _ assms(2-12)]"], ["proof (prove)\nusing this:\n  convert_poly var ?p (xs' @ x # xs) = Some ?p' \\<Longrightarrow>\n  eval (quadratic_sub_fm var a b c d (convertDerivative var ?p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni ?p'))\n   x\n\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "by (metis At'_simp Less None_eq_map_option_iff assms(1) convert_atom.simps(1) option.distinct(1) option.exhaust_sel option.the_def p'_def substInfinitesimalQuadraticUni.simps(2) substInfinitesimalQuadratic.simps(2))"], ["proof (state)\nthis:\n  eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At') x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "define p' where \"p' = (case convert_poly var p (xs'@ x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have At'_simp :  \"At' = EqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At' = EqUni p'", "using assms Eq"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Eq p\n\ngoal (1 subgoal):\n 1. At' = EqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Eq p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. At' = EqUni p'", "by auto"], ["proof (state)\nthis:\n  At' = EqUni p'\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 3. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "unfolding At'_simp Eq  substInfinitesimalQuadraticUni.simps substInfinitesimalQuadratic.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using At'_simp Eq assms(1) convert_substNegInfinity assms(12)"], ["proof (prove)\nusing this:\n  At' = EqUni p'\n  At = Eq p\n  convert_atom var At (xs' @ x # xs) = Some At'\n  \\<lbrakk>convert_atom ?var ?A (?xs' @ ?x # ?xs) = Some ?A';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (substNegInfinity ?var ?A) (?xs' @ ?x # ?xs) =\n                    evalUni (substNegInfinityUni ?A') ?x\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "by fastforce"], ["proof (state)\nthis:\n  eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "define p' where \"p' = (case convert_poly var p (xs'@ x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have At'_simp :  \"At' = LeqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At' = LeqUni p'", "using assms Leq"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Leq p\n\ngoal (1 subgoal):\n 1. At' = LeqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Leq p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. At' = LeqUni p'", "by auto"], ["proof (state)\nthis:\n  At' = LeqUni p'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have allzero : \"eval (allZero p var) (xs'@ x#xs) = evalUni (allZero' p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "using Leq assms(1) convert_allZero p'_def assms(12)"], ["proof (prove)\nusing this:\n  At = Leq p\n  convert_atom var At (xs' @ x # xs) = Some At'\n  \\<lbrakk>convert_poly ?var ?p (?xs' @ ?x # ?xs) = Some ?p';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> eval (allZero ?p ?var) (?xs' @ ?x # ?xs) =\n                    evalUni (allZero' ?p') ?x\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x", "by force"], ["proof (state)\nthis:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have less : \"eval (quadratic_sub_fm var a b c d (convertDerivative var p)) (xs'@ x#xs) = evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "using convert_substInfinitesimalQuadratic_less[OF _ assms(2-12)]"], ["proof (prove)\nusing this:\n  convert_poly var ?p (xs' @ x # xs) = Some ?p' \\<Longrightarrow>\n  eval (quadratic_sub_fm var a b c d (convertDerivative var ?p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni ?p'))\n   x\n\ngoal (1 subgoal):\n 1. eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n     (xs' @ x # xs) =\n    evalUni\n     (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p')) x", "by (metis Leq assms(1) convert_atom.simps(3) option.distinct(1) option.exhaust_sel option.map(1) option.the_def p'_def)"], ["proof (state)\nthis:\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x\n 2. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "unfolding At'_simp Leq substInfinitesimalQuadraticUni.simps substInfinitesimalQuadratic.simps\n      eval.simps evalUni.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval (allZero p var) (xs' @ x # xs) \\<or>\n     eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n      (xs' @ x # xs)) =\n    (evalUni\n      (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n      x \\<or>\n     evalUni (allZero' p') x)", "using allzero less"], ["proof (prove)\nusing this:\n  eval (allZero p var) (xs' @ x # xs) = evalUni (allZero' p') x\n  eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n   (xs' @ x # xs) =\n  evalUni (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n   x\n\ngoal (1 subgoal):\n 1. (eval (allZero p var) (xs' @ x # xs) \\<or>\n     eval (quadratic_sub_fm var a b c d (convertDerivative var p))\n      (xs' @ x # xs)) =\n    (evalUni\n      (map_atomUni (quadraticSubUni A B C D) (convertDerivativeUni p'))\n      x \\<or>\n     evalUni (allZero' p') x)", "by auto"], ["proof (state)\nthis:\n  eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At') x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "define p' where \"p' = (case convert_poly var p (xs'@ x#xs) of Some p' \\<Rightarrow> p')\""], ["proof (state)\nthis:\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "have At'_simp :  \"At' = NeqUni p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At' = NeqUni p'", "using assms Neq"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Neq p\n\ngoal (1 subgoal):\n 1. At' = NeqUni p'", "using p'_def"], ["proof (prove)\nusing this:\n  convert_atom var At (xs' @ x # xs) = Some At'\n  insertion (nth_default 0 (xs' @ x # xs)) a = A\n  insertion (nth_default 0 (xs' @ x # xs)) b = B\n  insertion (nth_default 0 (xs' @ x # xs)) c = C\n  insertion (nth_default 0 (xs' @ x # xs)) d = D\n  D \\<noteq> 0\n  0 \\<le> C\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n  length xs' = var\n  At = Neq p\n  p' = (case convert_poly var p (xs' @ x # xs) of Some p' \\<Rightarrow> p')\n\ngoal (1 subgoal):\n 1. At' = NeqUni p'", "by auto"], ["proof (state)\nthis:\n  At' = NeqUni p'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>convert_atom var At (xs' @ x # xs) = Some At';\n        insertion (nth_default 0 (xs' @ x # xs)) a = A;\n        insertion (nth_default 0 (xs' @ x # xs)) b = B;\n        insertion (nth_default 0 (xs' @ x # xs)) c = C;\n        insertion (nth_default 0 (xs' @ x # xs)) d = D; D \\<noteq> 0;\n        0 \\<le> C; var \\<notin> vars a; var \\<notin> vars b;\n        var \\<notin> vars c; var \\<notin> vars d; length xs' = var;\n        At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (substInfinitesimalQuadratic var a b c d At)\n                          (xs' @ x # xs) =\n                         evalUni\n                          (substInfinitesimalQuadraticUni A B C D At') x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At') x", "unfolding At'_simp Neq substInfinitesimalQuadraticUni.simps substInfinitesimalQuadratic.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (neg (allZero p var)) (xs' @ x # xs) =\n    evalUni (negUni (allZero' p')) x", "by (metis assms(12) At'_simp Neq assms(1) convert_substNegInfinity eval.simps(6) eval_neg substNegInfinityUni.simps(4) substNegInfinity.simps(4))"], ["proof (state)\nthis:\n  eval (substInfinitesimalQuadratic var a b c d At) (xs' @ x # xs) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinitesimal_quad_helper:\n  fixes A B C D:: \"real\"\n  assumes at_is: \"At = LessUni p \\<or> At = EqUni p\"\n  assumes \"D\\<noteq>0\"\n  assumes \"C\\<ge>0\"\n  shows \"(\\<exists>y'::real>((A+B * sqrt(C))/(D)). \\<forall>x::real \\<in>{((A+B * sqrt(C))/(D))<..y'}. aEvalUni At x)\n      = (evalUni (substInfinitesimalQuadraticUni A B C D At) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases \"At = LessUni p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case True"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "have LessUni: \"At = LessUni p\""], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. At = LessUni p", "by auto"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (2 subgoals):\n 1. At = LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LessUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases \"2 * (a::real) * (A + B * sqrt C) / D + b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case True"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (2 subgoals):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  2 * a * (A + B * sqrt C) / D + b = 0", "have True1 : \"2 * a * (A + B * sqrt C) / D + b = 0\""], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0", "by auto"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (2 subgoals):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case True"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (2 subgoals):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0", "have True2 : \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\""], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0", "by auto"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (2 subgoals):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases \"a<0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case True"], ["proof (state)\nthis:\n  a < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  a < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding LessUni fields"], ["proof (prove)\nusing this:\n  a < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni (a, b, c))) x", "apply (simp add:True1 True2 True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using True1 True2 True"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume beq: \"2 * a * (A + B * sqrt C) / D + b = 0\""], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume root: \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume alt: \"a < 0 \""], ["proof (state)\nthis:\n  a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "let ?r = \"-((A + B * sqrt C) / D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have beq_var: \"b = 2 * a * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 2 * a * - ((A + B * sqrt C) / D)", "using beq"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. b = 2 * a * - ((A + B * sqrt C) / D)", "by auto"], ["proof (state)\nthis:\n  b = 2 * a * - ((A + B * sqrt C) / D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have root_var: \" a * ?r^2 - 2*a*?r*?r + c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (- ((A + B * sqrt C) / D))\\<^sup>2 -\n    2 * a * - ((A + B * sqrt C) / D) * - ((A + B * sqrt C) / D) +\n    c =\n    0", "using root"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. a * (- ((A + B * sqrt C) / D))\\<^sup>2 -\n    2 * a * - ((A + B * sqrt C) / D) * - ((A + B * sqrt C) / D) +\n    c =\n    0", "by (simp add: beq_var)"], ["proof (state)\nthis:\n  a * (- ((A + B * sqrt C) / D))\\<^sup>2 -\n  2 * a * - ((A + B * sqrt C) / D) * - ((A + B * sqrt C) / D) +\n  c =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have \"\\<exists>y'>- ?r. \\<forall>x\\<in>{- ?r<..y'}. a * x\\<^sup>2 + 2 * a *?r * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n       \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n          a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0", "using beq_var root_var alt one_root_a_lt0[where a = \"a\", where b=\"b\", where c=\"c\", where r=\"?r\"]"], ["proof (prove)\nusing this:\n  b = 2 * a * - ((A + B * sqrt C) / D)\n  a * (- ((A + B * sqrt C) / D))\\<^sup>2 -\n  2 * a * - ((A + B * sqrt C) / D) * - ((A + B * sqrt C) / D) +\n  c =\n  0\n  a < 0\n  \\<lbrakk>a < 0; b = 2 * a * - ((A + B * sqrt C) / D);\n   a * (- ((A + B * sqrt C) / D))\\<^sup>2 -\n   2 * a * - ((A + B * sqrt C) / D) * - ((A + B * sqrt C) / D) +\n   c =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n                       \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n                          a * x\\<^sup>2 +\n                          2 * a * - ((A + B * sqrt C) / D) * x +\n                          c\n                          < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n       \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n          a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n     \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n        a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0;\n     a < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n     \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n        a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0", "show \"\\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n     \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n        a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using beq_var"], ["proof (prove)\nusing this:\n  \\<exists>y'>- (- ((A + B * sqrt C) / D)).\n     \\<forall>x\\<in>{- (- ((A + B * sqrt C) / D))<..y'}.\n        a * x\\<^sup>2 + 2 * a * - ((A + B * sqrt C) / D) * x + c < 0\n  b = 2 * a * - ((A + B * sqrt C) / D)\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case False"], ["proof (state)\nthis:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     \\<not> a < 0\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                             aEvalUni At x) =\n                      evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  \\<not> a < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding LessUni fields"], ["proof (prove)\nusing this:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni (a, b, c))) x", "apply (simp add:True1 True2 False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y'>(A + B * sqrt C) / D.\n       \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          \\<not> a * x\\<^sup>2 + b * x + c < 0", "using True1 True2 False"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. \\<forall>y'>(A + B * sqrt C) / D.\n       \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          \\<not> a * x\\<^sup>2 + b * x + c < 0", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "fix y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume beq: \" 2 * a * (A + B * sqrt C) / D + b = 0\""], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume root: \" a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume agteq: \"\\<not> a < 0 \""], ["proof (state)\nthis:\n  \\<not> a < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume y_prop: \"(A + B * sqrt C) / D < y'\""], ["proof (state)\nthis:\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have beq_var: \"b = 2 * a * (- A - B * sqrt C) / D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 2 * a * (- A - B * sqrt C) / D", "using beq"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. b = 2 * a * (- A - B * sqrt C) / D", "by (metis (no_types, hide_lams) ab_group_add_class.ab_diff_conv_add_uminus add.left_neutral add_diff_cancel_left' divide_inverse mult.commute mult_minus_right)"], ["proof (state)\nthis:\n  b = 2 * a * (- A - B * sqrt C) / D\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have root_var: \" a * ((- A - B * sqrt C) / D)\\<^sup>2 - 2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) + c =  0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "using root"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "have f1: \"\\<And>r ra. - ((r::real) + ra) = - r - ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra. - (r + ra) = - r - ra", "by auto"], ["proof (state)\nthis:\n  - (?r + ?ra) = - ?r - ?ra\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "have f2: \"\\<And>r ra. r * (a * 2 * (- A - B * sqrt C)) / (ra * D) = r / (ra / b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra. r * (a * 2 * (- A - B * sqrt C)) / (ra * D) = r / (ra / b)", "by (simp add: beq_var)"], ["proof (state)\nthis:\n  ?r * (a * 2 * (- A - B * sqrt C)) / (?ra * D) = ?r / (?ra / b)\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "have f3: \"c - 0 + a * ((A + B * sqrt C) / D)\\<^sup>2 = - (b * (A + B * sqrt C) / D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c - 0 + a * ((A + B * sqrt C) / D)\\<^sup>2 =\n    - (b * (A + B * sqrt C) / D)", "using root"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. c - 0 + a * ((A + B * sqrt C) / D)\\<^sup>2 =\n    - (b * (A + B * sqrt C) / D)", "by force"], ["proof (state)\nthis:\n  c - 0 + a * ((A + B * sqrt C) / D)\\<^sup>2 = - (b * (A + B * sqrt C) / D)\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "have f4: \"\\<And>r ra rb. ((- (r::real) - ra) / rb)\\<^sup>2 = ((r + ra) / rb)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra rb. ((- r - ra) / rb)\\<^sup>2 = ((r + ra) / rb)\\<^sup>2", "using f1"], ["proof (prove)\nusing this:\n  - (?r + ?ra) = - ?r - ?ra\n\ngoal (1 subgoal):\n 1. \\<And>r ra rb. ((- r - ra) / rb)\\<^sup>2 = ((r + ra) / rb)\\<^sup>2", "by (metis (no_types) divide_minus_left power2_minus)"], ["proof (state)\nthis:\n  ((- ?r - ?ra) / ?rb)\\<^sup>2 = ((?r + ?ra) / ?rb)\\<^sup>2\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "have \"\\<And>r ra rb rc. - ((r::real) * (ra + rb) / rc) = r * (- ra - rb) / rc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ra rb rc. - (r * (ra + rb) / rc) = r * (- ra - rb) / rc", "using f1"], ["proof (prove)\nusing this:\n  - (?r + ?ra) = - ?r - ?ra\n\ngoal (1 subgoal):\n 1. \\<And>r ra rb rc. - (r * (ra + rb) / rc) = r * (- ra - rb) / rc", "by (metis divide_divide_eq_right divide_minus_left mult.commute)"], ["proof (state)\nthis:\n  - (?r * (?ra + ?rb) / ?rc) = ?r * (- ?ra - ?rb) / ?rc\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "then"], ["proof (chain)\npicking this:\n  - (?r * (?ra + ?rb) / ?rc) = ?r * (- ?ra - ?rb) / ?rc", "show ?thesis"], ["proof (prove)\nusing this:\n  - (?r * (?ra + ?rb) / ?rc) = ?r * (- ?ra - ?rb) / ?rc\n\ngoal (1 subgoal):\n 1. a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "using f4 f3 f2"], ["proof (prove)\nusing this:\n  - (?r * (?ra + ?rb) / ?rc) = ?r * (- ?ra - ?rb) / ?rc\n  ((- ?r - ?ra) / ?rb)\\<^sup>2 = ((?r + ?ra) / ?rb)\\<^sup>2\n  c - 0 + a * ((A + B * sqrt C) / D)\\<^sup>2 = - (b * (A + B * sqrt C) / D)\n  ?r * (a * 2 * (- A - B * sqrt C)) / (?ra * D) = ?r / (?ra / b)\n\ngoal (1 subgoal):\n 1. a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n    2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n    c =\n    0", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n  2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n  c =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n  2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n  c =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have y_prop_var: \"- ((- A - B * sqrt C) / D) < y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((- A - B * sqrt C) / D) < y'", "using y_prop"], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. - ((- A - B * sqrt C) / D) < y'", "by (metis add.commute diff_minus_eq_add divide_minus_left minus_diff_eq)"], ["proof (state)\nthis:\n  - ((- A - B * sqrt C) / D) < y'\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have \"\\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}. \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0", "using y_prop_var beq_var root_var agteq one_root_a_gt0[where a = \"a\", where b =\"b\", where c = \"c\", where r= \"-(A + B * sqrt C) / D\"]"], ["proof (prove)\nusing this:\n  - ((- A - B * sqrt C) / D) < y'\n  b = 2 * a * (- A - B * sqrt C) / D\n  a * ((- A - B * sqrt C) / D)\\<^sup>2 -\n  2 * a * (- A - B * sqrt C) * (- A - B * sqrt C) / (D * D) +\n  c =\n  0\n  \\<not> a < 0\n  \\<lbrakk>b = 2 * a * (- (A + B * sqrt C) / D); \\<not> a < 0;\n   a * (- (A + B * sqrt C) / D)\\<^sup>2 -\n   2 * a * (- (A + B * sqrt C) / D) * (- (A + B * sqrt C) / D) +\n   c =\n   0;\n   - (- (A + B * sqrt C) / D) < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..?y'}.\n                       \\<not> a * x\\<^sup>2 +\n                              2 * a * (- (A + B * sqrt C) / D) * x +\n                              c\n                              < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n     \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n        a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n        0;\n        \\<not> a < 0; (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n     \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0", "show \" \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n     \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f1: \"2 * a * (A + B * sqrt C) * inverse D + b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) * inverse D + b = 0", "by (metis True1 divide_inverse)"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) * inverse D + b = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "obtain rr :: real where\n                f2: \"rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and> \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and>\n        \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c\n               < 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}. \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n     \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and>\n        \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c\n               < 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and>\n  \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f3: \"a * ((A + B * sqrt C) * (inverse D * 2)) = - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) * (inverse D * 2)) = - b", "using f1"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) * inverse D + b = 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) * (inverse D * 2)) = - b", "by linarith"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) * (inverse D * 2)) = - b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f4: \"\\<forall>r. - (- (r::real)) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r. - (- r) = r", "by simp"], ["proof (state)\nthis:\n  \\<forall>r. - (- r) = r\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f5: \"\\<forall>r ra. (ra::real) * - r = r * - ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. ra * - r = r * - ra", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra. ra * - r = r * - ra\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f6: \"a * ((A + B * sqrt C) * (inverse D * - 2)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) * (inverse D * - 2)) = b", "using f3"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) * (inverse D * 2)) = - b\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) * (inverse D * - 2)) = b", "by simp"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) * (inverse D * - 2)) = b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f7: \"\\<forall>r ra rb. (rb::real) * (ra * r) = r * (rb * ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra rb. rb * (ra * r) = r * (rb * ra)", "by auto"], ["proof (state)\nthis:\n  \\<forall>r ra rb. rb * (ra * r) = r * (rb * ra)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f8: \"\\<forall>r ra. - (ra::real) * r = ra * - r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. - ra * r = ra * - r", "by linarith"], ["proof (state)\nthis:\n  \\<forall>r ra. - ra * r = ra * - r\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>r ra. - ra * r = ra * - r", "have f9: \"a * (inverse D * ((A + B * sqrt C) * - 2)) = b\""], ["proof (prove)\nusing this:\n  \\<forall>r ra. - ra * r = ra * - r\n\ngoal (1 subgoal):\n 1. a * (inverse D * ((A + B * sqrt C) * - 2)) = b", "using f7 f6 f5"], ["proof (prove)\nusing this:\n  \\<forall>r ra. - ra * r = ra * - r\n  \\<forall>r ra rb. rb * (ra * r) = r * (rb * ra)\n  a * ((A + B * sqrt C) * (inverse D * - 2)) = b\n  \\<forall>r ra. ra * - r = r * - ra\n\ngoal (1 subgoal):\n 1. a * (inverse D * ((A + B * sqrt C) * - 2)) = b", "by presburger"], ["proof (state)\nthis:\n  a * (inverse D * ((A + B * sqrt C) * - 2)) = b\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have f10: \"rr \\<in> {inverse D * (A + B * sqrt C)<..y'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rr \\<in> {inverse D * (A + B * sqrt C)<..y'}", "using f4 f2"], ["proof (prove)\nusing this:\n  \\<forall>r. - (- r) = r\n  rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and>\n  \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c < 0\n\ngoal (1 subgoal):\n 1. rr \\<in> {inverse D * (A + B * sqrt C)<..y'}", "by (metis (no_types) divide_inverse mult.commute mult_minus_right)"], ["proof (state)\nthis:\n  rr \\<in> {inverse D * (A + B * sqrt C)<..y'}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "have \"\\<not> c + (rr * b + a * rr\\<^sup>2) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c + (rr * b + a * rr\\<^sup>2) < 0", "using f9 f8 f7 f2"], ["proof (prove)\nusing this:\n  a * (inverse D * ((A + B * sqrt C) * - 2)) = b\n  \\<forall>r ra. - ra * r = ra * - r\n  \\<forall>r ra rb. rb * (ra * r) = r * (rb * ra)\n  rr \\<in> {- (- (A + B * sqrt C) / D)<..y'} \\<and>\n  \\<not> a * rr\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * rr + c < 0\n\ngoal (1 subgoal):\n 1. \\<not> c + (rr * b + a * rr\\<^sup>2) < 0", "by (metis (no_types) add.commute divide_inverse mult.commute mult_minus_right)"], ["proof (state)\nthis:\n  \\<not> c + (rr * b + a * rr\\<^sup>2) < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n       \\<not> a * x\\<^sup>2 + 2 * a * (- (A + B * sqrt C) / D) * x + c\n              < 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> c + (rr * b + a * rr\\<^sup>2) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c + (rr * b + a * rr\\<^sup>2) < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "using f10"], ["proof (prove)\nusing this:\n  \\<not> c + (rr * b + a * rr\\<^sup>2) < 0\n  rr \\<in> {inverse D * (A + B * sqrt C)<..y'}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "by (metis (no_types) add.commute divide_inverse mult.commute)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case False"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq>\n  0", "have False1 : \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n    c \\<noteq>\n    0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case True"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (2 subgoals):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding LessUni fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni (a, b, c))) x", "apply (simp add: True1 True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using True1 True"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n     < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "let ?r = \"(A + B * sqrt C) / D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n     < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume \" 2 * a * (A + B * sqrt C) / D + b = 0\""], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n     < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0 \""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n     < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0", "have \" \\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0\""], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0", "using continuity_lem_lt0[where r= \"(A + B * sqrt C) / D\", where c = \"c\", where b = \"b\", where a=\"a\"]\n                quadratic_poly_eval[of c b a ?r]"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n  poly [:c, b, a:] ((A + B * sqrt C) / D) < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0\n  poly [:c, b, a:] ((A + B * sqrt C) / D) =\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * a * (A + B * sqrt C) / D + b = 0;\n     a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n     < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0", "show \"\\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using quadratic_poly_eval[of c b a]"], ["proof (prove)\nusing this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. poly [:c, b, a:] x < 0\n  poly [:c, b, a:] ?x = a * ?x\\<^sup>2 + b * ?x + c\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case False"], ["proof (state)\nthis:\n  \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n         < 0\n\ngoal (1 subgoal):\n 1. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n         < 0", "have False' : \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c > 0\""], ["proof (prove)\nusing this:\n  \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n         < 0\n\ngoal (1 subgoal):\n 1. 0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c", "using False1"], ["proof (prove)\nusing this:\n  \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n         < 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. 0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c", "by auto"], ["proof (state)\nthis:\n  0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n\ngoal (1 subgoal):\n 1. \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n           < 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding LessUni fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni (a, b, c))) x", "apply(simp add: True1 False False1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y'>(A + B * sqrt C) / D.\n       \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          \\<not> a * x\\<^sup>2 + b * x + c < 0", "using True1 False' continuity_lem_gt0_expanded[where a = \"a\", where b = \"b\",where c = \"c\", where r = \"((A + B * sqrt C) / D)\"]"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b = 0\n  0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n  \\<lbrakk>(A + B * sqrt C) / D < ?k;\n   0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) +\n       c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?k}.\n                       0 < a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. \\<forall>y'>(A + B * sqrt C) / D.\n       \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          \\<not> a * x\\<^sup>2 + b * x + c < 0", "by (metis mult_less_0_iff not_square_less_zero times_divide_eq_right)"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case False"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0", "have False1 : \"2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "have c1: \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0 \\<Longrightarrow>\n    2 * a * (A + B * sqrt C) / D + b < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume root: \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "assume blt: \" 2 * a * (A + B * sqrt C) / D + b < 0\""], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "let ?r = \"-(A + B * sqrt C) / D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have bltvar: \"b < 2 * a * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b < 2 * a * (- (A + B * sqrt C) / D)", "using blt divide_minus_left mult_2 mult_minus_right real_add_less_0_iff"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b < 0\n  - ?a / ?b = - (?a / ?b)\n  (2::?'a) * ?z = ?z + ?z\n  ?a * - ?b = - (?a * ?b)\n  (?x + ?y < 0) = (?y < - ?x)\n\ngoal (1 subgoal):\n 1. b < 2 * a * (- (A + B * sqrt C) / D)", "by (metis times_divide_eq_right)"], ["proof (state)\nthis:\n  b < 2 * a * (- (A + B * sqrt C) / D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have rootvar: \"a * ?r^2 - b * ?r + c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "using root"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "have f1: \"\\<forall>r ra. - (ra::real) * r = ra * - r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. - ra * r = ra * - r", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra. - ra * r = ra * - r\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "have f2: \"\\<forall>r ra. ((ra::real) * - r)\\<^sup>2 = (ra * r)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. (ra * - r)\\<^sup>2 = (ra * r)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra. (ra * - r)\\<^sup>2 = (ra * r)\\<^sup>2\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "have f3: \"a * (inverse D * (A - B * - sqrt C))\\<^sup>2 - inverse D * (b * - (A - B * - sqrt C)) - - c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n    inverse D * (b * - (A - B * - sqrt C)) -\n    - c =\n    0", "by (metis (no_types) diff_minus_eq_add divide_inverse mult.commute mult_minus_left root)"], ["proof (state)\nthis:\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  inverse D * (b * - (A - B * - sqrt C)) -\n  - c =\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "have f4: \"\\<forall>r ra rb. (rb::real) * (ra * r) = ra * (r * rb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra rb. rb * (ra * r) = ra * (r * rb)", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra rb. rb * (ra * r) = ra * (r * rb)\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "have \"\\<forall>r ra. (ra::real) * - r = r * - ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r ra. ra * - r = r * - ra", "by simp"], ["proof (state)\nthis:\n  \\<forall>r ra. ra * - r = r * - ra\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "then"], ["proof (chain)\npicking this:\n  \\<forall>r ra. ra * - r = r * - ra", "have \"a * (inverse D * (A - B * - sqrt C))\\<^sup>2 - b * (inverse D * - (A - B * - sqrt C)) - - c = 0\""], ["proof (prove)\nusing this:\n  \\<forall>r ra. ra * - r = r * - ra\n\ngoal (1 subgoal):\n 1. a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n    b * (inverse D * - (A - B * - sqrt C)) -\n    - c =\n    0", "using f4 f3 f1"], ["proof (prove)\nusing this:\n  \\<forall>r ra. ra * - r = r * - ra\n  \\<forall>r ra rb. rb * (ra * r) = ra * (r * rb)\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  inverse D * (b * - (A - B * - sqrt C)) -\n  - c =\n  0\n  \\<forall>r ra. - ra * r = ra * - r\n\ngoal (1 subgoal):\n 1. a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n    b * (inverse D * - (A - B * - sqrt C)) -\n    - c =\n    0", "by (metis (no_types))"], ["proof (state)\nthis:\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "then"], ["proof (chain)\npicking this:\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0", "have \"a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 - b * (inverse D * - (A - B * - sqrt C)) - - c = 0\""], ["proof (prove)\nusing this:\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0\n\ngoal (1 subgoal):\n 1. a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 -\n    b * (inverse D * - (A - B * - sqrt C)) -\n    - c =\n    0", "using f2"], ["proof (prove)\nusing this:\n  a * (inverse D * (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0\n  \\<forall>r ra. (ra * - r)\\<^sup>2 = (ra * r)\\<^sup>2\n\ngoal (1 subgoal):\n 1. a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 -\n    b * (inverse D * - (A - B * - sqrt C)) -\n    - c =\n    0", "by presburger"], ["proof (state)\nthis:\n  a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n    0 \\<Longrightarrow>\n    a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "then"], ["proof (chain)\npicking this:\n  a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * (inverse D * - (A - B * - sqrt C))\\<^sup>2 -\n  b * (inverse D * - (A - B * - sqrt C)) -\n  - c =\n  0\n\ngoal (1 subgoal):\n 1. a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) +\n    c =\n    0", "by (simp add: divide_inverse mult.commute)"], ["proof (state)\nthis:\n  a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) + c =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) + c =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "have \"\\<exists>y'> ((A + B * sqrt C) / D). \\<forall>x\\<in>{((A + B * sqrt C) / D)<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using rootvar bltvar case_d1[where a= \"a\", where b = \"b\", where c = \"c\", where r = ?r]"], ["proof (prove)\nusing this:\n  a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) + c =\n  0\n  b < 2 * a * (- (A + B * sqrt C) / D)\n  \\<lbrakk>b < 2 * a * (- (A + B * sqrt C) / D);\n   a * (- (A + B * sqrt C) / D)\\<^sup>2 - b * (- (A + B * sqrt C) / D) + c =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>- (- (A + B * sqrt C) / D).\n                       \\<forall>x\\<in>{- (- (A + B * sqrt C) / D)<..y'}.\n                          a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by (metis add.inverse_inverse divide_inverse mult_minus_left)"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c =\n             0;\n     2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                         \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c =\n           0;\n   2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                          a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "have c2: \" \\<And>y'. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0 \\<Longrightarrow>\n          \\<not> 2 * a * (A + B * sqrt C) / D + b < 0 \\<Longrightarrow>\n          (A + B * sqrt C) / D < y' \\<Longrightarrow>\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "let ?r = \"(A + B * sqrt C) / D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "fix y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume h1: \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume h2: \"\\<not> 2 * a * (A + B * sqrt C) / D + b < 0\""], ["proof (state)\nthis:\n  \\<not> 2 * a * (A + B * sqrt C) / D + b < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "assume h3: \" (A + B * sqrt C) / D < y'\""], ["proof (state)\nthis:\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have eq: \"2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "using False1"], ["proof (prove)\nusing this:\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "by blast"], ["proof (state)\nthis:\n  2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "have \"2 * a * (A + B * sqrt C) / D + b > 0 \\<Longrightarrow> \\<exists>x\\<in>{?r<..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "using case_d4[where a = \"a\", where b = \"b\", where c= \"c\", where r = \"-?r\"] h1 h2 h3"], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<noteq> 2 * a * - ((A + B * sqrt C) / D);\n   \\<not> b < 2 * a * - ((A + B * sqrt C) / D);\n   a * (- ((A + B * sqrt C) / D))\\<^sup>2 - b * - ((A + B * sqrt C) / D) +\n   c =\n   0;\n   - (- ((A + B * sqrt C) / D)) < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{- (- ((A + B * sqrt C) / D))<..?y'}.\n                       \\<not> a * x\\<^sup>2 + b * x + c < 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c = 0\n  \\<not> 2 * a * (A + B * sqrt C) / D + b < 0\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. 0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n    \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "by auto"], ["proof (state)\nthis:\n  0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c =\n                0;\n        \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0", "show \"\\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "using h2 eq"], ["proof (prove)\nusing this:\n  0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n  \\<not> 2 * a * (A + B * sqrt C) / D + b < 0\n  2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "using False1"], ["proof (prove)\nusing this:\n  0 < 2 * a * (A + B * sqrt C) / D + b \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n  \\<not> 2 * a * (A + B * sqrt C) / D + b < 0\n  2 * a * (A + B * sqrt C) / D + b = 0 \\<Longrightarrow>\n  \\<exists>x\\<in>{(A + B * sqrt C) / D..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n  2 * a * (A + B * sqrt C) / D + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       \\<not> a * x\\<^sup>2 + b * x + c < 0", "by linarith"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c =\n           0;\n   \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n   (A + B * sqrt C) / D < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n                       \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "have c3: \"((a::real) * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0) \\<longrightarrow>\n    (\\<exists>y'>((A + B * sqrt C) / D). \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           a * x\\<^sup>2 + b * x + c < 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "assume assump: \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0 \""], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "have \"a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_lt0_expanded[where a= \"a\", where b = \"b\", where c = \"c\", where r = \"((A + B * sqrt C) / D)::real\"]"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n  < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by auto"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n  < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n  < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0", "have \"\\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n  < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using assump"], ["proof (prove)\nusing this:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) + c\n  < 0 \\<Longrightarrow>\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0", "obtain y where y_prop: \"y >(A + B * sqrt C) / D \\<and> (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\""], ["proof (prove)\nusing this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (A + B * sqrt C) / D < y \\<and>\n        (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}.\n            a * x\\<^sup>2 + b * x + c < 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)", "have h: \"\\<exists> k. k >(A + B * sqrt C) / D \\<and> k < y\""], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\n\ngoal (1 subgoal):\n 1. \\<exists>k>(A + B * sqrt C) / D. k < y", "using dense"], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\n  ?x < ?y \\<Longrightarrow> \\<exists>z>?x. z < ?y\n\ngoal (1 subgoal):\n 1. \\<exists>k>(A + B * sqrt C) / D. k < y", "by blast"], ["proof (state)\nthis:\n  \\<exists>k>(A + B * sqrt C) / D. k < y\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>k>(A + B * sqrt C) / D. k < y", "obtain k where k_prop: \"k >(A + B * sqrt C) / D  \\<and> k < y\""], ["proof (prove)\nusing this:\n  \\<exists>k>(A + B * sqrt C) / D. k < y\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (A + B * sqrt C) / D < k \\<and> k < y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A + B * sqrt C) / D < k \\<and> k < y\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  (A + B * sqrt C) / D < k \\<and> k < y", "have \"\\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < k \\<and> k < y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0", "using y_prop"], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < k \\<and> k < y\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0", "using assump"], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < k \\<and> k < y\n  (A + B * sqrt C) / D < y \\<and>\n  (\\<forall>x\\<in>{(A + B * sqrt C) / D<..y}. a * x\\<^sup>2 + b * x + c < 0)\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n    < 0 \\<Longrightarrow>\n    \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0", "show \"\\<exists>y'>((A + B * sqrt C) / D::real). \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "using k_prop"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{(A + B * sqrt C) / D..k}. a * x\\<^sup>2 + b * x + c < 0\n  (A + B * sqrt C) / D < k \\<and> k < y\n\ngoal (1 subgoal):\n 1. \\<exists>y'>(A + B * sqrt C) / D.\n       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n          a * x\\<^sup>2 + b * x + c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        a * x\\<^sup>2 + b * x + c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n  < 0 \\<longrightarrow>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         a * x\\<^sup>2 + b * x + c < 0)\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "have c4: \"\\<And>y'. a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c \\<noteq> 0 \\<Longrightarrow>\n          \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c < 0 \\<Longrightarrow>\n          (A + B * sqrt C) / D < y' \\<Longrightarrow>\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}. \\<not> a * x\\<^sup>2 + b * x + c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c \\<noteq>\n                0;\n        \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 +\n               b * (A + B * sqrt C) / D +\n               c\n               < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "using continuity_lem_gt0_expanded[where a= \"a\", where b = \"b\", where c = \"c\", where r= \"(A + B * sqrt C) / D\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(A + B * sqrt C) / D < ?k;\n   0 < a * ((A + B * sqrt C) / D)\\<^sup>2 + b * ((A + B * sqrt C) / D) +\n       c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?k}.\n                       0 < a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 +\n                b * (A + B * sqrt C) / D +\n                c \\<noteq>\n                0;\n        \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 +\n               b * (A + B * sqrt C) / D +\n               c\n               < 0;\n        (A + B * sqrt C) / D < y'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                            \\<not> a * x\\<^sup>2 + b * x + c < 0", "by (metis Groups.mult_ac(1) divide_inverse less_eq_real_def linorder_not_le)"], ["proof (state)\nthis:\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c \\<noteq>\n           0;\n   \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n          < 0;\n   (A + B * sqrt C) / D < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n                       \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. 2 * a * (A + B * sqrt C) / D + b \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding LessUni fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni (a, b, c))) x", "apply(simp add: False1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n     0 \\<longrightarrow>\n     (2 * a * (A + B * sqrt C) / D + b < 0 \\<longrightarrow>\n      (\\<exists>y'>(A + B * sqrt C) / D.\n          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<not> 2 * a * (A + B * sqrt C) / D + b < 0 \\<longrightarrow>\n      (\\<forall>y'>(A + B * sqrt C) / D.\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             \\<not> a * x\\<^sup>2 + b * x + c < 0))) \\<and>\n    (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n     c \\<noteq>\n     0 \\<longrightarrow>\n     (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n      < 0 \\<longrightarrow>\n      (\\<exists>y'>(A + B * sqrt C) / D.\n          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c\n             < 0 \\<longrightarrow>\n      (\\<forall>y'>(A + B * sqrt C) / D.\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             \\<not> a * x\\<^sup>2 + b * x + c < 0)))", "using c1 c2 c3 c4"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c =\n           0;\n   2 * a * (A + B * sqrt C) / D + b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'>(A + B * sqrt C) / D.\n                       \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                          a * x\\<^sup>2 + b * x + c < 0\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c =\n           0;\n   \\<not> 2 * a * (A + B * sqrt C) / D + b < 0;\n   (A + B * sqrt C) / D < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n                       \\<not> a * x\\<^sup>2 + b * x + c < 0\n  a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n  < 0 \\<longrightarrow>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         a * x\\<^sup>2 + b * x + c < 0)\n  \\<lbrakk>a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n           c \\<noteq>\n           0;\n   \\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n          < 0;\n   (A + B * sqrt C) / D < ?y'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n                       \\<not> a * x\\<^sup>2 + b * x + c < 0\n\ngoal (1 subgoal):\n 1. (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c =\n     0 \\<longrightarrow>\n     (2 * a * (A + B * sqrt C) / D + b < 0 \\<longrightarrow>\n      (\\<exists>y'>(A + B * sqrt C) / D.\n          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<not> 2 * a * (A + B * sqrt C) / D + b < 0 \\<longrightarrow>\n      (\\<forall>y'>(A + B * sqrt C) / D.\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             \\<not> a * x\\<^sup>2 + b * x + c < 0))) \\<and>\n    (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n     c \\<noteq>\n     0 \\<longrightarrow>\n     (a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D + c\n      < 0 \\<longrightarrow>\n      (\\<exists>y'>(A + B * sqrt C) / D.\n          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             a * x\\<^sup>2 + b * x + c < 0)) \\<and>\n     (\\<not> a * ((A + B * sqrt C) / D)\\<^sup>2 + b * (A + B * sqrt C) / D +\n             c\n             < 0 \\<longrightarrow>\n      (\\<forall>y'>(A + B * sqrt C) / D.\n          \\<exists>x\\<in>{(A + B * sqrt C) / D<..y'}.\n             \\<not> a * x\\<^sup>2 + b * x + c < 0)))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case False"], ["proof (state)\nthis:\n  At \\<noteq> LessUni p\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At \\<noteq> LessUni p", "have EqUni: \"At = EqUni p\""], ["proof (prove)\nusing this:\n  At \\<noteq> LessUni p\n\ngoal (1 subgoal):\n 1. At = EqUni p", "using at_is"], ["proof (prove)\nusing this:\n  At \\<noteq> LessUni p\n  At = LessUni p \\<or> At = EqUni p\n\ngoal (1 subgoal):\n 1. At = EqUni p", "by auto"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. At \\<noteq> LessUni p \\<Longrightarrow>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have \" \\<And>y'. (A + B * sqrt C) / D < y' \\<Longrightarrow>\n          \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow> (a = 0 \\<and> b = 0 \\<and> c = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>(A + B * sqrt C) / D < y';\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>(A + B * sqrt C) / D < y';\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0", "fix y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>(A + B * sqrt C) / D < y';\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0", "assume \"(A + B * sqrt C) / D < y'\""], ["proof (state)\nthis:\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>(A + B * sqrt C) / D < y';\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n       \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0", "then"], ["proof (chain)\npicking this:\n  (A + B * sqrt C) / D < y'", "show \" \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow> (a = 0 \\<and> b = 0 \\<and> c = 0)\""], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < y'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n    a = 0 \\<and> b = 0 \\<and> c = 0", "using assms continuity_lem_eq0[where r = \"(A + B * sqrt C) / D\", where p = \"y'\", where a= \"a\", where b =\"b\", where c=\"c\"]"], ["proof (prove)\nusing this:\n  (A + B * sqrt C) / D < y'\n  At = LessUni p \\<or> At = EqUni p\n  D \\<noteq> 0\n  0 \\<le> C\n  \\<lbrakk>(A + B * sqrt C) / D < y';\n   \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n      a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n  \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n       a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n    a = 0 \\<and> b = 0 \\<and> c = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n     a * x\\<^sup>2 + b * x + c = 0 \\<Longrightarrow>\n  a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(A + B * sqrt C) / D < ?y';\n   \\<forall>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n      a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n  \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = EqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(A + B * sqrt C) / D < ?y';\n   \\<forall>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n      a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n  \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(A + B * sqrt C) / D < ?y';\n   \\<forall>x\\<in>{(A + B * sqrt C) / D<..?y'}.\n      a * x\\<^sup>2 + b * x + c = 0\\<rbrakk>\n  \\<Longrightarrow> a = 0 \\<and> b = 0 \\<and> c = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "apply (auto simp add:EqUni fields )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> Ex ((<) ((A + B * sqrt C) / D))", "using linordered_field_no_ub"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. x < y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0; c = 0; b = 0\\<rbrakk>\n    \\<Longrightarrow> Ex ((<) ((A + B * sqrt C) / D))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinitesimal_quad:\n  fixes A B C D:: \"real\"\n  assumes \"D\\<noteq>0\"\n  assumes \"C\\<ge>0\"\n  shows \"(\\<exists>y'::real>((A+B * sqrt(C))/(D)). \\<forall>x::real \\<in>{((A+B * sqrt(C))/(D))<..y'}. aEvalUni At x)\n      = (evalUni (substInfinitesimalQuadraticUni A B C D At) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case (LessUni p)"], ["proof (state)\nthis:\n  At = LessUni p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = LessUni x1 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 3. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 4. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = LessUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LessUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using infinitesimal_quad_helper assms"], ["proof (prove)\nusing this:\n  At = LessUni p\n  \\<lbrakk>?At = LessUni ?p \\<or> ?At = EqUni ?p; ?D \\<noteq> 0;\n   0 \\<le> ?C\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(?A + ?B * sqrt ?C) / ?D.\n                        \\<forall>x\\<in>{(?A + ?B * sqrt ?C) / ?D<..y'}.\n                           aEvalUni ?At x) =\n                    evalUni (substInfinitesimalQuadraticUni ?A ?B ?C ?D ?At)\n                     ?x\n  D \\<noteq> 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case (EqUni p)"], ["proof (state)\nthis:\n  At = EqUni p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = EqUni x2 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 3. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = EqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = EqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using infinitesimal_quad_helper assms"], ["proof (prove)\nusing this:\n  At = EqUni p\n  \\<lbrakk>?At = LessUni ?p \\<or> ?At = EqUni ?p; ?D \\<noteq> 0;\n   0 \\<le> ?C\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(?A + ?B * sqrt ?C) / ?D.\n                        \\<forall>x\\<in>{(?A + ?B * sqrt ?C) / ?D<..y'}.\n                           aEvalUni ?At x) =\n                    evalUni (substInfinitesimalQuadraticUni ?A ?B ?C ?D ?At)\n                     ?x\n  D \\<noteq> 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case (LeqUni p)"], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = LeqUni x3 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\n 2. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = LeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof (cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have same: \"\\<forall>x. aEvalUni (LeqUni p) x = (aEvalUni (EqUni p) x) \\<or> (aEvalUni (LessUni p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n       aEvalUni (LessUni p) x", "apply (simp add: fields)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (a * x\\<^sup>2 + b * x + c \\<le> 0) =\n       (a * x\\<^sup>2 + b * x + c = 0) \\<or>\n       a * x\\<^sup>2 + b * x + c < 0", "by force"], ["proof (state)\nthis:\n  \\<forall>x.\n     aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n     aEvalUni (LessUni p) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "let ?r = \"(A + B * sqrt C) / D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have \"\\<And>a b c.\n       At = LeqUni p \\<Longrightarrow>\n       p = (a, b, c) \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D. \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "assume atis: \"At = LeqUni p\""], ["proof (state)\nthis:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "assume p_is: \" p = (a, b, c)\""], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have s1: \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. aEvalUni At x) = (\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}.  (aEvalUni (EqUni p) x) \\<or> (aEvalUni (LessUni p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)", "using atis same aEvalUni.simps(2) aEvalUni.simps(3) fields less_eq_real_def"], ["proof (prove)\nusing this:\n  At = LeqUni p\n  \\<forall>x.\n     aEvalUni (LeqUni p) x = aEvalUni (EqUni p) x \\<or>\n     aEvalUni (LessUni p) x\n  aEvalUni (LessUni (?a, ?b, ?c)) ?x = (?a * ?x\\<^sup>2 + ?b * ?x + ?c < 0)\n  aEvalUni (LeqUni (?a, ?b, ?c)) ?x =\n  (?a * ?x\\<^sup>2 + ?b * ?x + ?c \\<le> 0)\n  p = (a__, b__, c__)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have s2: \"... = (\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}.  (aEvalUni (EqUni p) x)) \\<or> (\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. (aEvalUni (LessUni p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x) \\<or>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x)", "using either_or[where r = \"?r\"] p_is"], ["proof (prove)\nusing this:\n  \\<exists>y'>(A + B * sqrt C) / D.\n     \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n        aEvalUni (EqUni (?a, ?b, ?c)) x \\<or>\n        aEvalUni (LessUni (?a, ?b, ?c)) x \\<Longrightarrow>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni (?a, ?b, ?c)) x) \\<or>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (LessUni (?a, ?b, ?c)) x)\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (EqUni p) x) \\<or>\n    (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x) \\<or>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have eq1: \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}.  (aEvalUni (EqUni p) x)) =  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (EqUni p) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x", "using infinitesimal_quad_helper[where At = \"EqUni p\", where p = \"p\", where B = \"B\", where C= \"C\", where A= \"A\", where D=\"D\"] \n          assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>EqUni p = LessUni p \\<or> EqUni p = EqUni p; D \\<noteq> 0;\n   0 \\<le> C\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni (EqUni p) x) =\n                    evalUni\n                     (substInfinitesimalQuadraticUni A B C D (EqUni p)) ?x\n  D \\<noteq> 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (EqUni p) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (EqUni p) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have eq2: \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}.  (aEvalUni (LessUni p) x)) =  (evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni p) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x", "using infinitesimal_quad_helper[where At = \"LessUni p\", where p = \"p\", where B = \"B\", where C= \"C\", where A= \"A\", where D=\"D\"] \n          assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>LessUni p = LessUni p \\<or> LessUni p = EqUni p; D \\<noteq> 0;\n   0 \\<le> C\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni (LessUni p) x) =\n                    evalUni\n                     (substInfinitesimalQuadraticUni A B C D (LessUni p)) ?x\n  D \\<noteq> 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (LessUni p) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have z1: \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. aEvalUni At x) = ((evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x) \\<or> (evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)", "using s1 s2 eq1 eq2"], ["proof (prove)\nusing this:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x)\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x \\<or> aEvalUni (LessUni p) x) =\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n         aEvalUni (EqUni p) x) \\<or>\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x)\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (EqUni p) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni (LessUni p) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have z2: \"(evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x) \\<or> (evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) = evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have z3: \"(evalUni (substInfinitesimalQuadraticUni A B C D At) x) = evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x", "using LeqUni"], ["proof (prove)\nusing this:\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n    evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x", "have z4: \"(evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x) \\<or> (evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) = (evalUni (substInfinitesimalQuadraticUni A B C D At) x) \""], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using z2 z3"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D (LeqUni p)) x\n\ngoal (1 subgoal):\n 1. evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n    evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by auto"], ["proof (state)\nthis:\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "let ?a = \"(evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x) \\<or> (evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "let ?b = \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. aEvalUni At x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "let ?c = \"(evalUni (substInfinitesimalQuadraticUni A B C D At) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have t1: \"?b = ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)", "using z1"], ["proof (prove)\nusing this:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "have t2: \"?a = ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using z4"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using atis"], ["proof (prove)\nusing this:\n  evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n  evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n  At = LeqUni p\n\ngoal (1 subgoal):\n 1. (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n     evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by auto"], ["proof (state)\nthis:\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x", "have \"?b = ?c\""], ["proof (prove)\nusing this:\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using t1 t2"], ["proof (prove)\nusing this:\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x)\n  (evalUni (substInfinitesimalQuadraticUni A B C D (EqUni p)) x \\<or>\n   evalUni (substInfinitesimalQuadraticUni A B C D (LessUni p)) x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show \"(\\<exists>y'>?r. \\<forall>x\\<in>{?r<..y'}. aEvalUni At x) = evalUni (substInfinitesimalQuadraticUni A B C D At) x\""], ["proof (prove)\nusing this:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni At x) =\n                    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = LeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni At x) =\n                    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni At x) =\n                    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "using LeqUni fields"], ["proof (prove)\nusing this:\n  \\<lbrakk>At = LeqUni p; p = (?a, ?b, ?c)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                           aEvalUni At x) =\n                    evalUni (substInfinitesimalQuadraticUni A B C D At) x\n  At = LeqUni p\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "by blast"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "case (NeqUni p)"], ["proof (state)\nthis:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = NeqUni x4 \\<Longrightarrow>\n       (\\<exists>y'>(A + B * sqrt C) / D.\n           \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n       evalUni (substInfinitesimalQuadraticUni A B C D At) x", "then"], ["proof (chain)\npicking this:\n  At = NeqUni p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = NeqUni p\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "proof (cases p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "case (fields a b c)"], ["proof (state)\nthis:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>At = NeqUni p; p = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y'>(A + B * sqrt C) / D.\n                             \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n                                aEvalUni At x) =\n                         evalUni (substInfinitesimalQuadraticUni A B C D At)\n                          x", "then"], ["proof (chain)\npicking this:\n  p = (a, b, c)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D At) x", "unfolding NeqUni fields"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (NeqUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (NeqUni (a, b, c))) x", "using nonzcoeffs"], ["proof (prove)\nusing this:\n  (a, b, c) = (a, b, c)\n  ?a \\<noteq> 0 \\<or> ?b \\<noteq> 0 \\<or> ?c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>y'>?r.\n     \\<forall>x\\<in>{?r<..y'}. ?a * x\\<^sup>2 + ?b * x + ?c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>y'>(A + B * sqrt C) / D.\n        \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}.\n           aEvalUni (NeqUni (a, b, c)) x) =\n    evalUni (substInfinitesimalQuadraticUni A B C D (NeqUni (a, b, c))) x", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>y'>(A + B * sqrt C) / D.\n      \\<forall>x\\<in>{(A + B * sqrt C) / D<..y'}. aEvalUni At x) =\n  evalUni (substInfinitesimalQuadraticUni A B C D At) x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}