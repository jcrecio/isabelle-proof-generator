{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/UniAtoms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma convert_atom_change :\n  assumes \"length xs' = var\"\n  shows \"convert_atom var At (xs' @ x # \\<Gamma>) = convert_atom var At (xs' @ x' # \\<Gamma>)\"", "lemma degree_convert_eq : \n  assumes \"convert_poly var p xs = Some(a)\"\n  shows \"MPoly_Type.degree p var < 3\"", "lemma poly_to_univar :\n  assumes \"MPoly_Type.degree p var < 3\"\n  assumes \"get_coeffs var p = (A,B,C)\"\n  assumes \"a = insertion (nth_default 0 (xs'@y#xs)) A\"\n  assumes \"b = insertion (nth_default 0 (xs'@y#xs)) B\"\n  assumes \"c = insertion (nth_default 0 (xs'@y#xs)) C\"\n  assumes \"length xs' = var\"\n  shows \"insertion (nth_default 0 (xs'@x#xs)) p = (a*x^2)+(b*x)+c\"", "lemma \"aEval_aEvalUni\":\n  assumes \"convert_atom var a (xs'@x#xs) = Some a'\"\n  assumes \"length xs' = var\"\n  shows \"aEval a (xs'@x#xs) = aEvalUni a' x\"", "lemma \"eval_evalUni\":\n  assumes \"convert_fm var F (xs'@x#xs) = Some F'\"\n  assumes \"length xs' = var\"\n  shows \"eval F (xs'@x#xs) = evalUni F' x\"", "lemma nil_grab : \"(grab_atoms var F = Some []) \\<Longrightarrow> (freeIn var F)\"", "lemma \"grab_atoms_convert\" : \"(isSome (grab_atoms var F)) = (isSome (convert_fm var F xs))\"", "lemma convert_aNeg :\n  assumes \"convert_atom var A (xs'@x#xs) = Some(A')\"\n  assumes \"length xs' = var\"\n  shows \"aEval (aNeg A) (xs'@x#xs) = aEvalUni (aNegUni A') x\"", "lemma convert_neg : \n  assumes \"convert_fm var F (xs'@x#xs) = Some(F')\"\n  assumes \"length xs' = var\"\n  shows \"eval (Neg F) (xs'@x#xs) = evalUni (negUni F') x\"", "lemma eval_list_disj_Uni : \"evalUni (list_disj_Uni L) x = (\\<exists>l\\<in>set(L). evalUni l x)\"", "lemma eval_list_conj_Uni : \"evalUni (list_conj_Uni A) x = (\\<forall>l\\<in>set A. evalUni l x)\"", "lemma eval_list_conj_Uni_append : \"evalUni (list_conj_Uni (A @ B)) x = (evalUni (list_conj_Uni (A)) x \\<and> evalUni (list_conj_Uni (B)) x)\"", "lemma liftatom_map_atom : \n  assumes \"\\<exists>F'. convert_fm var F xs = Some F'\"\n  shows \"liftmap f F 0 = map_atom (f 0) F\"", "lemma eval_map : \"(\\<exists>l\\<in>set(map f L). evalUni l x) = (\\<exists>l\\<in>set(L). evalUni (f l) x)\"", "lemma eval_map_all : \"(\\<forall>l\\<in>set(map f L). evalUni l x) = (\\<forall>l\\<in>set(L). evalUni (f l) x)\"", "lemma eval_append : \"(\\<exists>l\\<in>set (A#B).evalUni l x) = (evalUni A x \\<or> (\\<exists>l\\<in>set (B).evalUni l x))\"", "lemma eval_conj_atom : \"evalUni (list_conj_Uni (map AtomUni L)) x = (\\<forall>l\\<in>set(L). aEvalUni l x)\""], "translations": [["", "lemma convert_atom_change :\n  assumes \"length xs' = var\"\n  shows \"convert_atom var At (xs' @ x # \\<Gamma>) = convert_atom var At (xs' @ x' # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_atom var At (xs' @ x # \\<Gamma>) =\n    convert_atom var At (xs' @ x' # \\<Gamma>)", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)", "using assms"], ["proof (prove)\nusing this:\n  length xs' = var\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       convert_atom var At (xs' @ x # \\<Gamma>) =\n       convert_atom var At (xs' @ x' # \\<Gamma>)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>At = Less x1; length xs' = var\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree x1 var < 3 \\<longrightarrow>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x1 var 2) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x1 var 2) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x1 var (Suc 0)) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x1 var (Suc 0)) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x1 var 0) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x1 var 0)\n 2. \\<And>x2.\n       \\<lbrakk>At = Eq x2; length xs' = var\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree x2 var < 3 \\<longrightarrow>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x2 var 2) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x2 var 2) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x2 var (Suc 0)) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x2 var (Suc 0)) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x2 var 0) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x2 var 0)\n 3. \\<And>x3.\n       \\<lbrakk>At = Leq x3; length xs' = var\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree x3 var < 3 \\<longrightarrow>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x3 var 2) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x3 var 2) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x3 var (Suc 0)) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x3 var (Suc 0)) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x3 var 0) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x3 var 0)\n 4. \\<And>x4.\n       \\<lbrakk>At = Neq x4; length xs' = var\\<rbrakk>\n       \\<Longrightarrow> MPoly_Type.degree x4 var < 3 \\<longrightarrow>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x4 var 2) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x4 var 2) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x4 var (Suc 0)) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x4 var (Suc 0)) \\<and>\n                         insertion (nth_default 0 (xs' @ x # \\<Gamma>))\n                          (isolate_variable_sparse x4 var 0) =\n                         insertion (nth_default 0 (xs' @ x' # \\<Gamma>))\n                          (isolate_variable_sparse x4 var 0)", "by (metis insertion_lowerPoly1 not_in_isovarspar)+"], ["", "lemma degree_convert_eq : \n  assumes \"convert_poly var p xs = Some(a)\"\n  shows \"MPoly_Type.degree p var < 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "using assms"], ["proof (prove)\nusing this:\n  convert_poly var p xs = Some a\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var < 3", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>convert_poly var p xs = Some a;\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3\n 2. \\<lbrakk>convert_poly var p xs = Some a;\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.degree p var < 3", "by auto"], ["", "lemma poly_to_univar :\n  assumes \"MPoly_Type.degree p var < 3\"\n  assumes \"get_coeffs var p = (A,B,C)\"\n  assumes \"a = insertion (nth_default 0 (xs'@y#xs)) A\"\n  assumes \"b = insertion (nth_default 0 (xs'@y#xs)) B\"\n  assumes \"c = insertion (nth_default 0 (xs'@y#xs)) C\"\n  assumes \"length xs' = var\"\n  shows \"insertion (nth_default 0 (xs'@x#xs)) p = (a*x^2)+(b*x)+c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have ha: \"\\<And>x. a = insertion (nth_default 0 (xs'@x # xs)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. a = insertion (nth_default 0 (xs' @ x # xs)) A", "using assms(2)"], ["proof (prove)\nusing this:\n  get_coeffs var p = (A, B, C)\n\ngoal (1 subgoal):\n 1. \\<And>x. a = insertion (nth_default 0 (xs' @ x # xs)) A", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = isolate_variable_sparse p var 2;\n        B = isolate_variable_sparse p var (Suc 0);\n        C = isolate_variable_sparse p var 0\\<rbrakk>\n       \\<Longrightarrow> a =\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 2)", "by (metis assms(3) assms(6) insertion_lowerPoly1 not_in_isovarspar)"], ["proof (state)\nthis:\n  a = insertion (nth_default 0 (xs' @ ?x # xs)) A\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have hb: \"\\<And>x. b = insertion (nth_default 0 (xs'@x # xs)) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. b = insertion (nth_default 0 (xs' @ x # xs)) B", "using assms(2)"], ["proof (prove)\nusing this:\n  get_coeffs var p = (A, B, C)\n\ngoal (1 subgoal):\n 1. \\<And>x. b = insertion (nth_default 0 (xs' @ x # xs)) B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = isolate_variable_sparse p var 2;\n        B = isolate_variable_sparse p var (Suc 0);\n        C = isolate_variable_sparse p var 0\\<rbrakk>\n       \\<Longrightarrow> b =\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var (Suc 0))", "by (metis assms(4) assms(6) insertion_lowerPoly1 not_in_isovarspar)"], ["proof (state)\nthis:\n  b = insertion (nth_default 0 (xs' @ ?x # xs)) B\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have hc: \"\\<And>x. c = insertion (nth_default 0 (xs'@x # xs)) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. c = insertion (nth_default 0 (xs' @ x # xs)) C", "using assms(2)"], ["proof (prove)\nusing this:\n  get_coeffs var p = (A, B, C)\n\ngoal (1 subgoal):\n 1. \\<And>x. c = insertion (nth_default 0 (xs' @ x # xs)) C", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A = isolate_variable_sparse p var 2;\n        B = isolate_variable_sparse p var (Suc 0);\n        C = isolate_variable_sparse p var 0\\<rbrakk>\n       \\<Longrightarrow> c =\n                         insertion (nth_default 0 (xs' @ x # xs))\n                          (isolate_variable_sparse p var 0)", "by (metis assms(5) assms(6) insertion_lowerPoly1 not_in_isovarspar)"], ["proof (state)\nthis:\n  c = insertion (nth_default 0 (xs' @ ?x # xs)) C\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "proof(cases \"MPoly_Type.degree p var = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have h1 : \"var < length (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "using assms ha hb hc sum_over_degree_insertion[OF h1 True, of y]"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n  a = insertion (nth_default 0 (xs' @ ?x # xs)) A\n  b = insertion (nth_default 0 (xs' @ ?x # xs)) B\n  c = insertion (nth_default 0 (xs' @ ?x # xs)) C\n  (\\<Sum>i = 0..<0 + 1.\n      insertion (nth_default 0 ((xs' @ x # xs)[var := y]))\n       (isolate_variable_sparse p var i) *\n      y ^ i) =\n  insertion (nth_default 0 ((xs' @ x # xs)[var := y])) p\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "apply(simp add: isovar_greater_degree[of p ] True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A = 0 \\<and> B = 0 \\<and> isolate_variable_sparse p var 0 = C;\n     a = 0; b = 0; length xs' = var;\n     \\<And>x. c = insertion (nth_default 0 (xs' @ x # xs)) C;\n     insertion (nth_default 0 ((xs' @ x # xs)[var := y])) C =\n     insertion (nth_default 0 ((xs' @ x # xs)[var := y])) p\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p = c", "using True degree0isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 0\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A = 0 \\<and> B = 0 \\<and> isolate_variable_sparse p var 0 = C;\n     a = 0; b = 0; length xs' = var;\n     \\<And>x. c = insertion (nth_default 0 (xs' @ x # xs)) C;\n     insertion (nth_default 0 ((xs' @ x # xs)[var := y])) C =\n     insertion (nth_default 0 ((xs' @ x # xs)[var := y])) p\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs)) p = c", "by force"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 0", "have notzero : \"MPoly_Type.degree p var \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 0 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "proof(cases \"MPoly_Type.degree p var = 1\" )"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have h1 : \"var < length (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "using  sum_over_degree_insertion[OF h1 True, of x,  symmetric]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p =\n  (\\<Sum>i = 0..<1 + 1.\n      insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n       (isolate_variable_sparse p var i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "unfolding assms(6)[symmetric] list_update_length"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) p =\n  (\\<Sum>i = 0..<1 + 1.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "unfolding assms(6)"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) p =\n  (\\<Sum>i = 0..<1 + 1.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x =\n    a * x\\<^sup>2 + b * x + c", "using ha hb hc assms"], ["proof (prove)\nusing this:\n  a = insertion (nth_default 0 (xs' @ ?x # xs)) A\n  b = insertion (nth_default 0 (xs' @ ?x # xs)) B\n  c = insertion (nth_default 0 (xs' @ ?x # xs)) C\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x =\n    a * x\\<^sup>2 + b * x + c", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') 0) +\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') (Suc 0)) *\n             x;\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 2) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 2);\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0)) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0));\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 0) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 0);\n     MPoly_Type.degree p (length xs') < 3;\n     a =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 0);\n     var = length xs'; A = isolate_variable_sparse p (length xs') 2;\n     B = isolate_variable_sparse p (length xs') (Suc 0);\n     C = isolate_variable_sparse p (length xs') 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') 0) +\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x =\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 2) *\n                      x\\<^sup>2 +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 0)", "by (smt (verit, ccfv_threshold) One_nat_def True express_poly h1 insertion_add insertion_mult insertion_pow insertion_var list_update_length)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have deg2 : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using notzero assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var \\<noteq> 0\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have h1 : \"var < length (xs'@x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. var < length (xs' @ x # xs)", "by auto"], ["proof (state)\nthis:\n  var < length (xs' @ x # xs)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "have two : \"2 = Suc(Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by auto"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "using  sum_over_degree_insertion[OF h1 deg2, of x,  symmetric]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 ((xs' @ x # xs)[var := x])) p =\n  (\\<Sum>i = 0..<2 + 1.\n      insertion (nth_default 0 ((xs' @ x # xs)[var := x]))\n       (isolate_variable_sparse p var i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "unfolding assms(6)[symmetric] list_update_length"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) p =\n  (\\<Sum>i = 0..<2 + 1.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p (length xs') i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c", "unfolding assms(6) two"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 (xs' @ x # xs)) p =\n  (\\<Sum>i = 0..<Suc (Suc 0) + 1.\n      insertion (nth_default 0 (xs' @ x # xs))\n       (isolate_variable_sparse p var i) *\n      x ^ i)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p =\n    a * x ^ Suc (Suc 0) + b * x + c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    (x * x) \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    (x * x) =\n    a * (x * x) + b * x + c", "using ha hb hc assms"], ["proof (prove)\nusing this:\n  a = insertion (nth_default 0 (xs' @ ?x # xs)) A\n  b = insertion (nth_default 0 (xs' @ ?x # xs)) B\n  c = insertion (nth_default 0 (xs' @ ?x # xs)) C\n  MPoly_Type.degree p var < 3\n  get_coeffs var p = (A, B, C)\n  a = insertion (nth_default 0 (xs' @ y # xs)) A\n  b = insertion (nth_default 0 (xs' @ y # xs)) B\n  c = insertion (nth_default 0 (xs' @ y # xs)) C\n  length xs' = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs' @ x # xs)) p =\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    (x * x) \\<Longrightarrow>\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var 0) +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc 0)) *\n    x +\n    insertion (nth_default 0 (xs' @ x # xs))\n     (isolate_variable_sparse p var (Suc (Suc 0))) *\n    (x * x) =\n    a * (x * x) + b * x + c", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') 0) +\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') (Suc 0)) *\n             x +\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') (Suc (Suc 0))) *\n             (x * x);\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 2) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 2);\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0)) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0));\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 0) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 0);\n     MPoly_Type.degree p (length xs') < 3;\n     a =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 0);\n     var = length xs'; A = isolate_variable_sparse p (length xs') 2;\n     B = isolate_variable_sparse p (length xs') (Suc 0);\n     C = isolate_variable_sparse p (length xs') 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') 0) +\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x +\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs')\n                         (Suc (Suc 0))) *\n                      (x * x) =\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 2) *\n                      (x * x) +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 0)", "using deg2 express_poly h1 insertion_add insertion_mult insertion_pow insertion_var list_update_length"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 2\n  MPoly_Type.degree ?p ?var = 1 \\<or>\n  MPoly_Type.degree ?p ?var = 2 \\<Longrightarrow>\n  ?p =\n  isolate_variable_sparse ?p ?var 2 * (Var ?var)\\<^sup>2 +\n  isolate_variable_sparse ?p ?var 1 * Var ?var +\n  isolate_variable_sparse ?p ?var 0\n  var < length (xs' @ x # xs)\n  insertion ?f (?p + ?q) = insertion ?f ?p + insertion ?f ?q\n  insertion ?f (?p * ?q) = insertion ?f ?p * insertion ?f ?q\n  insertion ?f (?p ^ ?i) = insertion ?f ?p ^ ?i\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n  (?xs @ ?x # ?ys)[length ?xs := ?y] = ?xs @ ?y # ?ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insertion (nth_default 0 (xs' @ x # xs)) p =\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') 0) +\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') (Suc 0)) *\n             x +\n             insertion (nth_default 0 (xs' @ x # xs))\n              (isolate_variable_sparse p (length xs') (Suc (Suc 0))) *\n             (x * x);\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 2) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 2);\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0)) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') (Suc 0));\n     \\<And>x.\n        insertion (nth_default 0 (xs' @ y # xs))\n         (isolate_variable_sparse p (length xs') 0) =\n        insertion (nth_default 0 (xs' @ x # xs))\n         (isolate_variable_sparse p (length xs') 0);\n     MPoly_Type.degree p (length xs') < 3;\n     a =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 2);\n     b =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') (Suc 0));\n     c =\n     insertion (nth_default 0 (xs' @ y # xs))\n      (isolate_variable_sparse p (length xs') 0);\n     var = length xs'; A = isolate_variable_sparse p (length xs') 2;\n     B = isolate_variable_sparse p (length xs') (Suc 0);\n     C = isolate_variable_sparse p (length xs') 0\\<rbrakk>\n    \\<Longrightarrow> insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') 0) +\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x +\n                      insertion (nth_default 0 (xs' @ x # xs))\n                       (isolate_variable_sparse p (length xs')\n                         (Suc (Suc 0))) *\n                      (x * x) =\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 2) *\n                      (x * x) +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') (Suc 0)) *\n                      x +\n                      insertion (nth_default 0 (xs' @ y # xs))\n                       (isolate_variable_sparse p (length xs') 0)", "by (smt (verit, best) numeral_2_eq_2)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs' @ x # xs)) p = a * x\\<^sup>2 + b * x + c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"aEval_aEvalUni\":\n  assumes \"convert_atom var a (xs'@x#xs) = Some a'\"\n  assumes \"length xs' = var\"\n  shows \"aEval a (xs'@x#xs) = aEvalUni a' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case (Less x)"], ["proof (state)\nthis:\n  a = Less x\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  a = Less x", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Less x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "proof(cases \"MPoly_Type.degree x var < 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Less x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Less x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree x var < 3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Less x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Less x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "apply(simp add:Less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     LessUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x < 0) =\n                      aEvalUni a' x", "using poly_to_univar[OF True]"], ["proof (prove)\nusing this:\n  \\<lbrakk>get_coeffs var x = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) x =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     LessUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x < 0) =\n                      aEvalUni a' x", "by (metis One_nat_def aEvalUni.simps(2) get_coeffs.elims)"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Less x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Less x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case False"], ["proof (state)\nthis:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Less x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  \\<not> MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms Less"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n  a = Less x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "by auto"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case (Eq x)"], ["proof (state)\nthis:\n  a = Eq x\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 3. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  a = Eq x", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "proof(cases \"MPoly_Type.degree x var < 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Eq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree x var < 3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Eq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "apply(simp add:Eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     EqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x = 0) =\n                      aEvalUni a' x", "using poly_to_univar[OF True]"], ["proof (prove)\nusing this:\n  \\<lbrakk>get_coeffs var x = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) x =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     EqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x = 0) =\n                      aEvalUni a' x", "by (metis One_nat_def aEvalUni.simps(1) get_coeffs.elims)"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case False"], ["proof (state)\nthis:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  \\<not> MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms Eq"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n  a = Eq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "by auto"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case (Leq x)"], ["proof (state)\nthis:\n  a = Leq x\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  a = Leq x", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Leq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "proof(cases \"MPoly_Type.degree x var < 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Leq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Leq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree x var < 3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Leq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Leq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "apply(simp add:Leq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     LeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x \\<le> 0) =\n                      aEvalUni a' x", "using poly_to_univar[OF True]"], ["proof (prove)\nusing this:\n  \\<lbrakk>get_coeffs var x = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) x =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     LeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x \\<le> 0) =\n                      aEvalUni a' x", "by (metis One_nat_def aEvalUni.simps(3) get_coeffs.elims)"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Leq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Leq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case False"], ["proof (state)\nthis:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Leq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  \\<not> MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms Leq"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n  a = Leq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "by auto"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case (Neq x)"], ["proof (state)\nthis:\n  a = Neq x\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  a = Neq x", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Neq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "proof(cases \"MPoly_Type.degree x var < 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Neq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Neq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree x var < 3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Neq x; MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x\n 2. \\<lbrakk>a = Neq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "apply(simp add:Neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     NeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x \\<noteq>\n                       0) =\n                      aEvalUni a' x", "using poly_to_univar[OF True]"], ["proof (prove)\nusing this:\n  \\<lbrakk>get_coeffs var x = (?A, ?B, ?C);\n   ?a = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?A;\n   ?b = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?B;\n   ?c = insertion (nth_default 0 (?xs' @ ?y # ?xs)) ?C;\n   length ?xs' = var\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?xs' @ ?x # ?xs)) x =\n                    ?a * ?x\\<^sup>2 + ?b * ?x + ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MPoly_Type.degree x var < 3;\n     NeqUni\n      (insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 2),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var (Suc 0)),\n       insertion (nth_default 0 (xs' @ x # xs))\n        (isolate_variable_sparse x var 0)) =\n     a';\n     length xs' = var\\<rbrakk>\n    \\<Longrightarrow> (insertion (nth_default 0 (xs' @ x # xs)) x \\<noteq>\n                       0) =\n                      aEvalUni a' x", "by (metis One_nat_def aEvalUni.simps(4) get_coeffs.elims)"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Neq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Neq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "case False"], ["proof (state)\nthis:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Neq x; \\<not> MPoly_Type.degree x var < 3\\<rbrakk>\n    \\<Longrightarrow> aEval a (xs' @ x # xs) = aEvalUni a' x", "then"], ["proof (chain)\npicking this:\n  \\<not> MPoly_Type.degree x var < 3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "using assms Neq"], ["proof (prove)\nusing this:\n  \\<not> MPoly_Type.degree x var < 3\n  convert_atom var a (xs' @ x # xs) = Some a'\n  length xs' = var\n  a = Neq x\n\ngoal (1 subgoal):\n 1. aEval a (xs' @ x # xs) = aEvalUni a' x", "by auto"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval a (xs' @ x # xs) = aEvalUni a' x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun convert_fm :: \"nat \\<Rightarrow> atom fm \\<Rightarrow> real list \\<Rightarrow> (atomUni fmUni) option\" where\n  \"convert_fm var (Atom a) \\<Gamma> = map_option (AtomUni) (convert_atom var a \\<Gamma>)\" |\n  \"convert_fm var (TrueF) _ = Some TrueFUni\" |\n  \"convert_fm var (FalseF) _ = Some FalseFUni\" |\n  \"convert_fm var (And \\<phi> \\<psi>) \\<Gamma> = (case ((convert_fm var \\<phi> \\<Gamma>),(convert_fm var \\<psi> \\<Gamma>)) of (Some a, Some b) \\<Rightarrow> Some (AndUni a b) | _ \\<Rightarrow> None)\" |\n  \"convert_fm var (Or \\<phi> \\<psi>) \\<Gamma> = (case ((convert_fm var \\<phi> \\<Gamma>),(convert_fm var \\<psi> \\<Gamma>)) of (Some a, Some b) \\<Rightarrow> Some (OrUni a b) | _ \\<Rightarrow> None)\" |\n  \"convert_fm var (Neg \\<phi>) \\<Gamma> = None \" |\n  \"convert_fm var (ExQ \\<phi>) \\<Gamma> = None\" |\n  \"convert_fm var (AllQ \\<phi>) \\<Gamma> = None\"|\n  \"convert_fm var (AllN i \\<phi>) \\<Gamma> = None\"|\n  \"convert_fm var (ExN i \\<phi>) \\<Gamma> = None\""], ["", "lemma \"eval_evalUni\":\n  assumes \"convert_fm var F (xs'@x#xs) = Some F'\"\n  assumes \"length xs' = var\"\n  shows \"eval F (xs'@x#xs) = evalUni F' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (xs' @ x # xs) = evalUni F' x", "using assms"], ["proof (prove)\nusing this:\n  convert_fm var F (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval F (xs' @ x # xs) = evalUni F' x", "proof(induction F arbitrary: F')"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var TrueF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval TrueF (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (xs' @ x # xs) = evalUni F' x\n 3. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 10. \\<And>x1 F F'.\n        \\<lbrakk>\\<And>F'.\n                    \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                     length xs' = var\\<rbrakk>\n                    \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n         convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case TrueF"], ["proof (state)\nthis:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (10 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var TrueF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval TrueF (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (xs' @ x # xs) = evalUni F' x\n 3. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 10. \\<And>x1 F F'.\n        \\<lbrakk>\\<And>F'.\n                    \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                     length xs' = var\\<rbrakk>\n                    \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n         convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval TrueF (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval TrueF (xs' @ x # xs) = evalUni F' x\n\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (xs' @ x # xs) = evalUni F' x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (xs' @ x # xs) = evalUni F' x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case FalseF"], ["proof (state)\nthis:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval FalseF (xs' @ x # xs) = evalUni F' x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval FalseF (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval FalseF (xs' @ x # xs) = evalUni F' x\n\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (Atom x)"], ["proof (state)\nthis:\n  convert_fm var (fm.Atom x) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom xa) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  convert_fm var (fm.Atom x) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var (fm.Atom x) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (fm.Atom x) (xs' @ x # xs) = evalUni F' x", "using aEval_aEvalUni"], ["proof (prove)\nusing this:\n  convert_fm var (fm.Atom x) (xs' @ x # xs) = Some F'\n  length xs' = var\n  \\<lbrakk>convert_atom ?var ?a (?xs' @ ?x # ?xs) = Some ?a';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> aEval ?a (?xs' @ ?x # ?xs) = aEvalUni ?a' ?x\n\ngoal (1 subgoal):\n 1. eval (fm.Atom x) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (fm.Atom x) (xs' @ x # xs) = evalUni F' x\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (And F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (And F1 F2) (xs' @ x # xs) = evalUni F' x", "apply(cases \"convert_fm var F1 (xs'@x#xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                 length xs' = var\\<rbrakk>\n                \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n     \\<And>F'.\n        \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n     convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'; length xs' = var;\n     convert_fm var F1 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x", "apply(cases \"convert_fm var F2 (xs'@x#xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a;\n        convert_fm var F2 (xs' @ x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a;\n        convert_fm var F2 (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (And F1 F2) (xs' @ x # xs) = evalUni F' x\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (Or F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni ?F' x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x", "apply(cases \"convert_fm var F1 (xs'@x#xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                 length xs' = var\\<rbrakk>\n                \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n     \\<And>F'.\n        \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n     convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'; length xs' = var;\n     convert_fm var F1 (xs' @ x # xs) = None\\<rbrakk>\n    \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x", "apply(cases \"convert_fm var F2 (xs'@x#xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a;\n        convert_fm var F2 (xs' @ x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>a aa.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F1 (xs' @ x # xs) = evalUni F' x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval F2 (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var; convert_fm var F1 (xs' @ x # xs) = Some a;\n        convert_fm var F2 (xs' @ x # xs) = Some aa\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (Or F1 F2) (xs' @ x # xs) = evalUni F' x\n\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (Neg F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg F) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (Neg F) (xs' @ x # xs) = evalUni F' x\n\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (ExQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (ExQ F) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (ExQ F) (xs' @ x # xs) = evalUni F' x\n\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (AllQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (AllQ F) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (AllQ F) (xs' @ x # xs) = evalUni F' x\n\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (ExN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) (xs' @ x # xs) = evalUni F' x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (ExN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (ExN x1 \\<phi>) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (ExN x1 \\<phi>) (xs' @ x # xs) = evalUni F' x\n\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "case (AllN x1 \\<phi>)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval F (xs' @ x # xs) = evalUni F' x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) (xs' @ x # xs) = evalUni F' x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var \\<phi> (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval \\<phi> (xs' @ x # xs) = evalUni ?F' x\n  convert_fm var (AllN x1 \\<phi>) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (AllN x1 \\<phi>) (xs' @ x # xs) = evalUni F' x", "by auto"], ["proof (state)\nthis:\n  eval (AllN x1 \\<phi>) (xs' @ x # xs) = evalUni F' x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun grab_atoms :: \"nat \\<Rightarrow> atom fm \\<Rightarrow> atom list option\" where\n  \"grab_atoms var TrueF = Some([])\" |\n  \"grab_atoms var FalseF = Some([])\" |\n  \"grab_atoms var (Atom(Eq p)) = (if MPoly_Type.degree p var < 3 then (if MPoly_Type.degree p var > 0 then Some([Eq p]) else Some([])) else None)\"|\n  \"grab_atoms var (Atom(Less p)) = (if MPoly_Type.degree p var < 3 then (if MPoly_Type.degree p var > 0 then Some([Less p]) else Some([])) else None)\"|\n  \"grab_atoms var (Atom(Leq p)) = (if MPoly_Type.degree p var < 3 then (if MPoly_Type.degree p var > 0 then Some([Leq p]) else Some([])) else None)\"|\n  \"grab_atoms var (Atom(Neq p)) = (if MPoly_Type.degree p var < 3 then (if MPoly_Type.degree p var > 0 then Some([Neq p]) else Some([])) else None)\"|\n  \"grab_atoms var (And a b) = (\ncase grab_atoms var a of \n  Some(al) \\<Rightarrow> (\n    case grab_atoms var b of\n      Some(bl) \\<Rightarrow> Some(al@bl)\n    | None \\<Rightarrow> None\n  )\n| None \\<Rightarrow> None\n)\"|\n  \"grab_atoms var (Or a b) = (\ncase grab_atoms var a of \n  Some(al) \\<Rightarrow> (\n    case grab_atoms var b of\n      Some(bl) \\<Rightarrow> Some(al@bl)\n    | None \\<Rightarrow> None\n  )\n| None \\<Rightarrow> None\n)\"|\n\n\"grab_atoms var (Neg _) = None\"|\n\"grab_atoms var (ExQ _) = None\"|\n\"grab_atoms var (AllQ _) = None\"|\n\"grab_atoms var (AllN i _) = None\"|\n\"grab_atoms var (ExN i _) = None\""], ["", "lemma nil_grab : \"(grab_atoms var F = Some []) \\<Longrightarrow> (freeIn var F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F", "proof(induction F)"], ["proof (state)\ngoal (10 subgoals):\n 1. grab_atoms var TrueF = Some [] \\<Longrightarrow> freeIn var TrueF\n 2. grab_atoms var FalseF = Some [] \\<Longrightarrow> freeIn var FalseF\n 3. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 5. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 7. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 8. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 9. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 10. \\<And>x1 F.\n        \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n         grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n        \\<Longrightarrow> freeIn var (AllN x1 F)", "case TrueF"], ["proof (state)\nthis:\n  grab_atoms var TrueF = Some []\n\ngoal (10 subgoals):\n 1. grab_atoms var TrueF = Some [] \\<Longrightarrow> freeIn var TrueF\n 2. grab_atoms var FalseF = Some [] \\<Longrightarrow> freeIn var FalseF\n 3. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 5. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 7. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 8. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 9. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 10. \\<And>x1 F.\n        \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n         grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n        \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var TrueF = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var TrueF = Some []\n\ngoal (1 subgoal):\n 1. freeIn var TrueF", "by auto"], ["proof (state)\nthis:\n  freeIn var TrueF\n\ngoal (9 subgoals):\n 1. grab_atoms var FalseF = Some [] \\<Longrightarrow> freeIn var FalseF\n 2. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 4. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 7. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 9. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. grab_atoms var FalseF = Some [] \\<Longrightarrow> freeIn var FalseF\n 2. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 4. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 7. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 9. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case FalseF"], ["proof (state)\nthis:\n  grab_atoms var FalseF = Some []\n\ngoal (9 subgoals):\n 1. grab_atoms var FalseF = Some [] \\<Longrightarrow> freeIn var FalseF\n 2. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 4. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 7. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 9. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var FalseF = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var FalseF = Some []\n\ngoal (1 subgoal):\n 1. freeIn var FalseF", "by auto"], ["proof (state)\nthis:\n  freeIn var FalseF\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (Atom x)"], ["proof (state)\nthis:\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       grab_atoms var (fm.Atom x) = Some [] \\<Longrightarrow>\n       freeIn var (fm.Atom x)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 3. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 6. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 8. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var (fm.Atom x) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "proof(cases x)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Less x1\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x2.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 3. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 4. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "case (Less p)"], ["proof (state)\nthis:\n  x = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Less x1\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x2.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 3. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 4. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "then"], ["proof (chain)\npicking this:\n  x = Less p", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Less p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "using Atom"], ["proof (prove)\nusing this:\n  x = Less p\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Less p; grab_atoms var (fm.Atom x) = Some [];\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<lbrakk>x = Less p; grab_atoms var (fm.Atom x) = Some [];\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Less p;\n     (if 0 < MPoly_Type.degree p var then Some [Less p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MPoly_Type.degree p var > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Less p;\n     (if 0 < MPoly_Type.degree p var then Some [Less p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x = Less p;\n     (if 0 < MPoly_Type.degree p var then Some [Less p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     \\<not> 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Less p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "using degree0isovarspar not_in_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Less p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  freeIn var (fm.Atom x)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 3. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 3. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "case (Eq p)"], ["proof (state)\nthis:\n  x = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Eq x2\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 3. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "then"], ["proof (chain)\npicking this:\n  x = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Eq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "using Atom"], ["proof (prove)\nusing this:\n  x = Eq p\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Eq p; grab_atoms var (fm.Atom x) = Some [];\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<lbrakk>x = Eq p; grab_atoms var (fm.Atom x) = Some [];\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Eq p;\n     (if 0 < MPoly_Type.degree p var then Some [Eq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MPoly_Type.degree p var > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Eq p;\n     (if 0 < MPoly_Type.degree p var then Some [Eq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x = Eq p;\n     (if 0 < MPoly_Type.degree p var then Some [Eq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     \\<not> 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Eq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "using degree0isovarspar not_in_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Eq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  freeIn var (fm.Atom x)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "case (Leq p)"], ["proof (state)\nthis:\n  x = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Leq x3\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "then"], ["proof (chain)\npicking this:\n  x = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Leq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "using Atom"], ["proof (prove)\nusing this:\n  x = Leq p\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Leq p; grab_atoms var (fm.Atom x) = Some [];\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<lbrakk>x = Leq p; grab_atoms var (fm.Atom x) = Some [];\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Leq p;\n     (if 0 < MPoly_Type.degree p var then Some [Leq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MPoly_Type.degree p var > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Leq p;\n     (if 0 < MPoly_Type.degree p var then Some [Leq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x = Leq p;\n     (if 0 < MPoly_Type.degree p var then Some [Leq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     \\<not> 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Leq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "using degree0isovarspar not_in_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Leq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  freeIn var (fm.Atom x)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "case (Neq p)"], ["proof (state)\nthis:\n  x = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>grab_atoms var (fm.Atom x) = Some []; x = Neq x4\\<rbrakk>\n       \\<Longrightarrow> freeIn var (fm.Atom x)", "then"], ["proof (chain)\npicking this:\n  x = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Neq p\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "using Atom"], ["proof (prove)\nusing this:\n  x = Neq p\n  grab_atoms var (fm.Atom x) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom x)", "apply(cases \"MPoly_Type.degree p var < 3\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Neq p; grab_atoms var (fm.Atom x) = Some [];\n     MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)\n 2. \\<lbrakk>x = Neq p; grab_atoms var (fm.Atom x) = Some [];\n     \\<not> MPoly_Type.degree p var < 3\\<rbrakk>\n    \\<Longrightarrow> freeIn var (fm.Atom x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neq p;\n     (if 0 < MPoly_Type.degree p var then Some [Neq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p\\<rbrakk>\n    \\<Longrightarrow> False", "apply(cases \"MPoly_Type.degree p var > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Neq p;\n     (if 0 < MPoly_Type.degree p var then Some [Neq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>x = Neq p;\n     (if 0 < MPoly_Type.degree p var then Some [Neq p] else Some []) =\n     Some [];\n     MPoly_Type.degree p var < 3; var \\<in> vars p;\n     \\<not> 0 < MPoly_Type.degree p var\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "using degree0isovarspar not_in_isovarspar"], ["proof (prove)\nusing this:\n  MPoly_Type.degree ?p ?x = 0 \\<Longrightarrow>\n  isolate_variable_sparse ?p ?x 0 = ?p\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neq p; var \\<in> vars p;\n     MPoly_Type.degree p var = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  freeIn var (fm.Atom x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  freeIn var (fm.Atom x)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (And F1 F2)"], ["proof (state)\nthis:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (And F1 F2) = Some []\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 2. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 5. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 7. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (And F1 F2) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (And F1 F2) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (And F1 F2)", "apply(cases \"grab_atoms var F1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n     grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n     grab_atoms var (And F1 F2) = Some []; grab_atoms var F1 = None\\<rbrakk>\n    \\<Longrightarrow> freeIn var (And F1 F2)\n 2. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n     grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n     grab_atoms var (And F1 F2) = Some []; grab_atoms var F1 = None;\n     grab_atoms var F2 = None\\<rbrakk>\n    \\<Longrightarrow> freeIn var (And F1 F2)\n 2. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some []; grab_atoms var F1 = None;\n        grab_atoms var F2 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)\n 3. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (And F1 F2) = Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (And F1 F2)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 2. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = None\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 2. \\<And>a aa.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = Some aa\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 3. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = None\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2\n 2. \\<And>a aa.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = Some aa\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "by(auto)"], ["proof (state)\nthis:\n  freeIn var (And F1 F2)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (Or F1 F2)"], ["proof (state)\nthis:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (Or F1 F2) = Some []\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 4. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 6. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (Or F1 F2) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1\n  grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2\n  grab_atoms var (Or F1 F2) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (Or F1 F2)", "apply(cases \"grab_atoms var F1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n     grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n     grab_atoms var (Or F1 F2) = Some []; grab_atoms var F1 = None\\<rbrakk>\n    \\<Longrightarrow> freeIn var (Or F1 F2)\n 2. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n     grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n     grab_atoms var (Or F1 F2) = Some []; grab_atoms var F1 = None;\n     grab_atoms var F2 = None\\<rbrakk>\n    \\<Longrightarrow> freeIn var (Or F1 F2)\n 2. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some []; grab_atoms var F1 = None;\n        grab_atoms var F2 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)\n 3. \\<And>a.\n       \\<lbrakk>grab_atoms var F1 = Some [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        grab_atoms var (Or F1 F2) = Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Or F1 F2)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 2. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = None\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 2. \\<And>a aa.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = Some aa\\<rbrakk>\n       \\<Longrightarrow> freeIn var F1\n 3. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "apply(cases \"grab_atoms var F2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = None\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2\n 2. \\<And>a aa.\n       \\<lbrakk>a = [] \\<Longrightarrow> freeIn var F1;\n        grab_atoms var F2 = Some [] \\<Longrightarrow> freeIn var F2;\n        (case grab_atoms var F2 of None \\<Rightarrow> None\n         | Some bl \\<Rightarrow> Some (a @ bl)) =\n        Some [];\n        grab_atoms var F1 = Some a; grab_atoms var F2 = Some aa\\<rbrakk>\n       \\<Longrightarrow> freeIn var F2", "by(auto)"], ["proof (state)\nthis:\n  freeIn var (Or F1 F2)\n\ngoal (5 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (Neg F)"], ["proof (state)\nthis:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (Neg F) = Some []\n\ngoal (5 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (Neg F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (Neg F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 3. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 5. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (Neg F) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (Neg F) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (Neg F)", "by auto"], ["proof (state)\nthis:\n  freeIn var (Neg F)\n\ngoal (4 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (ExQ F)"], ["proof (state)\nthis:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExQ F) = Some []\n\ngoal (4 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExQ F)\n 2. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 4. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExQ F) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExQ F) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (ExQ F)", "by auto"], ["proof (state)\nthis:\n  freeIn var (ExQ F)\n\ngoal (3 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (AllQ F)"], ["proof (state)\nthis:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllQ F) = Some []\n\ngoal (3 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllQ F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllQ F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 3. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllQ F) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllQ F) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (AllQ F)", "by auto"], ["proof (state)\nthis:\n  freeIn var (AllQ F)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (ExN x1 F)"], ["proof (state)\nthis:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExN x1 F) = Some []\n\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (ExN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (ExN x1 F)\n 2. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExN x1 F) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (ExN x1 F) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (ExN x1 F)", "by auto"], ["proof (state)\nthis:\n  freeIn var (ExN x1 F)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "case (AllN x1 F)"], ["proof (state)\nthis:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllN x1 F) = Some []\n\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       \\<lbrakk>grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F;\n        grab_atoms var (AllN x1 F) = Some []\\<rbrakk>\n       \\<Longrightarrow> freeIn var (AllN x1 F)", "then"], ["proof (chain)\npicking this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllN x1 F) = Some []", "show ?case"], ["proof (prove)\nusing this:\n  grab_atoms var F = Some [] \\<Longrightarrow> freeIn var F\n  grab_atoms var (AllN x1 F) = Some []\n\ngoal (1 subgoal):\n 1. freeIn var (AllN x1 F)", "by auto"], ["proof (state)\nthis:\n  freeIn var (AllN x1 F)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun isSome :: \"'a option \\<Rightarrow> bool\" where\n  \"isSome (Some _) = True\" |\n  \"isSome None = False\""], ["", "lemma \"grab_atoms_convert\" : \"(isSome (grab_atoms var F)) = (isSome (convert_fm var F xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "proof(induction F)"], ["proof (state)\ngoal (10 subgoals):\n 1. isSome (grab_atoms var TrueF) = isSome (convert_fm var TrueF xs)\n 2. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n 3. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 4. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 5. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 7. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 8. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 9. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 10. \\<And>x1 F.\n        isSome (grab_atoms var F) =\n        isSome (convert_fm var F xs) \\<Longrightarrow>\n        isSome (grab_atoms var (AllN x1 F)) =\n        isSome (convert_fm var (AllN x1 F) xs)", "case TrueF"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. isSome (grab_atoms var TrueF) = isSome (convert_fm var TrueF xs)\n 2. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n 3. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 4. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 5. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 7. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 8. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 9. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 10. \\<And>x1 F.\n        isSome (grab_atoms var F) =\n        isSome (convert_fm var F xs) \\<Longrightarrow>\n        isSome (grab_atoms var (AllN x1 F)) =\n        isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isSome (grab_atoms var TrueF) = isSome (convert_fm var TrueF xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var TrueF) = isSome (convert_fm var TrueF xs)\n\ngoal (9 subgoals):\n 1. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n 2. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 4. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 7. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 9. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n 2. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 4. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 7. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 9. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case FalseF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n 2. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 4. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 7. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 9. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var FalseF) = isSome (convert_fm var FalseF xs)\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (Atom a)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x.\n       isSome (grab_atoms var (fm.Atom x)) =\n       isSome (convert_fm var (fm.Atom x) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 3. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 6. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 8. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (fm.Atom a)) =\n    isSome (convert_fm var (fm.Atom a) xs)", "apply(cases a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow>\n       isSome (grab_atoms var (fm.Atom a)) =\n       isSome (convert_fm var (fm.Atom a) xs)\n 2. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow>\n       isSome (grab_atoms var (fm.Atom a)) =\n       isSome (convert_fm var (fm.Atom a) xs)\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow>\n       isSome (grab_atoms var (fm.Atom a)) =\n       isSome (convert_fm var (fm.Atom a) xs)\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow>\n       isSome (grab_atoms var (fm.Atom a)) =\n       isSome (convert_fm var (fm.Atom a) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (fm.Atom a)) =\n  isSome (convert_fm var (fm.Atom a) xs)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (And F1 F2)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (And F1 F2)) =\n                         isSome (convert_fm var (And F1 F2) xs)\n 2. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 5. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 7. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (And F1 F2)) =\n    isSome (convert_fm var (And F1 F2) xs)", "by (smt convert_fm.simps(4) grab_atoms.simps(7) isSome.elims(2) isSome.elims(3) option.distinct(1) option.simps(5) option.split_sel_asm prod.simps(2))"], ["proof (state)\nthis:\n  isSome (grab_atoms var (And F1 F2)) =\n  isSome (convert_fm var (And F1 F2) xs)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (Or F1 F2)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2.\n       \\<lbrakk>isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs);\n        isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\\<rbrakk>\n       \\<Longrightarrow> isSome (grab_atoms var (Or F1 F2)) =\n                         isSome (convert_fm var (Or F1 F2) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 4. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 6. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F1) = isSome (convert_fm var F1 xs)\n  isSome (grab_atoms var F2) = isSome (convert_fm var F2 xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (Or F1 F2)) =\n    isSome (convert_fm var (Or F1 F2) xs)", "by (smt convert_fm.simps(5) grab_atoms.simps(8) isSome.elims(2) isSome.elims(3) option.distinct(1) option.simps(5) option.split_sel_asm prod.simps(2))"], ["proof (state)\nthis:\n  isSome (grab_atoms var (Or F1 F2)) = isSome (convert_fm var (Or F1 F2) xs)\n\ngoal (5 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (Neg F)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (5 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 3. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 5. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (Neg F)) = isSome (convert_fm var (Neg F) xs)\n\ngoal (4 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (ExQ F)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (4 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n 2. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 4. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (ExQ F)) = isSome (convert_fm var (ExQ F) xs)\n\ngoal (3 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (AllQ F)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (3 subgoals):\n 1. \\<And>F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllQ F)) =\n       isSome (convert_fm var (AllQ F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 3. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (AllQ F)) = isSome (convert_fm var (AllQ F) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (AllQ F)) = isSome (convert_fm var (AllQ F) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (ExN x1 F)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (ExN x1 F)) =\n       isSome (convert_fm var (ExN x1 F) xs)\n 2. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (ExN x1 F)) =\n    isSome (convert_fm var (ExN x1 F) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (ExN x1 F)) = isSome (convert_fm var (ExN x1 F) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "case (AllN x1 F)"], ["proof (state)\nthis:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F.\n       isSome (grab_atoms var F) =\n       isSome (convert_fm var F xs) \\<Longrightarrow>\n       isSome (grab_atoms var (AllN x1 F)) =\n       isSome (convert_fm var (AllN x1 F) xs)", "then"], ["proof (chain)\npicking this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)", "show ?case"], ["proof (prove)\nusing this:\n  isSome (grab_atoms var F) = isSome (convert_fm var F xs)\n\ngoal (1 subgoal):\n 1. isSome (grab_atoms var (AllN x1 F)) =\n    isSome (convert_fm var (AllN x1 F) xs)", "by auto"], ["proof (state)\nthis:\n  isSome (grab_atoms var (AllN x1 F)) =\n  isSome (convert_fm var (AllN x1 F) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_aNeg :\n  assumes \"convert_atom var A (xs'@x#xs) = Some(A')\"\n  assumes \"length xs' = var\"\n  shows \"aEval (aNeg A) (xs'@x#xs) = aEvalUni (aNegUni A') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "have \"aEval (aNeg A) (xs'@x#xs) = (\\<not> aEval A (xs'@x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = (\\<not> aEval A (xs' @ x # xs))", "using aNeg_aEval[of A \"(xs'@x#xs)\"]"], ["proof (prove)\nusing this:\n  aEval A (xs' @ x # xs) = (\\<not> aEval (aNeg A) (xs' @ x # xs))\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = (\\<not> aEval A (xs' @ x # xs))", "by auto"], ["proof (state)\nthis:\n  aEval (aNeg A) (xs' @ x # xs) = (\\<not> aEval A (xs' @ x # xs))\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "also"], ["proof (state)\nthis:\n  aEval (aNeg A) (xs' @ x # xs) = (\\<not> aEval A (xs' @ x # xs))\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "have \"... = (\\<not> aEvalUni A' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> aEval A (xs' @ x # xs)) = (\\<not> aEvalUni A' x)", "using assms aEval_aEvalUni"], ["proof (prove)\nusing this:\n  convert_atom var A (xs' @ x # xs) = Some A'\n  length xs' = var\n  \\<lbrakk>convert_atom ?var ?a (?xs' @ ?x # ?xs) = Some ?a';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> aEval ?a (?xs' @ ?x # ?xs) = aEvalUni ?a' ?x\n\ngoal (1 subgoal):\n 1. (\\<not> aEval A (xs' @ x # xs)) = (\\<not> aEvalUni A' x)", "by auto"], ["proof (state)\nthis:\n  (\\<not> aEval A (xs' @ x # xs)) = (\\<not> aEvalUni A' x)\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "also"], ["proof (state)\nthis:\n  (\\<not> aEval A (xs' @ x # xs)) = (\\<not> aEvalUni A' x)\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "have \"... = aEvalUni (aNegUni A') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> aEvalUni A' x) = aEvalUni (aNegUni A') x", "by(cases A')(auto)"], ["proof (state)\nthis:\n  (\\<not> aEvalUni A' x) = aEvalUni (aNegUni A') x\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "finally"], ["proof (chain)\npicking this:\n  aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "show ?thesis"], ["proof (prove)\nusing this:\n  aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x\n\ngoal (1 subgoal):\n 1. aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x", "."], ["proof (state)\nthis:\n  aEval (aNeg A) (xs' @ x # xs) = aEvalUni (aNegUni A') x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_neg : \n  assumes \"convert_fm var F (xs'@x#xs) = Some(F')\"\n  assumes \"length xs' = var\"\n  shows \"eval (Neg F) (xs'@x#xs) = evalUni (negUni F') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Neg F) (xs' @ x # xs) = evalUni (negUni F') x", "using assms"], ["proof (prove)\nusing this:\n  convert_fm var F (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg F) (xs' @ x # xs) = evalUni (negUni F') x", "proof(induction F arbitrary:F')"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var TrueF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg TrueF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg FalseF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 10. \\<And>x1 F F'.\n        \\<lbrakk>\\<And>F'.\n                    \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                     length xs' = var\\<rbrakk>\n                    \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\nevalUni (negUni F') x;\n         convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                          evalUni (negUni F') x", "case TrueF"], ["proof (state)\nthis:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (10 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var TrueF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg TrueF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg FalseF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 10. \\<And>x1 F F'.\n        \\<lbrakk>\\<And>F'.\n                    \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                     length xs' = var\\<rbrakk>\n                    \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\nevalUni (negUni F') x;\n         convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n         length xs' = var\\<rbrakk>\n        \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                          evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var TrueF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg TrueF) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg TrueF) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg FalseF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg FalseF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case FalseF"], ["proof (state)\nthis:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (9 subgoals):\n 1. \\<And>F'.\n       \\<lbrakk>convert_fm var FalseF (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg FalseF) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 9. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var FalseF (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg FalseF) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg FalseF) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (Atom p)"], ["proof (state)\nthis:\n  convert_fm var (fm.Atom p) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (8 subgoals):\n 1. \\<And>xa F'.\n       \\<lbrakk>convert_fm var (fm.Atom xa) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (fm.Atom xa)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 8. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  convert_fm var (fm.Atom p) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  convert_fm var (fm.Atom p) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (fm.Atom p)) (xs' @ x # xs) = evalUni (negUni F') x", "using convert_aNeg[of _ p]"], ["proof (prove)\nusing this:\n  convert_fm var (fm.Atom p) (xs' @ x # xs) = Some F'\n  length xs' = var\n  \\<lbrakk>convert_atom ?var p (?xs' @ ?x # ?xs) = Some ?A';\n   length ?xs' = ?var\\<rbrakk>\n  \\<Longrightarrow> aEval (aNeg p) (?xs' @ ?x # ?xs) =\n                    aEvalUni (aNegUni ?A') ?x\n\ngoal (1 subgoal):\n 1. eval (Neg (fm.Atom p)) (xs' @ x # xs) = evalUni (negUni F') x", "by (smt aNeg_aEval convert_fm.simps(1) evalUni.simps(1) eval.simps(1) eval.simps(6) map_option_eq_Some negUni.simps(1))"], ["proof (state)\nthis:\n  eval (Neg (fm.Atom p)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (And F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (And F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (And F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 7. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (And F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (And F1 F2)) (xs' @ x # xs) = evalUni (negUni F') x", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        (\\<not> eval F2 (xs' @ x # xs)) = evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; \\<not> eval F1 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> evalUni (negUni F') x\n 2. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                (\\<not> eval F1 (xs' @ x # xs)) = evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; \\<not> eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> evalUni (negUni F') x\n 3. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                \\<not> evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x; eval F1 (xs' @ x # xs);\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (no_types, lifting) evalUni.simps(5) negUni.simps(4) option.case_eq_if option.collapse option.distinct(1) option.sel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                (\\<not> eval F1 (xs' @ x # xs)) = evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; \\<not> eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> evalUni (negUni F') x\n 2. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                \\<not> evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x; eval F1 (xs' @ x # xs);\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt (verit, del_insts) evalUni.simps(5) isSome.elims(1) negUni.simps(4) option.inject option.simps(4) option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                \\<not> evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None\n          | Some b \\<Rightarrow> Some (AndUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x; eval F1 (xs' @ x # xs);\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "by (smt (verit, del_insts) evalUni.simps(5) isSome.elims(1) negUni.simps(4) option.inject option.simps(4) option.simps(5))"], ["proof (state)\nthis:\n  eval (Neg (And F1 F2)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (Or F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        \\<And>F'.\n           \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some F';\n            length xs' = var\\<rbrakk>\n           \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) =\n                             evalUni (negUni F') x;\n        convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Or F1 F2)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 6. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F1 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F1) (xs' @ x # xs) = evalUni (negUni ?F') x\n  \\<lbrakk>convert_fm var F2 (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F2) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Or F1 F2) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (Or F1 F2)) (xs' @ x # xs) = evalUni (negUni F') x", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; \\<not> eval F1 (xs' @ x # xs);\n     \\<not> eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> evalUni (negUni F') x\n 2. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                \\<not> evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        (\\<not> eval F2 (xs' @ x # xs)) = evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x;\n     eval F1 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                (\\<not> eval F1 (xs' @ x # xs)) = evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x;\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt (verit, del_insts) evalUni.simps(4) isSome.elims(1) negUni.simps(5) option.inject option.simps(4) option.simps(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                \\<not> evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        (\\<not> eval F2 (xs' @ x # xs)) = evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x;\n     eval F1 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                (\\<not> eval F1 (xs' @ x # xs)) = evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x;\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (smt (verit, del_insts) evalUni.simps(4) isSome.elims(1) negUni.simps(5) option.inject option.simps(4) option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F'.\n                convert_fm (length xs') F1 (xs' @ x # xs) =\n                Some F' \\<Longrightarrow>\n                (\\<not> eval F1 (xs' @ x # xs)) = evalUni (negUni F') x;\n     \\<And>F'.\n        convert_fm (length xs') F2 (xs' @ x # xs) =\n        Some F' \\<Longrightarrow>\n        \\<not> evalUni (negUni F') x;\n     (case convert_fm (length xs') F1 (xs' @ x # xs) of\n      None \\<Rightarrow> None\n      | Some a \\<Rightarrow>\n          case convert_fm (length xs') F2 (xs' @ x # xs) of\n          None \\<Rightarrow> None | Some b \\<Rightarrow> Some (OrUni a b)) =\n     Some F';\n     var = length xs'; evalUni (negUni F') x;\n     eval F2 (xs' @ x # xs)\\<rbrakk>\n    \\<Longrightarrow> False", "by (smt (verit, del_insts) evalUni.simps(4) isSome.elims(1) negUni.simps(5) option.inject option.simps(4) option.simps(5))"], ["proof (state)\nthis:\n  eval (Neg (Or F1 F2)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (Neg F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (5 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (Neg F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (Neg F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 5. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (Neg F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (Neg F)) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg (Neg F)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (ExQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 4. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (ExQ F)) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg (ExQ F)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (AllQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllQ F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllQ F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 3. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllQ F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (AllQ F)) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg (AllQ F)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (ExN x1 F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (2 subgoals):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (ExN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x\n 2. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (ExN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (ExN x1 F)) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg (ExN x1 F)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "case (AllN x1 F)"], ["proof (state)\nthis:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. \\<And>x1 F F'.\n       \\<lbrakk>\\<And>F'.\n                   \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some F';\n                    length xs' = var\\<rbrakk>\n                   \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) =\n                                     evalUni (negUni F') x;\n        convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F';\n        length xs' = var\\<rbrakk>\n       \\<Longrightarrow> eval (Neg (AllN x1 F)) (xs' @ x # xs) =\n                         evalUni (negUni F') x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>convert_fm var F (xs' @ x # xs) = Some ?F';\n   length xs' = var\\<rbrakk>\n  \\<Longrightarrow> eval (Neg F) (xs' @ x # xs) = evalUni (negUni ?F') x\n  convert_fm var (AllN x1 F) (xs' @ x # xs) = Some F'\n  length xs' = var\n\ngoal (1 subgoal):\n 1. eval (Neg (AllN x1 F)) (xs' @ x # xs) = evalUni (negUni F') x", "by auto"], ["proof (state)\nthis:\n  eval (Neg (AllN x1 F)) (xs' @ x # xs) = evalUni (negUni F') x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun list_disj_Uni :: \"'a fmUni list \\<Rightarrow> 'a fmUni\" where\n  \"list_disj_Uni [] = FalseFUni\"|\n  \"list_disj_Uni (x#xs) = OrUni x (list_disj_Uni xs)\""], ["", "fun list_conj_Uni :: \"'a fmUni list \\<Rightarrow> 'a fmUni\" where\n  \"list_conj_Uni [] = TrueFUni\"|\n  \"list_conj_Uni (x#xs) = AndUni x (list_conj_Uni xs)\""], ["", "lemma eval_list_disj_Uni : \"evalUni (list_disj_Uni L) x = (\\<exists>l\\<in>set(L). evalUni l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (list_disj_Uni L) x = (\\<exists>l\\<in>set L. evalUni l x)", "by(induction L)(auto)"], ["", "lemma eval_list_conj_Uni : \"evalUni (list_conj_Uni A) x = (\\<forall>l\\<in>set A. evalUni l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (list_conj_Uni A) x = (\\<forall>l\\<in>set A. evalUni l x)", "apply(induction A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evalUni (list_conj_Uni []) x = (\\<forall>l\\<in>set []. evalUni l x)\n 2. \\<And>a A.\n       evalUni (list_conj_Uni A) x =\n       (\\<forall>l\\<in>set A. evalUni l x) \\<Longrightarrow>\n       evalUni (list_conj_Uni (a # A)) x =\n       (\\<forall>l\\<in>set (a # A). evalUni l x)", "by auto"], ["", "lemma eval_list_conj_Uni_append : \"evalUni (list_conj_Uni (A @ B)) x = (evalUni (list_conj_Uni (A)) x \\<and> evalUni (list_conj_Uni (B)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (list_conj_Uni (A @ B)) x =\n    (evalUni (list_conj_Uni A) x \\<and> evalUni (list_conj_Uni B) x)", "apply(induction A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evalUni (list_conj_Uni ([] @ B)) x =\n    (evalUni (list_conj_Uni []) x \\<and> evalUni (list_conj_Uni B) x)\n 2. \\<And>a A.\n       evalUni (list_conj_Uni (A @ B)) x =\n       (evalUni (list_conj_Uni A) x \\<and>\n        evalUni (list_conj_Uni B) x) \\<Longrightarrow>\n       evalUni (list_conj_Uni ((a # A) @ B)) x =\n       (evalUni (list_conj_Uni (a # A)) x \\<and>\n        evalUni (list_conj_Uni B) x)", "by auto"], ["", "fun map_atomUni :: \"('a \\<Rightarrow> 'a fmUni) \\<Rightarrow> 'a fmUni \\<Rightarrow> 'a fmUni\" where\n  \"map_atomUni f (AtomUni a) = f a\" |\n  \"map_atomUni f (TrueFUni) = TrueFUni\" |\n  \"map_atomUni f (FalseFUni) = FalseFUni\" |\n  \"map_atomUni f (AndUni \\<phi> \\<psi>) = (AndUni (map_atomUni f \\<phi>) (map_atomUni f \\<psi>))\" |\n  \"map_atomUni f (OrUni \\<phi> \\<psi>) = (OrUni (map_atomUni f \\<phi>) (map_atomUni f \\<psi>))\""], ["", "fun map_atom :: \"(atom \\<Rightarrow> atom fm) \\<Rightarrow> atom fm \\<Rightarrow> atom fm\" where\n  \"map_atom f TrueF = TrueF\"|\n  \"map_atom f FalseF = FalseF\"|\n  \"map_atom f (Atom a) = f a\"|\n  \"map_atom f (And \\<phi> \\<psi>) = And (map_atom f \\<phi>) (map_atom f \\<psi>)\"|\n  \"map_atom f (Or \\<phi> \\<psi>) = Or (map_atom f \\<phi>) (map_atom f \\<psi>)\"|\n  \"map_atom f (Neg \\<phi>) = TrueF\"|\n  \"map_atom f (ExQ \\<phi>) = TrueF\"|\n  \"map_atom f (AllQ \\<phi>) = TrueF\"|\n  \"map_atom f (ExN i \\<phi>) = TrueF\"|\n  \"map_atom f (AllN i \\<phi>) = TrueF\""], ["", "fun getPoly :: \"atomUni => real * real * real\" where\n  \"getPoly (EqUni p) = p\"|\n  \"getPoly (LeqUni p) = p\"|\n  \"getPoly (NeqUni p) = p\"|\n  \"getPoly (LessUni p) = p\""], ["", "lemma liftatom_map_atom : \n  assumes \"\\<exists>F'. convert_fm var F xs = Some F'\"\n  shows \"liftmap f F 0 = map_atom (f 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftmap f F 0 = map_atom (f 0) F", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>F'. convert_fm var F xs = Some F'\n\ngoal (1 subgoal):\n 1. liftmap f F 0 = map_atom (f 0) F", "apply(induction F)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<exists>F'. convert_fm var TrueF xs = Some F' \\<Longrightarrow>\n    liftmap f TrueF 0 = map_atom (f 0) TrueF\n 2. \\<exists>F'. convert_fm var FalseF xs = Some F' \\<Longrightarrow>\n    liftmap f FalseF 0 = map_atom (f 0) FalseF\n 3. \\<And>x.\n       \\<exists>F'.\n          convert_fm var (fm.Atom x) xs = Some F' \\<Longrightarrow>\n       liftmap f (fm.Atom x) 0 = map_atom (f 0) (fm.Atom x)\n 4. \\<And>F1 F2.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        \\<exists>F'. convert_fm var (And F1 F2) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (And F1 F2) 0 =\n                         map_atom (f 0) (And F1 F2)\n 5. \\<And>F1 F2.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        \\<exists>F'. convert_fm var (Or F1 F2) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (Or F1 F2) 0 = map_atom (f 0) (Or F1 F2)\n 6. \\<And>F.\n       \\<lbrakk>\\<exists>F'. convert_fm var F xs = Some F' \\<Longrightarrow>\n                liftmap f F 0 = map_atom (f 0) F;\n        \\<exists>F'. convert_fm var (Neg F) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (Neg F) 0 = map_atom (f 0) (Neg F)\n 7. \\<And>F.\n       \\<lbrakk>\\<exists>F'. convert_fm var F xs = Some F' \\<Longrightarrow>\n                liftmap f F 0 = map_atom (f 0) F;\n        \\<exists>F'. convert_fm var (ExQ F) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (ExQ F) 0 = map_atom (f 0) (ExQ F)\n 8. \\<And>F.\n       \\<lbrakk>\\<exists>F'. convert_fm var F xs = Some F' \\<Longrightarrow>\n                liftmap f F 0 = map_atom (f 0) F;\n        \\<exists>F'. convert_fm var (AllQ F) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (AllQ F) 0 = map_atom (f 0) (AllQ F)\n 9. \\<And>x1 F.\n       \\<lbrakk>\\<exists>F'. convert_fm var F xs = Some F' \\<Longrightarrow>\n                liftmap f F 0 = map_atom (f 0) F;\n        \\<exists>F'. convert_fm var (ExN x1 F) xs = Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f (ExN x1 F) 0 = map_atom (f 0) (ExN x1 F)\n 10. \\<And>x1 F.\n        \\<lbrakk>\\<exists>F'.\n                    convert_fm var F xs = Some F' \\<Longrightarrow>\n                 liftmap f F 0 = map_atom (f 0) F;\n         \\<exists>F'. convert_fm var (AllN x1 F) xs = Some F'\\<rbrakk>\n        \\<Longrightarrow> liftmap f (AllN x1 F) 0 =\n                          map_atom (f 0) (AllN x1 F)", "apply(auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (AndUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F1 0 = map_atom (f 0) F1\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (AndUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F1 0 = map_atom (f 0) F1\n 4. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (AndUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F1 0 = map_atom (f 0) F1\n 3. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2", "apply (metis (no_types, lifting) isSome.elims(2) isSome.elims(3) option.case_eq_if)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F1 0 = map_atom (f 0) F1\n 2. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F1 F2 F'.\n       \\<lbrakk>\\<exists>F'.\n                   convert_fm var F1 xs = Some F' \\<Longrightarrow>\n                liftmap f F1 0 = map_atom (f 0) F1;\n        \\<exists>F'. convert_fm var F2 xs = Some F' \\<Longrightarrow>\n        liftmap f F2 0 = map_atom (f 0) F2;\n        (case convert_fm var F1 xs of None \\<Rightarrow> None\n         | Some a \\<Rightarrow>\n             case convert_fm var F2 xs of None \\<Rightarrow> None\n             | Some b \\<Rightarrow> Some (OrUni a b)) =\n        Some F'\\<rbrakk>\n       \\<Longrightarrow> liftmap f F2 0 = map_atom (f 0) F2", "by (metis (no_types, lifting) isSome.elims(2) isSome.elims(3) option.case_eq_if)"], ["", "lemma eval_map : \"(\\<exists>l\\<in>set(map f L). evalUni l x) = (\\<exists>l\\<in>set(L). evalUni (f l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set (map f L). evalUni l x) =\n    (\\<exists>l\\<in>set L. evalUni (f l) x)", "by auto"], ["", "lemma eval_map_all : \"(\\<forall>l\\<in>set(map f L). evalUni l x) = (\\<forall>l\\<in>set(L). evalUni (f l) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (map f L). evalUni l x) =\n    (\\<forall>l\\<in>set L. evalUni (f l) x)", "by auto"], ["", "lemma eval_append : \"(\\<exists>l\\<in>set (A#B).evalUni l x) = (evalUni A x \\<or> (\\<exists>l\\<in>set (B).evalUni l x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l\\<in>set (A # B). evalUni l x) =\n    (evalUni A x \\<or> (\\<exists>l\\<in>set B. evalUni l x))", "by auto"], ["", "lemma eval_conj_atom : \"evalUni (list_conj_Uni (map AtomUni L)) x = (\\<forall>l\\<in>set(L). aEvalUni l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalUni (list_conj_Uni (map AtomUni L)) x =\n    (\\<forall>l\\<in>set L. aEvalUni l x)", "unfolding eval_list_conj_Uni"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l\\<in>set (map AtomUni L). evalUni l x) =\n    (\\<forall>l\\<in>set L. aEvalUni l x)", "by auto"], ["", "end"]]}