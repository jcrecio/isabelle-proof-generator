{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/Reindex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma swap_swap : \"swap i j (swap i j x) = x\"", "lemma finite_swap_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (swap b i x) \\<noteq> c}\"", "lemma swap0_swap0: \"swap0 n i (swap0 n i x) = x\"", "lemma inj_swap: \"inj (swap b i)\"", "lemma inj_swap0: \"inj (swap0 b i)\"", "lemma swap0_eq: \"lookup (swap0 b i p) x = lookup p (swap b i x)\"", "lemma eq_onp_swap : \"eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0}) (\\<lambda>x. lookup m (swap b i x))\n   (\\<lambda>x. lookup m (swap b i x))\"", "lemma keys_swap: \"keys (swap0 b i m) = swap b i ` keys m\"", "lemma compute_swap\\<^sub>f[code]: \"swap\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)\"", "lemma compute_swap[code]: \"swap0 n i (Pm_fmap xs) = Pm_fmap (swap\\<^sub>f n i xs)\"", "lemma swap_zero[simp]: \"swap0 b i 0 = 0\"", "lemma keys_swap\\<^sub>0: \"keys (swapPoly\\<^sub>0 b i mp) = swap0 b i ` (keys mp)\"", "lemma compute_swapPoly\\<^sub>0[code]: \"swapPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (swapPoly\\<^sub>f n i m)\"", "lemma compute_swapPoly\\<^sub>f[code]: \"swapPoly\\<^sub>f n i (fmap_of_list xs) =\n  (fmap_of_list (map (\\<lambda>(mon, c). (swap0 n i mon, c))\n    xs))\"", "lemma coeff_swap_poly: \"MPoly_Type.coeff (swap_poly b i mp) x = MPoly_Type.coeff mp (swap0 b i x)\"", "lemma monomials_swap_poly: \"monomials (swap_poly b i mp) = swap0 b i ` (monomials mp) \"", "lemma swap_list_cons: \"swap_list (Suc a) (Suc b) (x # L) = x # swap_list a b L\"", "lemma inj_on : \"inj_on (swap0 a b) (monomials p)\"", "lemma inj_on' : \"inj_on (swap a b) (keys m)\"", "lemma swap_list : \n  assumes  \"a < length L\"\n  assumes \"b < length L\"\n  shows \"nth_default 0 (L[b := L ! a, a := L ! b]) (swap a b xa) = nth_default 0 L xa\"", "lemma swap_poly : \n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"insertion (nth_default 0 L) p = insertion (nth_default 0 (swap_list a b L)) (swap_poly a b p)\"", "lemma swap_fm :\n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"eval F L = eval (swap_fm a b F) (swap_list a b L)\"", "lemma \"eval (ExQ (ExQ F)) L = eval (ExQ (ExQ (swap_fm 0 1 F))) L\"", "lemma swap_atom:\n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"aEval F L = aEval (swap_atom a b F) (swap_list a b L)\""], "translations": [["", "lemma swap_swap : \"swap i j (swap i j x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap i j (swap i j x) = x", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if x = i then j else if x = j then i else x) = i then j\n     else if (if x = i then j else if x = j then i else x) = j then i\n          else if x = i then j else if x = j then i else x) =\n    x", "by auto"], ["", "lemma finite_swap_ne: \"finite {x. f x \\<noteq> c} \\<Longrightarrow> finite {x. f (swap b i x) \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "assume finset: \"finite {x. f x \\<noteq> c}\""], ["proof (state)\nthis:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "let ?A = \"{x. f x \\<noteq> c}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "let ?B = \"{x. f (swap b i x) \\<noteq> c}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "have finsubset: \"finite (?A - {i, b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({x. f x \\<noteq> c} - {i, b})", "using finset"], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. finite ({x. f x \\<noteq> c} - {i, b})", "by auto"], ["proof (state)\nthis:\n  finite ({x. f x \\<noteq> c} - {i, b})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "have sames: \"(?A - {i, b}) = (?B - {i, b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f x \\<noteq> c} - {i, b} = {x. f (swap b i x) \\<noteq> c} - {i, b}", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f x \\<noteq> c} - {i, b} =\n    {x. f (if x = b then i else if x = i then b else x) \\<noteq> c} - {i, b}", "by auto"], ["proof (state)\nthis:\n  {x. f x \\<noteq> c} - {i, b} = {x. f (swap b i x) \\<noteq> c} - {i, b}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "then"], ["proof (chain)\npicking this:\n  {x. f x \\<noteq> c} - {i, b} = {x. f (swap b i x) \\<noteq> c} - {i, b}", "have \"finite (?B - {i, b})\""], ["proof (prove)\nusing this:\n  {x. f x \\<noteq> c} - {i, b} = {x. f (swap b i x) \\<noteq> c} - {i, b}\n\ngoal (1 subgoal):\n 1. finite ({x. f (swap b i x) \\<noteq> c} - {i, b})", "using finsubset"], ["proof (prove)\nusing this:\n  {x. f x \\<noteq> c} - {i, b} = {x. f (swap b i x) \\<noteq> c} - {i, b}\n  finite ({x. f x \\<noteq> c} - {i, b})\n\ngoal (1 subgoal):\n 1. finite ({x. f (swap b i x) \\<noteq> c} - {i, b})", "by auto"], ["proof (state)\nthis:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "then"], ["proof (chain)\npicking this:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b})", "have finBset: \"finite ((?B - {i, b}) \\<union> {i, b})\""], ["proof (prove)\nusing this:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b})\n\ngoal (1 subgoal):\n 1. finite ({x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b})", "by auto"], ["proof (state)\nthis:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b})\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "then"], ["proof (chain)\npicking this:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b})", "have \"?B \\<subseteq> ((?B - {i, b}) \\<union> {i, b})\""], ["proof (prove)\nusing this:\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b})\n\ngoal (1 subgoal):\n 1. {x. f (swap b i x) \\<noteq> c}\n    \\<subseteq> {x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b}", "by auto"], ["proof (state)\nthis:\n  {x. f (swap b i x) \\<noteq> c}\n  \\<subseteq> {x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b}\n\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> c} \\<Longrightarrow>\n    finite {x. f (swap b i x) \\<noteq> c}", "then"], ["proof (chain)\npicking this:\n  {x. f (swap b i x) \\<noteq> c}\n  \\<subseteq> {x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. f (swap b i x) \\<noteq> c}\n  \\<subseteq> {x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b}\n\ngoal (1 subgoal):\n 1. finite {x. f (swap b i x) \\<noteq> c}", "using finBset"], ["proof (prove)\nusing this:\n  {x. f (swap b i x) \\<noteq> c}\n  \\<subseteq> {x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b}\n  finite ({x. f (swap b i x) \\<noteq> c} - {i, b} \\<union> {i, b})\n\ngoal (1 subgoal):\n 1. finite {x. f (swap b i x) \\<noteq> c}", "by auto"], ["proof (state)\nthis:\n  finite {x. f (swap b i x) \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition swap0::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'a::zero)\"\n  is \"\\<lambda>b i p x. p (swap b i x)::'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap nat1 nat2 x) \\<noteq> (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap nat1 nat2 x) \\<noteq> (0::'a)}", "fix b i::nat and p::\"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap nat1 nat2 x) \\<noteq> (0::'a)}", "assume \"finite {x. p x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap nat1 nat2 x) \\<noteq> (0::'a)}", "then"], ["proof (chain)\npicking this:\n  finite {x. p x \\<noteq> (0::'a)}", "have \"finite {x. p (swap b i x) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  finite {x. p x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. p (swap b i x) \\<noteq> (0::'a)}", "by (rule finite_swap_ne)"], ["proof (state)\nthis:\n  finite {x. p (swap b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap nat1 nat2 x) \\<noteq> (0::'a)}", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite {x. p (swap b i x) \\<noteq> (0::'a)}", "show \"finite {x. p (swap b i x)  \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite {x. p (swap b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. p (swap b i x) \\<noteq> (0::'a)}", "by (rule finite_subset) auto"], ["proof (state)\nthis:\n  finite {x. p (swap b i x) \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap0_swap0: \"swap0 n i (swap0 n i x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap0 n i (swap0 n i x) = x", "by transfer (force simp: swap_def)"], ["", "lemma inj_swap: \"inj (swap b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (swap b i)", "using swap_swap"], ["proof (prove)\nusing this:\n  swap ?i ?j (swap ?i ?j ?x) = ?x\n\ngoal (1 subgoal):\n 1. inj (swap b i)", "by (rule inj_on_inverseI)"], ["", "lemma inj_swap0: \"inj (swap0 b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (swap0 b i)", "using swap0_swap0"], ["proof (prove)\nusing this:\n  swap0 ?n ?i (swap0 ?n ?i ?x) = ?x\n\ngoal (1 subgoal):\n 1. inj (swap0 b i)", "by (rule inj_on_inverseI)"], ["", "lemma swap0_eq: \"lookup (swap0 b i p) x = lookup p (swap b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (swap0 b i p) x = lookup p (swap b i x)", "by (simp_all add: swap0.rep_eq)"], ["", "lemma eq_onp_swap : \"eq_onp (\\<lambda>f. finite {x. f x \\<noteq> 0}) (\\<lambda>x. lookup m (swap b i x))\n   (\\<lambda>x. lookup m (swap b i x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_onp (\\<lambda>f. finite {x. f x \\<noteq> (0::'b)})\n     (\\<lambda>x. lookup m (swap b i x)) (\\<lambda>x. lookup m (swap b i x))", "unfolding eq_onp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. lookup m (swap b i x) \\<noteq> (0::'b)} \\<and>\n    (\\<lambda>x. lookup m (swap b i x)) =\n    (\\<lambda>x. lookup m (swap b i x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. lookup m (swap b i x) \\<noteq> (0::'b)}", "apply(rule finite_swap_ne)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. lookup m x \\<noteq> (0::'b)}", "by auto"], ["", "lemma keys_swap: \"keys (swap0 b i m) = swap b i ` keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (swap0 b i m) = swap b i ` keys m", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (swap0 b i m) \\<Longrightarrow>\n       x \\<in> swap b i ` keys m\n 2. \\<And>x xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       swap b i xa \\<in> keys (swap0 b i m)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (swap0 b i m) \\<Longrightarrow> x \\<in> swap b i ` keys m", "unfolding swap0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys\n             (map_fun id (map_fun id (map_fun lookup Abs_poly_mapping))\n               (\\<lambda>b i p x. p (swap b i x)) b i m) \\<Longrightarrow>\n    x \\<in> swap b i ` keys m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys\n             (Abs_poly_mapping\n               (\\<lambda>x. lookup m (swap b i x))) \\<Longrightarrow>\n    x \\<in> swap b i ` keys m", "unfolding keys.abs_eq[OF eq_onp_swap]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {k. lookup m (swap b i k) \\<noteq> (0::'a)} \\<Longrightarrow>\n    x \\<in> swap b i ` keys m", "by (metis (mono_tags, lifting) Reindex.swap_swap image_eqI lookupNotIn mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> keys m \\<Longrightarrow>\n       swap b i xa \\<in> keys (swap0 b i m)", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> keys m \\<Longrightarrow> swap b i y \\<in> keys (swap0 b i m)", "unfolding swap0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> keys m \\<Longrightarrow>\n    swap b i y\n    \\<in> keys\n           (map_fun id (map_fun id (map_fun lookup Abs_poly_mapping))\n             (\\<lambda>b i p x. p (swap b i x)) b i m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> keys m \\<Longrightarrow>\n    swap b i y\n    \\<in> keys (Abs_poly_mapping (\\<lambda>x. lookup m (swap b i x)))", "unfolding keys.abs_eq[OF eq_onp_swap]"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> keys m \\<Longrightarrow>\n    swap b i y \\<in> {k. lookup m (swap b i k) \\<noteq> (0::'a)}", "by (metis (mono_tags, lifting) Reindex.swap_swap lookup_eq_zero_in_keys_contradict mem_Collect_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context includes fmap.lifting begin"], ["", "lift_definition swap\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> (nat, 'a) fmap \\<Rightarrow> (nat, 'a::zero) fmap\"\n  is \"\\<lambda>b i p x. p (swap b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "fix b i::nat and p::\"nat \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "assume \"finite (dom p)\""], ["proof (state)\nthis:\n  finite (dom p)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "then"], ["proof (chain)\npicking this:\n  finite (dom p)", "have \"finite {x. p x \\<noteq> None}\""], ["proof (prove)\nusing this:\n  finite (dom p)\n\ngoal (1 subgoal):\n 1. finite {x. p x \\<noteq> None}", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  finite {x. p x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "have \"dom (\\<lambda>x. p (swap b i x)) = {x. p (swap b i x) \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x. p (swap b i x)) = {x. p (swap b i x) \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  dom (\\<lambda>x. p (swap b i x)) = {x. p (swap b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>x. p (swap b i x)) = {x. p (swap b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. p (swap b i x) \\<noteq> None}", "by (rule finite_swap_ne) fact"], ["proof (state)\nthis:\n  finite {x. p (swap b i x) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "finally"], ["proof (chain)\npicking this:\n  finite (dom (\\<lambda>x. p (swap b i x)))", "have \"finite (dom (\\<lambda>x. p (swap b i x)))\""], ["proof (prove)\nusing this:\n  finite (dom (\\<lambda>x. p (swap b i x)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>x. p (swap b i x)))", "."], ["proof (state)\nthis:\n  finite (dom (\\<lambda>x. p (swap b i x)))\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>x. fun (swap nat1 nat2 x)))", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom (\\<lambda>x. p (swap b i x)))", "show \"finite (dom (\\<lambda>x. p (swap b i x)))\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom (\\<lambda>x. p (swap b i x)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>x. p (swap b i x)))", "by (rule finite_subset) (auto split: if_splits)"], ["proof (state)\nthis:\n  finite (dom (\\<lambda>x. p (swap b i x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_swap\\<^sub>f[code]: \"swap\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. swap\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "have *: \"map_of (map (\\<lambda>(k, y). (swap b i k, y)) (xs)) x =\n    map_of xs (swap b i x)\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs) x =\n    map_of xs (swap b i x)", "apply (rule map_of_map_key_inverse_fun_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set xs \\<Longrightarrow> swap b i (swap b i (fst x)) = fst x\n 2. swap b i (swap b i x) = x", "unfolding swap_swap"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> fst x = fst x\n 2. x = x", "by auto"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs) ?x =\n  map_of xs (swap b i ?x)\n\ngoal (1 subgoal):\n 1. swap\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. swap\\<^sub>f b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "unfolding swap\\<^sub>f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun id (map_fun fmlookup Abs_fmap))\n     (\\<lambda>b i p x. p (swap b i x)) b i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fmap (\\<lambda>x. fmlookup (fmap_of_list xs) (swap b i x)) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "unfolding fmlookup_of_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fmap (\\<lambda>x. map_of xs (swap b i x)) =\n    fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)", "unfolding Finite_Map.fmap_of_list.abs_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fmap (\\<lambda>x. map_of xs (swap b i x)) =\n    Abs_fmap (map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs))", "using map_of_map_key_inverse_fun_eq[where f=\"swap b i\", where g=\"swap b i\", where xs=xs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set xs \\<Longrightarrow>\n              swap b i (swap b i (fst x)) = fst x;\n   swap b i (swap b i ?x) = ?x\\<rbrakk>\n  \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs) ?x =\n                    map_of xs (swap b i ?x)\n\ngoal (1 subgoal):\n 1. Abs_fmap (\\<lambda>x. map_of xs (swap b i x)) =\n    Abs_fmap (map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs))", "unfolding swap_swap"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> fst x = fst x;\n   ?x = ?x\\<rbrakk>\n  \\<Longrightarrow> map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs) ?x =\n                    map_of xs (swap b i ?x)\n\ngoal (1 subgoal):\n 1. Abs_fmap (\\<lambda>x. map_of xs (swap b i x)) =\n    Abs_fmap (map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs) x =\n        map_of xs (swap b i x)) \\<Longrightarrow>\n    Abs_fmap (\\<lambda>x. map_of xs (swap b i x)) =\n    Abs_fmap (map_of (map (\\<lambda>(k, y). (swap b i k, y)) xs))", "by presburger"], ["proof (state)\nthis:\n  swap\\<^sub>f b i (fmap_of_list xs) =\n  fmap_of_list (map (\\<lambda>(k, v). (swap b i k, v)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_swap[code]: \"swap0 n i (Pm_fmap xs) = Pm_fmap (swap\\<^sub>f n i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap0 n i (Pm_fmap xs) = Pm_fmap (swap\\<^sub>f n i xs)", "apply(rule poly_mapping_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (swap0 n i (Pm_fmap xs)) k =\n       lookup (Pm_fmap (swap\\<^sub>f n i xs)) k", "by  (auto simp: swap\\<^sub>f.rep_eq swap0.rep_eq fmlookup_default_def swap_def\n      split: option.splits)"], ["", "lift_definition swapPoly\\<^sub>0::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0'a::zero) \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>\\<^sub>0 'a)\" is\n  \"\\<lambda>b i (mp::(nat\\<Rightarrow>\\<^sub>0nat)\\<Rightarrow>'a) mon. mp (swap0 b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "assume \"finite {x. mp x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "have \"{x. mp (swap0 b i x) \\<noteq> 0} = (swap0 b i -` {x. mp x \\<noteq> 0})\"\n    (is \"?set = ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. mp (swap0 b i x) \\<noteq> (0::'a)} =\n    swap0 b i -` {x. mp x \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. mp (swap0 b i x) \\<noteq> (0::'a)} =\n  swap0 b i -` {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "also"], ["proof (state)\nthis:\n  {x. mp (swap0 b i x) \\<noteq> (0::'a)} =\n  swap0 b i -` {x. mp x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "from finite_vimageI[OF \\<open>finite _\\<close> inj_swap0]"], ["proof (chain)\npicking this:\n  finite (swap0 ?b1 ?i1 -` {x. mp x \\<noteq> (0::'a)})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite (swap0 ?b1 ?i1 -` {x. mp x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. finite (swap0 b i -` {x. mp x \\<noteq> (0::'a)})", "."], ["proof (state)\nthis:\n  finite (swap0 b i -` {x. mp x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite {x. fun x \\<noteq> (0::'a)} \\<Longrightarrow>\n       finite {x. fun (swap0 nat1 nat2 x) \\<noteq> (0::'a)}", "finally"], ["proof (chain)\npicking this:\n  finite {x. mp (swap0 b i x) \\<noteq> (0::'a)}", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite {x. mp (swap0 b i x) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. finite {x. mp (swap0 b i x) \\<noteq> (0::'a)}", "."], ["proof (state)\nthis:\n  finite {x. mp (swap0 b i x) \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_zero[simp]: \"swap0 b i 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap0 b i 0 = 0", "by transfer auto"], ["", "context includes fmap.lifting begin"], ["", "lift_definition swapPoly\\<^sub>f::\"nat \\<Rightarrow> nat \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a::zero)fmap \\<Rightarrow> ((nat\\<Rightarrow>\\<^sub>0nat), 'a)fmap\" is\n  \"\\<lambda>b i (mp::((nat\\<Rightarrow>\\<^sub>0nat)\\<rightharpoonup>'a)) mon::(nat\\<Rightarrow>\\<^sub>0nat). mp (swap0 b i mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "proof -\\<comment> \\<open>TODO: this is exactly the same proof as the one for \\<open>lowerPoly\\<^sub>0\\<close>\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "fix b i and mp::\"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "assume \"finite (dom mp)\""], ["proof (state)\nthis:\n  finite (dom mp)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  finite (dom mp)\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "have \"dom mp = {x. mp x \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom mp = {x. mp x \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  dom mp = {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "finally"], ["proof (chain)\npicking this:\n  finite {x. mp x \\<noteq> None}", "have \"finite {x. mp x \\<noteq> None}\""], ["proof (prove)\nusing this:\n  finite {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. finite {x. mp x \\<noteq> None}", "."], ["proof (state)\nthis:\n  finite {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "have \"(dom (\\<lambda>mon. mp (swap0 b i mon))) = {mon. mp (swap0 b i mon) \\<noteq> None}\"\n    (is \"?set = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>mon. mp (swap0 b i mon)) =\n    {mon. mp (swap0 b i mon) \\<noteq> None}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  dom (\\<lambda>mon. mp (swap0 b i mon)) =\n  {mon. mp (swap0 b i mon) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  dom (\\<lambda>mon. mp (swap0 b i mon)) =\n  {mon. mp (swap0 b i mon) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "have \"\\<dots> = swap0 b i -` {x. mp x \\<noteq> None}\" (is \"_ = ?vimage\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {mon. mp (swap0 b i mon) \\<noteq> None} =\n    swap0 b i -` {x. mp x \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  {mon. mp (swap0 b i mon) \\<noteq> None} =\n  swap0 b i -` {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "also"], ["proof (state)\nthis:\n  {mon. mp (swap0 b i mon) \\<noteq> None} =\n  swap0 b i -` {x. mp x \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "from finite_vimageI[OF \\<open>finite {x. mp x \\<noteq> None}\\<close> inj_swap0]"], ["proof (chain)\npicking this:\n  finite (swap0 ?b1 ?i1 -` {x. mp x \\<noteq> None})", "have \"finite ?vimage\""], ["proof (prove)\nusing this:\n  finite (swap0 ?b1 ?i1 -` {x. mp x \\<noteq> None})\n\ngoal (1 subgoal):\n 1. finite (swap0 b i -` {x. mp x \\<noteq> None})", "."], ["proof (state)\nthis:\n  finite (swap0 b i -` {x. mp x \\<noteq> None})\n\ngoal (1 subgoal):\n 1. \\<And>nat1 nat2 fun.\n       finite (dom fun) \\<Longrightarrow>\n       finite (dom (\\<lambda>mon. fun (swap0 nat1 nat2 mon)))", "finally"], ["proof (chain)\npicking this:\n  finite (dom (\\<lambda>mon. mp (swap0 b i mon)))", "show \"finite ?set\""], ["proof (prove)\nusing this:\n  finite (dom (\\<lambda>mon. mp (swap0 b i mon)))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<lambda>mon. mp (swap0 b i mon)))", "."], ["proof (state)\nthis:\n  finite (dom (\\<lambda>mon. mp (swap0 b i mon)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_swap\\<^sub>0: \"keys (swapPoly\\<^sub>0 b i mp) = swap0 b i ` (keys mp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (swapPoly\\<^sub>0 b i mp) = swap0 b i ` keys mp", "apply (auto )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> keys (swapPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n       x \\<in> swap0 b i ` keys mp\n 2. \\<And>xa.\n       xa \\<in> keys mp \\<Longrightarrow>\n       swap0 b i xa \\<in> keys (swapPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys (swapPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x \\<in> swap0 b i ` keys mp", "apply (rule image_eqI[where x=\"swap0 b i x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> keys (swapPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    x = swap0 b i (swap0 b i x)\n 2. x \\<in> keys (swapPoly\\<^sub>0 b i mp) \\<Longrightarrow>\n    swap0 b i x \\<in> keys mp", "by (auto simp: swap0_swap0 in_keys_iff swapPoly\\<^sub>0.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys mp \\<Longrightarrow>\n       swap0 b i xa \\<in> keys (swapPoly\\<^sub>0 b i mp)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> keys mp \\<Longrightarrow>\n    swap0 b i x \\<in> keys (swapPoly\\<^sub>0 b i mp)", "apply (auto simp: in_keys_iff swapPoly\\<^sub>0.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup mp x \\<noteq> (0::'a);\n     lookup mp (swap0 b i (swap0 b i x)) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: swap0_swap0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma compute_swapPoly\\<^sub>0[code]: \"swapPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (swapPoly\\<^sub>f n i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapPoly\\<^sub>0 n i (Pm_fmap m) = Pm_fmap (swapPoly\\<^sub>f n i m)", "by (auto simp: swapPoly\\<^sub>0.rep_eq fmlookup_default_def swapPoly\\<^sub>f.rep_eq\n      split: option.splits\n      intro!: poly_mapping_eqI)"], ["", "lemma compute_swapPoly\\<^sub>f[code]: \"swapPoly\\<^sub>f n i (fmap_of_list xs) =\n  (fmap_of_list (map (\\<lambda>(mon, c). (swap0 n i mon, c))\n    xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapPoly\\<^sub>f n i (fmap_of_list xs) =\n    fmap_of_list (map (\\<lambda>(mon, c). (swap0 n i mon, c)) xs)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list (map (\\<lambda>(mon, c). (swap0 n i mon, c)) xs) =\n    swapPoly\\<^sub>f n i (fmap_of_list xs)", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup\n        (fmap_of_list (map (\\<lambda>(mon, c). (swap0 n i mon, c)) xs)) x =\n       fmlookup (swapPoly\\<^sub>f n i (fmap_of_list xs)) x", "unfolding swapPoly\\<^sub>f.rep_eq fmlookup_of_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of (map (\\<lambda>(mon, y). (swap0 n i mon, y)) xs) x =\n       map_of xs (swap0 n i x)", "apply (subst map_of_map_key_inverse_fun_eq[where g=\"swap0 n i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> set xs \\<Longrightarrow>\n       swap0 n i (swap0 n i (fst xa)) = fst xa\n 2. \\<And>x. swap0 n i (swap0 n i x) = x\n 3. \\<And>x. map_of xs (swap0 n i x) = map_of xs (swap0 n i x)", "unfolding swap0_swap0"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa. xa \\<in> set xs \\<Longrightarrow> fst xa = fst xa\n 2. \\<And>x. x = x\n 3. \\<And>x. map_of xs (swap0 n i x) = map_of xs (swap0 n i x)", "by auto"], ["", "end"], ["", "end"], ["", "lift_definition swap_poly::\"nat \\<Rightarrow> nat \\<Rightarrow> 'a::zero mpoly \\<Rightarrow> 'a mpoly\" is swapPoly\\<^sub>0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "value \"swap_poly 0 1 (Var 0 :: real mpoly)\""], ["", "lemma coeff_swap_poly: \"MPoly_Type.coeff (swap_poly b i mp) x = MPoly_Type.coeff mp (swap0 b i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (swap_poly b i mp) x =\n    MPoly_Type.coeff mp (swap0 b i x)", "by (transfer') (simp add: swapPoly\\<^sub>0.rep_eq)"], ["", "lemma monomials_swap_poly: \"monomials (swap_poly b i mp) = swap0 b i ` (monomials mp) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomials (swap_poly b i mp) = swap0 b i ` monomials mp", "by transfer' (simp add: keys_swap\\<^sub>0)"], ["", "fun swap_atom :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom \\<Rightarrow> atom\" where\n  \"swap_atom a b (Eq p) = Eq (swap_poly a b p)\"|\n  \"swap_atom a b (Less p) = Less (swap_poly a b p)\"|\n  \"swap_atom a b (Leq p) = Leq (swap_poly a b p)\"|\n  \"swap_atom a b (Neq p) = Neq (swap_poly a b p)\""], ["", "fun swap_fm :: \"nat \\<Rightarrow> nat \\<Rightarrow> atom fm \\<Rightarrow> atom fm\" where\n  \"swap_fm a b TrueF = TrueF\"|\n  \"swap_fm a b FalseF = FalseF\"|\n  \"swap_fm a b (Atom At) = Atom(swap_atom a b At)\"|\n  \"swap_fm a b (And A B) = And(swap_fm a b A)(swap_fm a b B)\"|\n  \"swap_fm a b (Or A B) = Or(swap_fm a b A)(swap_fm a b B)\"|\n  \"swap_fm a b (Neg A) = Neg(swap_fm a b A)\"|\n  \"swap_fm a b (ExQ A) = ExQ(swap_fm (a+1) (b+1) A)\"|\n  \"swap_fm a b (AllQ A) = AllQ(swap_fm (a+1) (b+1) A)\"|\n  \"swap_fm a b (ExN i A) = ExN i (swap_fm (a+i) (b+i) A)\"|\n  \"swap_fm a b (AllN i A) = AllN i (swap_fm (a+i) (b+i) A)\""], ["", "fun swap_list :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"where\n  \"swap_list i j l = l[j := nth l i, i := nth l j]\""], ["", "lemma swap_list_cons: \"swap_list (Suc a) (Suc b) (x # L) = x # swap_list a b L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_list (Suc a) (Suc b) (x # L) = x # swap_list a b L", "by auto"], ["", "lemma inj_on : \"inj_on (swap0 a b) (monomials p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (swap0 a b) (monomials p)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>monomials p.\n       \\<forall>y\\<in>monomials p.\n          swap0 a b x = swap0 a b y \\<longrightarrow> x = y", "by (metis swap0_swap0)"], ["", "lemma inj_on' : \"inj_on (swap a b) (keys m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (swap a b) (keys m)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>keys m.\n       \\<forall>y\\<in>keys m.\n          swap a b x = swap a b y \\<longrightarrow> x = y", "by (meson Reindex.inj_swap injD)"], ["", "lemma swap_list : \n  assumes  \"a < length L\"\n  assumes \"b < length L\"\n  shows \"nth_default 0 (L[b := L ! a, a := L ! b]) (swap a b xa) = nth_default 0 L xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a) (L[b := L ! a, a := L ! b]) (swap a b xa) =\n    nth_default (0::'a) L xa", "using assms"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (L[b := L ! a, a := L ! b]) (swap a b xa) =\n    nth_default (0::'a) L xa", "unfolding swap_def"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. nth_default (0::'a) (L[b := L ! a, a := L ! b])\n     (if xa = a then b else if xa = b then a else xa) =\n    nth_default (0::'a) L xa", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a < length L; b < length L; xa = b; b \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> nth_default (0::'a) (L[b := L ! a, a := L ! b]) a =\n                      nth_default (0::'a) L b\n 2. \\<lbrakk>a < length L; b < length L; a \\<noteq> b; xa = a\\<rbrakk>\n    \\<Longrightarrow> nth_default (0::'a) (L[b := L ! a, a := L ! b]) b =\n                      nth_default (0::'a) L a\n 3. \\<lbrakk>a < length L; b < length L; xa \\<noteq> b;\n     xa \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> nth_default (0::'a) (L[b := L ! a, a := L ! b]) xa =\n                      nth_default (0::'a) L xa", "apply (simp_all add: nth_default_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < length L; b < length L; xa \\<noteq> b;\n     xa \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> nth_default (0::'a) (L[b := L ! a, a := L ! b]) xa =\n                      nth_default (0::'a) L xa", "by (simp add: nth_default_def)"], ["", "lemma swap_poly : \n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"insertion (nth_default 0 L) p = insertion (nth_default 0 (swap_list a b L)) (swap_poly a b p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default (0::'a) L) p =\n    insertion (nth_default (0::'a) (swap_list a b L)) (swap_poly a b p)", "unfolding insertion_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (swap_poly a b p).\n       MPoly_Type.coeff (swap_poly a b p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (swap_list a b L) k ^ lookup m k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (swap_poly a b p).\n       MPoly_Type.coeff (swap_poly a b p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^ lookup m k))", "unfolding monomials.abs_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>m\\<in>monomials (swap_poly a b p).\n       MPoly_Type.coeff (swap_poly a b p) m *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^ lookup m k))", "unfolding coeff_swap_poly monomials_swap_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>m\\<in>swap0 a b ` monomials p.\n       MPoly_Type.coeff p (swap0 a b m) *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^ lookup m k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>m\\<in>swap0 a b ` monomials p.\n       MPoly_Type.coeff p (swap0 a b m) *\n       (\\<Prod>k\\<in>keys m.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^ lookup m k))", "unfolding Groups_Big.comm_monoid_add_class.sum.reindex[OF inj_on]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    sum ((\\<lambda>m.\n             MPoly_Type.coeff p (swap0 a b m) *\n             (\\<Prod>k\\<in>keys m.\n                nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^\n                lookup m k)) \\<circ>\n         swap0 a b)\n     (monomials p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p (swap0 a b (swap0 a b x)) *\n       (\\<Prod>k\\<in>keys (swap0 a b x).\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^\n          lookup (swap0 a b x) k))", "unfolding swap0_swap0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>keys (swap0 a b x).\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^\n          lookup (swap0 a b x) k))", "unfolding keys_swap"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p x *\n       (\\<Prod>k\\<in>swap a b ` keys x.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^\n          lookup (swap0 a b x) k))", "unfolding Groups_Big.comm_monoid_mult_class.prod.reindex[OF inj_on']"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p x *\n       prod\n        ((\\<lambda>k.\n             nth_default (0::'a) (L[b := L ! a, a := L ! b]) k ^\n             lookup (swap0 a b x) k) \\<circ>\n         swap a b)\n        (keys x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p x *\n       (\\<Prod>xa\\<in>keys x.\n          nth_default (0::'a) (L[b := L ! a, a := L ! b]) (swap a b xa) ^\n          lookup (swap0 a b x) (swap a b xa)))", "unfolding swap0_eq swap_swap swap_list[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>monomials p.\n       MPoly_Type.coeff p m *\n       (\\<Prod>k\\<in>keys m. nth_default (0::'a) L k ^ lookup m k)) =\n    (\\<Sum>x\\<in>monomials p.\n       MPoly_Type.coeff p x *\n       (\\<Prod>xa\\<in>keys x. nth_default (0::'a) L xa ^ lookup x xa))", "by auto"], ["", "lemma swap_fm :\n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"eval F L = eval (swap_fm a b F) (swap_list a b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F L = eval (swap_fm a b F) (swap_list a b L)", "using assms"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval F L = eval (swap_fm a b F) (swap_list a b L)", "proof(induction F arbitrary: a b L)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval TrueF L =\n                         eval (swap_fm a b TrueF) (swap_list a b L)\n 2. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF L =\n                         eval (swap_fm a b FalseF) (swap_list a b L)\n 3. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 4. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 5. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 7. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 8. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 9. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 10. \\<And>x1 F a b L.\n        \\<lbrakk>\\<And>a b L.\n                    \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                    \\<Longrightarrow> eval F L =\neval (swap_fm a b F) (swap_list a b L);\n         a < length L; b < length L\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) L =\n                          eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case TrueF"], ["proof (state)\nthis:\n  a < length L\n  b < length L\n\ngoal (10 subgoals):\n 1. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval TrueF L =\n                         eval (swap_fm a b TrueF) (swap_list a b L)\n 2. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF L =\n                         eval (swap_fm a b FalseF) (swap_list a b L)\n 3. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 4. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 5. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 7. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 8. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 9. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 10. \\<And>x1 F a b L.\n        \\<lbrakk>\\<And>a b L.\n                    \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                    \\<Longrightarrow> eval F L =\neval (swap_fm a b F) (swap_list a b L);\n         a < length L; b < length L\\<rbrakk>\n        \\<Longrightarrow> eval (AllN x1 F) L =\n                          eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval TrueF L = eval (swap_fm a b TrueF) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval TrueF L = eval (swap_fm a b TrueF) (swap_list a b L)\n\ngoal (9 subgoals):\n 1. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF L =\n                         eval (swap_fm a b FalseF) (swap_list a b L)\n 2. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 4. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 7. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 9. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF L =\n                         eval (swap_fm a b FalseF) (swap_list a b L)\n 2. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 4. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 7. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 9. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case FalseF"], ["proof (state)\nthis:\n  a < length L\n  b < length L\n\ngoal (9 subgoals):\n 1. \\<And>a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval FalseF L =\n                         eval (swap_fm a b FalseF) (swap_list a b L)\n 2. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 4. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 7. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 9. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval FalseF L = eval (swap_fm a b FalseF) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval FalseF L = eval (swap_fm a b FalseF) (swap_list a b L)\n\ngoal (8 subgoals):\n 1. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (Atom At)"], ["proof (state)\nthis:\n  a < length L\n  b < length L\n\ngoal (8 subgoals):\n 1. \\<And>x a b L.\n       \\<lbrakk>a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom x) L =\n                         eval (swap_fm a b (fm.Atom x)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 3. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 6. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 8. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval (fm.Atom At) L = eval (swap_fm a b (fm.Atom At)) (swap_list a b L)", "apply(cases At)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>a < length L; b < length L; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 2. \\<And>x2.\n       \\<lbrakk>a < length L; b < length L; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 3. \\<And>x3.\n       \\<lbrakk>a < length L; b < length L; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 4. \\<And>x4.\n       \\<lbrakk>a < length L; b < length L; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)", "using swap_poly[OF Atom(1) Atom(2)]"], ["proof (prove)\nusing this:\n  insertion (nth_default 0 L) ?p =\n  insertion (nth_default 0 (swap_list a b L)) (swap_poly a b ?p)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>a < length L; b < length L; At = Less x1\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 2. \\<And>x2.\n       \\<lbrakk>a < length L; b < length L; At = Eq x2\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 3. \\<And>x3.\n       \\<lbrakk>a < length L; b < length L; At = Leq x3\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n 4. \\<And>x4.\n       \\<lbrakk>a < length L; b < length L; At = Neq x4\\<rbrakk>\n       \\<Longrightarrow> eval (fm.Atom At) L =\n                         eval (swap_fm a b (fm.Atom At)) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval (fm.Atom At) L = eval (swap_fm a b (fm.Atom At)) (swap_list a b L)\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (And F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 ?L =\n                    eval (swap_fm ?a ?b F1) (swap_list ?a ?b ?L)\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 ?L =\n                    eval (swap_fm ?a ?b F2) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (7 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (And F1 F2) L =\n                         eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n 2. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 5. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 7. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (And F1 F2) L = eval (swap_fm a b (And F1 F2)) (swap_list a b L)", "using And(1)[OF And(3-4)] And(2)[OF And(3-4)]"], ["proof (prove)\nusing this:\n  eval F1 L = eval (swap_fm a b F1) (swap_list a b L)\n  eval F2 L = eval (swap_fm a b F2) (swap_list a b L)\n\ngoal (1 subgoal):\n 1. eval (And F1 F2) L = eval (swap_fm a b (And F1 F2)) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval (And F1 F2) L = eval (swap_fm a b (And F1 F2)) (swap_list a b L)\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (Or F1 F2)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 ?L =\n                    eval (swap_fm ?a ?b F1) (swap_list ?a ?b ?L)\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 ?L =\n                    eval (swap_fm ?a ?b F2) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (6 subgoals):\n 1. \\<And>F1 F2 a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F1 L =\n                                     eval (swap_fm a b F1)\n(swap_list a b L);\n        \\<And>a b L.\n           \\<lbrakk>a < length L; b < length L\\<rbrakk>\n           \\<Longrightarrow> eval F2 L =\n                             eval (swap_fm a b F2) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Or F1 F2) L =\n                         eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 4. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 6. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 ?L =\n                    eval (swap_fm ?a ?b F1) (swap_list ?a ?b ?L)\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 ?L =\n                    eval (swap_fm ?a ?b F2) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 ?L =\n                    eval (swap_fm ?a ?b F1) (swap_list ?a ?b ?L)\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 ?L =\n                    eval (swap_fm ?a ?b F2) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval (Or F1 F2) L = eval (swap_fm a b (Or F1 F2)) (swap_list a b L)", "using Or(1)[OF Or(3-4)] Or(2)[OF Or(3-4)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F1 ?L =\n                    eval (swap_fm ?a ?b F1) (swap_list ?a ?b ?L)\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F2 ?L =\n                    eval (swap_fm ?a ?b F2) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n  eval F1 L = eval (swap_fm a b F1) (swap_list a b L)\n  eval F2 L = eval (swap_fm a b F2) (swap_list a b L)\n\ngoal (1 subgoal):\n 1. eval (Or F1 F2) L = eval (swap_fm a b (Or F1 F2)) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval (Or F1 F2) L = eval (swap_fm a b (Or F1 F2)) (swap_list a b L)\n\ngoal (5 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (Neg F)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (5 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (Neg F) L =\n                         eval (swap_fm a b (Neg F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 3. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 5. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval (Neg F) L = eval (swap_fm a b (Neg F)) (swap_list a b L)", "using Neg(1)[OF Neg(2-3)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n  eval F L = eval (swap_fm a b F) (swap_list a b L)\n\ngoal (1 subgoal):\n 1. eval (Neg F) L = eval (swap_fm a b (Neg F)) (swap_list a b L)", "by auto"], ["proof (state)\nthis:\n  eval (Neg F) L = eval (swap_fm a b (Neg F)) (swap_list a b L)\n\ngoal (4 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (ExQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (4 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExQ F) L =\n                         eval (swap_fm a b (ExQ F)) (swap_list a b L)\n 2. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 4. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExQ F) L = eval (swap_fm a b (ExQ F)) (swap_list a b L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval F (x # L)) =\n    (\\<exists>x.\n        eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b]))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval F (x # L) =\n       eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b])", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (x # L) =\n    eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b])", "using ExQ(1)[of \"Suc a\" \"x#L\" \"Suc b\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F)\n                     (swap_list (Suc a) (Suc b) (x # L))\n\ngoal (1 subgoal):\n 1. eval F (x # L) =\n    eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b])", "unfolding swap_list_cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F) (x # swap_list a b L)\n\ngoal (1 subgoal):\n 1. eval F (x # L) =\n    eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b])", "using ExQ(2-3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F) (x # swap_list a b L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval F (x # L) =\n    eval (swap_fm (Suc a) (Suc b) F) (x # L[b := L ! a, a := L ! b])", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExQ F) L = eval (swap_fm a b (ExQ F)) (swap_list a b L)\n\ngoal (3 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (AllQ F)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (3 subgoals):\n 1. \\<And>F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllQ F) L =\n                         eval (swap_fm a b (AllQ F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 3. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval (AllQ F) L = eval (swap_fm a b (AllQ F)) (swap_list a b L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x. eval F (x # L)) =\n                      (\\<forall>x.\n                          eval (swap_fm (Suc a) (Suc b) F)\n                           (x # L[b := L ! a, a := L ! b]))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>a L b.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F)\n(L[b := L ! a, a := L ! b]);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval F (x # L) =\n                         eval (swap_fm (Suc a) (Suc b) F)\n                          (x # L[b := L ! a, a := L ! b])", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> eval F (x # L) =\n                      eval (swap_fm (Suc a) (Suc b) F)\n                       (x # L[b := L ! a, a := L ! b])", "using AllQ(1)[of \"Suc a\" \"x#L\" \"Suc b\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F)\n                     (swap_list (Suc a) (Suc b) (x # L))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> eval F (x # L) =\n                      eval (swap_fm (Suc a) (Suc b) F)\n                       (x # L[b := L ! a, a := L ! b])", "unfolding swap_list_cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F) (x # swap_list a b L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> eval F (x # L) =\n                      eval (swap_fm (Suc a) (Suc b) F)\n                       (x # L[b := L ! a, a := L ! b])", "using AllQ(2-3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc a < length (x # L); Suc b < length (x # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (x # L) =\n                    eval (swap_fm (Suc a) (Suc b) F) (x # swap_list a b L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> eval F (x # L) =\n                      eval (swap_fm (Suc a) (Suc b) F)\n                       (x # L[b := L ! a, a := L ! b])", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (AllQ F) L = eval (swap_fm a b (AllQ F)) (swap_list a b L)\n\ngoal (2 subgoals):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (ExN i F)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (2 subgoals):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (ExN x1 F) L =\n                         eval (swap_fm a b (ExN x1 F)) (swap_list a b L)\n 2. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN i F) L = eval (swap_fm a b (ExN i F)) (swap_list a b L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = i \\<and> eval F (l @ L)) =\n    (\\<exists>l.\n        length l = i \\<and>\n        eval (swap_fm (a + i) (b + i) F) (l @ L[b := L ! a, a := L ! b]))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       (length l = i \\<and> eval F (l @ L)) =\n       (length l = i \\<and>\n        eval (swap_fm (a + i) (b + i) F) (l @ L[b := L ! a, a := L ! b]))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l = i \\<and> eval F (l @ L)) =\n    (length l = i \\<and>\n     eval (swap_fm (a + i) (b + i) F) (l @ L[b := L ! a, a := L ! b]))", "using ExN(1)[of \"a+i\" \"l@L\" \"b+i\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a + i < length (l @ L); b + i < length (l @ L)\\<rbrakk>\n  \\<Longrightarrow> eval F (l @ L) =\n                    eval (swap_fm (a + i) (b + i) F)\n                     (swap_list (a + i) (b + i) (l @ L))\n\ngoal (1 subgoal):\n 1. (length l = i \\<and> eval F (l @ L)) =\n    (length l = i \\<and>\n     eval (swap_fm (a + i) (b + i) F) (l @ L[b := L ! a, a := L ! b]))", "by (smt (verit, del_insts) ExN.prems(1) ExN.prems(2) add.commute add_diff_cancel_right' add_less_cancel_left length_append list_update_append not_add_less2 nth_append swap_list.elims)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eval (ExN i F) L = eval (swap_fm a b (ExN i F)) (swap_list a b L)\n\ngoal (1 subgoal):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "case (AllN i F)"], ["proof (state)\nthis:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. \\<And>x1 F a b L.\n       \\<lbrakk>\\<And>a b L.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F) (swap_list a b L);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> eval (AllN x1 F) L =\n                         eval (swap_fm a b (AllN x1 F)) (swap_list a b L)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < length ?L; ?b < length ?L\\<rbrakk>\n  \\<Longrightarrow> eval F ?L = eval (swap_fm ?a ?b F) (swap_list ?a ?b ?L)\n  a < length L\n  b < length L\n\ngoal (1 subgoal):\n 1. eval (AllN i F) L = eval (swap_fm a b (AllN i F)) (swap_list a b L)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a L b.\n                \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                \\<Longrightarrow> eval F L =\n                                  eval (swap_fm a b F)\n                                   (L[b := L ! a, a := L ! b]);\n     a < length L; b < length L\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>l.\n                          length l = i \\<longrightarrow> eval F (l @ L)) =\n                      (\\<forall>l.\n                          length l = i \\<longrightarrow>\n                          eval (swap_fm (a + i) (b + i) F)\n                           (l @ L[b := L ! a, a := L ! b]))", "apply(rule all_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>a L b.\n                   \\<lbrakk>a < length L; b < length L\\<rbrakk>\n                   \\<Longrightarrow> eval F L =\n                                     eval (swap_fm a b F)\n(L[b := L ! a, a := L ! b]);\n        a < length L; b < length L\\<rbrakk>\n       \\<Longrightarrow> (length l = i \\<longrightarrow> eval F (l @ L)) =\n                         (length l = i \\<longrightarrow>\n                          eval (swap_fm (a + i) (b + i) F)\n                           (l @ L[b := L ! a, a := L ! b]))", "by (smt (z3) add.commute add_diff_cancel_right' le_add2 length_append less_diff_conv2 list_update_append not_add_less2 nth_append)"], ["proof (state)\nthis:\n  eval (AllN i F) L = eval (swap_fm a b (AllN i F)) (swap_list a b L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"eval (ExQ (ExQ F)) L = eval (ExQ (ExQ (swap_fm 0 1 F))) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExQ (ExQ F)) L = eval (ExQ (ExQ (swap_fm 0 1 F))) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x xa. eval F (xa # x # L)) =\n    (\\<exists>x xa. eval (swap_fm 0 (Suc 0) F) (xa # x # L))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       eval F (xa # x # L) \\<Longrightarrow>\n       \\<exists>x xa. eval (swap_fm 0 (Suc 0) F) (xa # x # L)\n 2. \\<And>x xa.\n       eval (swap_fm 0 (Suc 0) F) (xa # x # L) \\<Longrightarrow>\n       \\<exists>x xa. eval F (xa # x # L)", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (j # i # L) \\<Longrightarrow>\n    \\<exists>x xa. eval (swap_fm 0 (Suc 0) F) (xa # x # L)", "apply(rule exI[where x=j])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (j # i # L) \\<Longrightarrow>\n    \\<exists>x. eval (swap_fm 0 (Suc 0) F) (x # j # L)", "apply(rule exI[where x=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval F (j # i # L) \\<Longrightarrow>\n    eval (swap_fm 0 (Suc 0) F) (i # j # L)", "using swap_fm[of 0 \"j # i # L\" \"Suc 0\" F]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (j # i # L); Suc 0 < length (j # i # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (j # i # L) =\n                    eval (swap_fm 0 (Suc 0) F)\n                     (swap_list 0 (Suc 0) (j # i # L))\n\ngoal (1 subgoal):\n 1. eval F (j # i # L) \\<Longrightarrow>\n    eval (swap_fm 0 (Suc 0) F) (i # j # L)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eval (swap_fm 0 (Suc 0) F) (xa # x # L) \\<Longrightarrow>\n       \\<exists>x xa. eval F (xa # x # L)", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (swap_fm 0 (Suc 0) F) (j # i # L) \\<Longrightarrow>\n    \\<exists>x xa. eval F (xa # x # L)", "apply(rule exI[where x=j])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (swap_fm 0 (Suc 0) F) (j # i # L) \\<Longrightarrow>\n    \\<exists>x. eval F (x # j # L)", "apply(rule exI[where x=i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (swap_fm 0 (Suc 0) F) (j # i # L) \\<Longrightarrow>\n    eval F (i # j # L)", "using swap_fm[of 0 \"i # j # L\" \"Suc 0\" F]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (i # j # L); Suc 0 < length (i # j # L)\\<rbrakk>\n  \\<Longrightarrow> eval F (i # j # L) =\n                    eval (swap_fm 0 (Suc 0) F)\n                     (swap_list 0 (Suc 0) (i # j # L))\n\ngoal (1 subgoal):\n 1. eval (swap_fm 0 (Suc 0) F) (j # i # L) \\<Longrightarrow>\n    eval F (i # j # L)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swap_atom:\n  assumes \"length L > a\"\n  assumes \"length L > b\"\n  shows \"aEval F L = aEval (swap_atom a b F) (swap_list a b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval F L = aEval (swap_atom a b F) (swap_list a b L)", "using swap_fm[OF assms, of \"Atom F\"]"], ["proof (prove)\nusing this:\n  eval (fm.Atom F) L = eval (swap_fm a b (fm.Atom F)) (swap_list a b L)\n\ngoal (1 subgoal):\n 1. aEval F L = aEval (swap_atom a b F) (swap_list a b L)", "by auto"], ["", "end"]]}