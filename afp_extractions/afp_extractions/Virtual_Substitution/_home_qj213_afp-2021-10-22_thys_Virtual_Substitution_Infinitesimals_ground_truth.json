{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/Infinitesimals.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma freeIn_substInfinitesimalQuadratic :\n  assumes \"var \\<notin> vars a\"\n    \"var \\<notin> vars b\"\n    \"var \\<notin> vars c\"\n    \"var \\<notin> vars d\"\n  shows \"freeIn var (substInfinitesimalQuadratic var a b c d At)\"", "lemma freeIn_substInfinitesimalQuadratic_fm : assumes \"var \\<notin> vars a\"\n  \"var \\<notin> vars b\"\n  \"var \\<notin> vars c\"\n  \"var \\<notin> vars d\"\nshows\"freeIn var (substInfinitesimalQuadratic_fm var a b c d F)\"", "lemma freeIn_substInfinitesimalLinear:\n  assumes \"var \\<notin> vars a\" \"var \\<notin> vars b\"\n  shows \"freeIn var (substInfinitesimalLinear var a b At)\"", "lemma freeIn_substInfinitesimalLinear_fm:\n  assumes \"var \\<notin> vars a\" \"var \\<notin> vars b\"\n  shows \"freeIn var (substInfinitesimalLinear_fm var a b F)\""], "translations": [["", "lemma freeIn_substInfinitesimalQuadratic :\n  assumes \"var \\<notin> vars a\"\n    \"var \\<notin> vars b\"\n    \"var \\<notin> vars c\"\n    \"var \\<notin> vars d\"\n  shows \"freeIn var (substInfinitesimalQuadratic var a b c d At)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic var a b c d At)", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic var a b c d At)", "unfolding substInfinitesimalQuadratic.simps Less"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (quadratic_sub_fm var a b c d (convertDerivative var p))", "apply(rule free_in_quad_fm[of var a b c d \"(convertDerivative var p)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. var \\<notin> vars a\n 2. var \\<notin> vars b\n 3. var \\<notin> vars c\n 4. var \\<notin> vars d", "using assms"], ["proof (prove)\nusing this:\n  var \\<notin> vars a\n  var \\<notin> vars b\n  var \\<notin> vars c\n  var \\<notin> vars d\n\ngoal (4 subgoals):\n 1. var \\<notin> vars a\n 2. var \\<notin> vars b\n 3. var \\<notin> vars c\n 4. var \\<notin> vars d", "by auto"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalQuadratic var a b c d At)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic var a b c d At)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. At = Eq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n         [0..<MPoly_Type.degree p var] @\n        [fm.Atom\n          (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. At = Eq p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (\\<lambda>i.\n                                fm.Atom\n                                 (Eq (isolate_variable_sparse p var i)))\n                         [0..<MPoly_Type.degree p var] @\n                        [fm.Atom\n                          (Eq (isolate_variable_sparse p var\n                                (MPoly_Type.degree p var)))]).\n       freeIn var f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Eq p; x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Eq p; x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalQuadratic var a b c d At)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "then"], ["proof (chain)\npicking this:\n  At = Leq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Leq p\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic var a b c d At)", "unfolding substInfinitesimalQuadratic.simps Leq freeIn.simps"], ["proof (prove)\nusing this:\n  Leq p = Leq p\n\ngoal (1 subgoal):\n 1. freeIn var (allZero p var) \\<and>\n    freeIn var (quadratic_sub_fm var a b c d (convertDerivative var p))", "using free_in_quad_fm[of var a b c d \"(convertDerivative var p)\", OF assms]"], ["proof (prove)\nusing this:\n  Leq p = Leq p\n  freeIn var (quadratic_sub_fm var a b c d (convertDerivative var p))\n\ngoal (1 subgoal):\n 1. freeIn var (allZero p var) \\<and>\n    freeIn var (quadratic_sub_fm var a b c d (convertDerivative var p))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x.\n           quadratic_sub (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n            (liftPoly 0 x c) (liftPoly 0 x d))\n       (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0) \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n         [0..<MPoly_Type.degree p var] @\n        [fm.Atom\n          (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x.\n           quadratic_sub (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n            (liftPoly 0 x c) (liftPoly 0 x d))\n       (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0) \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (\\<lambda>i.\n                                fm.Atom\n                                 (Eq (isolate_variable_sparse p var i)))\n                         [0..<MPoly_Type.degree p var] @\n                        [fm.Atom\n                          (Eq (isolate_variable_sparse p var\n                                (MPoly_Type.degree p var)))]).\n       freeIn var f", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x.\n           quadratic_sub (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n            (liftPoly 0 x c) (liftPoly 0 x d))\n       (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0) \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (\\<lambda>i.\n                                fm.Atom\n                                 (Eq (isolate_variable_sparse p var i)))\n                         [0..<MPoly_Type.degree p var] @\n                        [fm.Atom\n                          (Eq (isolate_variable_sparse p var\n                                (MPoly_Type.degree p var)))]).\n       freeIn var f", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalQuadratic var a b c d At)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalQuadratic var a b c d At)", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic var a b c d At)", "apply (auto simp add:neg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (list_conj\n                         (map (\\<lambda>i.\n                                  fm.Atom\n                                   (Eq (isolate_variable_sparse p var i)))\n                           [0..<MPoly_Type.degree p var] @\n                          [fm.Atom\n                            (Eq (isolate_variable_sparse p var\n                                  (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF\\<rbrakk>\n    \\<Longrightarrow> \\<forall>f\\<in>set\n(map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n  [0..<MPoly_Type.degree p var] @\n [fm.Atom (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]).\n                         freeIn var f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Neq p;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        FalseF;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        TrueF;\n        x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Neq p;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        FalseF;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        TrueF;\n        x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalQuadratic var a b c d At)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_substInfinitesimalQuadratic_fm : assumes \"var \\<notin> vars a\"\n  \"var \\<notin> vars b\"\n  \"var \\<notin> vars c\"\n  \"var \\<notin> vars d\"\nshows\"freeIn var (substInfinitesimalQuadratic_fm var a b c d F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "have \"freeIn (var+z)\n     (liftmap\n       (\\<lambda>x. substInfinitesimalQuadratic (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              (liftPoly 0 x c) (liftPoly 0 x d))\n       F z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (liftmap\n       (\\<lambda>x.\n           substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n            (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n       F z)", "apply(induction F arbitrary:z)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          TrueF z)\n 2. \\<And>z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          FalseF z)\n 3. \\<And>x z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          (fm.Atom x) z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (liftmap\n                      (\\<lambda>x.\n                          substInfinitesimalQuadratic (var + x)\n                           (liftPoly 0 x a) (liftPoly 0 x b)\n                           (liftPoly 0 x c) (liftPoly 0 x d))\n                      F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x a) (liftPoly 0 x b)\n                                 (liftPoly 0 x c) (liftPoly 0 x d))\n                            (And F1 F2) z)\n 5. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (liftmap\n                      (\\<lambda>x.\n                          substInfinitesimalQuadratic (var + x)\n                           (liftPoly 0 x a) (liftPoly 0 x b)\n                           (liftPoly 0 x c) (liftPoly 0 x d))\n                      F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalQuadratic (var + x)\n                                 (liftPoly 0 x a) (liftPoly 0 x b)\n                                 (liftPoly 0 x c) (liftPoly 0 x d))\n                            (Or F1 F2) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          (Neg F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          (ExQ F) z)\n 8. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          (AllQ F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          (ExN x1 F) z)\n 10. \\<And>x1 F z.\n        (\\<And>z.\n            freeIn (var + z)\n             (liftmap\n               (\\<lambda>x.\n                   substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                    (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n               F z)) \\<Longrightarrow>\n        freeIn (var + z)\n         (liftmap\n           (\\<lambda>x.\n               substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n           (AllN x1 F) z)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x z.\n       freeIn (var + z)\n        (substInfinitesimalQuadratic (var + z) (liftPoly 0 z a)\n          (liftPoly 0 z b) (liftPoly 0 z c) (liftPoly 0 z d) x)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "apply(rule freeIn_substInfinitesimalQuadratic)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z a)\n 2. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z b)\n 3. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z c)\n 4. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z d)\n 5. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 7. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))\n 8. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "apply (simp_all add: assms not_in_lift)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "apply (metis (no_types, lifting) add_Suc_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (Suc z))\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "apply (metis (mono_tags, lifting) add_Suc_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "apply (simp add: ab_semigroup_add_class.add_ac(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n          F (z + x1))", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  freeIn (var + z)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n     F z)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "}"], ["proof (state)\nthis:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n     F ?z2)", "show ?thesis"], ["proof (prove)\nusing this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalQuadratic_fm var a b c d F)", "unfolding substInfinitesimalQuadratic_fm.simps"], ["proof (prove)\nusing this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x.\n           substInfinitesimalQuadratic (var + x) (liftPoly 0 x a)\n            (liftPoly 0 x b) (liftPoly 0 x c) (liftPoly 0 x d))\n       F 0)", "by (metis (no_types, lifting) add.right_neutral)"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalQuadratic_fm var a b c d F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_substInfinitesimalLinear:\n  assumes \"var \\<notin> vars a\" \"var \\<notin> vars b\"\n  shows \"freeIn var (substInfinitesimalLinear var a b At)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear var a b At)", "proof(cases At)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "case (Less p)"], ["proof (state)\nthis:\n  At = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       At = Less x1 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 3. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 4. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear var a b At)", "unfolding Less substInfinitesimalLinear.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "using var_not_in_linear_fm[of var a b \"(convertDerivative var p)\", OF assms]"], ["proof (prove)\nusing this:\n  freeIn var (linear_substitution_fm var a b (convertDerivative var p))\n\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "unfolding linear_substitution_fm.simps linear_substitution_fm_helper.simps"], ["proof (prove)\nusing this:\n  freeIn var\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n            A))\n     (convertDerivative var p) 0)\n\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "."], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalLinear var a b At)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "case (Eq p)"], ["proof (state)\nthis:\n  At = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       At = Eq x2 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 3. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "then"], ["proof (chain)\npicking this:\n  At = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Eq p\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear var a b At)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. At = Eq p \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n         [0..<MPoly_Type.degree p var] @\n        [fm.Atom\n          (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. At = Eq p \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (\\<lambda>i.\n                                fm.Atom\n                                 (Eq (isolate_variable_sparse p var i)))\n                         [0..<MPoly_Type.degree p var] @\n                        [fm.Atom\n                          (Eq (isolate_variable_sparse p var\n                                (MPoly_Type.degree p var)))]).\n       freeIn var f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Eq p; x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Eq p;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Eq p; x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalLinear var a b At)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "case (Leq p)"], ["proof (state)\nthis:\n  At = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       At = Leq x3 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)\n 2. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear var a b At)", "unfolding Leq substInfinitesimalLinear.simps freeIn.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (allZero p var) \\<and>\n    freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "using var_not_in_linear_fm[of var a b \"(convertDerivative var p)\", OF assms]"], ["proof (prove)\nusing this:\n  freeIn var (linear_substitution_fm var a b (convertDerivative var p))\n\ngoal (1 subgoal):\n 1. freeIn var (allZero p var) \\<and>\n    freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "unfolding linear_substitution_fm.simps linear_substitution_fm_helper.simps"], ["proof (prove)\nusing this:\n  freeIn var\n   (liftmap\n     (\\<lambda>x A.\n         fm.Atom\n          (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n            A))\n     (convertDerivative var p) 0)\n\ngoal (1 subgoal):\n 1. freeIn var (allZero p var) \\<and>\n    freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (convertDerivative var p) 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0) \\<Longrightarrow>\n    freeIn var\n     (list_conj\n       (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n         [0..<MPoly_Type.degree p var] @\n        [fm.Atom\n          (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x A.\n           fm.Atom\n            (linear_substitution (var + x) (liftPoly 0 x a) (liftPoly 0 x b)\n              A))\n       (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n        else Or (fm.Atom (Less p))\n              (And (fm.Atom (Eq p))\n                (convertDerivative var (derivative var p))))\n       0) \\<Longrightarrow>\n    \\<forall>f\\<in>set (map (\\<lambda>i.\n                                fm.Atom\n                                 (Eq (isolate_variable_sparse p var i)))\n                         [0..<MPoly_Type.degree p var] @\n                        [fm.Atom\n                          (Eq (isolate_variable_sparse p var\n                                (MPoly_Type.degree p var)))]).\n       freeIn var f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn var\n              (liftmap\n                (\\<lambda>x A.\n                    fm.Atom\n                     (linear_substitution (var + x) (liftPoly 0 x a)\n                       (liftPoly 0 x b) A))\n                (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n                 else Or (fm.Atom (Less p))\n                       (And (fm.Atom (Eq p))\n                         (convertDerivative var (derivative var p))))\n                0);\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x);\n        freeIn var\n         (fm.Atom\n           (let d = MPoly_Type.degree p var\n            in Less\n                (((\\<Sum>i = 0..<d.\n                      isolate_variable_sparse p var i * liftPoly 0 0 a ^ i *\n                      liftPoly 0 0 b ^ (d - i)) +\n                  isolate_variable_sparse p var d * liftPoly 0 0 a ^ d) *\n                 liftPoly 0 0 b ^ (d mod 2))));\n        freeIn var\n         (fm.Atom\n           (let d = MPoly_Type.degree p var\n            in Eq ((\\<Sum>i = 0..<d.\n                       isolate_variable_sparse p var i *\n                       liftPoly 0 0 a ^ i *\n                       liftPoly 0 0 b ^ (d - i)) +\n                   isolate_variable_sparse p var d * liftPoly 0 0 a ^ d)));\n        freeIn var\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x a)\n                  (liftPoly 0 x b) A))\n           (if MPoly_Type.degree (derivative var p) var = 0\n            then fm.Atom (Less (derivative var p))\n            else Or (fm.Atom (Less (derivative var p)))\n                  (And (fm.Atom (Eq (derivative var p)))\n                    (convertDerivative var\n                      (derivative var (derivative var p)))))\n           0)\\<rbrakk>\n       \\<Longrightarrow> False", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>freeIn var\n              (liftmap\n                (\\<lambda>x A.\n                    fm.Atom\n                     (linear_substitution (var + x) (liftPoly 0 x a)\n                       (liftPoly 0 x b) A))\n                (if MPoly_Type.degree p var = 0 then fm.Atom (Less p)\n                 else Or (fm.Atom (Less p))\n                       (And (fm.Atom (Eq p))\n                         (convertDerivative var (derivative var p))))\n                0);\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x);\n        freeIn var\n         (fm.Atom\n           (let d = MPoly_Type.degree p var\n            in Less\n                (((\\<Sum>i = 0..<d.\n                      isolate_variable_sparse p var i * liftPoly 0 0 a ^ i *\n                      liftPoly 0 0 b ^ (d - i)) +\n                  isolate_variable_sparse p var d * liftPoly 0 0 a ^ d) *\n                 liftPoly 0 0 b ^ (d mod 2))));\n        freeIn var\n         (fm.Atom\n           (let d = MPoly_Type.degree p var\n            in Eq ((\\<Sum>i = 0..<d.\n                       isolate_variable_sparse p var i *\n                       liftPoly 0 0 a ^ i *\n                       liftPoly 0 0 b ^ (d - i)) +\n                   isolate_variable_sparse p var d * liftPoly 0 0 a ^ d)));\n        freeIn var\n         (liftmap\n           (\\<lambda>x A.\n               fm.Atom\n                (linear_substitution (var + x) (liftPoly 0 x a)\n                  (liftPoly 0 x b) A))\n           (if MPoly_Type.degree (derivative var p) var = 0\n            then fm.Atom (Less (derivative var p))\n            else Or (fm.Atom (Less (derivative var p)))\n                  (And (fm.Atom (Eq (derivative var p)))\n                    (convertDerivative var\n                      (derivative var (derivative var p)))))\n           0)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalLinear var a b At)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "case (Neq p)"], ["proof (state)\nthis:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       At = Neq x4 \\<Longrightarrow>\n       freeIn var (substInfinitesimalLinear var a b At)", "then"], ["proof (chain)\npicking this:\n  At = Neq p", "show ?thesis"], ["proof (prove)\nusing this:\n  At = Neq p\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear var a b At)", "apply (auto simp add:neg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF\\<rbrakk>\n    \\<Longrightarrow> freeIn var\n                       (list_conj\n                         (map (\\<lambda>i.\n                                  fm.Atom\n                                   (Eq (isolate_variable_sparse p var i)))\n                           [0..<MPoly_Type.degree p var] @\n                          [fm.Atom\n                            (Eq (isolate_variable_sparse p var\n                                  (MPoly_Type.degree p var)))]))", "apply(rule freeIn_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF\\<rbrakk>\n    \\<Longrightarrow> \\<forall>f\\<in>set\n(map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n  [0..<MPoly_Type.degree p var] @\n [fm.Atom (Eq (isolate_variable_sparse p var (MPoly_Type.degree p var)))]).\n                         freeIn var f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Neq p;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        FalseF;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        TrueF;\n        x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>At = Neq p;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     FalseF;\n     list_conj\n      (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n        [0..<MPoly_Type.degree p var] @\n       [fm.Atom\n         (Eq (isolate_variable_sparse p var\n               (MPoly_Type.degree p var)))]) \\<noteq>\n     TrueF;\n     var\n     \\<in> vars\n            (isolate_variable_sparse p var\n              (MPoly_Type.degree p var))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>At = Neq p;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        FalseF;\n        list_conj\n         (map (\\<lambda>i. fm.Atom (Eq (isolate_variable_sparse p var i)))\n           [0..<MPoly_Type.degree p var] @\n          [fm.Atom\n            (Eq (isolate_variable_sparse p var\n                  (MPoly_Type.degree p var)))]) \\<noteq>\n        TrueF;\n        x < MPoly_Type.degree p var;\n        var \\<in> vars (isolate_variable_sparse p var x)\\<rbrakk>\n       \\<Longrightarrow> False", "by simp_all"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalLinear var a b At)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_substInfinitesimalLinear_fm:\n  assumes \"var \\<notin> vars a\" \"var \\<notin> vars b\"\n  shows \"freeIn var (substInfinitesimalLinear_fm var a b F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "have \"freeIn (var+z)\n     (liftmap (\\<lambda>x. substInfinitesimalLinear (var + x) (liftPoly 0 x a) (liftPoly 0 x b)) F z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn (var + z)\n     (liftmap\n       (\\<lambda>x.\n           substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n            (liftPoly 0 x b))\n       F z)", "apply(induction F arbitrary:z)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          TrueF z)\n 2. \\<And>z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          FalseF z)\n 3. \\<And>x z.\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          (fm.Atom x) z)\n 4. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (liftmap\n                      (\\<lambda>x.\n                          substInfinitesimalLinear (var + x)\n                           (liftPoly 0 x a) (liftPoly 0 x b))\n                      F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x a) (liftPoly 0 x b))\n                            (And F1 F2) z)\n 5. \\<And>F1 F2 z.\n       \\<lbrakk>\\<And>z.\n                   freeIn (var + z)\n                    (liftmap\n                      (\\<lambda>x.\n                          substInfinitesimalLinear (var + x)\n                           (liftPoly 0 x a) (liftPoly 0 x b))\n                      F1 z);\n        \\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F2 z)\\<rbrakk>\n       \\<Longrightarrow> freeIn (var + z)\n                          (liftmap\n                            (\\<lambda>x.\n                                substInfinitesimalLinear (var + x)\n                                 (liftPoly 0 x a) (liftPoly 0 x b))\n                            (Or F1 F2) z)\n 6. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          (Neg F) z)\n 7. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          (ExQ F) z)\n 8. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          (AllQ F) z)\n 9. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          (ExN x1 F) z)\n 10. \\<And>x1 F z.\n        (\\<And>z.\n            freeIn (var + z)\n             (liftmap\n               (\\<lambda>x.\n                   substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                    (liftPoly 0 x b))\n               F z)) \\<Longrightarrow>\n        freeIn (var + z)\n         (liftmap\n           (\\<lambda>x.\n               substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                (liftPoly 0 x b))\n           (AllN x1 F) z)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x z.\n       freeIn (var + z)\n        (substInfinitesimalLinear (var + z) (liftPoly 0 z a)\n          (liftPoly 0 z b) x)\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "apply(rule freeIn_substInfinitesimalLinear)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z a)\n 2. \\<And>x z. var + z \\<notin> vars (liftPoly 0 z b)\n 3. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 4. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 5. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))\n 6. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "apply (simp_all add: assms not_in_lift)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 2. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))\n 4. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "apply (metis (full_types) Suc_eq_plus1 ab_semigroup_add_class.add_ac(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (Suc (var + z))\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (Suc z))\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))\n 3. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "apply (metis (full_types) Suc_eq_plus1 ab_semigroup_add_class.add_ac(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))\n 2. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "apply (simp add: add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 F z.\n       (\\<And>z.\n           freeIn (var + z)\n            (liftmap\n              (\\<lambda>x.\n                  substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n                   (liftPoly 0 x b))\n              F z)) \\<Longrightarrow>\n       freeIn (var + z + x1)\n        (liftmap\n          (\\<lambda>x.\n              substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n               (liftPoly 0 x b))\n          F (z + x1))", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  freeIn (var + z)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b))\n     F z)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "}"], ["proof (state)\nthis:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "then"], ["proof (chain)\npicking this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b))\n     F ?z2)", "show ?thesis"], ["proof (prove)\nusing this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var (substInfinitesimalLinear_fm var a b F)", "unfolding substInfinitesimalLinear_fm.simps"], ["proof (prove)\nusing this:\n  freeIn (var + ?z2)\n   (liftmap\n     (\\<lambda>x.\n         substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n          (liftPoly 0 x b))\n     F ?z2)\n\ngoal (1 subgoal):\n 1. freeIn var\n     (liftmap\n       (\\<lambda>x.\n           substInfinitesimalLinear (var + x) (liftPoly 0 x a)\n            (liftPoly 0 x b))\n       F 0)", "by (metis (no_types, lifting) add.right_neutral)"], ["proof (state)\nthis:\n  freeIn var (substInfinitesimalLinear_fm var a b F)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}