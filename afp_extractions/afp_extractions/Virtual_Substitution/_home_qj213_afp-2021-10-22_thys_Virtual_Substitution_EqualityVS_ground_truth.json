{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/EqualityVS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma degree_find_eq :\n  assumes \"find_eq var L = (A,L')\"\n  shows \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\"", "lemma list_in_find_eq :\n  assumes \"find_eq var L = (A,L')\"\n  shows \"set(map Eq A @ L') = set L\"", "lemma qe_eq_one_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (qe_eq_one var L F) (xs @ (x#\\<Gamma>))))\"", "lemma qe_eq_repeat_helper_eval_case1 :\n  assumes hlength : \"length xs = var\"\n  assumes degreeGood : \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"((eval (list_conj ((map (Atom o Eq)  A) @ (map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) \n        \\<Longrightarrow> (eval (qe_eq_repeat_helper var A L F) (xs @ x # \\<Gamma>))\"", "lemma qe_eq_repeat_helper_eval_case2 :\n  assumes hlength : \"length xs = var\"\n  assumes degreeGood : \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"(eval (qe_eq_repeat_helper var A L F) (xs @ x # \\<Gamma>))\n        \\<Longrightarrow> \\<exists>x. ((eval (list_conj ((map (Atom o Eq)  A) @ (map Atom L) @ F)) (xs @ (x#\\<Gamma>))))\"", "lemma qe_eq_repeat_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (qe_eq_repeat var L F) (xs @ (x#\\<Gamma>))))\""], "translations": [["", "lemma degree_find_eq :\n  assumes \"find_eq var L = (A,L')\"\n  shows \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using assms(1)"], ["proof (prove)\nusing this:\n  find_eq var L = (A, L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "proof(induction L arbitrary: A L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L'.\n       find_eq var [] = (A, L') \\<Longrightarrow>\n       \\<forall>p\\<in>set A.\n          MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 2. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case Nil"], ["proof (state)\nthis:\n  find_eq var [] = (A, L')\n\ngoal (2 subgoals):\n 1. \\<And>A L'.\n       find_eq var [] = (A, L') \\<Longrightarrow>\n       \\<forall>p\\<in>set A.\n          MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n 2. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var [] = (A, L')", "show ?case"], ["proof (prove)\nusing this:\n  find_eq var [] = (A, L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case (Cons a L)"], ["proof (state)\nthis:\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L')\n\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L')", "show ?case"], ["proof (prove)\nusing this:\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "{"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "fix A' L'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "assume h : \"find_eq var L = (A', L')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L')\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "have \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Less Cons h"], ["proof (prove)\nusing this:\n  a = Less p\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  A = A'", "have \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Cons h"], ["proof (prove)\nusing this:\n  A = A'\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by (meson surj_pair)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "proof(cases \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "{"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "fix A' L'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "assume h : \"find_eq var L = (A', L')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "have \"A= (p#A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = p # A'", "using Eq Cons h True"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. A = p # A'", "by auto"], ["proof (state)\nthis:\n  A = p # A'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  A = p # A'", "have \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  A = p # A'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Cons h True"], ["proof (prove)\nusing this:\n  A = p # A'\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by (meson surj_pair)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "case False"], ["proof (state)\nthis:\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "{"], ["proof (state)\nthis:\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "fix A' L'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "assume h : \"find_eq var L = (A', L')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "have \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Eq Cons h False"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. A = A'", "by (smt One_nat_def case_prod_conv find_eq.simps(3) less_2_cases less_SucE numeral_2_eq_2 numeral_3_eq_3 prod.sel(1))"], ["proof (state)\nthis:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  A = A'", "have \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Cons h"], ["proof (prove)\nusing this:\n  A = A'\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>set A.\n                         MPoly_Type.degree p var = 1 \\<or>\n                         MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by (meson surj_pair)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "{"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "fix A' L'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "assume h : \"find_eq var L = (A', L')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L')\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "have \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Leq Cons h"], ["proof (prove)\nusing this:\n  a = Leq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  A = A'", "have \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Cons h"], ["proof (prove)\nusing this:\n  A = A'\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by (meson surj_pair)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "{"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "fix A' L'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "assume h : \"find_eq var L = (A', L')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "have \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Neq Cons h"], ["proof (prove)\nusing this:\n  a = Neq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  A = A'", "have \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using Cons h"], ["proof (prove)\nusing this:\n  A = A'\n  find_eq var L = (?A, ?L') \\<Longrightarrow>\n  \\<forall>p\\<in>set ?A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n  find_eq var (a # L) = (A, L'a__)\n  find_eq var L = (A', L')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'a__); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   \\<forall>p\\<in>set A.\n                      MPoly_Type.degree p var = 1 \\<or>\n                      MPoly_Type.degree p var = 2;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set A.\n                            MPoly_Type.degree p var = 1 \\<or>\n                            MPoly_Type.degree p var = 2", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L'b2) \\<Longrightarrow>\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by (meson surj_pair)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_in_find_eq :\n  assumes \"find_eq var L = (A,L')\"\n  shows \"set(map Eq A @ L') = set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set L", "using assms(1)"], ["proof (prove)\nusing this:\n  find_eq var L = (A, L')\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set L", "proof(induction L arbitrary: A L')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A L'.\n       find_eq var [] = (A, L') \\<Longrightarrow>\n       set (map Eq A @ L') = set []\n 2. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case Nil"], ["proof (state)\nthis:\n  find_eq var [] = (A, L')\n\ngoal (2 subgoals):\n 1. \\<And>A L'.\n       find_eq var [] = (A, L') \\<Longrightarrow>\n       set (map Eq A @ L') = set []\n 2. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var [] = (A, L')", "show ?case"], ["proof (prove)\nusing this:\n  find_eq var [] = (A, L')\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set []", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set []\n\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case (Cons a L)"], ["proof (state)\nthis:\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n\ngoal (1 subgoal):\n 1. \\<And>a L A L'.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L')\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')", "show ?case"], ["proof (prove)\nusing this:\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "proof(cases a)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case (Less p)"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "{"], ["proof (state)\nthis:\n  a = Less p\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "fix A' L''"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "assume h : \"find_eq var L = (A', L'')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L'')\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have A : \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Less Cons h"], ["proof (prove)\nusing this:\n  a = Less p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have L : \"L'=Less p # L''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = Less p # L''", "using Less Cons h"], ["proof (prove)\nusing this:\n  a = Less p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. L' = Less p # L''", "by simp"], ["proof (state)\nthis:\n  L' = Less p # L''\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have \"set (map Eq A @ L') = set (a # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "apply(simp add: A L Less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Less p) (Eq ` set A' \\<union> set L'') = insert (Less p) (set L)", "using Cons(1)[OF h]"], ["proof (prove)\nusing this:\n  set (map Eq A' @ L'') = set L\n\ngoal (1 subgoal):\n 1. insert (Less p) (Eq ` set A' \\<union> set L'') = insert (Less p) (set L)", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Less x1\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "by (meson surj_pair)"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case (Eq p)"], ["proof (state)\nthis:\n  a = Eq p\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Eq x2\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  a = Eq p", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Eq p\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "proof(cases \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "{"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "fix A' L''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "assume h : \"find_eq var L = (A', L'')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L'')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have A : \"A=(p#A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = p # A'", "using Eq Cons h True"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. A = p # A'", "by auto"], ["proof (state)\nthis:\n  A = p # A'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have L : \"L'= L''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = L''", "using Eq Cons h True"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. L' = L''", "by auto"], ["proof (state)\nthis:\n  L' = L''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have \"set (map Eq A @ L') = set (a # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "apply(simp add: A L Eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Eq p) (Eq ` set A' \\<union> set L'') = insert (Eq p) (set L)", "using Cons(1)[OF h]"], ["proof (prove)\nusing this:\n  set (map Eq A' @ L'') = set L\n\ngoal (1 subgoal):\n 1. insert (Eq p) (Eq ` set A' \\<union> set L'') = insert (Eq p) (set L)", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Eq p;\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "by (meson surj_pair)"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case False"], ["proof (state)\nthis:\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "{"], ["proof (state)\nthis:\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "fix A' L''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "assume h : \"find_eq var L = (A', L'')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have A : \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Eq Cons h False"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n  \\<not> (MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2)\n\ngoal (1 subgoal):\n 1. A = A'", "by (smt case_prod_conv degree_find_eq find_eq.simps(3) list.set_intros(1) prod.sel(1))"], ["proof (state)\nthis:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have L : \"L'=Eq p # L''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = Eq p # L''", "using Eq Cons h"], ["proof (prove)\nusing this:\n  a = Eq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. L' = Eq p # L''", "by (smt A case_prod_conv find_eq.simps(3) not_Cons_self2 prod.sel(1) prod.sel(2))"], ["proof (state)\nthis:\n  L' = Eq p # L''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have \"set (map Eq A @ L') = set (a # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "apply(simp add: A L Eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Eq p) (Eq ` set A' \\<union> set L'') = insert (Eq p) (set L)", "using Cons(1)[OF h]"], ["proof (prove)\nusing this:\n  set (map Eq A' @ L'') = set L\n\ngoal (1 subgoal):\n 1. insert (Eq p) (Eq ` set A' \\<union> set L'') = insert (Eq p) (set L)", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Eq p;\n     \\<not> (MPoly_Type.degree p var = 1 \\<or>\n             MPoly_Type.degree p var = 2)\\<rbrakk>\n    \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "by (meson surj_pair)"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case (Leq p)"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "{"], ["proof (state)\nthis:\n  a = Leq p\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "fix A' L''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "assume h : \"find_eq var L = (A', L'')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L'')\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have A : \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Leq Cons h"], ["proof (prove)\nusing this:\n  a = Leq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have L : \"L'=Leq p # L''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = Leq p # L''", "using Leq Cons h"], ["proof (prove)\nusing this:\n  a = Leq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. L' = Leq p # L''", "by simp"], ["proof (state)\nthis:\n  L' = Leq p # L''\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have \"set (map Eq A @ L') = set (a # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "apply(simp add: A L Leq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Leq p) (Eq ` set A' \\<union> set L'') = insert (Leq p) (set L)", "using Cons(1)[OF h]"], ["proof (prove)\nusing this:\n  set (map Eq A' @ L'') = set L\n\ngoal (1 subgoal):\n 1. insert (Leq p) (Eq ` set A' \\<union> set L'') = insert (Leq p) (set L)", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Leq x3\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)\n 2. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "by (meson surj_pair)"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "case (Neq p)"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "{"], ["proof (state)\nthis:\n  a = Neq p\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "fix A' L''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "assume h : \"find_eq var L = (A', L'')\""], ["proof (state)\nthis:\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have A : \"A=A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A'", "using Neq Cons h"], ["proof (prove)\nusing this:\n  a = Neq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. A = A'", "by(simp)"], ["proof (state)\nthis:\n  A = A'\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have L : \"L'=Neq p # L''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L' = Neq p # L''", "using Neq Cons h"], ["proof (prove)\nusing this:\n  a = Neq p\n  find_eq var L = (?A, ?L') \\<Longrightarrow> set (map Eq ?A @ ?L') = set L\n  find_eq var (a # L) = (A, L')\n  find_eq var L = (A', L'')\n\ngoal (1 subgoal):\n 1. L' = Neq p # L''", "by simp"], ["proof (state)\nthis:\n  L' = Neq p # L''\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "have \"set (map Eq A @ L') = set (a # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "apply(simp add: A L Neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Neq p) (Eq ` set A' \\<union> set L'') = insert (Neq p) (set L)", "using Cons(1)[OF h]"], ["proof (prove)\nusing this:\n  set (map Eq A' @ L'') = set L\n\ngoal (1 subgoal):\n 1. insert (Neq p) (Eq ` set A' \\<union> set L'') = insert (Neq p) (set L)", "by auto"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "}"], ["proof (state)\nthis:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. \\<And>x4.\n       \\<lbrakk>\\<And>A L'.\n                   find_eq var L = (A, L') \\<Longrightarrow>\n                   set (map Eq A @ L') = set L;\n        find_eq var (a # L) = (A, L'); a = Neq x4\\<rbrakk>\n       \\<Longrightarrow> set (map Eq A @ L') = set (a # L)", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (?A'2, ?L''2) \\<Longrightarrow>\n  set (map Eq A @ L') = set (a # L)\n\ngoal (1 subgoal):\n 1. set (map Eq A @ L') = set (a # L)", "by (meson surj_pair)"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map Eq A @ L') = set (a # L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qe_eq_one_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (qe_eq_one var L F) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "proof(cases \"find_eq var L\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       find_eq var L = (a, b) \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "case (Pair A L')"], ["proof (state)\nthis:\n  find_eq var L = (A, L')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       find_eq var L = (a, b) \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  find_eq var L = (A, L')", "show ?thesis"], ["proof (prove)\nusing this:\n  find_eq var L = (A, L')\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "proof(cases A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>find_eq var L = (A, L'); A = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "case Nil"], ["proof (state)\nthis:\n  A = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>find_eq var L = (A, L'); A = []\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          eval (list_conj (map fm.Atom L @ F))\n                           (xs @ x # \\<Gamma>)) =\n                      (\\<exists>x.\n                          eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       eval (list_conj (map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       eval (list_conj (map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "assume h : \"eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\""], ["proof (state)\nthis:\n  eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       eval (list_conj (map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "show \"\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (case find_eq var L of\n         ([], L') \\<Rightarrow> list_conj (map fm.Atom L @ F)\n         | (p # A, L') \\<Rightarrow>\n             Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n              (And (split_p var p)\n                (list_conj (map fm.Atom (map Eq A @ L') @ F))))\n        (xs @ x # \\<Gamma>)", "using Nil Pair h"], ["proof (prove)\nusing this:\n  A = []\n  find_eq var L = (A, L')\n  eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (case find_eq var L of\n         ([], L') \\<Rightarrow> list_conj (map fm.Atom L @ F)\n         | (p # A, L') \\<Rightarrow>\n             Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n              (And (split_p var p)\n                (list_conj (map fm.Atom (map Eq A @ L') @ F))))\n        (xs @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "assume h : \"eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\""], ["proof (state)\nthis:\n  eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "show \"\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "apply(rule exI[where x=\"x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "using Nil Pair h"], ["proof (prove)\nusing this:\n  A = []\n  find_eq var L = (A, L')\n  eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "case (Cons p A')"], ["proof (state)\nthis:\n  A = p # A'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "have \"set(map Eq (p # A') @ L') = set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq (p # A') @ L') = set L", "using list_in_find_eq[OF Pair] Cons"], ["proof (prove)\nusing this:\n  set (map Eq A @ L') = set L\n  A = p # A'\n\ngoal (1 subgoal):\n 1. set (map Eq (p # A') @ L') = set L", "by auto"], ["proof (state)\nthis:\n  set (map Eq (p # A') @ L') = set L\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  set (map Eq (p # A') @ L') = set L", "have in_p: \"Eq p \\<in> set (L)\""], ["proof (prove)\nusing this:\n  set (map Eq (p # A') @ L') = set L\n\ngoal (1 subgoal):\n 1. Eq p \\<in> set L", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set L\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "have \"p\\<in>(set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set A", "using Cons"], ["proof (prove)\nusing this:\n  A = p # A'\n\ngoal (1 subgoal):\n 1. p \\<in> set A", "by auto"], ["proof (state)\nthis:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  p \\<in> set A", "have low_pow : \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using degree_find_eq[OF Pair]"], ["proof (prove)\nusing this:\n  p \\<in> set A\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "have \"(\\<exists>x.(eval (qe_eq_one var L F) (xs @ (x#\\<Gamma>)))) = \n          (\\<exists>x.(eval (Or (And (Neg (split_p var p))\n                      ((elimVar var L F) (Eq p))\n                    )\n                    (And (split_p var p) \n                      (list_conj (map Atom ((map Eq A')  @ L') @ F))\n                    )) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval\n         (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n           (And (split_p var p)\n             (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n         (xs @ x # \\<Gamma>))", "apply(rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (qe_eq_one var L F) (xs @ x # \\<Gamma>) =\n       eval\n        (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n          (And (split_p var p)\n            (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n        (xs @ x # \\<Gamma>)", "apply(simp only: qe_eq_one.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval\n        (case find_eq var L of\n         ([], L') \\<Rightarrow> list_conj (map fm.Atom L @ F)\n         | (p # A, L') \\<Rightarrow>\n             Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n              (And (split_p var p)\n                (list_conj (map fm.Atom (map Eq A @ L') @ F))))\n        (xs @ x # \\<Gamma>) =\n       eval\n        (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n          (And (split_p var p)\n            (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n        (xs @ x # \\<Gamma>)", "using Pair Cons"], ["proof (prove)\nusing this:\n  find_eq var L = (A, L')\n  A = p # A'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval\n        (case find_eq var L of\n         ([], L') \\<Rightarrow> list_conj (map fm.Atom L @ F)\n         | (p # A, L') \\<Rightarrow>\n             Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n              (And (split_p var p)\n                (list_conj (map fm.Atom (map Eq A @ L') @ F))))\n        (xs @ x # \\<Gamma>) =\n       eval\n        (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n          (And (split_p var p)\n            (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n        (xs @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval\n       (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n         (And (split_p var p)\n           (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n       (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "also"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval\n       (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n         (And (split_p var p)\n           (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n       (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "have \"... = (\\<exists>x. ((\\<not>eval (split_p var p) (xs @ x # \\<Gamma>)) \\<and> eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)) \\<or>\n         eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n         (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F). eval f (xs @ x # \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n           (And (split_p var p)\n             (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>)))", "by(simp add: eval_list_conj)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      eval\n       (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n         (And (split_p var p)\n           (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "also"], ["proof (state)\nthis:\n  (\\<exists>x.\n      eval\n       (Or (And (Neg (split_p var p)) (elimVar var L F (Eq p)))\n         (And (split_p var p)\n           (list_conj (map fm.Atom (map Eq A' @ L') @ F))))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "have \"... = (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "proof(cases \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 2) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 1) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 0) \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0 \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n 2. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "case True"], ["proof (state)\nthis:\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0 \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n 2. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have \"(\\<exists>x. ((\\<not>eval (split_p var p) (xs @ x # \\<Gamma>)) \\<and> eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)) \\<or>\n         eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n         (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F). eval f (xs @ x # \\<Gamma>))) =\n        (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> eval (split_p var p) (xs @ x # \\<Gamma>);\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 3. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> eval (split_p var p) (xs @ x # \\<Gamma>);\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 3. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "assume \"eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (state)\nthis:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> eval (split_p var p) (xs @ x # \\<Gamma>);\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 3. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)", "show \"\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "assume h : \"eval (split_p var p) (xs @ x # \\<Gamma>)\""], ["proof (state)\nthis:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "have \"\\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)", "using True"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>eval (split_p var p) (xs @ x # \\<Gamma>);\n        \\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval (elimVar var L F (Eq p))\n                             (xs @ x # \\<Gamma>)\n 2. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)", "show \"\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  \\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "assume \"eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (state)\nthis:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n       \\<exists>x.\n          \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n          eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n          (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n              eval f (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)", "show \"\\<exists>x. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and> eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n             eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n             (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F). eval f (xs @ x # \\<Gamma>))\""], ["proof (prove)\nusing this:\n  eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n       eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n       eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n       (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n           eval f (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n     eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n     eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n     (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n         eval f (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0 \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n 2. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "using elimVar_eq_2[OF hlength in_p low_pow True]"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>))\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ ?F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (elimVar var L ?F (Eq p)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x.\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 2) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 1) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 0) \\<noteq>\n             0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have h1: \"\\<forall>x. eval (split_p var p) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. eval (split_p var p) (xs @ x # \\<Gamma>)", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x.\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 2) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 1) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 0) \\<noteq>\n             0)\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval (split_p var p) (xs @ x # \\<Gamma>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       0", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       0", "by (metis hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have \"set(map Eq (p # A') @ L') = set L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Eq (p # A') @ L') = set L", "using list_in_find_eq[OF Pair] Cons"], ["proof (prove)\nusing this:\n  set (map Eq A @ L') = set L\n  A = p # A'\n\ngoal (1 subgoal):\n 1. set (map Eq (p # A') @ L') = set L", "by auto"], ["proof (state)\nthis:\n  set (map Eq (p # A') @ L') = set L\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  set (map Eq (p # A') @ L') = set L", "have h5 : \"set(map fm.Atom (map Eq (p # A') @ L') @ F) = set(map fm.Atom L @ F)\""], ["proof (prove)\nusing this:\n  set (map Eq (p # A') @ L') = set L\n\ngoal (1 subgoal):\n 1. set (map fm.Atom (map Eq (p # A') @ L') @ F) = set (map fm.Atom L @ F)", "by auto"], ["proof (state)\nthis:\n  set (map fm.Atom (map Eq (p # A') @ L') @ F) = set (map fm.Atom L @ F)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have h4 : \"(\\<exists>x. (aEval (Eq p) (xs @ x # \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F). eval f (xs @ x # \\<Gamma>))) = \n          (\\<exists>x.(\\<forall>f\\<in>set (map fm.Atom (map Eq (p#A') @ L') @ F). eval f (xs @ x # \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x.\n        \\<forall>f\\<in>set (map fm.Atom (map Eq (p # A') @ L') @ F).\n           eval f (xs @ x # \\<Gamma>))", "by(simp)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x.\n      \\<forall>f\\<in>set (map fm.Atom (map Eq (p # A') @ L') @ F).\n         eval f (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have h2 : \"(\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) = (\\<exists>x. (aEval (Eq p) (xs @ x # \\<Gamma>)) \\<and>\n         (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F). eval f (xs @ x # \\<Gamma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>)))", "by(simp only: h4 h5 eval_list_conj)"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have h3 : \"\\<forall>x. (aEval (Eq p) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "define A where \"A = (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  A = isolate_variable_sparse p var 2\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "define B where \"B = (isolate_variable_sparse p var 1)\""], ["proof (state)\nthis:\n  B = isolate_variable_sparse p var 1\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "define C where \"C = (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  C = isolate_variable_sparse p var 0\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeA : \"var \\<notin> vars A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 2)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars A\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeB : \"var \\<notin> vars B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 1)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars B\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeC : \"var \\<notin> vars C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars C\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have express_p : \"p = A*(Var var)^2+B*(Var var)+C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "using express_poly[OF low_pow]"], ["proof (prove)\nusing this:\n  p =\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 0\n\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "unfolding A_def B_def C_def"], ["proof (prove)\nusing this:\n  p =\n  isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n  isolate_variable_sparse p var 1 * Var var +\n  isolate_variable_sparse p var 0\n\ngoal (1 subgoal):\n 1. p =\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2 +\n    isolate_variable_sparse p var 1 * Var var +\n    isolate_variable_sparse p var 0", "by fastforce"], ["proof (state)\nthis:\n  p = A * (Var var)\\<^sup>2 + B * Var var + C\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have xlength : \"\\<forall>x. (insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var))= x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "using hlength insertion_var"], ["proof (prove)\nusing this:\n  length xs = var\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "by (metis add.commute add_strict_increasing length_append length_greater_0_conv list.distinct(1) list_update_id nth_append_length order_refl)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "define c where \"c i = (insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var i))\" for i"], ["proof (state)\nthis:\n  c ?i =\n  insertion (nth_default 0 (xs @ x # \\<Gamma>))\n   (isolate_variable_sparse p var ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c2 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2", "using freeA"], ["proof (prove)\nusing this:\n  var \\<notin> vars A\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2", "apply(simp add: A_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 2) \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2)", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c1 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1", "using freeB"], ["proof (prove)\nusing this:\n  var \\<notin> vars B\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1", "apply(simp add: B_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars (isolate_variable_sparse p var (Suc 0)) \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0))", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c0 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0", "using freeC"], ["proof (prove)\nusing this:\n  var \\<notin> vars C\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0", "apply(simp add: C_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0) \\<Longrightarrow>\n    \\<forall>xa.\n       insertion (nth_default 0 (xs @ xa # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0)", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "have sum : \"\\<forall>x. c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)", "by (simp add: numerals(2))"], ["proof (state)\nthis:\n  \\<forall>x.\n     c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)\n\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)", "unfolding express_p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       aEval (Eq (A * (Var var)\\<^sup>2 + B * Var var + C))\n        (xs @ x # \\<Gamma>)", "apply(simp add:insertion_add insertion_mult insertion_pow xlength)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>)) A * x\\<^sup>2 +\n       insertion (nth_default 0 (xs @ x # \\<Gamma>)) B * x +\n       insertion (nth_default 0 (xs @ x # \\<Gamma>)) C =\n       0", "apply(simp add:c2 c1 c0 sum polyfun_eq_0[where c=\"c\", where n=\"2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>2. c i = 0", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x.\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 2) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 1) \\<noteq>\n             0 \\<or>\n             insertion (nth_default 0 (xs @ x # \\<Gamma>))\n              (isolate_variable_sparse p var 0) \\<noteq>\n             0)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>2. c i = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<and>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       0 \\<Longrightarrow>\n    \\<forall>i\\<le>2. c i = 0", "by (metis A_def B_def C_def One_nat_def c0 c1 c2 le_SucE le_zero_eq numeral_2_eq_2)"], ["proof (state)\nthis:\n  \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 2) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 1) \\<noteq>\n               0 \\<or>\n               insertion (nth_default 0 (xs @ x # \\<Gamma>))\n                (isolate_variable_sparse p var 0) \\<noteq>\n               0) \\<Longrightarrow>\n    (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "apply(simp only: h1 h2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> True \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        True \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x.\n        aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>)))", "using h3"], ["proof (prove)\nusing this:\n  \\<forall>x. aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<not> True \\<and>\n        eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n        True \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>))) =\n    (\\<exists>x.\n        aEval (Eq p) (xs @ x # \\<Gamma>) \\<and>\n        (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n            eval f (xs @ x # \\<Gamma>)))", "by(simp)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      eval (elimVar var L F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n      eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n      (\\<forall>f\\<in>set (map fm.Atom (map Eq A' @ L') @ F).\n          eval f (xs @ x # \\<Gamma>))) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>find_eq var L = (A, L'); A = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_one var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qe_eq_repeat_helper_eval_case1 :\n  assumes hlength : \"length xs = var\"\n  assumes degreeGood : \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"((eval (list_conj ((map (Atom o Eq)  A) @ (map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) \n        \\<Longrightarrow> (eval (qe_eq_repeat_helper var A L F) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    eval (qe_eq_repeat_helper var A L F) (xs @ x # \\<Gamma>)", "proof(induction A rule : in_list_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)\n 2. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "case Nil"], ["proof (state)\nthis:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)\n 2. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)", "show ?case"], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "case (Cons p A')"], ["proof (state)\nthis:\n  p \\<in> set A\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "assume assm : \"((eval (list_conj ((map (Atom o Eq) (p#A')) @ (map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) \""], ["proof (state)\nthis:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)", "have h :  \"insertion (nth_default 0 (xs @ x # \\<Gamma>)) p = 0 \\<and> (eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>))\""], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) p = 0 \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "using Cons"], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n  p \\<in> set A\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) p = 0 \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "by(simp add: eval_list_conj)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs @ x # \\<Gamma>)) p = 0 \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "have \"\\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and> eval (elimVar var ((map Eq (p# A')) @ L) F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and> eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "proof(cases \"eval (split_p var p) (xs @ x # \\<Gamma>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "case True"], ["proof (state)\nthis:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  eval (split_p var p) (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "using h"], ["proof (prove)\nusing this:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n  insertion (nth_default 0 (xs @ x # \\<Gamma>)) p = 0 \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "case False"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "have all0 :  \" \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 2) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 1) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using False"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "by (metis hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "have in_p : \"Eq p\\<in>set((map Eq (p # A') @ L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eq p \\<in> set (map Eq (p # A') @ L)", "by auto"], ["proof (state)\nthis:\n  Eq p \\<in> set (map Eq (p # A') @ L)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "have \"p\\<in>(set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set A", "using Cons"], ["proof (prove)\nusing this:\n  p \\<in> set A\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. p \\<in> set A", "by auto"], ["proof (state)\nthis:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  p \\<in> set A", "have low_pow : \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using degreeGood"], ["proof (prove)\nusing this:\n  p \\<in> set A\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "have list_manipulate : \"map fm.Atom (map Eq (p # A') @ L) = map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fm.Atom (map Eq (p # A') @ L) =\n    map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L", "by(simp)"], ["proof (state)\nthis:\n  map fm.Atom (map Eq (p # A') @ L) =\n  map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "have \"eval (elimVar var ((map Eq (p# A')) @ L) F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "using elimVar_eq_2[OF hlength in_p low_pow all0, where F=\"F\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom (map Eq (p # A') @ L) @ F))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "apply(simp only: list_manipulate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (list_conj\n           ((map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L) @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n         (xs @ x # \\<Gamma>)) \\<Longrightarrow>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "using assm freeIn_elimVar_eq[where var=\"var\", where L=\"(map Eq (p # A') @ L)\", where F=\"F\", where p=\"p\"]"], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n  freeIn var (elimVar var (map Eq (p # A') @ L) F (Eq p))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval\n         (list_conj\n           ((map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L) @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n         (xs @ x # \\<Gamma>)) \\<Longrightarrow>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "by (metis append.assoc hlength list_update_length var_not_in_eval)"], ["proof (state)\nthis:\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "apply(simp only: False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<not> False \\<and> True \\<or>\n    False \\<and> eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        eval (qe_eq_repeat_helper var xsa L F) (xs @ x # \\<Gamma>);\n        eval\n         (list_conj\n           (map (fm.Atom \\<circ> Eq) (xa # xsa) @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> eval (qe_eq_repeat_helper var (xa # xsa) L F)\n                          (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (qe_eq_repeat_helper var (p # A') L F) (xs @ x # \\<Gamma>)", "by(simp only: qe_eq_repeat_helper.simps eval.simps)"], ["proof (state)\nthis:\n  eval (qe_eq_repeat_helper var (p # A') L F) (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qe_eq_repeat_helper_eval_case2 :\n  assumes hlength : \"length xs = var\"\n  assumes degreeGood : \"\\<forall>p\\<in>set(A). MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\"\n  shows \"(eval (qe_eq_repeat_helper var A L F) (xs @ x # \\<Gamma>))\n        \\<Longrightarrow> \\<exists>x. ((eval (list_conj ((map (Atom o Eq)  A) @ (map Atom L) @ F)) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (qe_eq_repeat_helper var A L F)\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "proof(induction A rule : in_list_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (qe_eq_repeat_helper var [] L F)\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "case Nil"], ["proof (state)\nthis:\n  eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (qe_eq_repeat_helper var [] L F)\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)", "show ?case"], ["proof (prove)\nusing this:\n  eval (qe_eq_repeat_helper var [] L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "apply(rule exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) [] @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "case (Cons p A')"], ["proof (state)\nthis:\n  p \\<in> set A\n  eval (qe_eq_repeat_helper var A' L F)\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n  eval (qe_eq_repeat_helper var (p # A') L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "have h : \"\\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and> eval (elimVar var ((map Eq (p# A')) @ L) F (Eq p)) (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and> eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "using Cons"], ["proof (prove)\nusing this:\n  p \\<in> set A\n  eval (qe_eq_repeat_helper var A' L F)\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n  eval (qe_eq_repeat_helper var (p # A') L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n     (xs @ x # \\<Gamma>) \\<or>\n    eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n    eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)", "by(simp only:qe_eq_repeat_helper.simps eval.simps)"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "have \"p\\<in>set(A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set A", "using Cons(1)"], ["proof (prove)\nusing this:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. p \\<in> set A", "."], ["proof (state)\nthis:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  p \\<in> set A", "have degp : \"MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  p \\<in> set A\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using degreeGood"], ["proof (prove)\nusing this:\n  p \\<in> set A\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       \\<lbrakk>xa \\<in> set A;\n        eval (qe_eq_repeat_helper var xsa L F)\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        \\<exists>x.\n           eval\n            (list_conj (map (fm.Atom \\<circ> Eq) xsa @ map fm.Atom L @ F))\n            (xs @ x # \\<Gamma>);\n        eval (qe_eq_repeat_helper var (xa # xsa) L F)\n         (xs @ x # \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            eval\n                             (list_conj\n                               (map (fm.Atom \\<circ> Eq) (xa # xsa) @\n                                map fm.Atom L @ F))\n                             (xs @ x # \\<Gamma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "proof(cases \"eval (split_p var p) (xs @ x # \\<Gamma>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "case True"], ["proof (state)\nthis:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have \"\\<exists>x. eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "using h True Cons"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n  p \\<in> set A\n  eval (qe_eq_repeat_helper var A' L F)\n   (xs @ x # \\<Gamma>) \\<Longrightarrow>\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n  eval (qe_eq_repeat_helper var (p # A') L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)", "obtain x where x_def : \"eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n         (xs @ x # \\<Gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "define A where \"A = (isolate_variable_sparse p var 2)\""], ["proof (state)\nthis:\n  A = isolate_variable_sparse p var 2\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "define B where \"B = (isolate_variable_sparse p var 1)\""], ["proof (state)\nthis:\n  B = isolate_variable_sparse p var 1\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "define C where \"C = (isolate_variable_sparse p var 0)\""], ["proof (state)\nthis:\n  C = isolate_variable_sparse p var 0\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have express_p : \"p = A * Var var ^2+B * Var var+C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "proof(cases \"MPoly_Type.degree p var = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "case True"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 1\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "have a0 : \"A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "apply(simp add: A_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var 2 = 0", "using True"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var = 1\n\ngoal (1 subgoal):\n 1. isolate_variable_sparse p var 2 = 0", "by (simp add: isovar_greater_degree)"], ["proof (state)\nthis:\n  A = 0\n\ngoal (2 subgoals):\n 1. MPoly_Type.degree p var = 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C\n 2. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "using sum_over_zero[where mp=\"p\", where x=\"var\"]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "apply(subst (asm) True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>1.\n        isolate_variable_sparse p var i * Var var ^ i) \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "by(simp add:a0 B_def C_def add.commute)"], ["proof (state)\nthis:\n  p = A * (Var var)\\<^sup>2 + B * Var var + C\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "case False"], ["proof (state)\nthis:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.degree p var \\<noteq> 1", "have deg : \"MPoly_Type.degree p var = 2\""], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "using degp"], ["proof (prove)\nusing this:\n  MPoly_Type.degree p var \\<noteq> 1\n  MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var = 2", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "have flip : \"A * (Var var)\\<^sup>2 + B * Var var + C = C + B * Var var + A * (Var var)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (Var var)\\<^sup>2 + B * Var var + C =\n    C + B * Var var + A * (Var var)\\<^sup>2", "using add.commute"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. A * (Var var)\\<^sup>2 + B * Var var + C =\n    C + B * Var var + A * (Var var)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  A * (Var var)\\<^sup>2 + B * Var var + C =\n  C + B * Var var + A * (Var var)\\<^sup>2\n\ngoal (1 subgoal):\n 1. MPoly_Type.degree p var \\<noteq> 1 \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "using sum_over_zero[where mp=\"p\", where x=\"var\"]"], ["proof (prove)\nusing this:\n  p =\n  (\\<Sum>i\\<le>MPoly_Type.degree p var.\n      isolate_variable_sparse p var i * Var var ^ i)\n\ngoal (1 subgoal):\n 1. p = A * (Var var)\\<^sup>2 + B * Var var + C", "apply(subst (asm) deg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>2.\n        isolate_variable_sparse p var i * Var var ^ i) \\<Longrightarrow>\n    p = A * (Var var)\\<^sup>2 + B * Var var + C", "apply(simp add: flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>2.\n        isolate_variable_sparse p var i * Var var ^ i) \\<Longrightarrow>\n    p = C + B * Var var + A * (Var var)\\<^sup>2", "apply(simp add: A_def B_def C_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    (\\<Sum>i\\<le>2.\n        isolate_variable_sparse p var i * Var var ^ i) \\<Longrightarrow>\n    p =\n    isolate_variable_sparse p var 0 +\n    isolate_variable_sparse p var (Suc 0) * Var var +\n    isolate_variable_sparse p var 2 * (Var var)\\<^sup>2", "by (simp add: numeral_2_eq_2)"], ["proof (state)\nthis:\n  p = A * (Var var)\\<^sup>2 + B * Var var + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = A * (Var var)\\<^sup>2 + B * Var var + C\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have insert_x : \"insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "using hlength"], ["proof (prove)\nusing this:\n  length xs = var\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "by (metis add.commute add_strict_increasing insertion_var length_append length_greater_0_conv list.distinct(1) list_update_id nth_append_length order_refl)"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have h : \"(aEval (Eq p) (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeA : \"var \\<notin> vars A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 2)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars A\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeB : \"var \\<notin> vars B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 1)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars B\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have freeC : \"var \\<notin> vars C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0)", "by (simp add: not_in_isovarspar)"], ["proof (state)\nthis:\n  var \\<notin> vars C\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have xlength : \"(insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var))= x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "using hlength insertion_var"], ["proof (prove)\nusing this:\n  length xs = var\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "using insert_x"], ["proof (prove)\nusing this:\n  length xs = var\n  ?var < length ?L \\<Longrightarrow>\n  insertion (nth_default (0::?'a) (?L[?var := ?x])) (Var ?var) = ?x\n  insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x", "by blast"], ["proof (state)\nthis:\n  insertion (nth_default 0 (xs @ x # \\<Gamma>)) (Var var) = x\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "define c where \"c i = (insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var i))\" for i"], ["proof (state)\nthis:\n  c ?i =\n  insertion (nth_default 0 (xs @ x # \\<Gamma>))\n   (isolate_variable_sparse p var ?i)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c2 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2", "using freeA"], ["proof (prove)\nusing this:\n  var \\<notin> vars A\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2", "apply(simp add: A_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 2) \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2)", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A = c 2\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c1 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1", "using freeB"], ["proof (prove)\nusing this:\n  var \\<notin> vars B\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1", "apply(simp add: B_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> vars (isolate_variable_sparse p var (Suc 0)) \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0))", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) B = c 1\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have c0 : \"\\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0", "using freeC"], ["proof (prove)\nusing this:\n  var \\<notin> vars C\n\ngoal (1 subgoal):\n 1. \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0", "apply(simp add: C_def c_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> vars (isolate_variable_sparse p var 0) \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) =\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0)", "by (simp add: hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) C = c 0\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "have sum : \"c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)", "by (simp add: numerals(2))"], ["proof (state)\nthis:\n  c 2 * x\\<^sup>2 + c (Suc 0) * x + c 0 = (\\<Sum>i\\<le>2. c i * x ^ i)\n\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq p) (xs @ x # \\<Gamma>)", "apply(subst express_p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq (A * (Var var)\\<^sup>2 + B * Var var + C)) (xs @ x # \\<Gamma>)", "apply(simp add:insertion_add insertion_mult insertion_pow xlength)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>)) A * x\\<^sup>2 +\n    insertion (nth_default 0 (xs @ x # \\<Gamma>)) B * x +\n    insertion (nth_default 0 (xs @ x # \\<Gamma>)) C =\n    0", "apply(simp add:c2 c1 c0 sum polyfun_eq_0[where c=\"c\", where n=\"2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. c i * x ^ i) = 0", "using True"], ["proof (prove)\nusing this:\n  eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>2. c i * x ^ i) = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<and>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<and>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) =\n    0 \\<Longrightarrow>\n    (\\<Sum>i\\<le>2. c i * x ^ i) = 0", "using le_SucE numeral_2_eq_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m \\<le> Suc ?n; ?m \\<le> ?n \\<Longrightarrow> ?R;\n   ?m = Suc ?n \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<and>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<and>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) =\n    0 \\<Longrightarrow>\n    (\\<Sum>i\\<le>2. c i * x ^ i) = 0", "by (metis (no_types) A_def B_def C_def One_nat_def add.left_neutral c0 c1 c2 mult_zero_class.mult_zero_left sum)"], ["proof (state)\nthis:\n  aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)\n 2. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "apply(rule exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>)", "using x_def h"], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A' @ map fm.Atom L @ F))\n   (xs @ x # \\<Gamma>)\n  aEval (Eq p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n     (xs @ x # \\<Gamma>)", "apply(simp only:eval_list_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>f\\<in>set (map (fm.Atom \\<circ> Eq) A' @\n                                 map fm.Atom L @ F).\n                eval f (xs @ x # \\<Gamma>);\n     aEval (Eq p) (xs @ x # \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>f\\<in>set\n(map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F).\n                         eval f (xs @ x # \\<Gamma>)", "by(simp)"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval\n      (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "case False"], ["proof (state)\nthis:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have all0 :  \" \\<forall>x. insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 2) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 1) \\<noteq> 0 \\<or>\n      insertion (nth_default 0 (xs @ x # \\<Gamma>)) (isolate_variable_sparse p var 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using False"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 1) \\<noteq>\n       0 \\<or>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "using not_in_isovarspar"], ["proof (prove)\nusing this:\n  isolate_variable_sparse ?p ?var ?x = ?q \\<Longrightarrow>\n  ?var \\<notin> vars ?q\n\ngoal (1 subgoal):\n 1. insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var (Suc 0)) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 2) =\n    0 \\<longrightarrow>\n    insertion (nth_default 0 (xs @ x # \\<Gamma>))\n     (isolate_variable_sparse p var 0) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x.\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var (Suc 0)) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 2) =\n       0 \\<longrightarrow>\n       insertion (nth_default 0 (xs @ x # \\<Gamma>))\n        (isolate_variable_sparse p var 0) \\<noteq>\n       0", "by (metis hlength insertion_lowerPoly1)"], ["proof (state)\nthis:\n  \\<forall>x.\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 2) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 1) \\<noteq>\n     0 \\<or>\n     insertion (nth_default 0 (xs @ x # \\<Gamma>))\n      (isolate_variable_sparse p var 0) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have h : \"eval (elimVar var ((map Eq (p# A')) @ L) F (Eq p)) (xs @ x # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "using False h"], ["proof (prove)\nusing this:\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>)\n  \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p))\n   (xs @ x # \\<Gamma>) \\<or>\n  eval (split_p var p) (xs @ x # \\<Gamma>) \\<and>\n  eval (qe_eq_repeat_helper var A' L F) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "have in_list : \"Eq p \\<in> set (((map Eq (p# A')) @ L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Eq p \\<in> set (map Eq (p # A') @ L)", "by(simp)"], ["proof (state)\nthis:\n  Eq p \\<in> set (map Eq (p # A') @ L)\n\ngoal (1 subgoal):\n 1. \\<not> eval (split_p var p) (xs @ x # \\<Gamma>) \\<Longrightarrow>\n    \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "using elimVar_eq_2[OF hlength in_list, where F=\"F\", OF degp all0] h"], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      eval (list_conj (map fm.Atom (map Eq (p # A') @ L) @ F))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>))\n  eval (elimVar var (map Eq (p # A') @ L) F (Eq p)) (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       eval\n        (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n        (xs @ x # \\<Gamma>)", "by (metis append_assoc map_append map_map)"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval\n      (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     eval\n      (list_conj (map (fm.Atom \\<circ> Eq) (p # A') @ map fm.Atom L @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qe_eq_repeat_eval :\n  assumes hlength : \"length xs = var\"\n  shows \"(\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>)))) = (\\<exists>x.(eval (qe_eq_repeat var L F) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "proof(cases \"luckyFind var L F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. luckyFind var L F = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       luckyFind var L F = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "case None"], ["proof (state)\nthis:\n  luckyFind var L F = None\n\ngoal (2 subgoals):\n 1. luckyFind var L F = None \\<Longrightarrow>\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n 2. \\<And>a.\n       luckyFind var L F = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  luckyFind var L F = None", "show ?thesis"], ["proof (prove)\nusing this:\n  luckyFind var L F = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "proof(cases \"find_eq var L\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "case (Pair A L')"], ["proof (state)\nthis:\n  find_eq var L = (A, L')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "have degGood : \"\\<forall>p\\<in>set A. MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "using degree_find_eq[OF Pair]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set A.\n       MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2", "."], ["proof (state)\nthis:\n  \\<forall>p\\<in>set A.\n     MPoly_Type.degree p var = 1 \\<or> MPoly_Type.degree p var = 2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "have \"(\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =(\\<exists>x. eval\n        (qe_eq_repeat_helper var A L' F)\n        (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>))", "using Pair None"], ["proof (prove)\nusing this:\n  find_eq var L = (A, L')\n  luckyFind var L F = None\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "also"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "have \"...\n      = (\\<exists>x. ((eval (list_conj ((map (Atom o Eq)  A) @ (map Atom L') @ F)) (xs @ (x#\\<Gamma>)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>))", "using qe_eq_repeat_helper_eval_case1[OF hlength degGood, where L=\"L'\", where F=\"F\", where \\<Gamma>=\"\\<Gamma>\"]\n        qe_eq_repeat_helper_eval_case2[OF hlength degGood, where L=\"L'\", where F=\"F\", where \\<Gamma>=\"\\<Gamma>\"]"], ["proof (prove)\nusing this:\n  eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n   (xs @ ?x # \\<Gamma>) \\<Longrightarrow>\n  eval (qe_eq_repeat_helper var A L' F) (xs @ ?x # \\<Gamma>)\n  eval (qe_eq_repeat_helper var A L' F)\n   (xs @ ?x # \\<Gamma>) \\<Longrightarrow>\n  \\<exists>x.\n     eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n      (xs @ x # \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n       (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "also"], ["proof (state)\nthis:\n  (\\<exists>x. eval (qe_eq_repeat_helper var A L' F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n       (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "have \"... = (\\<exists>x. (eval (list_conj ((map Atom L) @ F)) (xs @ (x#\\<Gamma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have list_manipulate : \"map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' = map fm.Atom (map Eq A @ L')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' =\n    map fm.Atom (map Eq A @ L')", "by simp"], ["proof (state)\nthis:\n  map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' = map fm.Atom (map Eq A @ L')\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have changeA :  \"map (fm.Atom \\<circ> Eq) A = map Atom (map Eq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (fm.Atom \\<circ> Eq) A = map fm.Atom (map Eq A)", "by auto"], ["proof (state)\nthis:\n  map (fm.Atom \\<circ> Eq) A = map fm.Atom (map Eq A)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have split : \"(\\<exists>x. \\<forall>f\\<in>set ((map (fm.Atom \\<circ> Eq) A) @\n                (map fm.Atom L') @ F).\n          eval f (xs @ x # \\<Gamma>)) = (\\<exists>x. \\<forall>f\\<in> (Atom ` set ((map (Eq) A) @ L')) \\<union> set(F).\n          eval f (xs @ x # \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>f\\<in>set (map (fm.Atom \\<circ> Eq) A @\n                            map fm.Atom L' @ F).\n           eval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        \\<forall>f\\<in>fm.Atom ` set (map Eq A @ L') \\<union> set F.\n           eval f (xs @ x # \\<Gamma>))", "apply (rule ex_cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (map (fm.Atom \\<circ> Eq) A @\n                            map fm.Atom L' @ F).\n           eval f (xs @ x # \\<Gamma>)) =\n       (\\<forall>f\\<in>fm.Atom ` set (map Eq A @ L') \\<union> set F.\n           eval f (xs @ x # \\<Gamma>))", "apply(subst changeA)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>f\\<in>set (map fm.Atom (map Eq A) @ map fm.Atom L' @ F).\n           eval f (xs @ x # \\<Gamma>)) =\n       (\\<forall>f\\<in>fm.Atom ` set (map Eq A @ L') \\<union> set F.\n           eval f (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x.\n      \\<forall>f\\<in>set (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F).\n         eval f (xs @ x # \\<Gamma>)) =\n  (\\<exists>x.\n      \\<forall>f\\<in>fm.Atom ` set (map Eq A @ L') \\<union> set F.\n         eval f (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n         (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "apply(simp only: eval_list_conj split list_in_find_eq[OF Pair])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        \\<forall>f\\<in>fm.Atom ` set L \\<union> set F.\n           eval f (xs @ x # \\<Gamma>)) =\n    (\\<exists>x.\n        \\<forall>f\\<in>set (map fm.Atom L @ F). eval f (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x.\n      eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      eval (list_conj (map (fm.Atom \\<circ> Eq) A @ map fm.Atom L' @ F))\n       (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))", "have ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>luckyFind var L F = None; find_eq var L = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             eval (list_conj (map fm.Atom L @ F))\n                              (xs @ x # \\<Gamma>)) =\n                         (\\<exists>x.\n                             eval (qe_eq_repeat var L F)\n                              (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L F = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L F = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "case (Some a)"], ["proof (state)\nthis:\n  luckyFind var L F = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       luckyFind var L F = Some a \\<Longrightarrow>\n       (\\<exists>x.\n           eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n       (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "then"], ["proof (chain)\npicking this:\n  luckyFind var L F = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  luckyFind var L F = Some a\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "using luckyFind_eval[OF Some assms(1)]"], ["proof (prove)\nusing this:\n  luckyFind var L F = Some a\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # ?\\<Gamma>)) =\n  (\\<exists>x. eval a (xs @ x # ?\\<Gamma>))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n    (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. eval (list_conj (map fm.Atom L @ F)) (xs @ x # \\<Gamma>)) =\n  (\\<exists>x. eval (qe_eq_repeat var L F) (xs @ x # \\<Gamma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}