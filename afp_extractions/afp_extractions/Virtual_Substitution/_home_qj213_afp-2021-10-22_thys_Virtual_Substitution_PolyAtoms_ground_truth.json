{"file_name": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution/PolyAtoms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Virtual_Substitution", "problem_names": ["lemma aNeg_aEval : \"aEval a L \\<longleftrightarrow> (\\<not> aEval (aNeg a) L)\"", "lemma \"eval (ExQ (Or (Atom A) (Atom B))) xs =  eval (Or (ExQ(Atom A)) (ExQ(Atom B))) xs\"", "lemma eval_neg_neg : \"eval (neg (neg f)) L \\<longleftrightarrow> eval f L\"", "lemma eval_neg : \"(\\<not> eval (neg f) L) \\<longleftrightarrow> eval f L\"", "lemma eval_and : \"eval (and a b) L \\<longleftrightarrow> (eval a L \\<and> eval b L)\"", "lemma eval_or : \"eval (or a b) L \\<longleftrightarrow> (eval a L \\<or> eval b L)\"", "lemma eval_Or : \"eval (Or a b) L \\<longleftrightarrow> (eval a L \\<or> eval b L)\"", "lemma eval_And : \"eval (And a b) L \\<longleftrightarrow> (eval a L \\<and> eval b L)\"", "lemma eval_not : \"eval (neg a) L \\<longleftrightarrow> \\<not>(eval a L)\"", "lemma eval_true : \"eval TrueF L\"", "lemma eval_false : \"\\<not>(eval FalseF L)\"", "lemma eval_Neg : \"eval (Neg \\<phi>) L = eval (neg \\<phi>) L\"", "lemma eval_Neg_Neg : \"eval (Neg (Neg \\<phi>)) L = eval \\<phi> L\"", "lemma eval_Neg_And : \"eval (Neg (And \\<phi> \\<psi>)) L = eval (Or (Neg \\<phi>) (Neg \\<psi>)) L\"", "lemma aEval_leq : \"aEval (Leq p) L = (aEval (Less p) L \\<or> aEval (Eq p) L)\"", "lemma sum_eq : \"eval (Atom(Eq p)) L \\<longrightarrow> eval (Atom(Eq q)) L \\<longrightarrow> eval (Atom(Eq(p + q))) L\"", "lemma freeIn_list_conj : \"(\\<forall>f\\<in>set(F). freeIn var f) \\<Longrightarrow> freeIn var (list_conj F)\"", "lemma freeIn_list_disj : \n  assumes \"\\<forall>f\\<in>set (L::atom fm list). freeIn var f\"\n  shows \"freeIn var (list_disj L)\"", "lemma var_not_in_aEval : \"freeIn var (Atom \\<phi>) \\<Longrightarrow> (\\<exists>x. aEval \\<phi> (list_update L var x)) = (\\<forall>x. aEval \\<phi> (list_update L var x))\"", "lemma var_not_in_aEval2 : \"freeIn 0 (Atom \\<phi>) \\<Longrightarrow> (\\<exists>x. aEval \\<phi> (x#L)) = (\\<forall>x. aEval \\<phi> (x#L))\"", "lemma plugInLinear :\n  assumes lLength : \"length L>var\"\n  assumes nonzero : \"B\\<noteq>0\"\n  assumes hb : \"\\<forall>v. insertion (nth_default 0 (list_update L var v)) b = B\"\n  assumes hc : \"\\<forall>v. insertion (nth_default 0 (list_update L var v)) c = C\"\n  shows \"aEval (Eq(b*Var var + c)) (list_update L var (-C/B))\"", "lemma doubleExist : \"eval (ExN 2 A) L = eval (ExQ (ExQ A)) L\"", "lemma doubleForall : \"eval (AllN 2 A) L = eval (AllQ (AllQ A)) L\"", "lemma unwrapExist : \"eval (ExN (j + 1) A) L = eval (ExQ (ExN j A)) L\"", "lemma unwrapExist' : \"eval (ExN (j + 1) A) L =  eval (ExN j (ExQ A)) L\"", "lemma unwrapExist'' : \"eval (ExN (i + j) A) L = eval (ExN i(ExN j A)) L\"", "lemma unwrapForall : \"eval (AllN (j + 1) A) L = eval (AllQ (AllN j A)) L\"", "lemma unwrapForall' : \"eval (AllN (j + 1) A) L =  eval (AllN j (AllQ A)) L\"", "lemma unwrapForall'' : \"eval (AllN (i + j) A) L = eval (AllN i(AllN j A)) L\"", "lemma var_not_in_eval : \"\\<forall>var. \\<forall>L. (freeIn var \\<phi> \\<longrightarrow> ((\\<exists>x. eval \\<phi> (list_update L var x)) = (\\<forall>x. eval \\<phi> (list_update L var x))))\"", "lemma var_not_in_eval2 : \"\\<forall>L. (freeIn 0 \\<phi> \\<longrightarrow> ((\\<exists>x. eval \\<phi> (x#L)) = (\\<forall>x. eval \\<phi> (x#L))))\"", "lemma var_not_in_eval3 :\n  assumes \"freeIn var \\<phi>\"\n  assumes \"length xs' = var\"\n  shows \"((\\<exists>x. eval \\<phi> (xs'@x#L)) = (\\<forall>x. eval \\<phi> (xs'@x#L)))\"", "lemma eval_list_conj : \"eval (list_conj F) L = (\\<forall>f\\<in>set(F). eval f L)\"", "lemma eval_list_disj : \"eval (list_disj F) L = (\\<exists>f\\<in>set(F). eval f L)\""], "translations": [["", "lemma aNeg_aEval : \"aEval a L \\<longleftrightarrow> (\\<not> aEval (aNeg a) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval a L = (\\<not> aEval (aNeg a) L)", "apply(cases a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       a = Less x1 \\<Longrightarrow> aEval a L = (\\<not> aEval (aNeg a) L)\n 2. \\<And>x2.\n       a = Eq x2 \\<Longrightarrow> aEval a L = (\\<not> aEval (aNeg a) L)\n 3. \\<And>x3.\n       a = Leq x3 \\<Longrightarrow> aEval a L = (\\<not> aEval (aNeg a) L)\n 4. \\<And>x4.\n       a = Neq x4 \\<Longrightarrow> aEval a L = (\\<not> aEval (aNeg a) L)", "apply(auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>a = Less x1; insertion (nth_default 0 L) x1 < 0;\n        insertion (nth_default 0 L) (- x1) \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x1.\n       \\<lbrakk>a = Less x1;\n        \\<not> insertion (nth_default 0 L) (- x1) \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x1 < 0\n 3. \\<And>x3.\n       \\<lbrakk>a = Leq x3; insertion (nth_default 0 L) x3 \\<le> 0;\n        insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x3.\n       \\<lbrakk>a = Leq x3;\n        \\<not> insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x3 \\<le> 0", "apply(smt insertionNegative)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>a = Less x1;\n        \\<not> insertion (nth_default 0 L) (- x1) \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x1 < 0\n 2. \\<And>x3.\n       \\<lbrakk>a = Leq x3; insertion (nth_default 0 L) x3 \\<le> 0;\n        insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x3.\n       \\<lbrakk>a = Leq x3;\n        \\<not> insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x3 \\<le> 0", "apply(smt insertionNegative)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>a = Leq x3; insertion (nth_default 0 L) x3 \\<le> 0;\n        insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x3.\n       \\<lbrakk>a = Leq x3;\n        \\<not> insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x3 \\<le> 0", "apply(smt insertionNegative)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>a = Leq x3;\n        \\<not> insertion (nth_default 0 L) (- x3) < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 L) x3 \\<le> 0", "apply(smt insertionNegative)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"\nWe can extend this to formulas instead of just atoms. Given a formula in prenex normal form,\nwe simply iterate through and apply the quantifiers\n\""], ["", "fun eval :: \"atom fm \\<Rightarrow> real list \\<Rightarrow> bool\" where\n  \"eval (Atom a) \\<Gamma> = aEval a \\<Gamma>\" |\n  \"eval (TrueF) _ = True\" |\n  \"eval (FalseF) _ = False\" |\n  \"eval (And \\<phi> \\<psi>) \\<Gamma> = ((eval \\<phi> \\<Gamma>) \\<and> (eval \\<psi> \\<Gamma>))\" |\n  \"eval (Or \\<phi> \\<psi>) \\<Gamma> = ((eval \\<phi> \\<Gamma>) \\<or> (eval \\<psi> \\<Gamma>))\" |\n  \"eval (Neg \\<phi>) \\<Gamma> = (\\<not> (eval \\<phi> \\<Gamma>))\" |\n  \"eval (ExQ \\<phi>) \\<Gamma> = (\\<exists>x. (eval \\<phi> (x#\\<Gamma>)))\" |\n  \"eval (AllQ \\<phi>) \\<Gamma> = (\\<forall>x. (eval \\<phi> (x#\\<Gamma>)))\"|\n  \"eval (AllN i \\<phi>) \\<Gamma> = (\\<forall>l. length l = i \\<longrightarrow> (eval \\<phi> (l @ \\<Gamma>)))\"|\n  \"eval (ExN i \\<phi>) \\<Gamma> = (\\<exists>l. length l = i \\<and> (eval \\<phi> (l @ \\<Gamma>)))\""], ["", "lemma \"eval (ExQ (Or (Atom A) (Atom B))) xs =  eval (Or (ExQ(Atom A)) (ExQ(Atom B))) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExQ (Or (fm.Atom A) (fm.Atom B))) xs =\n    eval (Or (ExQ (fm.Atom A)) (ExQ (fm.Atom B))) xs", "by(auto)"], ["", "lemma eval_neg_neg : \"eval (neg (neg f)) L \\<longleftrightarrow> eval f L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (neg (neg f)) L = eval f L", "by (simp add: neg_def)"], ["", "lemma eval_neg : \"(\\<not> eval (neg f) L) \\<longleftrightarrow> eval f L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> eval (neg f) L) = eval f L", "by (simp add: neg_def)"], ["", "lemma eval_and : \"eval (and a b) L \\<longleftrightarrow> (eval a L \\<and> eval b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (and a b) L = (eval a L \\<and> eval b L)", "by (simp add: and_def)"], ["", "lemma eval_or : \"eval (or a b) L \\<longleftrightarrow> (eval a L \\<or> eval b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (or a b) L = (eval a L \\<or> eval b L)", "by (simp add: or_def)"], ["", "lemma eval_Or : \"eval (Or a b) L \\<longleftrightarrow> (eval a L \\<or> eval b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Or a b) L = (eval a L \\<or> eval b L)", "by (simp)"], ["", "lemma eval_And : \"eval (And a b) L \\<longleftrightarrow> (eval a L \\<and> eval b L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (And a b) L = (eval a L \\<and> eval b L)", "by (simp)"], ["", "lemma eval_not : \"eval (neg a) L \\<longleftrightarrow> \\<not>(eval a L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (neg a) L = (\\<not> eval a L)", "by (simp add: neg_def)"], ["", "lemma eval_true : \"eval TrueF L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval TrueF L", "by simp"], ["", "lemma eval_false : \"\\<not>(eval FalseF L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval FalseF L", "by simp"], ["", "lemma eval_Neg : \"eval (Neg \\<phi>) L = eval (neg \\<phi>) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Neg \\<phi>) L = eval (neg \\<phi>) L", "by (simp add: eval_not)"], ["", "lemma eval_Neg_Neg : \"eval (Neg (Neg \\<phi>)) L = eval \\<phi> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Neg (Neg \\<phi>)) L = eval \\<phi> L", "by (simp add: eval_not)"], ["", "lemma eval_Neg_And : \"eval (Neg (And \\<phi> \\<psi>)) L = eval (Or (Neg \\<phi>) (Neg \\<psi>)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Neg (And \\<phi> \\<psi>)) L = eval (Or (Neg \\<phi>) (Neg \\<psi>)) L", "by simp"], ["", "lemma aEval_leq : \"aEval (Leq p) L = (aEval (Less p) L \\<or> aEval (Eq p) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Leq p) L = (aEval (Less p) L \\<or> aEval (Eq p) L)", "by auto"], ["", "text \"This function is misleading because it is true iff \n  the variable given doesn't occur as a free variable in the atom fm\""], ["", "fun freeIn :: \"nat \\<Rightarrow> atom fm \\<Rightarrow> bool\" where\n  \"freeIn var (Atom(Eq p)) = (var \\<notin> (vars p))\"|\n  \"freeIn var (Atom(Less p)) = (var \\<notin> (vars p))\"|\n  \"freeIn var (Atom(Leq p)) = (var \\<notin> (vars p))\"|\n  \"freeIn var (Atom(Neq p)) = (var \\<notin> (vars p))\"|\n  \"freeIn var (TrueF) = True\"|\n  \"freeIn var (FalseF) = True\"|\n  \"freeIn var (And a b) = ((freeIn var a) \\<and> (freeIn var b))\"|\n  \"freeIn var (Or a b) = ((freeIn var a) \\<and> (freeIn var b))\"|\n  \"freeIn var (Neg a) = freeIn var a\"|\n  \"freeIn var (ExQ a) = freeIn (var+1) a\"|\n  \"freeIn var (AllQ a) = freeIn (var+1) a\"|\n  \"freeIn var (AllN i a) = freeIn (var+i) a\"|\n  \"freeIn var (ExN i a) = freeIn (var+i) a\""], ["", "fun liftmap :: \"(nat \\<Rightarrow> atom \\<Rightarrow> atom fm) \\<Rightarrow> atom fm \\<Rightarrow> nat \\<Rightarrow> atom fm\" where\n  \"liftmap f TrueF var = TrueF\"|\n  \"liftmap f FalseF var = FalseF\"|\n  \"liftmap f (Atom a) var = f var a\"|\n  \"liftmap f (And \\<phi> \\<psi>) var = And (liftmap f \\<phi> var) (liftmap f \\<psi> var)\"|\n  \"liftmap f (Or \\<phi> \\<psi>) var = Or (liftmap f \\<phi> var) (liftmap f \\<psi> var)\"|\n  \"liftmap f (Neg \\<phi>) var = Neg (liftmap f \\<phi> var)\"|\n  \"liftmap f (ExQ \\<phi>) var = ExQ (liftmap f \\<phi> (var+1))\"|\n  \"liftmap f (AllQ \\<phi>) var = AllQ (liftmap f \\<phi> (var+1))\"|\n  \"liftmap f (AllN i \\<phi>) var = AllN i (liftmap f \\<phi> (var+i))\"|\n  \"liftmap f (ExN i \\<phi>) var = ExN i (liftmap f \\<phi> (var+i))\""], ["", "(*\nfun greatestFreeVariable :: \"atom fm \\<Rightarrow> nat option\" where\n\"greatestFreeVariable F = None\"\n\nfun is_closed :: \"atom fm \\<Rightarrow> real list \\<Rightarrow> bool\" where\n\"is_closed F xs = (case greatestFreeVariable F of Some x \\<Rightarrow> (x = length xs) | None \\<Rightarrow> (0=length xs))\"\n*)"], ["", "fun depth :: \"'a fm \\<Rightarrow> nat\"where\n  \"depth TrueF = 1\"|\n  \"depth FalseF = 1\"|\n  \"depth (Atom _) = 1\"|\n  \"depth (And \\<phi> \\<psi>) = max (depth \\<phi>) (depth \\<psi>) + 1\"|\n  \"depth (Or \\<phi> \\<psi>) = max (depth \\<phi>) (depth \\<psi>) + 1\"|\n  \"depth (Neg \\<phi>) = depth \\<phi> + 1\"|\n  \"depth (ExQ \\<phi>) = depth \\<phi> + 1\"|\n  \"depth (AllQ \\<phi>) = depth \\<phi> + 1\"|\n  \"depth (AllN i \\<phi>) = depth \\<phi> + 1\"|\n  \"depth (ExN i \\<phi>) = depth \\<phi> + 1\""], ["", "value \"AllQ (And \n    (ExQ (Atom (Eq (Var 1 * Var 2 - (Var 0)^2 * Var 3))))\n    (Neg (AllQ (Atom (Leq (Const 5 * (Var 1)^2 - Var 0)))))\n)\""], ["", "fun negation_free :: \"atom fm \\<Rightarrow> bool\" where \n  \"negation_free TrueF = True\" |\n  \"negation_free FalseF = True \" |\n  \"negation_free (Atom a) = True\" |\n  \"negation_free (And \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = ((negation_free \\<phi>\\<^sub>1) \\<and> (negation_free \\<phi>\\<^sub>2))\" |\n  \"negation_free (Or \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = ((negation_free \\<phi>\\<^sub>1) \\<and> (negation_free \\<phi>\\<^sub>2))\" |\n  \"negation_free (ExQ \\<phi>) = negation_free \\<phi>\" |\n  \"negation_free (AllQ \\<phi>) = negation_free \\<phi>\" |\n  \"negation_free (AllN i \\<phi>) = negation_free \\<phi>\" |\n  \"negation_free (ExN i \\<phi>) = negation_free \\<phi>\" |\n  \"negation_free (Neg _) = False\""], ["", "subsection \"Useful Properties\""], ["", "lemma sum_eq : \"eval (Atom(Eq p)) L \\<longrightarrow> eval (Atom(Eq q)) L \\<longrightarrow> eval (Atom(Eq(p + q))) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (fm.Atom (Eq p)) L \\<longrightarrow>\n    eval (fm.Atom (Eq q)) L \\<longrightarrow> eval (fm.Atom (Eq (p + q))) L", "by (simp add: insertion_add)"], ["", "lemma freeIn_list_conj : \"(\\<forall>f\\<in>set(F). freeIn var f) \\<Longrightarrow> freeIn var (list_conj F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set F. freeIn var f \\<Longrightarrow>\n    freeIn var (list_conj F)", "proof(induct F)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set []) (freeIn var) \\<Longrightarrow> freeIn var (list_conj [])\n 2. \\<And>a F.\n       \\<lbrakk>Ball (set F) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_conj F);\n        Ball (set (a # F)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_conj (a # F))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. freeIn var a\n\ngoal (2 subgoals):\n 1. Ball (set []) (freeIn var) \\<Longrightarrow> freeIn var (list_conj [])\n 2. \\<And>a F.\n       \\<lbrakk>Ball (set F) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_conj F);\n        Ball (set (a # F)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_conj (a # F))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set []. freeIn var a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var (list_conj [])", "by(simp add: list_conj_def)"], ["proof (state)\nthis:\n  freeIn var (list_conj [])\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>Ball (set F) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_conj F);\n        Ball (set (a # F)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_conj (a # F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>Ball (set F) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_conj F);\n        Ball (set (a # F)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_conj (a # F))", "case (Cons a F)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set F. freeIn var a \\<Longrightarrow>\n  freeIn var (list_conj F)\n  \\<forall>a\\<in>set (a # F). freeIn var a\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>Ball (set F) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_conj F);\n        Ball (set (a # F)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_conj (a # F))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set F. freeIn var a \\<Longrightarrow>\n  freeIn var (list_conj F)\n  \\<forall>a\\<in>set (a # F). freeIn var a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set F. freeIn var a \\<Longrightarrow>\n  freeIn var (list_conj F)\n  \\<forall>a\\<in>set (a # F). freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var (list_conj (a # F))", "by (simp add: PolyAtoms.and_def list_conj_def)"], ["proof (state)\nthis:\n  freeIn var (list_conj (a # F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeIn_list_disj : \n  assumes \"\\<forall>f\\<in>set (L::atom fm list). freeIn var f\"\n  shows \"freeIn var (list_disj L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (list_disj L)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set L. freeIn var f\n\ngoal (1 subgoal):\n 1. freeIn var (list_disj L)", "proof(induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set []) (freeIn var) \\<Longrightarrow> freeIn var (list_disj [])\n 2. \\<And>a L.\n       \\<lbrakk>Ball (set L) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_disj L);\n        Ball (set (a # L)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_disj (a # L))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set []. freeIn var a\n\ngoal (2 subgoals):\n 1. Ball (set []) (freeIn var) \\<Longrightarrow> freeIn var (list_disj [])\n 2. \\<And>a L.\n       \\<lbrakk>Ball (set L) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_disj L);\n        Ball (set (a # L)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_disj (a # L))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set []. freeIn var a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var (list_disj [])", "unfolding list_disj_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set []. freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var (foldr or [] FalseF)", "by auto"], ["proof (state)\nthis:\n  freeIn var (list_disj [])\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>Ball (set L) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_disj L);\n        Ball (set (a # L)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_disj (a # L))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>Ball (set L) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_disj L);\n        Ball (set (a # L)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_disj (a # L))", "case (Cons a L)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set L. freeIn var a \\<Longrightarrow>\n  freeIn var (list_disj L)\n  \\<forall>a\\<in>set (a # L). freeIn var a\n\ngoal (1 subgoal):\n 1. \\<And>a L.\n       \\<lbrakk>Ball (set L) (freeIn var) \\<Longrightarrow>\n                freeIn var (list_disj L);\n        Ball (set (a # L)) (freeIn var)\\<rbrakk>\n       \\<Longrightarrow> freeIn var (list_disj (a # L))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set L. freeIn var a \\<Longrightarrow>\n  freeIn var (list_disj L)\n  \\<forall>a\\<in>set (a # L). freeIn var a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set L. freeIn var a \\<Longrightarrow>\n  freeIn var (list_disj L)\n  \\<forall>a\\<in>set (a # L). freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var (list_disj (a # L))", "unfolding list_disj_def or_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set L. freeIn var a \\<Longrightarrow>\n  freeIn var\n   (foldr\n     (\\<lambda>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n         if \\<phi>\\<^sub>1 = FalseF then \\<phi>\\<^sub>2\n         else if \\<phi>\\<^sub>2 = FalseF then \\<phi>\\<^sub>1\n              else if \\<phi>\\<^sub>1 = TrueF \\<or> \\<phi>\\<^sub>2 = TrueF\n                   then TrueF else Or \\<phi>\\<^sub>1 \\<phi>\\<^sub>2)\n     L FalseF)\n  \\<forall>a\\<in>set (a # L). freeIn var a\n\ngoal (1 subgoal):\n 1. freeIn var\n     (foldr\n       (\\<lambda>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n           if \\<phi>\\<^sub>1 = FalseF then \\<phi>\\<^sub>2\n           else if \\<phi>\\<^sub>2 = FalseF then \\<phi>\\<^sub>1\n                else if \\<phi>\\<^sub>1 = TrueF \\<or> \\<phi>\\<^sub>2 = TrueF\n                     then TrueF else Or \\<phi>\\<^sub>1 \\<phi>\\<^sub>2)\n       (a # L) FalseF)", "by simp"], ["proof (state)\nthis:\n  freeIn var (list_disj (a # L))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma var_not_in_aEval : \"freeIn var (Atom \\<phi>) \\<Longrightarrow> (\\<exists>x. aEval \\<phi> (list_update L var x)) = (\\<forall>x. aEval \\<phi> (list_update L var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn var (fm.Atom \\<phi>) \\<Longrightarrow>\n    (\\<exists>x. aEval \\<phi> (L[var := x])) =\n    (\\<forall>x. aEval \\<phi> (L[var := x]))", "proof(induction \\<phi>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Less x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Less x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Less x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Eq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Eq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Eq x) (L[var := xa]))\n 3. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 4. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "case (Less p)"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (Less p))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Less x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Less x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Less x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Eq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Eq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Eq x) (L[var := xa]))\n 3. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 4. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "then"], ["proof (chain)\npicking this:\n  freeIn var (fm.Atom (Less p))", "show ?case"], ["proof (prove)\nusing this:\n  freeIn var (fm.Atom (Less p))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. aEval (Less p) (L[var := x])) =\n    (\\<forall>x. aEval (Less p) (L[var := x]))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p < 0", "using not_contains_insertion"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p;\n   insertion (nth_default 0 (?L[?var := ?x])) ?p = ?val\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?L[?var := ?y])) ?p = ?val\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p < 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p < 0", "by metis"], ["proof (state)\nthis:\n  (\\<exists>x. aEval (Less p) (L[var := x])) =\n  (\\<forall>x. aEval (Less p) (L[var := x]))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Eq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Eq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Eq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 3. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Eq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Eq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Eq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 3. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "case (Eq p)"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (Eq p))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Eq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Eq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Eq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 3. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "then"], ["proof (chain)\npicking this:\n  freeIn var (fm.Atom (Eq p))", "show ?case"], ["proof (prove)\nusing this:\n  freeIn var (fm.Atom (Eq p))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. aEval (Eq p) (L[var := x])) =\n    (\\<forall>x. aEval (Eq p) (L[var := x]))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p = 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p = 0", "using not_contains_insertion"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p;\n   insertion (nth_default 0 (?L[?var := ?x])) ?p = ?val\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?L[?var := ?y])) ?p = ?val\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p = 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p = 0", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. aEval (Eq p) (L[var := x])) =\n  (\\<forall>x. aEval (Eq p) (L[var := x]))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "case (Leq p)"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (Leq p))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Leq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Leq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Leq x) (L[var := xa]))\n 2. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "then"], ["proof (chain)\npicking this:\n  freeIn var (fm.Atom (Leq p))", "show ?case"], ["proof (prove)\nusing this:\n  freeIn var (fm.Atom (Leq p))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. aEval (Leq p) (L[var := x])) =\n    (\\<forall>x. aEval (Leq p) (L[var := x]))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p \\<le> 0", "using not_contains_insertion"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p;\n   insertion (nth_default 0 (?L[?var := ?x])) ?p = ?val\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?L[?var := ?y])) ?p = ?val\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> insertion (nth_default 0 (L[var := xa])) p \\<le> 0", "by metis"], ["proof (state)\nthis:\n  (\\<exists>x. aEval (Leq p) (L[var := x])) =\n  (\\<forall>x. aEval (Leq p) (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "case (Neq p)"], ["proof (state)\nthis:\n  freeIn var (fm.Atom (Neq p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       freeIn var (fm.Atom (Neq x)) \\<Longrightarrow>\n       (\\<exists>xa. aEval (Neq x) (L[var := xa])) =\n       (\\<forall>xa. aEval (Neq x) (L[var := xa]))", "then"], ["proof (chain)\npicking this:\n  freeIn var (fm.Atom (Neq p))", "show ?case"], ["proof (prove)\nusing this:\n  freeIn var (fm.Atom (Neq p))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. aEval (Neq p) (L[var := x])) =\n    (\\<forall>x. aEval (Neq p) (L[var := x]))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p \\<noteq> 0;\n        insertion (nth_default 0 (L[var := xa])) p = 0\\<rbrakk>\n       \\<Longrightarrow> False", "using not_contains_insertion"], ["proof (prove)\nusing this:\n  \\<lbrakk>?var \\<notin> vars ?p;\n   insertion (nth_default 0 (?L[?var := ?x])) ?p = ?val\\<rbrakk>\n  \\<Longrightarrow> insertion (nth_default 0 (?L[?var := ?y])) ?p = ?val\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>var \\<notin> vars p;\n        insertion (nth_default 0 (L[var := x])) p \\<noteq> 0;\n        insertion (nth_default 0 (L[var := xa])) p = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by metis"], ["proof (state)\nthis:\n  (\\<exists>x. aEval (Neq p) (L[var := x])) =\n  (\\<forall>x. aEval (Neq p) (L[var := x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma var_not_in_aEval2 : \"freeIn 0 (Atom \\<phi>) \\<Longrightarrow> (\\<exists>x. aEval \\<phi> (x#L)) = (\\<forall>x. aEval \\<phi> (x#L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeIn 0 (fm.Atom \\<phi>) \\<Longrightarrow>\n    (\\<exists>x. aEval \\<phi> (x # L)) = (\\<forall>x. aEval \\<phi> (x # L))", "by (metis list_update_code(2) var_not_in_aEval)"], ["", "lemma plugInLinear :\n  assumes lLength : \"length L>var\"\n  assumes nonzero : \"B\\<noteq>0\"\n  assumes hb : \"\\<forall>v. insertion (nth_default 0 (list_update L var v)) b = B\"\n  assumes hc : \"\\<forall>v. insertion (nth_default 0 (list_update L var v)) c = C\"\n  shows \"aEval (Eq(b*Var var + c)) (list_update L var (-C/B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aEval (Eq (b * Var var + c)) (L[var := - C / B])", "by(simp add: lLength insertion_add insertion_mult nonzero hb hc insertion_var)"], ["", "subsection \"Some eval results\""], ["", "lemma doubleExist : \"eval (ExN 2 A) L = eval (ExQ (ExQ A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN 2 A) L = eval (ExQ (ExQ A)) L", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = 2 \\<and> eval A (l @ L)) =\n    (\\<exists>x xa. eval A (xa # x # L))", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = 2; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = 2; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "assume h : \"length l = 2\" \"eval A (l @ L)\""], ["proof (state)\nthis:\n  length l = 2\n  eval A (l @ L)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = 2; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "show \"\\<exists>x xa. eval A (xa # x # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "proof(cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "case Nil"], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "then"], ["proof (chain)\npicking this:\n  l = []", "show ?thesis"], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "using h"], ["proof (prove)\nusing this:\n  l = []\n  length l = 2\n  eval A (l @ L)\n\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x xa. eval A (xa # x # L)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "case (Cons a list)"], ["proof (state)\nthis:\n  l = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "then"], ["proof (chain)\npicking this:\n  l = a # list", "have Cons' : \"l = a # list\""], ["proof (prove)\nusing this:\n  l = a # list\n\ngoal (1 subgoal):\n 1. l = a # list", "by auto"], ["proof (state)\nthis:\n  l = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "then"], ["proof (chain)\npicking this:\n  l = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  l = a # list\n\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "proof(cases list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l = a # list; list = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>aa lista.\n       \\<lbrakk>l = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "case Nil"], ["proof (state)\nthis:\n  list = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l = a # list; list = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)\n 2. \\<And>aa lista.\n       \\<lbrakk>l = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "then"], ["proof (chain)\npicking this:\n  list = []", "show ?thesis"], ["proof (prove)\nusing this:\n  list = []\n\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "using h Cons"], ["proof (prove)\nusing this:\n  list = []\n  length l = 2\n  eval A (l @ L)\n  l = a # list\n\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x xa. eval A (xa # x # L)\n\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>l = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>l = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "case (Cons b list)"], ["proof (state)\nthis:\n  list__ = b # list\n\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>l = a # list__; list__ = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x xa. eval A (xa # x # L)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x xa. eval A (xa # x # L)", "apply(rule exI[where x=b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa. eval A (xa # b # L)", "apply(rule exI[where x=a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval A (a # b # L)", "using h Cons' Cons"], ["proof (prove)\nusing this:\n  length l = 2\n  eval A (l @ L)\n  l = a # list__\n  list__ = b # list\n\ngoal (1 subgoal):\n 1. eval A (a # b # L)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x xa. eval A (xa # x # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x xa. eval A (xa # x # L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x xa. eval A (xa # x # L)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "fix x xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "assume h : \"eval A (xa # x # L)\""], ["proof (state)\nthis:\n  eval A (xa # x # L)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eval A (xa # x # L) \\<Longrightarrow>\n       \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "show \"\\<exists>l. length l = 2 \\<and> eval A (l @ L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. length l = 2 \\<and> eval A (l @ L)", "apply(rule exI[where x=\"[xa,x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [xa, x] = 2 \\<and> eval A ([xa, x] @ L)", "using h"], ["proof (prove)\nusing this:\n  eval A (xa # x # L)\n\ngoal (1 subgoal):\n 1. length [xa, x] = 2 \\<and> eval A ([xa, x] @ L)", "by simp"], ["proof (state)\nthis:\n  \\<exists>l. length l = 2 \\<and> eval A (l @ L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma doubleForall : \"eval (AllN 2 A) L = eval (AllQ (AllQ A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN 2 A) L = eval (AllQ (AllQ A)) L", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>l. length l = 2 \\<longrightarrow> eval A (l @ L)) =\n    (\\<forall>x xa. eval A (xa # x # L))", "using doubleExist eval_neg"], ["proof (prove)\nusing this:\n  eval (ExN 2 ?A) ?L = eval (ExQ (ExQ ?A)) ?L\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. (\\<forall>l. length l = 2 \\<longrightarrow> eval A (l @ L)) =\n    (\\<forall>x xa. eval A (xa # x # L))", "by fastforce"], ["", "lemma unwrapExist : \"eval (ExN (j + 1) A) L = eval (ExQ (ExN j A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN (j + 1) A) L = eval (ExQ (ExN j A)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = Suc j \\<and> eval A (l @ L)) =\n    (\\<exists>x l. length l = j \\<and> eval A (l @ x # L))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x l.\n                            length l = j \\<and> eval A (l @ x # L)\n 2. \\<And>x l.\n       \\<lbrakk>eval A (l @ x # L); j = length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>la.\n                            length la = Suc (length l) \\<and>\n                            eval A (la @ L)", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x l. length l = j \\<and> eval A (l @ x # L)", "apply(rule exI[where x=\"nth l j\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = j \\<and> eval A (la @ l ! j # L)", "apply(rule exI[where x=\"take j l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> length (take j l) = j \\<and>\n                      eval A (take j l @ l ! j # L)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> eval A (take j l @ l ! j # L)", "by (metis Cons_nth_drop_Suc append.assoc append_Cons append_eq_append_conv_if append_take_drop_id lessI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>eval A (l @ x # L); j = length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>la.\n                            length la = Suc (length l) \\<and>\n                            eval A (la @ L)", "subgoal for x l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval A (l @ x # L); j = length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = Suc (length l) \\<and> eval A (la @ L)", "apply(rule exI[where x=\"l @ [x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval A (l @ x # L); j = length l\\<rbrakk>\n    \\<Longrightarrow> length (l @ [x]) = Suc (length l) \\<and>\n                      eval A ((l @ [x]) @ L)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unwrapExist' : \"eval (ExN (j + 1) A) L =  eval (ExN j (ExQ A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN (j + 1) A) L = eval (ExN j (ExQ A)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = Suc j \\<and> eval A (l @ L)) =\n    (\\<exists>l. length l = j \\<and> (\\<exists>x. eval A (x # l @ L)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = j \\<and>\n                            (\\<exists>x. eval A (x # l @ L))\n 2. \\<And>l x.\n       \\<lbrakk>j = length l; eval A (x # l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>la.\n                            length la = Suc (length l) \\<and>\n                            eval A (la @ L)", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = j \\<and>\n                         (\\<exists>x. eval A (x # l @ L))", "apply(rule exI[where x=\"drop 1 l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> length (drop 1 l) = j \\<and>\n                      (\\<exists>x. eval A (x # drop 1 l @ L))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. eval A (x # drop (Suc 0) l @ L)", "apply(rule exI[where x=\"nth l 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = Suc j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> eval A (l ! 0 # drop (Suc 0) l @ L)", "by (metis Cons_nth_drop_Suc append_Cons drop0 zero_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x.\n       \\<lbrakk>j = length l; eval A (x # l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>la.\n                            length la = Suc (length l) \\<and>\n                            eval A (la @ L)", "subgoal for l x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = length l; eval A (x # l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = Suc (length l) \\<and> eval A (la @ L)", "apply(rule exI[where x=\"x#l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = length l; eval A (x # l @ L)\\<rbrakk>\n    \\<Longrightarrow> length (x # l) = Suc (length l) \\<and>\n                      eval A ((x # l) @ L)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unwrapExist'' : \"eval (ExN (i + j) A) L = eval (ExN i(ExN j A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (ExN (i + j) A) L = eval (ExN i (ExN j A)) L", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>l. length l = i + j \\<and> eval A (l @ L)) =\n    (\\<exists>l.\n        length l = i \\<and>\n        (\\<exists>la. length la = j \\<and> eval A (la @ l @ L)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            length l = i \\<and>\n                            (\\<exists>la.\n                                length la = j \\<and> eval A (la @ l @ L))\n 2. \\<And>l la.\n       \\<lbrakk>i = length l; eval A (la @ l @ L); j = length la\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lb.\n                            length lb = length l + length la \\<and>\n                            eval A (lb @ L)", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l.\n                         length l = i \\<and>\n                         (\\<exists>la.\n                             length la = j \\<and> eval A (la @ l @ L))", "apply(rule exI[where x=\"drop j l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> length (drop j l) = i \\<and>\n                      (\\<exists>la.\n                          length la = j \\<and> eval A (la @ drop j l @ L))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la.\n                         length la = j \\<and> eval A (la @ drop j l @ L)", "apply(rule exI[where x=\"take j l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> length (take j l) = j \\<and>\n                      eval A (take j l @ drop j l @ L)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length l = i + j; eval A (l @ L)\\<rbrakk>\n    \\<Longrightarrow> eval A (take j l @ drop j l @ L)", "by (metis append.assoc append_take_drop_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l la.\n       \\<lbrakk>i = length l; eval A (la @ l @ L); j = length la\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lb.\n                            length lb = length l + length la \\<and>\n                            eval A (lb @ L)", "subgoal for l la"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = length l; eval A (la @ l @ L); j = length la\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lb.\n                         length lb = length l + length la \\<and>\n                         eval A (lb @ L)", "apply(rule exI[where x=\"la@l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = length l; eval A (la @ l @ L); j = length la\\<rbrakk>\n    \\<Longrightarrow> length (la @ l) = length l + length la \\<and>\n                      eval A ((la @ l) @ L)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unwrapForall : \"eval (AllN (j + 1) A) L = eval (AllQ (AllN j A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN (j + 1) A) L = eval (AllQ (AllN j A)) L", "using unwrapExist[of j \"neg A\" L] eval_neg"], ["proof (prove)\nusing this:\n  eval (ExN (j + 1) (neg A)) L = eval (ExQ (ExN j (neg A))) L\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. eval (AllN (j + 1) A) L = eval (AllQ (AllN j A)) L", "by fastforce"], ["", "lemma unwrapForall' : \"eval (AllN (j + 1) A) L =  eval (AllN j (AllQ A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN (j + 1) A) L = eval (AllN j (AllQ A)) L", "using unwrapExist'[of j \"neg A\" L] eval_neg"], ["proof (prove)\nusing this:\n  eval (ExN (j + 1) (neg A)) L = eval (ExN j (ExQ (neg A))) L\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. eval (AllN (j + 1) A) L = eval (AllN j (AllQ A)) L", "by fastforce"], ["", "lemma unwrapForall'' : \"eval (AllN (i + j) A) L = eval (AllN i(AllN j A)) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (AllN (i + j) A) L = eval (AllN i (AllN j A)) L", "using unwrapExist''[of i j \"neg A\" L] eval_neg"], ["proof (prove)\nusing this:\n  eval (ExN (i + j) (neg A)) L = eval (ExN i (ExN j (neg A))) L\n  (\\<not> eval (neg ?f) ?L) = eval ?f ?L\n\ngoal (1 subgoal):\n 1. eval (AllN (i + j) A) L = eval (AllN i (AllN j A)) L", "by fastforce"], ["", "lemma var_not_in_eval : \"\\<forall>var. \\<forall>L. (freeIn var \\<phi> \\<longrightarrow> ((\\<exists>x. eval \\<phi> (list_update L var x)) = (\\<forall>x. eval \\<phi> (list_update L var x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var \\<phi> \\<longrightarrow>\n       (\\<exists>x. eval \\<phi> (L[var := x])) =\n       (\\<forall>x. eval \\<phi> (L[var := x]))", "proof(induction \\<phi>)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<forall>var L.\n       freeIn var TrueF \\<longrightarrow>\n       (\\<exists>x. eval TrueF (L[var := x])) =\n       (\\<forall>x. eval TrueF (L[var := x]))\n 2. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))\n 3. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 7. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 8. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 9. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 10. \\<And>x1 \\<phi>.\n        \\<forall>var L.\n           freeIn var \\<phi> \\<longrightarrow>\n           (\\<exists>x. eval \\<phi> (L[var := x])) =\n           (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n        \\<forall>var L.\n           freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n           (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n           (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case TrueF"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<forall>var L.\n       freeIn var TrueF \\<longrightarrow>\n       (\\<exists>x. eval TrueF (L[var := x])) =\n       (\\<forall>x. eval TrueF (L[var := x]))\n 2. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))\n 3. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 5. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 7. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 8. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 9. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 10. \\<And>x1 \\<phi>.\n        \\<forall>var L.\n           freeIn var \\<phi> \\<longrightarrow>\n           (\\<exists>x. eval \\<phi> (L[var := x])) =\n           (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n        \\<forall>var L.\n           freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n           (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n           (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var TrueF \\<longrightarrow>\n       (\\<exists>x. eval TrueF (L[var := x])) =\n       (\\<forall>x. eval TrueF (L[var := x]))", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var TrueF \\<longrightarrow>\n     (\\<exists>x. eval TrueF (L[var := x])) =\n     (\\<forall>x. eval TrueF (L[var := x]))\n\ngoal (9 subgoals):\n 1. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))\n 2. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 7. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 9. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))\n 2. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 7. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 9. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case FalseF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))\n 2. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 7. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 9. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var FalseF \\<longrightarrow>\n       (\\<exists>x. eval FalseF (L[var := x])) =\n       (\\<forall>x. eval FalseF (L[var := x]))", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var FalseF \\<longrightarrow>\n     (\\<exists>x. eval FalseF (L[var := x])) =\n     (\\<forall>x. eval FalseF (L[var := x]))\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (Atom x)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x.\n       \\<forall>var L.\n          freeIn var (fm.Atom x) \\<longrightarrow>\n          (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n          (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 6. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 8. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (fm.Atom x) \\<longrightarrow>\n       (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n       (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))", "using var_not_in_aEval eval.simps(1)"], ["proof (prove)\nusing this:\n  freeIn ?var (fm.Atom ?\\<phi>) \\<Longrightarrow>\n  (\\<exists>x. aEval ?\\<phi> (?L[?var := x])) =\n  (\\<forall>x. aEval ?\\<phi> (?L[?var := x]))\n  eval (fm.Atom ?a) ?\\<Gamma> = aEval ?a ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (fm.Atom x) \\<longrightarrow>\n       (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n       (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))", "by blast"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (fm.Atom x) \\<longrightarrow>\n     (\\<exists>xa. eval (fm.Atom x) (L[var := xa])) =\n     (\\<forall>xa. eval (fm.Atom x) (L[var := xa]))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (And \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 5. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 7. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n       (\\<exists>x. eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n       (\\<forall>x. eval (And \\<phi>1 \\<phi>2) (L[var := x]))", "by (meson eval.simps(4) freeIn.simps(7))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (And \\<phi>1 \\<phi>2) \\<longrightarrow>\n     (\\<exists>x. eval (And \\<phi>1 \\<phi>2) (L[var := x])) =\n     (\\<forall>x. eval (And \\<phi>1 \\<phi>2) (L[var := x]))\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>\\<forall>var L.\n                   freeIn var \\<phi>1 \\<longrightarrow>\n                   (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n                   (\\<forall>x. eval \\<phi>1 (L[var := x]));\n        \\<forall>var L.\n           freeIn var \\<phi>2 \\<longrightarrow>\n           (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n           (\\<forall>x. eval \\<phi>2 (L[var := x]))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>var L.\n                            freeIn var\n                             (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n                            (\\<exists>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n                            (\\<forall>x.\n                                eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 4. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 6. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>var L.\n     freeIn var \\<phi>1 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>1 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>1 (L[var := x]))\n  \\<forall>var L.\n     freeIn var \\<phi>2 \\<longrightarrow>\n     (\\<exists>x. eval \\<phi>2 (L[var := x])) =\n     (\\<forall>x. eval \\<phi>2 (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n       (\\<exists>x. eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n       (\\<forall>x. eval (Or \\<phi>1 \\<phi>2) (L[var := x]))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (Or \\<phi>1 \\<phi>2) \\<longrightarrow>\n     (\\<exists>x. eval (Or \\<phi>1 \\<phi>2) (L[var := x])) =\n     (\\<forall>x. eval (Or \\<phi>1 \\<phi>2) (L[var := x]))\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (Neg \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 3. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 5. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (Neg \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))", "by (meson eval.simps(6) freeIn.simps(9))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (Neg \\<phi>) \\<longrightarrow>\n     (\\<exists>x. eval (Neg \\<phi>) (L[var := x])) =\n     (\\<forall>x. eval (Neg \\<phi>) (L[var := x]))\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (ExQ \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "fix xa L var x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "have  \"(xa::real) # L[var := x] = (xa#L)[var+1:=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa # L[var := x] = (xa # L)[var + 1 := x]", "by simp"], ["proof (state)\nthis:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n\ngoal (4 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n 2. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 4. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]", "show ?case"], ["proof (prove)\nusing this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (ExQ \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))", "using ExQ"], ["proof (prove)\nusing this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (ExQ \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))", "by (metis Suc_eq_plus1 eval.simps(7) freeIn.simps(10) list_update_code(3))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (ExQ \\<phi>) \\<longrightarrow>\n     (\\<exists>x. eval (ExQ \\<phi>) (L[var := x])) =\n     (\\<forall>x. eval (ExQ \\<phi>) (L[var := x]))\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (AllQ \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "fix xa L var x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "have  \"(xa::real) # L[var := x] = (xa#L)[var+1:=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa # L[var := x] = (xa # L)[var + 1 := x]", "by simp"], ["proof (state)\nthis:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n\ngoal (3 subgoals):\n 1. \\<And>\\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllQ \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 3. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]", "show ?case"], ["proof (prove)\nusing this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (AllQ \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))", "using AllQ"], ["proof (prove)\nusing this:\n  xa # L[var := x] = (xa # L)[var + 1 := x]\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (AllQ \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))", "by (metis Suc_eq_plus1 eval.simps(8) freeIn.simps(11) list_update_code(3))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (AllQ \\<phi>) \\<longrightarrow>\n     (\\<exists>x. eval (AllQ \\<phi>) (L[var := x])) =\n     (\\<forall>x. eval (AllQ \\<phi>) (L[var := x]))\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (ExN i \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "{"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "fix xa L var x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "assume \"length (xa::real list) = i\""], ["proof (state)\nthis:\n  length xa = i\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "have  \"xa @ L[var := x] = (xa@L)[var+i:=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa @ L[var := x] = (xa @ L)[var + i := x]", "by (simp add: \\<open>length xa = i\\<close> list_update_append)"], ["proof (state)\nthis:\n  xa @ L[var := x] = (xa @ L)[var + i := x]\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "}"], ["proof (state)\nthis:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n\ngoal (2 subgoals):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (ExN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (ExN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (ExN x1 \\<phi>) (L[var := x]))\n 2. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]", "show ?case"], ["proof (prove)\nusing this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (ExN i \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (ExN i \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (ExN i \\<phi>) (L[var := x]))", "using ExN"], ["proof (prove)\nusing this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (ExN i \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (ExN i \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (ExN i \\<phi>) (L[var := x]))", "by (metis eval.simps(10) freeIn.simps(13))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (ExN i \\<phi>) \\<longrightarrow>\n     (\\<exists>x. eval (ExN i \\<phi>) (L[var := x])) =\n     (\\<forall>x. eval (ExN i \\<phi>) (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "case (AllN i \\<phi>)"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "{"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "fix xa L var x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "assume \"length (xa::real list) = i\""], ["proof (state)\nthis:\n  length xa = i\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "have  \"xa @ L[var := x] = (xa@L)[var+i:=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa @ L[var := x] = (xa @ L)[var + i := x]", "by (simp add: \\<open>length xa = i\\<close> list_update_append)"], ["proof (state)\nthis:\n  xa @ L[var := x] = (xa @ L)[var + i := x]\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "}"], ["proof (state)\nthis:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n\ngoal (1 subgoal):\n 1. \\<And>x1 \\<phi>.\n       \\<forall>var L.\n          freeIn var \\<phi> \\<longrightarrow>\n          (\\<exists>x. eval \\<phi> (L[var := x])) =\n          (\\<forall>x. eval \\<phi> (L[var := x])) \\<Longrightarrow>\n       \\<forall>var L.\n          freeIn var (AllN x1 \\<phi>) \\<longrightarrow>\n          (\\<exists>x. eval (AllN x1 \\<phi>) (L[var := x])) =\n          (\\<forall>x. eval (AllN x1 \\<phi>) (L[var := x]))", "then"], ["proof (chain)\npicking this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]", "show ?case"], ["proof (prove)\nusing this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (AllN i \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (AllN i \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (AllN i \\<phi>) (L[var := x]))", "using AllN"], ["proof (prove)\nusing this:\n  length ?xa2 = i \\<Longrightarrow>\n  ?xa2 @ ?L2[?var2 := ?x2] = (?xa2 @ ?L2)[?var2 + i := ?x2]\n  \\<forall>var L.\n     freeIn var \\<phi> \\<longrightarrow>\n     (\\<exists>x. eval \\<phi> (L[var := x])) =\n     (\\<forall>x. eval \\<phi> (L[var := x]))\n\ngoal (1 subgoal):\n 1. \\<forall>var L.\n       freeIn var (AllN i \\<phi>) \\<longrightarrow>\n       (\\<exists>x. eval (AllN i \\<phi>) (L[var := x])) =\n       (\\<forall>x. eval (AllN i \\<phi>) (L[var := x]))", "by (metis eval.simps(9) freeIn.simps(12))"], ["proof (state)\nthis:\n  \\<forall>var L.\n     freeIn var (AllN i \\<phi>) \\<longrightarrow>\n     (\\<exists>x. eval (AllN i \\<phi>) (L[var := x])) =\n     (\\<forall>x. eval (AllN i \\<phi>) (L[var := x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma var_not_in_eval2 : \"\\<forall>L. (freeIn 0 \\<phi> \\<longrightarrow> ((\\<exists>x. eval \\<phi> (x#L)) = (\\<forall>x. eval \\<phi> (x#L))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L.\n       freeIn 0 \\<phi> \\<longrightarrow>\n       (\\<exists>x. eval \\<phi> (x # L)) = (\\<forall>x. eval \\<phi> (x # L))", "by (metis list_update_code(2) var_not_in_eval)"], ["", "lemma var_not_in_eval3 :\n  assumes \"freeIn var \\<phi>\"\n  assumes \"length xs' = var\"\n  shows \"((\\<exists>x. eval \\<phi> (xs'@x#L)) = (\\<forall>x. eval \\<phi> (xs'@x#L)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. eval \\<phi> (xs' @ x # L)) =\n    (\\<forall>x. eval \\<phi> (xs' @ x # L))", "using assms"], ["proof (prove)\nusing this:\n  freeIn var \\<phi>\n  length xs' = var\n\ngoal (1 subgoal):\n 1. (\\<exists>x. eval \\<phi> (xs' @ x # L)) =\n    (\\<forall>x. eval \\<phi> (xs' @ x # L))", "by (metis list_update_length var_not_in_eval)"], ["", "lemma eval_list_conj : \"eval (list_conj F) L = (\\<forall>f\\<in>set(F). eval f L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "fix f F"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "have h : \"eval (foldr and F f) L = (eval f L \\<and> (\\<forall>f \\<in> set F. eval f L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (foldr and F f) L =\n    (eval f L \\<and> (\\<forall>f\\<in>set F. eval f L))", "apply(induct F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. eval (foldr and [] f) L =\n    (eval f L \\<and> (\\<forall>f\\<in>set []. eval f L))\n 2. \\<And>a F.\n       eval (foldr and F f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr and (a # F) f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set (a # F). eval f L))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       eval (foldr and F f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr and (a # F) f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set (a # F). eval f L))", "using eval_and"], ["proof (prove)\nusing this:\n  eval (and ?a ?b) ?L = (eval ?a ?L \\<and> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       eval (foldr and F f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr and (a # F) f) L =\n       (eval f L \\<and> (\\<forall>f\\<in>set (a # F). eval f L))", "by auto"], ["proof (state)\nthis:\n  eval (foldr and F f) L =\n  (eval f L \\<and> (\\<forall>f\\<in>set F. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "}"], ["proof (state)\nthis:\n  eval (foldr and ?Fa2 ?f2) L =\n  (eval ?f2 L \\<and> (\\<forall>f\\<in>set ?Fa2. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "then"], ["proof (chain)\npicking this:\n  eval (foldr and ?Fa2 ?f2) L =\n  (eval ?f2 L \\<and> (\\<forall>f\\<in>set ?Fa2. eval f L))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (foldr and ?Fa2 ?f2) L =\n  (eval ?f2 L \\<and> (\\<forall>f\\<in>set ?Fa2. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)", "by(simp add:list_conj_def)"], ["proof (state)\nthis:\n  eval (list_conj F) L = (\\<forall>f\\<in>set F. eval f L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_list_disj : \"eval (list_disj F) L = (\\<exists>f\\<in>set(F). eval f L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "fix f F"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "have h : \"eval (foldr or F f) L = (eval f L \\<or> (\\<exists>f \\<in> set F. eval f L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (foldr or F f) L =\n    (eval f L \\<or> (\\<exists>f\\<in>set F. eval f L))", "apply(induct F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. eval (foldr or [] f) L =\n    (eval f L \\<or> (\\<exists>f\\<in>set []. eval f L))\n 2. \\<And>a F.\n       eval (foldr or F f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr or (a # F) f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set (a # F). eval f L))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       eval (foldr or F f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr or (a # F) f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set (a # F). eval f L))", "using eval_or"], ["proof (prove)\nusing this:\n  eval (or ?a ?b) ?L = (eval ?a ?L \\<or> eval ?b ?L)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       eval (foldr or F f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set F. eval f L)) \\<Longrightarrow>\n       eval (foldr or (a # F) f) L =\n       (eval f L \\<or> (\\<exists>f\\<in>set (a # F). eval f L))", "by auto"], ["proof (state)\nthis:\n  eval (foldr or F f) L = (eval f L \\<or> (\\<exists>f\\<in>set F. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "}"], ["proof (state)\nthis:\n  eval (foldr or ?Fa2 ?f2) L =\n  (eval ?f2 L \\<or> (\\<exists>f\\<in>set ?Fa2. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "then"], ["proof (chain)\npicking this:\n  eval (foldr or ?Fa2 ?f2) L =\n  (eval ?f2 L \\<or> (\\<exists>f\\<in>set ?Fa2. eval f L))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (foldr or ?Fa2 ?f2) L =\n  (eval ?f2 L \\<or> (\\<exists>f\\<in>set ?Fa2. eval f L))\n\ngoal (1 subgoal):\n 1. eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)", "by(simp add:list_disj_def)"], ["proof (state)\nthis:\n  eval (list_disj F) L = (\\<exists>f\\<in>set F. eval f L)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}